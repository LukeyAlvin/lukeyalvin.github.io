<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>七、滑动窗口算法</title>
    <url>/posts/a39e0cda.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>在学习滑动窗口算法之前，推荐读者先阅读，<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>以及<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>，这两篇博客奠定了本文的基础，有助于对本文的理解。</p>
<h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>我们知道，SLAM中的优化问题，就是优化一个最小二乘的问题，这里我们首先介绍一个引例。</p>
<p>如下图所示，存在这么一个图模型，对于图模型大家肯定不是很陌生，了解过g2o的都应该很清楚，图中圆圈表示顶点，是待优化的变量，而顶点之间的边，表示的顶点之间构建的残差。</p>
<p><img src="/images/滑动窗口算法/image-20220513195856537.png" alt="image-20220513195856537" style="zoom:50%;" /></p>
<blockquote>
<p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p>
</blockquote>
<p>对于这样一个系统，我们首先构建出最小二乘，如下：</p>
<script type="math/tex; mode=display">
\xi^*=\underset{\xi}{\arg\min}\frac{1}{2}\sum_i\parallel r_i \parallel^2_{\Sigma_i}\tag{1}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p>
<p>根据文章<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>中提到的，SLAM优化问题，最终运动观测方程优化的部分是<strong>马氏距离</strong>，残差项即为<strong>马氏距离</strong>:</p>
<script type="math/tex; mode=display">
\parallel r_i \parallel^2_{\Sigma_i}=r^T\Sigma^{-1}r\tag{2}</script><p>其中 $\Sigma$ 表示残差的<strong>协方差矩阵</strong>， $\Sigma^{-1}$ 表示残差的<strong>信息矩阵</strong>，因此，此处相当于一种<strong>加权的</strong>最小二乘问题。</p>
<p>应用高斯牛顿法，可以求解上述最小二乘问题的<strong>正规方程</strong>：</p>
<script type="math/tex; mode=display">
J^T\Sigma^{-1}J\ \delta\xi = -J^T\Sigma^{-1}\ r\tag{3}</script><p>其中海塞矩阵 $H=J^T\Sigma^{-1}J$，矩阵 $g= -J^T\Sigma^{-1}\ r$，雅可比矩阵为：</p>
<script type="math/tex; mode=display">
J=\frac{\partial r}{\partial \xi}=\begin{bmatrix}
\frac{\partial r_{12} }{\partial \xi}\\\frac{\partial r_{13} }{\partial \xi}\\
\frac{\partial r_{14} }{\partial \xi}\\\frac{\partial r_{15} }{\partial \xi}\\
\frac{\partial r_{56} }{\partial \xi}
\end{bmatrix}=\begin{bmatrix}J_1\\J_2\\J_3\\J_4\\J_5\\J_6 \end{bmatrix}\tag{4}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p>
<p>矩阵乘法公式 $(3)$ 可以写成连加：</p>
<script type="math/tex; mode=display">
\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i J_i\ \delta\xi=-\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i\ r\tag{5}</script><p>由于每个残差只和某几个状态量有关，因此，雅克比矩阵求导时，无关项的雅克比为 0。比如</p>
<script type="math/tex; mode=display">
J_2=\frac{\partial r_{13} }{\partial \xi}=
\begin{bmatrix}
\frac{\partial r_{13} }{\partial \xi_1}&0&
\frac{\partial r_{13} }{\partial \xi_3}&0&0&0
\end{bmatrix}\tag{6}</script><p>对应的新的信息矩阵：</p>
<script type="math/tex; mode=display">
Λ_2=J^T_2\Sigma^{-1}_2J_2=\begin{bmatrix}
(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\
(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\
0&0&0&0&0&0\\0&0&0&0&0&0
\end{bmatrix}\tag{7}</script><p>同理，可以计算 $Λ_1 , Λ_3 , Λ_4 , Λ_5 $，并且也是稀疏的。</p>
<p><strong>将五个残差的信息矩阵加起来</strong>，得到样例最终的<strong>信息矩阵</strong> $Λ$，可视化如下：</p>
<p><img src="/images/滑动窗口算法/image-20220513203817364.png" alt="image-20220513203817364" style="zoom: 33%;" /></p>
<p>关于稀疏矩阵。我们知道，可以用舒尔消元法或者称之为边缘化，来使之变得稠密，减少计算量。</p>
<h1 id="基于边际概率的滑动窗口算法"><a href="#基于边际概率的滑动窗口算法" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h1><h2 id="什么是滑动窗口算法？"><a href="#什么是滑动窗口算法？" class="headerlink" title="什么是滑动窗口算法？"></a>什么是滑动窗口算法？</h2><p><strong>什么是滑动窗口算法</strong></p>
<p>在引例的条件下，我们知道，一般情况下，SLAM问题构建的残差的信息矩阵是一个稀疏矩阵，在此基础上，我们讨论SLAM中的滑动窗口算法。</p>
<p>所谓的滑动窗口算法，并没有明确的定义，我做了一个动图，其展示的过程就是滑动窗口算法：</p>
<p><img src="/images/滑动窗口算法/cell-16526620480511.gif" alt="cell"></p>
<p>**为什么使用滑动窗口算法？</p>
<p>那么，使用它有什么好处呢？在文章开篇的概述中已经提及，这里再做强调：</p>
<ul>
<li>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</li>
<li>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态<strong>增加或移除优化变量</strong>。</li>
</ul>
<p>其实它的作用也是动图中展示的，我们优化的变量就是红色框中的部分，外部的变量不断增加进来，一些历史的变量做清除。</p>
<p><strong>滑动窗口中的关键问题是什么？</strong></p>
<p>但是我们需要考虑的关键就是，如何增加或者移除？直接移除吗？比如引例中的变量 $\xi_1$如果直接把顶点连同边一起移除，那么所有的其他变量之间的边可就都没了，边就是误差项，误差都没了，如何优化？这是下面我们需要介绍的重要内容。</p>
<p><strong>滑动窗口算法大致流程</strong></p>
<p>① 增加新的变量进入最小二乘系统优化</p>
<p>② 如果变量数目达到了一定的维度，则移除老的变量。</p>
<p>③ SLAM 系统不断循环前面两步</p>
<h2 id="基于边际概率的滑动窗口算法-1"><a href="#基于边际概率的滑动窗口算法-1" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h2><p>关于这里，有必要回顾文章<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>中的案例，会对此有更加深刻的理解。</p>
<p>直接丢弃变量和对应的测量值，会损失信息。因此，我们需要选择一种“优雅的”方式丢掉历史信息，正确的做法是使用<strong>边际概率</strong>，将丢弃变量所携带的信息传递给剩余变量。意思就是，历史变量虽然被移除了，但是它的“影响力”还在。</p>
<p>还是用引例，我们将引例中的历史变量 $\xi_1$ 丢掉，应该如何操作呢？</p>
<blockquote>
<p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p>
</blockquote>
<p><img src="/images/滑动窗口算法/image-20220513210526896.png" alt="image-20220513210526896"></p>
<p>很明显，去除历史变量 $\xi_1$ 之后，其他出现了互相之间的关联，这就是说历史变量 $\xi_1$ 虽然被去除了，但是它把自己的信息传递给其他变量了，虽然自己凉了，但是完成了火炬的传递。</p>
<p><strong>结论：</strong><span style="color:red;"><strong>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</strong></span> 另外，marg的这一特征也给我们启示，就是在SLAM运动观测模型中，marg特征点的时候，我们要<strong>marg那些不被其他帧观测到的特征点</strong>。因为他们不会显著的使得 H 变得稠密。对于那些被其他帧观测到的特征点，要么就别设置为marg，要么就宁愿丢弃，这就是okvis和dso中用到的一些策略。</p>
<hr>
<p>那么，如果在移除变量 $\xi_1$ 的同时，加入新的变量 $\xi_7$，整个信息矩阵又如何变化呢？</p>
<p>如下图所示，在 $t \in [0, k]$s 时刻, 系统中状态量为 $\xi_i , i \in [1, 6]$。</p>
<p>在第 $k $ 时刻，最小二乘优化完以后，marg 掉变量 $\xi_1$  。被 marg 的状态量记为 $x_m$ , 剩余的变量 $ξ_i , i \in [2, 5]$ 记为 $x_r $，marg 发生以后， $x_m$ 所有的变量以及对应的测量将被丢弃。同时，这部分信息通过 marg 操作传递给了保留变量 $x_r$ 。</p>
<p>第 $k^′$ 时刻，加入新的观测和状态量  $\xi_7$，新的变量  $\xi_7$ 跟老的变量  $\xi_2$ 之间存在观测信息，能构建残差 $r_{27}$ 。然后开始新一轮最小二乘优化。</p>
<p><img src="/images/滑动窗口算法/image-20220513213728826.png" alt="image-20220513213728826"></p>
<p>新残差加上之前 <strong>marg 留下的信息</strong>，构建新的最小二乘系统，对应的信息矩阵的变化如下图所示：</p>
<p><img src="/images/滑动窗口算法/image-20220513212137697.png" alt="image-20220513212137697" style="zoom:40%;" /></p>
<p>注意：  $\xi_2$  自身的信息矩阵由两部分组成，一部分是原来的$Λ^{\prime}$  中的老信息，另一部分是新生成的 $Λ_6$中的新信息，这会使得系统存在<strong>潜在风险</strong>。</p>
<p>新老信息融合的问题在于<strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。对于零空间的介绍在后文中。</p>
<hr>
<p><span style="color:red;"><strong>marg 留下的信息到底是啥？</strong></span></p>
<p>marg 发生后，留下的到底是什么信息？  </p>
<p>marg 前，变量 $x_m$ （指将要被 marg 的变量，$\xi_i,i=1$）以及对应测量 $\mathcal{S}_m$ （指的是与 $\xi_1$ 构成的边 $r_{1j},j\in[2,5]$）构建的最小二乘信息矩阵为（使用高斯牛顿）：  </p>
<script type="math/tex; mode=display">
\begin{align*}
b_m(k)&=
\begin{bmatrix}b_{mm}(k)\\b_{mr}(k)\end{bmatrix}
=-\sum_{(i,j)\in\mathcal{S}_m}J^T_{ij}(k)\Sigma^{-1}_{ij}r_{ij}\\
Λ_m(k)&=
\begin{bmatrix}Λ_{mm}(k)&Λ_{mr}(k)\\Λ_{rm}(k)&Λ_{rr}(k)\end{bmatrix}
=\sum_{(i,j)\in\mathcal{S}_m}J^T_{ij}(k)\Sigma^{-1}_{ij}J_{ij}(k)
\end{align*}\tag{8}</script><p>然后marg掉  $\xi_1$ ，即丢掉变418133364量  $x_m$ ， 而 $x_m$ 的测量信息，传递给了变量  $x_r$ （指的是 marg 剩余后的变量 $\xi_i,i\in[2,5]$）:  </p>
<script type="math/tex; mode=display">
\begin{align*}
b_p(k)&=b_{mr}(k)-Λ_{rm}(k)Λ^{-1}_{mm}(k)b_{mm}(k)\\
Λ_p(k)&=Λ_{rr}(k)-Λ_{rm}(k)Λ^{-1}_{mm}(k)Λ_{mm}(k)
\end{align*}\tag{9}</script><p>下标 p 表示 prior. 即这些信息将构建一个关于 $x_r$ 的先验信息。</p>
<p>由：</p>
<script type="math/tex; mode=display">
\begin{align*}
Λ_p(k)\delta x&=b_p(k)\\
J^T_{p}(k)\Sigma^{-1}J_{p}(k)\ \delta x&= -J^T_{p}(k)\Sigma^{-1}r_p(k)
\end{align*}\tag{10}</script><p>因此，我们可以从 $b_p(k),Λ_p(k)$反解出一个残差 $r_p(k)$ 和对应的雅可比矩阵 $J_{p}(k)$ ，需要注意的是<strong>，随着变量 $x_r(k)$ 的后续不断优化变化，残差 $r_p(k)$ 或者 $b_p(k)$ 也跟着变换，但是雅可比 $J_{p}(k)$ 则固定不变了。</strong></p>
<p>在 $k^′$ 时刻，新残差 $r_{27}$ 和先验信息  $b_p(k),Λ_p(k)$ 以及残差 $r_{56}$ 构建新的最小二乘问题 :</p>
<script type="math/tex; mode=display">
\begin{align*}
b_m(k^′)&=\Pi^Tb_p(k)
-\sum_{(i,j)\in\mathcal{S}_a(k^′)}J^T_{ij}(k^′)\Sigma^{-1}_{ij}r_{ij}(k^′)\\
Λ_m(k^′)&=\Pi^TΛ_p(k) \Pi
+\sum_{(i,j)\in\mathcal{S}_a(k^′)}J^T_{ij}(k^′)\Sigma^{-1}_{ij}J_{ij}(k^′)
\end{align*}\tag{11}</script><p>其中，$\Pi=[I_{dim\ x_r}\ \ 0]$用来将矩阵的维度进行扩张。 $\mathcal{S}_a$ 用来表示除被marg 掉的测量以外的其他测量，包括原本的与marg 变量无关的  $r_{56}$，以及新加入的变量 $r_{27}$。  </p>
<p><strong>出现的问题</strong></p>
<p>由于  $ξ_2$  的信息由两部分组成：</p>
<ul>
<li><p>一部分是marg 前的先验信息  $Λ_p(k)$ ，在marg 后，由于被 marg 的变量以及对应的测量已被丢弃，因此之前的雅可比不会被更新了，因此公式 $(11)$ 的等号右侧第一部分的线性化点是<strong>不变的</strong>；</p>
</li>
<li><p>另一部分信息就是新的边 $r_{27}$ ，其雅克比会随着 $ξ_2$  的迭代更新而不断在最新的线性化点处计算，因此公式 $(11)$ 的等号右侧第二部分的线性化点是<strong>不断变化的</strong>；</p>
</li>
<li><strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，它们在相加的时候，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。</li>
</ul>
<h2 id="信息矩阵的零空间变化"><a href="#信息矩阵的零空间变化" class="headerlink" title="信息矩阵的零空间变化"></a>信息矩阵的零空间变化</h2><p>滑动窗口算法优化的时候，信息矩阵如公式 $(11)$ 变成了两部分，且这两部分计算雅克比时的<strong>线性化点不同</strong>。这可能会导致信息矩阵的零空间发生变化，从而在求解时引入错误信息。  </p>
<p>这里引用贺博的博客：<a href="https://blog.csdn.net/heyijia0327/article/details/52822104?spm=1001.2014.3001.5501">SLAM中的marginalization 和 Schur complement</a></p>
<p><img src="/images/滑动窗口算法/image-20220514165208897-16526621209192.png" alt="image-20220514165208897" style="zoom: 33%;" /></p>
<p>在刘毅(稀疏毅)，王京，晓佳等人讨论下，对这张图作出了如下解释：</p>
<p>四张能量图中，第一张是说明能量函数 $E$ 由两个同样的非线性函数 $E_1$和 $E_2$组成，我们令函数 $E=0$，这时方程的解为 $x y = 1$ ，对应图中深蓝色的一条曲线。</p>
<p>第二张能量函数图中的 $E_1^′$对应函数  $E_1$ 在点 $(0.5,1.4)$ 处的二阶泰勒展开;</p>
<p>第三张能量函数图中的 $E_2^′$ 对应函数在  $E_2$ 点 $(1.2,0.5)$ 处的二阶泰勒展开。注意这两个近似的能量函数 $E_1^′$ 和 $E_2^′$是在不同的线性点附近对原函数展开得到的。</p>
<p>最后一张图就是把这个近似得到的能量函数合并起来，对整个系统 $E$ 的二阶近似。</p>
<p>从第四个能量函数图中，我们发现一个大问题，能量函数为 $0$ 的解由以前的一条曲线变成了一个点，<strong>不确定性的东西变得确定了</strong>，专业的术语叫<strong>不可观的状态变量变得可观了</strong>，说明我们人为的引入了错误的信息。回到marg过程，上面这个例子告诉我们，marg 时，被 marg 的那些变量的雅克比已经不更新了，而此时留在滑动窗口里的其他变量的雅克比要用和 marg 时一样的线性点，就是 $FEJ,(first\ estimate\ jocabian)$ 算法，不要用新的线性点了。</p>
<hr>
<p><strong>FEJ 算法：</strong>$FEJ,(first\ estimate\ jocabian)$ ,不同残差对同一个状态求雅克比时，线性化点必须一致。这样就能避免零空间退化而使得不可观变量变得可观。  比如: 引例中计算 $r_{27}$ 对 $ξ_2$ 的雅克比时， $ξ_2$ 的线性话点必须和 $r_{12}$对其求导时一致。  </p>
]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>滑动窗口算法</tag>
      </tags>
  </entry>
  <entry>
    <title>VSLAM中的非线性优化</title>
    <url>/posts/48933.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经典 SLAM 模型。它由一个状态方程和一个运动方程构成：</p>
<script type="math/tex; mode=display">
\begin{align*}
x_k&=f(x_{k-1},u_{k})+w_{k}\\
z_{k,j}&=h(y_j,x_k)+v_{k,j}
\end{align*}\tag{1}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$</p>
<p>对应视觉$SLAM$，这里的 $x_k $乃是相机的位姿，$u_k$ 是运动传感器的读数（有时也叫输入），$y_j$代表的是相机在$x_k $处观察到的路标，并且观察到$y_j$后，产生了一个观测数据 $z_{k,j}$。整个方程里面，求解相机的位姿$x_k $就是一个定位的问题，而求解路标$y_j$就是一个建图的过程，但是由于噪声$w_{k}，v_{k,j}$的影响，我们得到的传感器数据$u_k$ 和$z_{k,j}$肯定不是完全准确的，因此需要使用这两组不太准确的数据，寻找一个相对最优的相机位姿$x_k $以及路标$y_j$。这个过程就是SLAM中的非线性优化问题。</p>
<h2 id="需要优化什么？"><a href="#需要优化什么？" class="headerlink" title="需要优化什么？"></a>需要优化什么？</h2><p>我们把所有带估计的数据放在一个集合：</p>
<script type="math/tex; mode=display">
x=\left\{x_1,....,x_N,y_1,...y_M\}\right.\tag{2}</script><p>那么，我们的问题就变成求已知输入数据 $u$ 和观测数据 $z$ 的条件下，计算状态 $x$ 的条件概率分布：</p>
<script type="math/tex; mode=display">
P(x|z,u)\tag{3}</script><hr>
<p>但是多数情况下，我们只有相机观察到的一帧帧的图片$z_{k,j}$，即只考虑观测方程带来的数据时，没有运动传感器$u_k$ ，这个概率分布就变成$P(x|z)$，利用贝叶斯法则：</p>
<script type="math/tex; mode=display">
P(x|z)=\frac{P(z|x)P(x)}{P(z)}∝P (z|x) P (x) .\tag{4}</script><p>$\frac{P(z|x)P(x)}{P(z)}$称为<strong>后验估计</strong>，$P (z|x)$ 称为<strong>似然</strong>，另一部分$ P (x)$ 称为<strong>先验</strong>。</p>
<p>直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下，后验概率最大化（Maximize a Posterior，MAP），则是可行的：</p>
<script type="math/tex; mode=display">
x^∗_{MAP} = \arg \max P (x|z) = \arg \max P (z|x)P (x).\tag{5}</script><p>但是当我们不知道机器人位姿大概在什么地方，此时就没有了先验,那么，可以求解$x $的最大似然估计（Maximize Likelihood Estimation, MLE）：</p>
<script type="math/tex; mode=display">
x^∗_{MLE} = \arg \max P (z|x)\tag{6}</script><p>最大似然估计的含义就是：相机在什么样的状态下（这里指集合$x$即为相机位姿$x_{k}$以及路标$y_{j}$），最可能产生当前观测到的数据$z_{k,j}$。</p>
<p><strong>所以我们需要优化的内容就是：求解最优的$x_k , y_j$，使得观测方程带来的最小误差，此时就是求$x$（或者是说$x_k , y_j$）的最大似然然估计。</strong></p>
<h2 id="最小二乘问题"><a href="#最小二乘问题" class="headerlink" title="最小二乘问题"></a>最小二乘问题</h2><p>只考虑观测方程：</p>
<script type="math/tex; mode=display">
z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{7}</script><p>由于我们假设了噪声项 $v_k ∼ N (0, Q)$，所以观测数据的条件概率为：</p>
<script type="math/tex; mode=display">
P (z_{j,k} |x_k , y_j ) = N (h(y_j , x_k ), Q) .\tag{8}</script><p>我们的目标就是最大化$x_k , y_j$，使得该状态下最可能产生当前观测到的数据$z_{k,j}$。</p>
<p>考虑一个任意的高维高斯分布 $x ∼ N (\mu, \Sigma)$，它的概率密度函数展开形式为:</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x)=\frac{1}{\sqrt{(2\pi)^N det(\Sigma)} }exp(−(x−\mu)\Sigma^{-1} (x−\mu))
\end{align*}\tag{9}</script><p>取负对数:</p>
<script type="math/tex; mode=display">
\begin{align*}
-ln(p(x))=\frac{1}{2}ln((2\pi)^N det(Σ))+\frac{1}{2}(x−\mu)^TΣ^{-1} (x−\mu)
\end{align*}\tag{10}</script><p>对原分布求最大化相当于对负对数求最小化。在最小化上式的 $x$ 时，第一项与 $x $无关，可以略去于是，只要最小化右侧的二次型项，也称为<strong>马氏距离</strong>。带入 SLAM 观测模型：</p>
<script type="math/tex; mode=display">
x^*=\arg\min\left((z_{k,j}-h(x_k,y_j))^TQ^{-1}_{k,j}(z_{k,j}-h(x_k,y_j))\right)\tag{11}</script><p>定义：</p>
<script type="math/tex; mode=display">
\begin{align*}
e_{v,k}&=x_k-f(x_{k-1},u_k)\\
e_{u,j,k}&=z_{k,j}-h(x_k,y_j)
\end{align*}\tag{12}</script><p>考虑运动与观测方程结合来看，我们求解的就是总的<strong>误差的平方和</strong>：</p>
<script type="math/tex; mode=display">
J(x)=\sum_ke^T_{v,k}R^{-1}e_{v,k}+\sum_k\sum_je^T_{y,k,j}Q^{-1}e_{y,k,j}\tag{13}</script><p>这就得到了一个总体意义下的<strong>最小二乘问题</strong>（Least Square Problem）。我们明白它的最优解等价于状态的最大似然估计。直观来讲，由于噪声的存在，当我们把估计的轨迹与地图代入 SLAM 的运动、观测方程中时，它们并不会完美的成立。这时候怎么办呢？我们把状态的估计值进行微调，使得整体的误差下降一些。当然这个下降也有限度，它一般会到达一个极小值。这就是一个典型非线性优化的过程。</p>
<h2 id="非线性函数线性化"><a href="#非线性函数线性化" class="headerlink" title="非线性函数线性化"></a>非线性函数线性化</h2><p>在非线性优化的过程中，由于高斯分布经过非线性映射后不会再符合高斯分布，因此，一般我们对非线性进行线性化，这里用到泰勒级数：</p>
<p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p>
<script type="math/tex; mode=display">
f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}\tag{14}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p>
<script type="math/tex; mode=display">
f(x)=f(x_0)+f^\prime(x_0)(x-x_0)\tag{15}</script><p>如果对于二维以上的，我们的一阶泰勒展开如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(x，y)&=f(x_0)+\frac{\partial f}{\partial x}|_{x=x_0}(x-x_0)\\
&=f(x_0)+J(x)(x-x_0)
\end{align*}\tag{16}</script><p>这里的雅克比矩阵代表的就是$f(x)$对于$x$的偏导数。</p>
<h1 id="求解非线性最小二乘"><a href="#求解非线性最小二乘" class="headerlink" title="求解非线性最小二乘"></a>求解非线性最小二乘</h1><p>对于上文，我们知道通过把最大似然估计问题转化为最小化其负对数的问题，其实就是求解一个非线性函数的最小值的问题，我们暂且考虑一个问题，我们有一个非线性的函数$f(x)$，如何求解它的最小值？</p>
<p>这就是一个简单的最小二乘问题：</p>
<script type="math/tex; mode=display">
\underset{x}{min}\frac{1}{2}\parallel f(x) \parallel^2\tag{17}</script><p>这里自变量 $x\in \mathbb R^n$ ，$f $是任意一个非线性函数，我们设它有 $m $维：$f (x) \in \mathbb R^m$ 。</p>
<p>一般求解就是类似于二元函数求极值，对$x$求导，使得$\frac{df}{dx}=0$，即可得到$f(x)$的极值，但是也不是绝对的，我们知道这个点可能是极大值、极小值也可能是鞍点，因此需要比较所有使得$\frac{df}{dx}=0$的自变量对应的函数值$f(x)$.</p>
<p>但是在SLAM中，$f(x)$将是一个复杂的非线性方程，所以一般我们使用迭代的方法，从一个初始值出发，不断地更新当前的优化变量，使目标函数下降，具体步骤如下：</p>
<ul>
<li>给定某个初始值$ x_0$</li>
<li>对于第$k$次迭代，寻找一个增量$\Delta x_k$，使得$\parallel f(x_k+\Delta x_k)\parallel^2_2$达到极小值。</li>
<li>若$\Delta x_k$足够小，则停止</li>
<li>否则，令$x_{k+1}=x_k+\Delta x_k$，返回第二步。</li>
</ul>
<p>这让求解导函数为零的问题，变成了一个不断寻找梯度并下降的过程。直到某个时刻增量非常小，无法再使函数下降。此时算法收敛，目标达到了一个极小，我们完成了寻找极小值的过程。在这个过程中，我们只要找到迭代点的梯度方向即可，而无需寻找全局导函数为零的情况。</p>
<hr>
<p><strong>如何寻找$\Delta x_k$?</strong></p>
<h2 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h2><p>我们之前介绍过非线性的线性化方法，我们可以将一个非线性函数在某个点附件进行泰勒展开。</p>
<p>比如：对于增量方程在$x$附近进行泰勒展开：</p>
<script type="math/tex; mode=display">
\parallel f(x+\Delta x)\parallel^2_2\approx\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{18}</script><p>这里$J$是 $\parallel f(x)\parallel^2$ 关于$ x $的导数（雅可比矩阵），而$ H $则是二阶导数（海塞（Hessian）矩阵）。保留一阶二阶分别就对应了一阶梯度法和二阶梯度法。</p>
<h3 id="一阶梯度法"><a href="#一阶梯度法" class="headerlink" title="一阶梯度法"></a>一阶梯度法</h3><script type="math/tex; mode=display">
\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x\tag{19}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p>
<script type="math/tex; mode=display">
\Delta x^*=-J^T(x)\tag{20}</script><p>当然，我们还需要该方向上取一个步长$\lambda$，求得最快的下降方式。这种方法被称为<strong>最速下降法</strong>。但是它本身也有缺点：最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。</p>
<h3 id="二阶梯度-牛顿法"><a href="#二阶梯度-牛顿法" class="headerlink" title="二阶梯度(牛顿法)"></a>二阶梯度(牛顿法)</h3><script type="math/tex; mode=display">
\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{21}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p>
<script type="math/tex; mode=display">
H\Delta x=-J^T.\tag{22}</script><p>但是牛顿法需要计算目标函数的 $H $矩阵，这在问题规模较大时非常困难，我们通常倾向于避免$ H $的计算。</p>
<h2 id="Gauss-Newton"><a href="#Gauss-Newton" class="headerlink" title="Gauss-Newton"></a>Gauss-Newton</h2><p>Gauss Newton 是最优化算法里面最简单的方法之一。它的思想是$f(x)$而不是$f(x)^2$在$x$处进行一阶泰勒展开：</p>
<script type="math/tex; mode=display">
f(x+\Delta x)\approx f(x)+J(x)\Delta x\tag{23}</script><p>这里$ J (x)$ 为$ f (x) $关于$ x$ 的导数，实际上是一个$ m × n$ 的矩阵，也是一个雅可比矩阵。</p>
<p>当前的目标是为了寻找下降矢量 $\Delta x$，使得$ f(x+\Delta x)$达到最小。为了求 $\Delta x$，我们需要解一个线性的最小二乘问题：</p>
<script type="math/tex; mode=display">
\Delta x^*=\arg\min\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2\tag{24}</script><p>对上式平方项进行展开：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2&=\frac{1}{2}
\left(f(x)+J(x)\Delta x)^T(f(x)+J(x)\Delta x\right)\\
&=\frac{1}{2}\left(\parallel f(x)\parallel^2_2+2f(x)^TJ(x)\Delta x+\Delta x^TJ(x)^TJ(x)\Delta x\right)\\
\end{align*}\tag{25}</script><p>求上式关于 $\Delta x$ 的导数，并令其为零：</p>
<script type="math/tex; mode=display">
2J(x)^Tf(x)+2J(x)^TJ(x)\Delta x=0\tag{26}</script><p>化简：</p>
<script type="math/tex; mode=display">
J(x)^TJ(x)\Delta x=-J(x)^Tf(x)\tag{27}</script><p>要求解的变量是  $\Delta x$，因此这是一个线性方程组，我们称它为增量方程，也可以称为<strong>高斯牛顿方程 (Gauss Newton equations)</strong> 或者<strong>正规方程 (Normal equations)</strong>。我们把左边的系数定义为 $H$，右边定义为 $g$，那么上式变为：</p>
<script type="math/tex; mode=display">
H \Delta x=g\tag{28}</script><p>对比牛顿法可见，Gauss-Newton 用$J(x)^TJ(x)$作为牛顿法中二阶 Hessian 矩阵的近似，从而省略了计算 $H $的过程。求解增量方程是整个优化问题的核心所在。</p>
<p>Gauss Newton 求解步骤：</p>
<ul>
<li>给定初始值$x_0$</li>
<li>对于第$k$次迭代，求出当前的雅可比矩阵$J(x_k)和误差$$f(x_k)$</li>
<li>求解增量方程：$H \Delta x=g$</li>
<li>若$\Delta x_k$足够小，则停止。否则，令$x_{k+1}=x_k+\Delta x_k$，返回步骤2.</li>
</ul>
<p>整个步骤中，增量方程的求解占据着主要地位。原则上，它要求我们所用的近似 $H$ 矩阵是可逆的（而且是正定的），但实际数据中计算得到的 $J(x)^TJ(x)$却只有半正定性。也就是说，在使用 Gauss Newton 方法时，可能出现$J(x)^TJ(x)$为<strong>奇异矩阵</strong>或者<strong>病态 (ill-condition)</strong> 的情况，此时增量的稳定性较差，导致算法不收敛。</p>
<p>更严重的是，就算我们假设$ H $非奇异也非病态，如果我们求出来的步长$ ∆x $太大，也会导致我们采用的局部近似不够准确，这样一来我们甚至都无法保证它的迭代收敛，哪怕是让目标函数变得更大都是有可能的。</p>
<h2 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h2><p>由于 Gauss-Newton 方法中采用的近似二阶泰勒展开<strong>只能在展开点附近有较好的近似效果</strong>，所以我们很自然地想到应该给 $\Delta x$ 添加一个信赖区域（$Trust\ Region$），不能让它太大而使得近似不准确。非线性优化种有一系列这类方法，这类方法也被称之为信赖区域方法 $ (Trust\ Region\ Method)$。<strong>在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</strong> </p>
<p>那么如何确定这个信赖区域的范围呢？一个比较好的方法是<strong>根据我们的近似模型跟实际函数之间的差异来确定这个范围</strong>：如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。因此，考虑使用 $(29)$ 来判断泰勒近似是否够好。</p>
<script type="math/tex; mode=display">
\rho=\frac{f(x+\Delta x)-f(x)}{J(x)\Delta x }\tag{29}</script><p>$\rho$ 的分子是<strong>实际函数下降</strong>的值，分母是<strong>近似模型下降</strong>的值。如果 $\rho$ 接近于 1，则近似是好的。如果 $\rho$  太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。反之，如果 $\rho$  比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。</p>
<p><img src="/images/SLAM中的非线性优化数学推导/image-20220513154553510.png" alt="image-20220513154553510" style="zoom: 67%;" /></p>
<p>我们用 Lagrange 乘子将$(6.24)$ 转化为一个无约束优化问题：</p>
<script type="math/tex; mode=display">
\underset{\Delta x_K}{\min}\frac{1}{2}
\parallel f(x_k)+J(x_k)\Delta x_k
\parallel^2
=\frac{\lambda}{2}\parallel D\Delta x \parallel^2\tag{30}</script><p>类似于 Gauss-Newton 中的做法，把它展开后，我们发现该方法最终也是计算增量的线性方程：</p>
<script type="math/tex; mode=display">
(H+\lambda D^TD)\Delta x=g\tag{31}</script><p>可以看到，增量方程相比于 Gauss-Newton，多了一项 $\lambda D^T D$。如果考虑它的简化形 式，即 $D = I$，那么相当于求解：</p>
<script type="math/tex; mode=display">
(H+\lambda I)\Delta x=g\tag{32}</script><p>我们看到，当参数 $λ$ 比较小时，$H $占主要地位，这说明二次近似模型在该范围内是比 较好的，L-M 方法更接近于 G-N 法。另一方面，当 $λ$ 比较大时，$λI $占据主要地位，L-M 更接近于一阶梯度下降法（即最速下降），这说明附近的二次近似不够好。L-M 的求解方 式，可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题，提供更稳定更准确 的增量 $∆x$。</p>
<h1 id="BA求解"><a href="#BA求解" class="headerlink" title="BA求解"></a>BA求解</h1><p>通过前文。我们知道SLAM 中的优化问题什么，而且我们知道优化的数学工具最小二乘法，那么如何进行优化，就是我们下面讨论的主要问题。</p>
<h2 id="投影模型"><a href="#投影模型" class="headerlink" title="投影模型"></a>投影模型</h2><p>从一个世界坐标系中的点 $p$ 出发，把相机的内外参数和畸变都考虑进来，最后投影成像素坐标，一共需要如下几个步骤：</p>
<ol>
<li>首先，把世界坐标转换到相机坐标，这里将用到相机外参数$ (R, t)$：</li>
</ol>
<script type="math/tex; mode=display">
P^\prime=Rp+t=[X^\prime,Y^\prime,Z^\prime]^T\tag{33}</script><ol>
<li>然后，将 $P^\prime$ 投至归一化平面，得到归一化坐标：</li>
</ol>
<script type="math/tex; mode=display">
P_c=[u_c,v_c,1]^T=[\frac{X^\prime}{Z^\prime},\frac{Y^\prime}{Z^\prime},1]^T\tag{34}</script><ol>
<li>对归一化坐标去畸变，得到去畸变后的坐标。这里暂时只考虑径向畸变：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align*}
u_c^\prime=u_c(1+k_1r_c^2+k_2r_c^4)\\
v_c^\prime=v_c(1+k_1r_c^2+k_2r_c^4)\\
\end{align*}
\tag{35}</script><ol>
<li>最后，根据内参模型，计算像素坐标：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align*}
u_s=f_xu_c^\prime+c_x\\
v_s=f_yv_c^\prime+c_y
\end{align*}
\tag{36}</script><p>对于观测方程：</p>
<script type="math/tex; mode=display">
z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{37}</script><p>这里的 $x$ 指代此时相机的位姿，即外参 $R, t$，它对应的李代数为 $ξ$。路标 $y$ 即这里的三维点 $p$，而观测数据则是像素坐标$z = [u_s , v_s ]^T $。</p>
<p><img src="/images/SLAM中的非线性优化数学推导/image-20220405145736323.png" alt="image-20220405145736323"></p>
<p>以最小二乘的角度来考虑，那么可以列写关于此次观测的误差：</p>
<script type="math/tex; mode=display">
e=z-h(\xi,p)\tag{38}</script><p>设 $z_{ij}$为在位姿 $\xi_i $处观察路标 $p_j $产生的数据，那么整体的损失函数（Cost Function）为：</p>
<script type="math/tex; mode=display">
\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}\parallel^2=\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel z_{ij}-h(ξ_i,p_j) \parallel^2\tag{39}</script><p>对这个最小二乘进行求解，相当于对位姿和路标同时作了调整，也就是所谓的$BA$。</p>
<h2 id="BA求解-1"><a href="#BA求解-1" class="headerlink" title="BA求解"></a>BA求解</h2><p>在整体 $BA$目标函数上，我们必须把自变量定义成所有待优化的变量：</p>
<script type="math/tex; mode=display">
x=[\xi_1,...,\xi_m,p_1,...,p_n]^T\tag{40}</script><p>相应的，增量方程中的$ ∆x $则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为：</p>
<script type="math/tex; mode=display">
\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}+F_{ij}\Delta\xi_i+E_{ij}\Delta p_i \parallel^2\tag{41}</script><p>其中$ F_{ij} $表示整个代价函数在当前状态下对<strong>相机姿态</strong>的偏导数，而 $E_{ij}$ 表示该函数对<strong>路标点位置</strong>的偏导。</p>
<p><strong>观测相机方程关于相机位姿的导数矩阵：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
F&=-
\begin{bmatrix}
\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}
&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}
\\
0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}
\end{bmatrix}\\
\end{align*}\tag{42}</script><p><strong>观测相机方程关于特征点的导数矩阵</strong></p>
<script type="math/tex; mode=display">
E=\begin{bmatrix}
\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\
0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
\end{bmatrix}R\tag{43}</script><p>关于$E,F$雅可比矩阵的具体求导过程，可以查阅：<a href="https://lukeyalvin.top/posts/20908.html">ch7_求解PnP并使用BA优化</a></p>
<p>现在，把相机位姿变量放在一起：</p>
<script type="math/tex; mode=display">
x_c=[\xi_1,\xi_2,...,\xi_m]\in\mathbb{R}^{6m}\tag{44}</script><p>并把空间点的变量也放在一起：</p>
<script type="math/tex; mode=display">
x_p=[p_1,p_2,...,p_n]^T\in \mathbb{R}^{3n}\tag{45}</script><p>目标函数变为：</p>
<script type="math/tex; mode=display">
\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e+F\Delta x_c+E_\Delta x_p \parallel^2\tag{46}</script><p>需要注意的是，该式从一个由<strong>很多个小型二次项之和</strong>，变成了一个更整体的样子。这里的雅可比矩阵 $E $和$ F$ 必须是整体目标函数对整体变量的导数，它将是一个很大块的矩阵，而里头每个小分块，需要由每个误差项的导数 $F_{ij} $和 $E_{ij}$ “拼凑”起来。然后，无论我们使用 $G-N$ 还是$ L-M $方法，最后都将面对增量线性方程：</p>
<script type="math/tex; mode=display">
H\Delta x = g\tag{47}</script><p>如果是高斯牛顿，$H$ 取$J^TJ$；列文伯格是 $J^T J + λI $的形式</p>
<p>由于我们把变量归类成了位姿和空间点两种，所以雅可比矩阵可以分块为：</p>
<script type="math/tex; mode=display">
J=
\begin{bmatrix}
F & E
\end{bmatrix}\tag{48}</script><p>其中$F$是$2 × 6$的矩阵，$E$是$2 × 3$的矩阵.</p>
<p>以 G-N 为例，则 H 矩阵为：</p>
<script type="math/tex; mode=display">
H=J^TJ=
\begin{bmatrix}
F^TF & F^TE\\
E^TF & E^TE
\end{bmatrix}\tag{49}</script><p>在SLAM中我们会考虑H矩阵的稀疏性，进而加速BA的求解。</p>
<h2 id="稀疏性和边缘化"><a href="#稀疏性和边缘化" class="headerlink" title="稀疏性和边缘化"></a>稀疏性和边缘化</h2><p>在视觉 SLAM 中，一个图像就会提出数百个特征点，大大增加了这个线性方程的规模。如果直接对 H 求逆来计算增量方程，由于矩阵求逆是复杂度为 $O(n^3 )$ 的操作，这是非常消耗计算资源的。幸运地是，这里的 H 矩阵是有一定的特殊结构的。利用这个特殊结构，我们可以加速求解过程。</p>
<p>21 世纪视觉 SLAM 的一个重要进展是认识到了矩阵 H 的稀疏结构，并发现该结构可以自然、显式地用图优化来表示 。</p>
<p>举例：假设一个场景内有 $2$ 个相机位姿 $(C_1 , C_2 )$ 和 $6$ 个路标 $(P_1 , P_2 , P_3 , P_4 , P_5 , P_6 )$。这些相机和点云所对应的变量为 $ξ_i , i = 1, 2$ 以及 $p_j , j = 1, . . . , 6$。相机 $C_1$ 观测到路标 $P_1 , P_2 , P_3 , P_4$ ，相机 $C_2$ 观测到了路标 $P_3 , P_4 , P_5 , P_6$ 。</p>
<p>如图所示：相机和路标以圆形节点表示。如果 $i$ 相机能够观测到 $j$ 点云，我们就在它们对应的节点连上一条边。</p>
<p><img src="/images/SLAM中的非线性优化数学推导/image-20220513160409346.png" alt="image-20220513160409346" style="zoom: 33%;" /></p>
<p>可以推出该场景下的 BA 目标函数应该是：</p>
<script type="math/tex; mode=display">
\frac{1}{2}\left(
\parallel e_{11} \parallel^2+\parallel e_{12} \parallel^2+\parallel e_{13} \parallel^2+
\parallel e_{14} \parallel^2+\parallel e_{23} \parallel^2+\parallel e_{24} \parallel^2+
\parallel e_{25} \parallel^2+\parallel e_{26} \parallel^2
\right)\tag{50}</script><p>这里的 $e_{ij}$ 使用之前定义过的代价函数，即式 $(39)$。以 $e_{11}$ 为例，它描述了在 $C_1$ 看到了 $P_1$ 这件事，与其他的相机位姿和路标无关。令 $J_{11}$  为  $e_{11}$  所对应的雅可比矩阵，不难看出  $e_{11}$  对相机变量 $\xi_2$ 和路标点 $p_2 , . . . , p_6$ 的偏导都为 0。我们把所有变量以 $x = (ξ_1 , ξ_2 , p_1 , . . . , p_6 )^T$ 的顺序摆放，则有：</p>
<script type="math/tex; mode=display">
J_{11}=\frac{\partial e_{11} }{\partial x}
=\left(
\frac{\partial e_{11} }{\partial \xi_1},0,\frac{\partial e_{11} }{\partial p_1}
,0,0,0,0,0
\right)\tag{51}</script><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161314472.png" alt="image-20220513161314472" style="zoom:50%;" /></p>
<p>类似地，可以推导出如下图案：</p>
<p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161435601.png" alt="image-20220513161435601" style="zoom: 50%;" /></p>
<p>现在考虑更一般的情况，假如我们有 $m$ 个相机位姿，$n $ 个路标点。由于通常路标数量 远远会比相机多，于是有 $n ≫ m$。由上面推理可知，实际当中的 H 矩阵会像下图所示的那样。它的左上角块显得非常小，而右下角的对角块占据了大量地方。除此之外，非 对角部分则分布着散乱的观测数据。由于它的形状很像箭头，又称为<strong>箭头形（Arrow-like） 矩阵</strong>。同时它又很像一把镐子，所以也叫<strong>镐形矩阵</strong>。</p>
<p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161821872.png" alt="image-20220513161821872" style="zoom: 33%;" /></p>
<p>于是，对应的线性方程组也可以由 $H∆x = g $ 变为如下形式：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
B&E\\E^T&C
\end{bmatrix}
\begin{bmatrix}
\Delta x_c\\\Delta x_p
\end{bmatrix}=
\begin{bmatrix}
v\\w
\end{bmatrix}\tag{52}</script><p>其中 $B$ 是对角块矩阵，每个对角块的维度和相机参数的维度相同，对角块的个数是相机变量的个数。由于路标数量会远远大于相机变量个数，所以 $C$ 往往也远大于 $B$。三 维空间中每个路标点为三维，于是 $C$ 矩阵为对角块矩阵，每个块为 $3 \times 3$ 维矩阵。</p>
<p>考虑到对角块矩阵求逆的难度远小于对一般矩阵的求逆难度，我们对线性方程组进行高斯消元，目标是消去右上角的非对角部分 $E$，得：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I&-EC^{-1}\\0&I
\end{bmatrix}
\begin{bmatrix}
B&E\\E^T&C
\end{bmatrix}
\begin{bmatrix}
\Delta x_c\\\Delta x_p
\end{bmatrix}=
\begin{bmatrix}
I&-EC^{-1}\\0&I
\end{bmatrix}
\begin{bmatrix}
v\\w
\end{bmatrix}\tag{53}</script><p>整理得：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
B-EC^{-1}E^T&0\\E^T&C
\end{bmatrix}
\begin{bmatrix}
\Delta x_c\\\Delta x_p
\end{bmatrix}=
\begin{bmatrix}
v-EC^{-1}w\\w
\end{bmatrix}\tag{54}</script><p>经过消元之后，第一行方程组变成和 $∆x_p$ 无关的项。单独把它拿出来，得到关于位姿部分的增量方程：</p>
<script type="math/tex; mode=display">
[B-EC^{-1}E^T]\Delta x_c=v-EC^{-1}w\tag{55}</script><p>这个线性方程组的维度和 $B$ 矩阵一样。我们的做法是先求解这个方程，然后把解得 的 $∆x_c$ 代入到原方程，然后求解 $∆x_p$ 。</p>
<script type="math/tex; mode=display">
\Delta x_p=C^{-1}(w-E^T\Delta x_c)\tag{56}</script><p>这个过程称为 <strong>Marginalization</strong>，或者 <strong>Schur 消元 (Schur Elimination)</strong>。</p>
<p>我们记 式 $(55)$ 中的 $\Delta x_c$的系数为 $S=B-EC^{-1}E^T$ ，我们看一下它的稀疏性：</p>
<p><img src="/images/SLAM中的非线性优化数学推导/image-20220513165129947.png" alt="image-20220513165129947" style="zoom: 33%;" /></p>
<p>$S$ 矩阵的非对角线上的非零矩阵块，表示了该处对应的两个相机变量之间存在着共同观测的路标点，有时候称为<strong>共视（Co-visibility）</strong>。反之，如果该块为零，则表示这两个相机没有共同观测。如上图所示的稀疏矩阵，左上角前 $4 \times 4$ 个矩阵块可以表示对应的相 机变量 $C_1 , C_2 , C_3 , C_4$ 之间有共同观测。</p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>最小二乘法</tag>
        <tag>后端优化</tag>
        <tag>BA与图优化</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM中的概率基础</title>
    <url>/posts/2613d057.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="概率与概率密度"><a href="#概率与概率密度" class="headerlink" title="概率与概率密度"></a>概率与概率密度</h2><p><img src="/images/SLAM中的概率基础/image-20220511204935450.png" alt="image-20220511204935450" style="zoom:50%;" /></p>
<p>图中，函数 $p(x)$ 表示 $x$ 在区间 $[a,b]$ 上的<strong>概率密度</strong>，它表示的是随机变量在区间的分布情况。</p>
<p>$Pr$ 代表的是 $x$ 在区间 $[c,d]$ 上的<strong>概率</strong>，它是概率密度函数的积分：</p>
<script type="math/tex; mode=display">
Pr(c\leq x \leq d)=\int^d_c p(x)dx\tag{1}</script><p>我们平时所说“高斯分布”、“非高斯分布”均是指它的概率密度。</p>
<h2 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h2><p><strong>联合概率</strong>表示两个事件共同发生的概率。事件 $A$ 和事件 $B$ 的联合概率表示为 $P(A\cap B),P(A,B),P(AB)$ </p>
<p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ 的联合概率密度函数可以表示为 $p(x,y)$，其积分表示 $x,y$ 同处在某个区间的概率，满足下式：</p>
<script type="math/tex; mode=display">
\int^b_a\int^s_rp(x,y)dydx=1\tag{2}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p>
<script type="math/tex; mode=display">
p(x,y)=p(x)p(y)\tag{3}</script><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>就是事件 $A$ 在事件 $B$ 发生的条件下发生的概率。即为 $P(B|A)$.</p>
<p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ ，当在 $y$ 已知的前提下，$x$ 的概率分布满足下式：</p>
<script type="math/tex; mode=display">
p(x)=\int^s_r p(x|y)p(y)dy\tag{4}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p>
<script type="math/tex; mode=display">
p(x|y)=p(x)\tag{5}</script><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>联合概率分解成条件概率和边缘概率的乘积，即</p>
<script type="math/tex; mode=display">
p(x,y)=p(x|y)p(y)=p(y|x)p(x)\tag{6}</script><p>重新整理，即可得贝叶斯公式</p>
<script type="math/tex; mode=display">
p(x|y)=\frac{p(y|x)p(x)}{p(y)}\tag{7}</script><h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>贝叶斯推断可以理解为贝叶斯公式的运用，它是指，如果已知<strong>先验</strong>概率密度函数 $p(x)$，以及<strong>传感器模型</strong> $p(y|x)$，那么就可以根据贝叶斯公式推断出<strong>后验</strong>概率密度。</p>
<script type="math/tex; mode=display">
p(x|y)=\frac{p(y|x)p(x)}{\int p(y|x)p(x)dx}\tag{8}</script><p>实际中，贝叶斯推断有时也叫贝叶斯估计。</p>
<h2 id="高斯概率密度函数"><a href="#高斯概率密度函数" class="headerlink" title="高斯概率密度函数"></a>高斯概率密度函数</h2><p><strong>一维情况下，</strong>高斯概率密度函数表示：</p>
<script type="math/tex; mode=display">
p(x|\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2} }\exp(-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2})\tag{9}</script><p>其中 $\mu$ 为均值， $\sigma$ 为方差。</p>
<p><strong>多维情况下，</strong>高斯概率密度函数表示为：</p>
<script type="math/tex; mode=display">
p(x|\mu,\Sigma)=\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(
-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)
\right)\tag{10}</script><p>其中 $\mu$ 为均值， $\Sigma$ 为方差。</p>
<p>一般把高斯分布写成 $x\sim\mathcal{N}(\mu,\Sigma)$。</p>
<h2 id="联合高斯概率密度函数"><a href="#联合高斯概率密度函数" class="headerlink" title="联合高斯概率密度函数"></a>联合高斯概率密度函数</h2><p>若有高斯分布：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x)&=\mathcal{N}(\mu_x,\Sigma_{xx})\\
p(x)&=\mathcal{N}(\mu_y,\Sigma_{yy})
\end{align*}\tag{11}</script><p>则它们的联合概率密度函数可以表示为:</p>
<script type="math/tex; mode=display">
p(x,y)=\mathcal{N}
\left(
\begin{bmatrix}\mu_x\\\mu_y\end{bmatrix},
\begin{bmatrix}\Sigma_{xx}&\Sigma_{xy}\\\Sigma_{yx}&\Sigma_{yy}\end{bmatrix}
\right)\tag{12}</script><p>由于联合概率满足下式:</p>
<script type="math/tex; mode=display">
p(x,y)=p(x|y)p(y)\tag{13}</script><p>该式在高斯分布的前提下可以重新分解。</p>
<h1 id="高斯分布和协方差矩阵"><a href="#高斯分布和协方差矩阵" class="headerlink" title="高斯分布和协方差矩阵"></a>高斯分布和协方差矩阵</h1><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>由公式 $(10)$可知，零均值的多元高斯分布有如下概率形式：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x)=&\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(
-\frac{1}{2}x^T\Sigma^{-1}x
\right)\\
=&\frac{1}{Z }\exp\left(
-\frac{1}{2}x^T\Sigma^{-1}x
\right)
\end{align*}
\tag{14}</script><p>其中 $\Sigma$ 是<strong>协方差矩阵</strong>，协方差矩阵的逆记作 $Λ = \Sigma^{-1}$ ，也称之为<strong>信息矩阵</strong>。</p>
<p>比如变量 $x$ 为三维的变量时，协方差矩阵为:</p>
<script type="math/tex; mode=display">
\Sigma=\begin{bmatrix}
\Sigma_{11}&\Sigma_{12}&\Sigma_{13}\\
\Sigma_{21}&\Sigma_{22}&\Sigma_{23}\\
\Sigma_{31}&\Sigma_{32}&\Sigma_{33}
\end{bmatrix}\tag{15}</script><p>根据协方差的定义，其中 $Σ_{ij} = E(x_ix_j ) $为对应元素求期望。</p>
<p>关于协方差矩阵的一些案例介绍，可以查看，<a href="https://lukeyalvin.top/posts/8369.html#%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">协方差矩阵</a></p>
<h2 id="协方差矩阵与信息矩阵"><a href="#协方差矩阵与信息矩阵" class="headerlink" title="协方差矩阵与信息矩阵"></a>协方差矩阵与信息矩阵</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>设 $x_2$ 为室外的温度，$x_1 , x_3$ 分别为房间 $1$ 和房间 $3$ 的室内温度:</p>
<script type="math/tex; mode=display">
\begin{align*}
x_2&=v_2\\
x_1&=w_1x_2+v_1\\
x_3&=w_3x_2+v_3\\
\end{align*}\tag{16}</script><p>其中，$w_i$ 为正的常数值，$v_i$ 相互独立，且各自服从协方差矩阵为 $\sigma_i^2$ 的高斯分布。</p>
<p><img src="/images/SLAM中的概率基础/image-20220512153417672.png" alt="image-20220512153417672" style="zoom:25%;" /></p>
<p>从上述关系，根据协方差公式的计算方式，我们可以写出 $x$ 的协方差矩阵，先从对角元素开始计算：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma_{11}=E(x_1x_1)&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1})({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1}))\\
&={\color{red}w_1^2}E({\color{green}v_2^2})+2{\color{red}w_1}E({\color{red}v_1}{\color{green}v_2})+E({\color{red}v_1^2})\\
&={\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}
\end{align*}\tag{17}</script><p>同理有 $\Sigma_{22}={\color{green}\sigma_2^2},\Sigma_{33}={\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}$ ，对于协方差矩阵的非对角元素：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma_{12}&=E(x_1x_2)=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} ){\color{green}v_2})={\color{red}w_1}{\color{green}\sigma_2^2}\\
\Sigma_{13}&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} )({\color{blue}w_3}{\color{green}v_2}+{\color{blue}v_3} ))={\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}
\end{align*}\tag{18}</script><p>以此类推，可以得到整个<strong>协方差矩阵</strong>：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma=\begin{bmatrix}
{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\\
{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}
\end{bmatrix}
\end{align*}\tag{19}</script><p>通过计算<strong>联合高斯分布</strong>从而得到协方差矩阵的逆：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x_1,x_2,x_3)&=p(x_2)p(x_1|x_2)p(x_3|x_2)\\
&={\color{green}\frac{1}{Z_2}\exp(-\frac{x^2_2}{2\sigma_2^2})}
{\color{red}\frac{1}{Z_1}\exp(-\frac{(x_1-w_1x_2)^2}{2\sigma_1^2})}
{\color{blue}\frac{1}{Z_3}\exp(-\frac{(x_3-w_3x_2)^2}{2\sigma_3^2})}\\
&=\frac{1}{Z}\exp(
-x_2^2[{\color{green}\frac{1}{2\sigma_2^2} }
+{\color{red}\frac{w_1^2}{2\sigma_1^2} }
-{\color{blue}\frac{w_3^2}{2\sigma_3^2} }]
-x_1^2{\color{red}\frac{1}{2\sigma_1^2} }
+2x_1x_2{\color{red}\frac{w_1}{2\sigma_1^2} }
-x_3^2{\color{blue}\frac{1}{2\sigma_3^2} }
+2x_3x_2{\color{blue}\frac{w_3}{2\sigma_3^2} })\\
&=\frac{1}{Z}\exp(-\frac{1}{2}
\begin{bmatrix}x_1&x_2&x_3\end{bmatrix}
\begin{bmatrix}
{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\
{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&
{\color{blue}-\frac{w_3}{\sigma_3^2} }\\
0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }
\end{bmatrix}
\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}
)
\end{align*}\tag{20}</script><p>由此得到协方差矩阵的逆，即<strong>信息矩阵</strong>：</p>
<script type="math/tex; mode=display">
Λ =\Sigma^{-1} =\begin{bmatrix}
{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\
{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&
{\color{blue}-\frac{w_3}{\sigma_3^2} }\\
0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }
\end{bmatrix}\tag{21}</script><p><strong>总结：</strong></p>
<p><font color="#660066">协方差矩阵中，非对角元素 $\Sigma_{ij}&gt;0，i\ne j$ 表示两个变量之间是<strong>正相关</strong>；非对角元素 $\Sigma_{ij}=0，i\ne j$ 表示两个变量之间是<strong>相互独立</strong>；</font><br /></p>
<p><font color="#660066">信息矩阵中，非对角元素 $Λ_{ij}&lt;0，i\ne j$ 甚至于  $Λ_{ij}=0，i\ne j$ ，比如 $Λ_{12} &lt; 0$   表示在变量 $x_3$ 发生的条件下，元素 $x_1$ 和 $x_2$ <strong>正相关</strong>。  </font><br /></p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>类似与案例一，定义 $x_1,x_2,x_3$ 关系如下：</p>
<script type="math/tex; mode=display">
x_2=w_1x_1+w_3x_3+v_2\tag{22}</script><p>比如特征三角化，两个相机 pose 得到特征三维坐标。</p>
<p><img src="/images/SLAM中的概率基础/image-20220512164657043.png" alt="image-20220512164657043" style="zoom:25%;" /></p>
<p>同理，根据协方差矩阵的定义，可以得到协方差矩阵：</p>
<script type="math/tex; mode=display">
\Sigma=\begin{bmatrix}
{\color{red}\sigma_1^2}&{\color{red}w_1} {\color{red}\sigma_1^2}&0\\
{\color{red}w_1} {\color{red}\sigma_1^2}
&{\color{green}\sigma_2^2}+{\color{red}w_1} {\color{red}\sigma_1^2}+{\color{blue}w_3}  {\color{blue}\sigma_3^2}
&{\color{blue}w_3}  {\color{blue}\sigma_3^2}\\
0&{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}\sigma_3^2}
\end{bmatrix}\tag{23}</script><p><strong>协方差矩阵中非对角元素为 0 表示变量之 间没有相关性。</strong>这是否意味着信息矩阵中也会为 0 呢？</p>
<p>同样的方法求得协方差矩阵的逆，即<strong>信息矩阵</strong>：</p>
<script type="math/tex; mode=display">
Λ =\Sigma^{-1} =\begin{bmatrix}
{\color{red}\frac{1}{\sigma_1^2} }
+{\color{green}\frac{w_1^2}{\sigma_2^2} }&{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{w_1w_3}{\sigma_2^2} }\\
{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{1}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }\\
{\color{green}\frac{w_1w_3}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }&
{\color{BLUE}\frac{1}{\sigma_3^2} }+{\color{green}\frac{w_3^2}{\sigma_2^2} }
\end{bmatrix}\tag{24}</script><p><strong>总结：</strong></p>
<p><span style="color:red;">虽然 $x_1$ 和 $x_3$ <strong>不相关</strong>，但是不说明他们的信息矩阵对应元素 $Λ_{13}$<br>为 0；恰恰信息矩阵中 $Λ_{13} &gt; 0$, 表示的是在变量 $x_2$ 发生的条件下，变 量$x_1$ 和 $x_3$ 成<strong>负相关</strong>。对应上面的例子即  $x_2$ 为常数，<strong>如果 $x_1$  大，则 $x_3$ 小</strong>。</span></p>
<p><strong>样例的意义: 非常有助于我们了解 SLAM 的信息矩阵 H 的组成。</strong></p>
<h3 id="去除案例1中变量"><a href="#去除案例1中变量" class="headerlink" title="去除案例1中变量"></a>去除案例1中变量</h3><p>如果我们移除变量，信息矩阵或协方差矩阵如何变化呢?</p>
<p>比如对于案例一来说，去除变量$x_3$，那么它的信息矩阵或协方差矩阵如何变化呢?</p>
<p><img src="/images/SLAM中的概率基础/image-20220512170647991.png" alt="image-20220512170647991" style="zoom:25%;" /></p>
<p>利用协方差的计算公式可知，$x_1 , x_2$ 计算协方差时跟 $x_3$ ，并无关系，所以:</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma=\begin{bmatrix}
{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&
\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }\\
{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&
\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }\\
\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }&
\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }&
\xcancel{ {\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2} }
\end{bmatrix}
\end{align*}\tag{25}</script><p>就能得到去除 $x_3$  后的协方差矩阵：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma=\begin{bmatrix}
{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}\\
{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}\\
\end{bmatrix}
\end{align*}\tag{26}</script><p>同样，我们只418133364需要把信息矩阵公式 $(16)$ 中 $x_3$  对应的部分 (蓝色) 去掉 就可以:</p>
<script type="math/tex; mode=display">
Λ =\Sigma^{-1} =\begin{bmatrix}
{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&\xcancel{0}\\
{\color{red}\frac{w_1}{\sigma_1^2} }&
{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2}+\xcancel{ {\color{blue}\frac{w_3^2}{\sigma_3^2} } } }&
\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }\\
\xcancel{0}&
\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }&
\xcancel{ {\color{blue}-\frac{1}{\sigma_3^2} } }
\end{bmatrix}\tag{27}</script><p>从而得到：</p>
<script type="math/tex; mode=display">
Λ =\Sigma^{-1} =\begin{bmatrix}
{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\
{\color{red}\frac{w_1}{\sigma_1^2} }&
{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\
\end{bmatrix}\tag{28}</script><p>是不是非常简单？但是问题在于：<strong>实际操作过程中并不会有这种颜色标记。</strong></p>
<p>这时，需要引入 marginalization <strong>(边缘化)</strong> 和 Schur’s complement <strong>(舒尔补)</strong>来解决这个问题。</p>
<h1 id="舒尔补及其应用"><a href="#舒尔补及其应用" class="headerlink" title="舒尔补及其应用"></a>舒尔补及其应用</h1><h2 id="舒尔补的概念"><a href="#舒尔补的概念" class="headerlink" title="舒尔补的概念"></a>舒尔补的概念</h2><p>给定任意矩阵块 $M$，如下所示：</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{29}</script><p>如果，矩阵块 $D$ 是可逆的，则 $A − BD^{−1} C$称之为 $D$ 关于 $M$ 的舒尔补。</p>
<p>如果，矩阵块 $A$ 是可逆的，则 $D − CA^{−1} B$ 称之为 $A$ 关于 $M$ 的舒尔补。</p>
<h2 id="舒尔补的来由"><a href="#舒尔补的来由" class="headerlink" title="舒尔补的来由"></a>舒尔补的来由</h2><p>将 $M$ 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p>
<script type="math/tex; mode=display">
\begin{align*}
\begin{bmatrix}
I&0\\-CA^{-1}&I
\end{bmatrix}
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}=
\begin{bmatrix}
A&B\\0&\Delta_A
\end{bmatrix}\\
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}
\begin{bmatrix}
I&-A^{-1}B\\0&I
\end{bmatrix}=
\begin{bmatrix}
A&0\\C&\Delta_A
\end{bmatrix}
\end{align*}\tag{30}</script><p>其中：$∆_A = D − CA^{−1} B$。联合起来，将 $M$ 变形成对角形：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I&0\\-CA^{-1}&I
\end{bmatrix}
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}
\begin{bmatrix}
I&-A^{-1}B\\0&I
\end{bmatrix}=
\begin{bmatrix}
A&0\\0&\Delta_A
\end{bmatrix}\tag{31}</script><p>反过来，我们又能从对角形恢复成矩阵 $M$：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I&0\\CA^{-1}&I
\end{bmatrix}
\begin{bmatrix}
A&0\\0&\Delta_A
\end{bmatrix}
\begin{bmatrix}
I&A^{-1}B\\0&I
\end{bmatrix}=
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}
\tag{32}</script><h2 id="舒尔补分解的好处"><a href="#舒尔补分解的好处" class="headerlink" title="舒尔补分解的好处"></a>舒尔补分解的好处</h2><p><strong>快速求解矩阵 M 的逆</strong>。由于矩阵 $M$ 可以写成：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}=
\begin{bmatrix}
I&0\\CA^{-1}&I
\end{bmatrix}
\begin{bmatrix}
A&0\\0&\Delta_A
\end{bmatrix}
\begin{bmatrix}
I&A^{-1}B\\0&I
\end{bmatrix}
\tag{33}</script><p>由此可得到矩阵 $M$ 的逆：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}^{-1}=
\begin{bmatrix}
I&-A^{-1}B\\0&I
\end{bmatrix}
\begin{bmatrix}
A^{-1}&0\\0&\Delta_A^{-1}
\end{bmatrix}
\begin{bmatrix}
I&0\\-CA^{-1}&I
\end{bmatrix}
\tag{34}</script><p>我们发现，原本复杂的求逆矩阵的过程变得更加容易了。</p>
<h2 id="舒尔补应用于多元高斯分布"><a href="#舒尔补应用于多元高斯分布" class="headerlink" title="舒尔补应用于多元高斯分布"></a>舒尔补应用于多元高斯分布</h2><p>假设多元变量 $x$ 服从高斯分布，且由两部分组成：$x=\begin{bmatrix}a\\b\end{bmatrix}$，变量之间的协方差矩阵为：</p>
<script type="math/tex; mode=display">
K=\begin{bmatrix}Cov(a,a)&Cov(a,b)\\Cov(b,a)&Cov(b,b)\end{bmatrix}=\begin{bmatrix}A&C^T\\C&D\end{bmatrix}\tag{35}</script><p>依据公式 $(6)$ ，变量 $x$ 的概率分布为：</p>
<script type="math/tex; mode=display">
P(a,b)=p(b|a)p(a)∝\exp
\left(
-\frac{1}{2}
\begin{bmatrix}a\\b\end{bmatrix}^T
\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}
\begin{bmatrix}a\\b\end{bmatrix}
\right)\tag{36}</script><p>利用舒尔补进行分解指数部分：</p>
<script type="math/tex; mode=display">
\begin{align*}
&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\\
&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}
I&-A^{-1}C^T\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}\right)\\
&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a^T&(b-CA^{-1}a)^T\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}a\\b-CA^{-1}a\end{bmatrix}\right)\\
&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)+(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\
&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)\right)\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\
&∝p(a)p(b|a)
\end{align*}\tag{37}</script><p>类似与公式 $(6)$ 的贝叶斯公式，我们将联合概率分解成条件概率和边缘概率的乘积。对于高斯分布而言，我们可以从多元高斯分布 $P(a,b)$ 中分解得到边际概率 $p(a)$ 和 条件概率 $p(b|a)$。</p>
<h3 id="P-a-P-b-a-的协方差矩阵"><a href="#P-a-P-b-a-的协方差矩阵" class="headerlink" title="$P(a), P(b|a)$ 的协方差矩阵"></a>$P(a), P(b|a)$ 的协方差矩阵</h3><p>$P(a)$ 的启示:</p>
<script type="math/tex; mode=display">
P(a)∝\exp
\left(
-\frac{1}{2}a^TA^{-1}a
\right)\sim\mathcal{N}(0,A)\tag{38}</script><p><span style="color:red;"><strong>启示：边际概率的协方差就是从联合分布中取对应的矩阵块就行了。</strong></span></p>
<p>$P(b|a)$ 的启示:</p>
<script type="math/tex; mode=display">
P(b|a)∝\exp
\left(
-\frac{1}{2}(b-CA^{-1}a)^T\Delta_A^{-1}(b-CA^{-1}a)\tag{39}
\right)</script><p><span style="color:red;"><strong>启示：$P(b|a)\sim \mathcal{N} (CA^{−1} a,\Delta_A )$。条件概率的协方差变为 $a$ 对应的舒尔补，均值也变了。</strong></span></p>
<h3 id="P-a-P-b-a-的信息矩阵"><a href="#P-a-P-b-a-的信息矩阵" class="headerlink" title="$P(a), P(b|a)$ 的信息矩阵"></a>$P(a), P(b|a)$ 的信息矩阵</h3><p><strong>为什么要讨论 $P (a), P (b|a)$ 的信息矩阵？</strong><br>因为基于优化的 SLAM 问题中，我们往往直接操作的是<strong>信息矩阵</strong>，而不是协方差矩阵。所以，有必要知道边际概率，条件概率的信息矩阵是何形式。</p>
<p>假设已知<strong>联合分布的信息矩阵</strong>：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}^{-1}=
\begin{bmatrix}
Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}
\end{bmatrix}\tag{40}</script><p>另外，由公式 $(34)$ 可知，协方差矩阵各块和信息矩阵之间有：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
A&B\\C&D
\end{bmatrix}^{-1}=
\begin{bmatrix}
A^{-1}+A^{-1}C^T\Delta_A^{-1}CA^{-1}
&-A^{-1}C^T\Delta_A^{-1}\\
-\Delta_A^{-1}CA^{-1}&\Delta_A^{-1}
\end{bmatrix}
\triangleq
\begin{bmatrix}
Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}
\end{bmatrix}\tag{41}</script><p>其中：$∆_A^{-1} = [D − CA^{−1} B]^{-1}$。</p>
<p>由条件概率 $P (b|a)$ 的<strong>协方差矩阵</strong>为 $∆_A$ 以及公式 $(41)$，易得其<strong>信息矩阵</strong>为：</p>
<script type="math/tex; mode=display">
∆_A^{-1}=Λ_{bb}\tag{42}</script><p>由边际概率 $P (a)$ 的<strong>协方差矩阵</strong>为 $A$ 以及公式$(41)$，易得其<strong>信息矩阵</strong>为：</p>
<script type="math/tex; mode=display">
A^{-1}=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\tag{43}</script><p>由此我们就知道如何从<strong>联合分布的信息矩阵</strong>中求解 $P ( a )$和 $P(b|a)$ 的<strong>信息矩阵</strong>了。</p>
<h2 id="回顾样例"><a href="#回顾样例" class="headerlink" title="回顾样例"></a>回顾样例</h2><p>回顾 “<strong>去除案例1中变量</strong>” 中去除变量 $x_3$ 的操作</p>
<p><img src="/images/SLAM中的概率基础/image-20220512213456958.png" alt="image-20220512213456958" style="zoom: 33%;" /></p>
<p>从联合分布 $P (x_1 , x_2 , x_3 )$中 marg 掉变量 $x_3$ ，即 $P (x_1 , x_2 )$ 对应的信息矩阵可以用公式 $(43)$ 得到。</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma^{-1}_2&=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\\
&=Λ_{aa}-\begin{bmatrix}0\\-\frac{w_3}{\sigma^2_3}\end{bmatrix}\sigma^2_3
\begin{bmatrix}0&-\frac{w_3}{\sigma^2_3}\end{bmatrix}\\
&=Λ_{aa}-\begin{bmatrix}0&0\\0&\frac{w_3}{\sigma^2_3}\end{bmatrix}\\
&=\begin{bmatrix}
{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\
{\color{red}\frac{w_1}{\sigma_1^2} }&
{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\
\end{bmatrix}
\end{align*}\tag{44}</script><p>这么操作，就使得在已知<strong>联合分布的信息矩阵</strong>的前提下，我们通过舒尔补的操作，即 $(44)$ 中的 $Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}$，65                   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。 条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。</strong> 表格总结如下:</p>
<script type="math/tex; mode=display">
P(a,b)=\mathcal{N}\left(
\begin{bmatrix}\mu_a\\\mu_b\end{bmatrix},
\begin{bmatrix}\Sigma_{aa}&\Sigma_{ab}\\\Sigma_{ba}&\Sigma_{bb}\end{bmatrix}
\right)=
\mathcal{N}^{-1}
\left(
\begin{bmatrix}\eta_a\\\eta_b\end{bmatrix},
\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}
\right)
\tag{45}</script><p><img src="/images/SLAM中的概率基础/image-20220512215118251.png" alt="image-20220512215118251" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>概率基础</tag>
      </tags>
  </entry>
  <entry>
    <title>六、VIO视觉残差的构建以及雅可比的求取</title>
    <url>/posts/c041a7d0.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p>
<h1 id="VIO残差构建"><a href="#VIO残差构建" class="headerlink" title="VIO残差构建"></a>VIO残差构建</h1><p>VIO重投影误差：</p>
<p>具体详解见：<a href="https://lukeyalvin.top/posts/ddbf64.html#VIO%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE"><a href="https://lukeyalvin.top/posts/ddbf64.html#VIO重投影误差">VIO重投影误差</a></a></p>
<p><img src="/images/5-VIO视觉残差的构建以及雅可比的求取/image-20220505205125811-16522560257751.png" alt="image-20220505205125811" style="zoom: 33%;" /></p>
<p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p>
<script type="math/tex; mode=display">
\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=
T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}
\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{1}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p>
<script type="math/tex; mode=display">
r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u_{cj}\\\frac{Y_{cj} }{Z_{cj} }-v_{cj}\end{bmatrix}\tag{2}</script><h1 id="VIO残差的雅可比推导"><a href="#VIO残差的雅可比推导" class="headerlink" title="VIO残差的雅可比推导"></a>VIO残差的雅可比推导</h1><p>按照变换矩阵和旋转矩阵之间的关系：</p>
<script type="math/tex; mode=display">
\begin{align*}
T_{bc}^{-1}&=\begin{bmatrix}R^T_{bc}&-R^T_{bc}p_{bc}\\0^T&1\end{bmatrix},\ 
T_{wb_j}^{-1}=\begin{bmatrix}R^T_{wb_j}&-R^T_{wb_j}p_{wb_j}\\0^T&1\end{bmatrix}\\
T_{wb_j}&=\begin{bmatrix}R^T_{wb_j}&p_{wb_j}\\0^T&1\end{bmatrix},
\ \ \ \ \  \ \  \ 
T_{bc}=\begin{bmatrix}R^T_{bc}&p_{bc}\\0^T&1\end{bmatrix}
\end{align*}\tag{3}</script><p>根据公式$(3)$将公式$(1)$中拆分成三维坐标形式：</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{c_j}=\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\end{bmatrix}&=
R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}\frac{1}{\lambda}
\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\
&+R^{T}_{bc}
\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)
\end{align*}
\tag{4}</script><p>为了推导的方便定义如下公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{c_i}&=\frac{1}{\lambda}
\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\
f_{b_i}&=R_{bc}f_{c_i}+p_{bc}\\
f_w&=R_{wb_i}f_{b_i}+p_{wb_i}\\
f_{b_j}&=R^T_{wb_j}(f_{w}-p_{bc})\\
\end{align*}\tag{5}</script><p>雅可比矩阵 为视觉误差对两个时刻的状态量，外参以及逆深度求导：</p>
<script type="math/tex; mode=display">
J=\begin{bmatrix}
\frac{\partial r_c}{\partial\begin{bmatrix}
\delta\mathbf{p}_{b_ib_i^\prime}\\ \delta\theta_{b_ib_i^\prime} \end{bmatrix} }&
\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_jb_j^\prime}\\ \delta\theta_{b_jb_j^\prime} \end{bmatrix} }&
\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{cc^\prime}\\ \delta\theta_{cc^\prime} \end{bmatrix} }&
\frac{\partial r_c}{\partial\delta\lambda } 
\end{bmatrix}\tag{6}</script><p>根据链式法则， Jacobian 的计算可以分两步走:</p>
<ul>
<li>第一步误差对 $f_{c_j}$ 求导：  </li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial r_c}{\partial f_{c_j} }=
\begin{bmatrix}
\frac{1}{Z_{c_j} }&0&\frac{X_{c_j}}{Z_{c_j}^2 }\\
0&\frac{1}{Z_{c_j} }&\frac{Y_{c_j}}{Z_{c_j}^2 }
\end{bmatrix}\tag{7}</script><ul>
<li>第二步对 $f_{c_j}$ 对各状态量求导：</li>
</ul>
<ol>
<li><strong>对 $i$ 时刻的状态量求导</strong></li>
</ol>
<p>① 对 $i$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p>
<script type="math/tex; mode=display">
\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_ib_i^\prime} }=R^{T}_{bc}R^{T}_{wb_j}\tag{8}</script><p>② 对 $i$ 时刻的<strong>角度</strong>增量求导</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{c_j}=
R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}
\left(
R^{T}_{wb_j}\left( ({\color{red}R_{wb_i} }p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)
\end{align*}
\tag{9}</script><p>上面公式和 $i$ 时刻角度相关的量并不多，下面为了简化，直接丢弃了不相关的部分 :</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{c_j}&=
R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }p_{bc}+(···)\\
&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(R_{bc}f_{c_i}+p_{bc})+(···)\\
&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}+(···)
\end{align*}
\tag{9}</script><p> 雅可比矩阵为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }
&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(I+[\delta\theta_{b_ib^\prime_i}]^{\land})f_{b_i}-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}
}{\partial\delta\theta_{b_ib^\prime_i} }\\
&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[\delta\theta_{b_ib^\prime_i}]^{\land}f_{b_i} }{\partial\delta\theta_{b_ib^\prime_i} }\\
&=-\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} [\delta\theta_{b_ib^\prime_i}]}{\partial\delta\theta_{b_ib^\prime_i} }\\
&=-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} 
\end{align*}\tag{10}</script><ol>
<li><strong>对 $j$ 时刻的状态量求导</strong></li>
</ol>
<p>① 对 $j$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p>
<script type="math/tex; mode=display">
\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_jb_j^\prime} }=-R^{T}_{bc}R^{T}_{wb_j}\tag{11}</script><p>② 对 $j$ 时刻的<strong>角度</strong>增量求导</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{c_j}&=
R^{T}_{bc}{\color{green}R^{T}_{wb_j} }R_{wb_i}R_{bc}f_{c_i}+R^{T}_{bc}
\left(
{\color{green}R^{T}_{wb_j} }\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)\\
&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }\left(
R_{wb_i}(R_{bc}f_{c_i}+p_{bc})+p_{wb_j}-p_{wb_j}
\right)+(···)\\
&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }(f_w-p_{wb_j})+(···)\\
\end{align*}
\tag{12}</script><p> 雅可比矩阵为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }
&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}(I-[\delta\theta_{b_ib^\prime_j}]^{\land}){\color{green}R^T_{wb_j} }(f_w-p_{wb_j})-R^{T}_{bc}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})
}{\partial\delta\theta_{b_ib^\prime_i} }\\
&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\
&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}f_{b_j} }{\partial\delta\theta_{b_ib^\prime_i} }\\
&-=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}
\frac{\partial
R^{T}_{bc}[f_{b_j}]^{\land}[\delta\theta_{b_ib^\prime_j}] }{\partial\delta\theta_{b_ib^\prime_i} }\\
&=-R^{T}_{bc}[f_{b_j}]^{\land}
\end{align*}\tag{13}</script><ol>
<li><strong>对 imu 和相机之间的外参求导</strong>  </li>
</ol>
<p>① 对<strong>位移</strong>求导</p>
<script type="math/tex; mode=display">
\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{cc^\prime} }=R^{T}_{bc}(R^{T}_{wb_j}R_{wb_i}-I_{3\times 3})\tag{14}</script><p>② 对<strong>角度</strong>增量求导，由于 $f_{c_j}$ 都和 $R_{bc}$ 有关，并且比较复杂，所以这次分两部分求导  </p>
<script type="math/tex; mode=display">
\begin{align*}
f_{c_j}&=
{\color{green}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i} }
+
{\color{blue}
R^{T}_{bc}\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)}\\
&={\color{green}f^1_{c_j} }+{\color{blue}f^2_{c_j} }
\end{align*}
\tag{15}</script><p>第一部分 ${\color{green}f^1_{c_j} }$ 雅可比为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial f_{c_j}^1 }{\partial\delta\theta_{cc^\prime} }=
&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}
\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\land}) R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(I+[\delta\theta_{cc^\prime}]^{\land}) f_{c_i}-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc} }{\partial\delta\theta_{cc^\prime} }\\
&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}
\frac{\partial R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[\delta\theta_{cc^\prime}]^{\land}f_{c_i}-
[\delta\theta_{cc^\prime}]^{\land} R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}+o^2(\theta_{cc^\prime}) }{\partial\delta\theta_{cc^\prime} }\\
&\approx \underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}
\frac{\partial -R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\land}[\delta\theta_{cc^\prime}]+
[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\land}[\delta\theta_{cc^\prime}] ) }{\partial\delta\theta_{cc^\prime} }\\
&=-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\land}+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\land}
\end{align*}\tag{16}</script><p>第一部分 ${\color{blue}f^2_{c_j} }$ 雅可比为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial f_{c_j}^2 }{\partial\delta\theta_{cc^\prime} }
&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}
\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\land} ) R^{T}_{bc}\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)-R^{T}_{bc}\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right) }{\partial\delta\theta_{cc^\prime} }\\
&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}
\frac{\partial-[\delta\theta_{cc^\prime}]^{\land} R^{T}_{bc}\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right) }{\partial\delta\theta_{cc^\prime} }\\
&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}
\frac{\partial-[R^{T}_{bc}\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)]^{\land}[\delta\theta_{cc^\prime}]  }{\partial\delta\theta_{cc^\prime} }\\
&=[R^{T}_{bc}\left(
R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}
\right)]^{\land}
\end{align*}\tag{17}</script><p>两个 Jacobian 相加就是视觉误差对外参中的角度增量的最终结果。  </p>
<ol>
<li><strong>视觉误差对特征逆深度的求导</strong>  </li>
</ol>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial f_{c_j} }{\partial \delta\lambda}&=
\frac{\partial f_{c_j} }{\partial f_{c_i} }
\frac{\partial f_{c_i} }{\partial \delta\lambda}\\
&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(-\frac{1}{\lambda^2}\begin{bmatrix}
u_{c_i}\\v_{c_i}\\1 \end{bmatrix})\\
&=-\frac{1}{\lambda}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}
\end{align*}\tag{18}</script>]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
      </tags>
  </entry>
  <entry>
    <title>五、预积分残差的雅克比求取</title>
    <url>/posts/b68d674.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>对于右乘雅可比，我们做如下的公式简化：</p>
<script type="math/tex; mode=display">
\frac{\partial x_a}{\partial \delta\theta}=
\underset{\delta\theta\rightarrow0}{lim}\frac{R_{ab}\exp([\delta\theta]^{\land})x_b-R_{ab}x_b}{\delta\theta}</script><p>后续简写为：</p>
<script type="math/tex; mode=display">
\frac{\partial x_a}{\partial \delta\theta}=
\frac{R_{ab}\exp([\delta\theta]^{\land})x_b}{\delta\theta}</script><h1 id="预积分残差的雅克比求取"><a href="#预积分残差的雅克比求取" class="headerlink" title="预积分残差的雅克比求取"></a>预积分残差的雅克比求取</h1><p>定义：一段时间内 IMU 构建的预积分量作为<strong>测量值</strong>，对两时刻之间的状态量进行约束，  </p>
<script type="math/tex; mode=display">
\begin{align*}
\mathbf{e}_{B}(x_i,x_j)=\begin{bmatrix}
r_p\\r_q\\r_v\\r_{ba}\\r_{bg}
\end{bmatrix}_{15\times1}=
\begin{bmatrix}
q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-
{\color{blue}\alpha_{b_ib_j} }\\
2[{\color{blue}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\
q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{blue}\beta_{b_ib_j} }\\
b^a_j-b^a_i\\
b^g_j-b^g_i
\end{bmatrix}
\end{align*}\tag{1}</script><p>其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\
\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\
q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t
\end{align*}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第二项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p>
<p>在求解非线性方程时，需要知道误差 $\mathbf{e}_{B}$ 对两个关键帧 $i, j$ 的状态量 $p, q, v, ba, bg$ 的雅可比。对 $i, j$ 时刻的状态量 $p, q, v$ 求导还是比较直观的，直接对误差公式进行计算就行。但是对 $i$ 时刻的 $b^a_i , b^g_i$ 求导就显得十分复杂，下面我们详细讨论。  </p>
<p>因为 $i$ 时刻的 bias 相关的预积分计算是通过迭代一步一步累计递推的，可以算但是太复杂。所以对于预积分量直接在 $i$ 时刻的 bias 附近用<strong>一阶泰勒展开</strong>来近似，而不用真的去迭代计算。  </p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_{b_ib_j}&=\alpha_{b_ib_j}+J^{\alpha}_{b^a_i}\delta b^a_i+J^{\alpha}_{b^g_i}\delta b^g_i\\
\beta_{b_ib_j}&=\beta_{b_ib_j}+J^{\beta}_{b^a_i}\delta b^a_i+J^{\beta}_{b^g_i}\delta b^g_i\\
q_{b_ib_j}&=q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^{q}_{b^g_i}\delta b^g_i \end{bmatrix}
\end{align*}\tag{2}</script><p>其中 $J^{\alpha}_{b^a_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^a_i},J^{\alpha}_{b^g_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^g_i},J^{\beta}_{b^a_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^a_i},J^{\beta}_{b^g_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^g_i},J^{q}_{b^g_i}=\frac{\partial q_{b_ib_j} }{\partial\delta b^g_i}$，表示预积分量对 $i$ 时刻的 bias 求导。</p>
<p>这些雅克比根据前面讨论的<strong>协方差传递公式</strong>，能一步步递推得到：  </p>
<script type="math/tex; mode=display">
J_{k+1}=\mathbf{F}J_k\tag{3}</script><h2 id="r-v-对各状态量的雅可比"><a href="#r-v-对各状态量的雅可比" class="headerlink" title="$r_v$ 对各状态量的雅可比"></a>$r_v$ 对各状态量的雅可比</h2><p>下面我们来讨论 IMU 误差相对于两帧的 PVQ 的 雅克比:由于 $r_p$ 和 $r_v$ 的误差形式很相近，对各状态量求导的 雅克比形式也很相似，所以这里只对 $r_v$ 的推导进行详细介绍  </p>
<p>① 对 $i$ 时刻<strong>位移</strong>的雅可比</p>
<script type="math/tex; mode=display">
\frac{\partial r_v}{\partial\delta p_{b_ib^\prime_i} }=0\tag{4}</script><p>② 对 $i$ 时刻<strong>旋转</strong>的雅可比</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial r_v}{\partial\delta \theta_{b_ib^\prime_i} }&=
\frac{\partial (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2} \delta \theta_{b_ib^\prime_i}\end{bmatrix})^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ 
&=
\frac{\partial (R_{wb_i}\exp([\delta \theta_{b_ib^\prime_i}]^{\land}))^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ 
&=
\frac{\partial\exp([-\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ 
&=
\frac{\partial(I-[\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ 
&=
\frac{\partial -[\delta \theta_{b_ib^\prime_i}]^{\land}[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]}{\partial\delta \theta_{b_ib^\prime_i} }\\ 
&=
\frac{\partial -[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}[\delta \theta_{b_ib^\prime_i}]}{\partial\delta \theta_{b_ib^\prime_i} }\\
&=[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}
\end{align*}\tag{5}</script><p>③ 对 $i$ 时刻<strong>速度</strong>的雅可比</p>
<script type="math/tex; mode=display">
\frac{\partial r_v}{\partial\delta v_i^w}=-R_{b_iw}\tag{6}</script><p>④ 对 $i$ 时刻<strong>加速度 bais</strong>的雅可比 ,注意 bias 量只和预积分 $\beta$ 有关：  </p>
<script type="math/tex; mode=display">
\frac{\partial r_v}{\partial\delta b_i^a}
=-\frac{\partial \beta_{b_ib_j} }{\partial\delta b_i^a}
=-J^{\beta}_{b^a_i}\tag{7}</script><h2 id="r-q-对各状态量的雅可比"><a href="#r-q-对各状态量的雅可比" class="headerlink" title="$r_q$ 对各状态量的雅可比"></a>$r_q$ 对各状态量的雅可比</h2><p>① 对 $i$ 时刻<strong>旋转</strong>的雅可比</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }
&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\
&=\frac{\partial2[q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*
\otimes q_{wb_j}]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\
&=\frac{\partial-2[(q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*
\otimes q_{wb_j})^*]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\
&=\frac{\partial-2[q_{wb_j}^* \otimes (q_{wb_i}\otimes\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})\otimes q_{b_ib_j}
 ]_{xyz}}{\partial \delta\theta_{b_ib^\prime_i} }\\
&=-2[0\ \ I]
\frac{\partial[q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R
\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}
\end{bmatrix} }
{\partial \delta\theta_{b_ib^\prime_i} }\\
&=-2[0\ \ I]
[q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R
\begin{bmatrix}
0\\\frac{1}{2}I
\end{bmatrix}
\end{align*}\tag{8}</script><p>其中 $[·]_L$ 和 $[·]_R$ 为四元数转为左/右旋转矩阵的算子。  </p>
<p>② 对 $j$ 时刻<strong>旋转</strong>的雅可比</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }
&=\frac{\partial2[q_{b_jb_i}
\otimes(q_{b_iw}
\otimes q_{wb_j})]_{xyz} }
{\partial \delta\theta_{b_jb^\prime_j} }\\
&=\frac{\partial2[q_{b_ib_j}^*
\otimes q_{wb_i}^*
\otimes q_{wb_j}
\otimes 
\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}
\end{bmatrix} 
]_{xyz} }
{\partial \delta\theta_{b_jb^\prime_j} }\\
&=\frac{\partial2[[q_{b_ib_j}^*
\otimes q_{wb_i}^*
\otimes q_{wb_j}]_L
\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}
\end{bmatrix} 
]_{xyz} }
{\partial \delta\theta_{b_jb^\prime_j} }\\
&=2[0\ \ I][q_{b_ib_j}^*
\otimes q_{wb_i}^*
\otimes q_{wb_j}]_L
\begin{bmatrix}
0\\\frac{1}{2}I
\end{bmatrix}
\end{align*}\tag{9}</script><p>② 对 $i$ 时刻<strong>陀螺仪偏置 $b^g_i$</strong> 的雅可比</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial r_v}{\partial\delta b_i^g}
&=\frac{\partial2[q_{b_jb_i}
\otimes(q_{b_iw}
\otimes q_{wb_j})]_{xyz} }
{\partial\delta b_i^g}\\
&=\frac{\partial2
[(q_{b_ib_j}\otimes
\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*
\otimes q_{wb_i}^*
\otimes q_{wb_j}]_{xyz} }
{\partial\delta b_i^g}\\
&=\frac{\partial-2
[((q_{b_ib_j}\otimes
\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*
\otimes q_{wb_i}^*
\otimes q_{wb_j})^*]_{xyz} }
{\partial\delta b_i^g}\\
&=\frac{\partial-2
[q_{wb_j}^*\otimes q_{wb_i}\otimes
(q_{b_ib_j} \otimes 
\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix}
)]_{xyz} }
{\partial\delta b_i^g}\\
&=-2[0\ \ I][q_{wb_j}^*\otimes q_{wb_i}\otimes q_{b_ib_j}]_L
\begin{bmatrix}0\\\frac{1}{2}J^q_{b^g_i}\end{bmatrix}
\end{align*}\tag{10}</script>]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>预积分理论</tag>
      </tags>
  </entry>
  <entry>
    <title>四、IMU误差状态传递方程的推导</title>
    <url>/posts/aaff1b40.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="IMU误差状态传递方程的推导"><a href="#IMU误差状态传递方程的推导" class="headerlink" title="IMU误差状态传递方程的推导"></a>IMU误差状态传递方程的推导</h1><h2 id="协方差的传播"><a href="#协方差的传播" class="headerlink" title="协方差的传播"></a>协方差的传播</h2><p>例如，已知一个变量$y=Ax,x\in \mathcal{N}(0,\Sigma_{x})$，则有$\Sigma_y=A\Sigma_xA^T$</p>
<script type="math/tex; mode=display">
\begin{align*}
\Sigma_y&=E((Ax)(Ax)^T)\\
&=E(Axx^TA^T)\\
&=A\Sigma_xA^T
\end{align*}\tag{1}</script><p>我们知道，一个IMU数据作为测量值的噪声方差我们可以标定 （类似公式$(1)$中的已知量$x$），那么一段时间的多个IMU数据形成的IMU数据积分形式的预积分量的方差（类似公式$(1)$中的已知量$y$），就可以通过以上形式求解，关键是找出IMU  噪声与预积分量之间的<strong>线性递推关系</strong>（类似公式$(1)$中的已知量$y=Ax$）。</p>
<p>假设已知了<strong>相邻时刻误差的线性传递方程：</strong></p>
<script type="math/tex; mode=display">
\eta_{ik}=\mathbf{F}_{k-1}\eta_{ik-1}+\mathbf{G}_{k-1}\mathbf{n}_{k-1}\tag{2}</script><p>比如：状态量误差为 $\eta_{ik}=[\delta\theta_{ik},\delta\mathbf{v}_{ik},\delta\mathbf{p}_{ik}]$，$\eta_{ik}$为当前时刻的误差，$\eta_{ik-1}$为上一时刻的误差；<strong>测量噪声</strong>为 $\mathbf{n}_{k}=[\mathbf{n}_{k}^a,\mathbf{n}_{k}^g]$，因此，误差的传递由两部分组成，即<strong>当前时刻的误差传递给下一时刻，当前时刻的测量噪声传递给下一时刻</strong>。</p>
<p>如果已知上面的误差状态传递方程，那么一段时间内IMU积分的协方差矩阵就可以轻松递推算出：</p>
<script type="math/tex; mode=display">
\Sigma_{ik}=\mathbf{F}_{k-1}\Sigma_{ik-1}\mathbf{F}_{k-1}^T+\mathbf{G}_{k-1}\Sigma_\mathbf{n}\mathbf{G}_{k-1}^T\tag{3}</script><p>其中，$\Sigma_n$是<strong>测量噪声的协方差矩阵</strong>，方差从 $i$ 时刻开始进行递推，$\Sigma_{ii}=0$</p>
<h2 id="状态误差线性递推方程的推导"><a href="#状态误差线性递推方程的推导" class="headerlink" title="状态误差线性递推方程的推导"></a>状态误差线性递推方程的推导</h2><p>通常情况下，对于状态量之间的递推关系是非线性的方程，如 $x_k=f(x_{k-1},\mathbf{u}_{k-1})$，其中状态量 $x,\mathbf{u}$ 为系统的输入量。</p>
<p>我们可以用两种方法来推导误差传递的线性递推关系：</p>
<ul>
<li>一种是<strong>基于一阶泰勒展开</strong>的误差传递方程，主要应用于 EKF 的协方差预测。</li>
<li>一种是<strong>基于误差随时间变化</strong>的递推方程。</li>
</ul>
<h3 id="基于一阶泰勒展开"><a href="#基于一阶泰勒展开" class="headerlink" title="基于一阶泰勒展开"></a>基于一阶泰勒展开</h3><p>令状态量为 $x=\hat{x}+\delta x$，其中，真值为$\hat{x}$，误差为 $\delta x$，另外输入量 $\mathbf{u}$ 的噪声为 $\mathbf{n}$。</p>
<p>对于非线性系统  $x_k=f(x_{k-1},\mathbf{u}_{k-1})$ 进行一阶泰勒展开有：</p>
<script type="math/tex; mode=display">
\begin{align*}
x_k&=f(x_{k-1},\mathbf{u}_{k-1})\\
\hat{x}_k+\delta x_k&=f(\hat{x}_{k-1}+\delta x_{k-1},\hat{\mathbf{u} }_{k-1}+\mathbf{n}_{k-1})\\
{\color{blue}\hat{x}_k}+\delta x_k&=
{\color{blue}f(\hat{x}_{k-1},\hat{\mathbf{u} }_{k-1})}+\mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}
\end{align*}\tag{4}</script><p>可以看出蓝色字体部分表示真值，他们相互抵消掉了，剩下的就是误差的线性递推关系：</p>
<script type="math/tex; mode=display">
\delta x_k = \mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\tag{5}</script><p>其中，$\mathbf{F}$ 是状态量 $x_k$ 对状态量 $x_{k-1}$ 的雅可比矩阵， $\mathbf{G}$ 是状态量 $x_k$ 对输入量 $\mathbf{u}_{k-1}$ 的雅可比矩阵。</p>
<h3 id="基于误差随时间变化"><a href="#基于误差随时间变化" class="headerlink" title="基于误差随时间变化"></a>基于误差随时间变化</h3><p>如果我们能够推导状态误差随着时间变换的倒数关系，比如：</p>
<script type="math/tex; mode=display">
\dot{\delta x}=\mathbf{A}\delta x+\mathbf{B}\mathbf{n}\tag{6}</script><p>则误差状态的递推方程为：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\delta x_k = \delta x_{k-1} + \dot{\delta x_{k-1} }\Delta t\\
\rightarrow&\delta x_k=(\mathbf{I}+\mathbf{A}\Delta t)\delta x_{k-1}+\mathbf{B}\Delta t \mathbf{n}_{k-1} 
\end{align*}\tag{7}</script><p>综合两种方法可以发现：</p>
<script type="math/tex; mode=display">
\mathbf{F}=\mathbf{I}+\mathbf{A}\Delta t,\ \ \ \ \mathbf{G}=\mathbf{B}\Delta t\tag{8}</script><p>由于在 VIO 系统中我们已经知道了状态的导数与状态之间的旋转矩阵，如公式 $(26)$:</p>
<script type="math/tex; mode=display">
\dot{\mathbf{v} }=Ra^b+g\tag{9}</script><p>那么我们就可以推导<strong>速度误差</strong>和<strong>状态误差</strong>之间的关系，再每一项上都加上各自的误差，既有：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot{\mathbf{v} }+\dot{\delta\mathbf{v} }&=R(\mathbf{I}+[\delta\theta]^{\land})(a^b+\delta a^b)+g+\delta g\\
\dot{\delta\mathbf{v} }&=R\delta a^b+R[\delta\theta]^{\land}(a^b+\delta a^b)+\delta g\\
\dot{\delta\mathbf{v} }&=R\delta a^b-R[a^b]^{\land}\delta\theta+\delta g
\end{align*}\tag{10}</script><p>由此就可以以此类推，很轻易的写出整个 $\mathbf{A}$ 和 $\mathbf{B}$ ，这也是此方法的优点。 </p>
<h1 id="基于一阶泰勒展开的推导"><a href="#基于一阶泰勒展开的推导" class="headerlink" title="基于一阶泰勒展开的推导"></a>基于一阶泰勒展开的推导</h1><p>由上一节的公式$(17)$：IMU 预积分误差的离散形式 ，此时将噪声模型也考虑进去：</p>
<script type="math/tex; mode=display">
\begin{align*}
a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}{\color{red}+\mathbf{n}^a_{k} }-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }{\color{red}+\mathbf{n}^a_{k+1} }-b^a_k)]\\
w&=\frac{1}{2}[(w^{b_k}{\color{red}+\mathbf{n}^g_{k} }-b^g_k)+(w^{b_{k+1} }{\color{red}+\mathbf{n}^g_{k+1} }-b^g_k)]\\
{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\
{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\
b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\
b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t
\end{align*}\tag{11}</script><p>用前面一阶泰勒展开的推导方式，我们希望能推导出如下的形式：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\delta\alpha_{b_{k+1}b^{\prime}_{k+1} }\\
\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\
\delta\beta_{b_{k+1}b^{\prime}_{k+1} }\\
\delta\mathbf{b}^a_{k+1}\\
\delta\mathbf{b}^g_{k+1}\\
\end{bmatrix}=\mathbf{F}
\begin{bmatrix}
\delta\alpha_{b_{k}b^{\prime}_{k} }\\
\delta\theta_{b_{k}b^{\prime}_{k} }\\
\delta\beta_{b_{k}b^{\prime}_{k} }\\
\delta\mathbf{b}^a_{k}\\
\delta\mathbf{b}^g_{k}\\
\end{bmatrix}+\mathbf{G}
\begin{bmatrix}
\mathbf{n}^a_{k}\\
\mathbf{n}^g_{k}\\
\mathbf{n}^a_{k+1}\\
\mathbf{n}^g_{k+1}\\
\mathbf{n}_{\mathbf{b}^a_k}\\
\mathbf{n}_{\mathbf{b}^g_k}\\
\end{bmatrix}\tag{12}</script><p>$\mathbf{F},\mathbf{G}$为两个时刻间的协方差传递矩阵。</p>
<p>这里我们直接给出 $\mathbf{F},\mathbf{G}$ 的最终形式，后面会对部分项进行详细推导：  </p>
<script type="math/tex; mode=display">
\mathbf{F}=
\begin{bmatrix}
\mathbf{I}&f_{12}&\mathbf{I}\delta t&-\frac{1}{4}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t^2&f_{15}\\
0&\mathbf{I}-[\omega]^{\land}&0&0&-\mathbf{I}\delta t\\
0&f_{32}&\mathbf{I}&-\frac{1}{2}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t&f_{35}\\
0&0&0&\mathbf{I}&0\\
0&0&0&0&\mathbf{I}
\end{bmatrix}\tag{13}</script><script type="math/tex; mode=display">
\mathbf{G}=
\begin{bmatrix}
\frac{1}{4}q_{b_ib_k}\delta t^2&g_{12}&\frac{1}{4}q_{b_ib_{k+1} }\delta t^2&g_{14}&0&0\\
0&\frac{1}{2}\mathbf{I}\delta t&0&\frac{1}{2}\mathbf{I}\delta t&0&0\\
\frac{1}{2}q_{b_ib_k}\delta t&g_{32}&\frac{1}{2}q_{b_ib_{k+1} }\delta t&g_{34}&0&0\\
0&0&0&0&\mathbf{I}\delta t&0\\
0&0&0&0&0&\mathbf{I}\delta t
\end{bmatrix}\tag{14}</script><p>其中的系数如下：</p>
<p><img src="/images/3-2-IMU误差状态传递的推导/image-20220509150144881-16521033725157.png" alt="image-20220509150144881"></p>
<h2 id="雅克比矩阵-mathbf-F-的推导"><a href="#雅克比矩阵-mathbf-F-的推导" class="headerlink" title="雅克比矩阵 $\mathbf{F}$ 的推导"></a>雅克比矩阵 $\mathbf{F}$ 的推导</h2><h3 id="速度预积分量的雅可比"><a href="#速度预积分量的雅可比" class="headerlink" title="速度预积分量的雅可比"></a>速度预积分量的雅可比</h3><p>$\beta$ 对于各个状态量的雅可比矩阵推导，即 $\mathbf{F}$ 矩阵第三行。速度预积分量 $\beta$ 的递推计算形式:  </p>
<script type="math/tex; mode=display">
\begin{align*}
\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\
&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t
\end{align*}\tag{15}</script><p>$f_{33}$: 对上一时刻<strong>速度预积分量</strong>的 雅可比：</p>
<script type="math/tex; mode=display">
f_{33}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\beta_{b_{k}b^{\prime}_{k} } }
=\mathbf{I}_{3\times 3}
\tag{16}</script><p>$f_{32}$: 对上一时刻<strong>角度预积分量</strong>的 雅可比：</p>
<p>首先将公式 $(32)$写成如下形式：</p>
<script type="math/tex; mode=display">
\begin{align*}
\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\
&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+
q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}
(a^{b_{k+1} }-b^a_k)]\delta t
\end{align*}\tag{17}</script><p>那么，<strong>速度的预积分量对角度预积分量</strong>的 雅可比：  </p>
<script type="math/tex; mode=display">
f_{32}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }
=\frac{\partial a\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }
\tag{18}</script><p>其中分子可以写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
a\delta t &=\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}(a^{b_k}-b^a_k)\delta t\\
&+\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}
1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}
(a^{b_{k+1} }-b^a_k)\delta t\\
&=\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t\\
&+\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t
\end{align*}\tag{19}</script><p>分别对分子的两项进行求导：</p>
<p>①第一项</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }(I + [\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t-R_{b_ib_{k} }(a^{b_{k} }-b^a_k)\delta t
}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[(a^{b_{k} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}[\delta\theta_{b_kb^{\prime}_{k} }]}
{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=-R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}
\end{align*}\tag{20}</script><p>②第二项</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}
{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }(I+[\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t
-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}
{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]}
{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }\left[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\ [\delta\theta_{b_kb^{\prime}_{k} }\right]}
{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}
\frac{\partial R_{b_ib_{k} }\exp([\omega\delta t]^{\land})\left[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})[\delta\theta_{b_kb^{\prime}_{k} }\right]}
{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\
&=-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\
&\approx-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}(I-[\omega\delta t]^{\land})
\end{align*}
\tag{21}</script><p>将上面两部分综合起来就能得到  :</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{32}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\
&=-\frac{1}{2}\left([a^{b_{k} }-b^a_k]^{\land}\delta t+
R_{b_ib_{k+1} }[a^{b_{k+1} }-b^a_k]^{\land}(I-[\omega]^{\land}\delta t)
\delta t \right)
\end{align*}
\tag{22}</script><p>$f_{35}$: <strong>速度预积分量</strong>对 $k$ 时刻<strong>角速度 bias</strong> 的 雅可比：</p>
<p>递推公式如下:</p>
<script type="math/tex; mode=display">
\begin{align*}
\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\
&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\\
&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes 
\begin{bmatrix}
1\\{\color{red}\frac{1}{2}w\delta t}
\end{bmatrix}
(a^{b_{k+1} }-b^a_k)]\delta t
\end{align*}\tag{23}</script><p>只有红色公式部分和角速度 bias 有关系，因此雅克比的推导只考虑红色公式部分。  </p>
<script type="math/tex; mode=display">
\begin{align}
f_{35}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\mathbf{b}^g_k}\\
&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}
\frac{\partial \frac{1}{2}q_{b_ib_{k} }\otimes 
\begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes 
\begin{bmatrix}1\\-\frac{1}{2}\mathbf{b}^g_k\delta t\end{bmatrix}
(a^{b_{k+1} }-b^a_k)\delta t-
\partial \frac{1}{2}q_{b_ib_{k} }\otimes 
\begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes 
(a^{b_{k+1} }-b^a_k)\delta t
}{\partial\delta\mathbf{b}^g_k}\\
&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}
\frac{1}{2}\frac{
\partial R_{b_ib_{k+1} }\exp([-\delta\mathbf{b}^g_k\delta t]^{\land})
(a^{b_{k+1} }-b^a_k)\delta t-
R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t
}
{\partial\delta\mathbf{b}^g_k}\\
&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}
\frac{1}{2}\frac{
\partial R_{b_ib_{k+1} }(I+[-\delta\mathbf{b}^g_k\delta t]^{\land})
(a^{b_{k+1} }-b^a_k)\delta t-
R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t
}
{\partial\delta\mathbf{b}^g_k}\\
&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}
\frac{1}{2}\frac{
\partial R_{b_ib_{k+1} }[-\delta\mathbf{b}^g_k\delta t]^{\land}
[(a^{b_{k+1} }-b^a_k)\delta t]}
{\partial\delta\mathbf{b}^g_k}\\
&=-\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}
\frac{1}{2}\frac{
\partial R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}
[-\delta\mathbf{b}^g_k\delta t]}
{\partial\delta\mathbf{b}^g_k}\\
&=-\frac{1}{2}(R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)]^{\land}\delta t)(-\delta t)
\end{align}\tag{24}</script><h3 id="旋转预积分量的雅可比"><a href="#旋转预积分量的雅可比" class="headerlink" title="旋转预积分量的雅可比"></a>旋转预积分量的雅可比</h3><p>旋转预积分的递推公式为：  </p>
<script type="math/tex; mode=display">
\begin{align*}
q_{b_ib_{k+1} }&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\
\frac{1}{2}(\frac{1}{2}(\omega^{b_k}+\omega^{b_{k+1} })-\mathbf{b}^g_k)\delta t
\end{bmatrix}
\end{align*}\tag{25}</script><p>$f_{22}$: 前一时刻的旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 如何影响当前的旋转误差  $\delta\theta_{b_{k+1}b^{\prime}_{k+1} }$ ？</p>
<p>假设两个时刻的真值为 $q_{b_ib_{k+1} },\ q_{b_ib_{k} }$，两个时间的增量真值为 $q_{b_kb_{k+1} }$。推导过程只考虑一个变量，即旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 的影响，而不考虑测量值 角速度 bias 误差影响，可以假设 $q_{b_kb_{k+1} }\approx\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}$。</p>
<p>另外，三元组四元数相乘有如下性质：</p>
<script type="math/tex; mode=display">
\mathbf{q}\otimes\mathbf{p}\otimes\mathbf{q}^*=
[\mathbf{q}]_L[\mathbf{q}]_R^T\mathbf{p}=\begin{bmatrix}p_w\\R\mathbf{p}_v\end{bmatrix}\tag{26}</script><p>其中 $R$是 $\mathbf{q}$ 对应的旋转矩阵，$\mathbf{q}^*$ 是 $\mathbf{q}$ 的共轭， $p_w$ 为 $\mathbf{p}$ 的实部，  $\mathbf{p}_v$ 为  $\mathbf{p}$ 的虚部。</p>
<p>下面开始详细推导：  </p>
<script type="math/tex; mode=display">
\begin{align*}
q_{b_ib_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}
&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes
\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}
&=q_{b_ib_{k+1} }^*\otimes q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes
\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
&=q_{b_{k+1}b_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes
\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
&\approx \begin{bmatrix}1\\-\frac{1}{2}\omega\delta t\end{bmatrix}\otimes
\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes
\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
&=\begin{bmatrix}1\\\frac{1}{2}R\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}
\end{align*}\tag{27}</script><p>注意：上面推导过程，也可以用李代数的右扰动   $R\exp([\delta\theta_{k+1}]^{\land})$</p>
<p>只考虑公式 $(27)$ 中的虚部：</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta\theta_{b_{k+1}b^{\prime}_{k+1} }
&=R\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\
&=\exp([-w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\\
&\approx (I-[w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }
\end{align*}\tag{28}</script><p>那么，第 $k+1$ 时刻的旋转预积分的误差相对于第 $k$ 时刻的 雅可比为：</p>
<script type="math/tex; mode=display">
f_{22}=\frac{\partial \delta\theta_{b_{k+1}b^{\prime}_{k+1} } }{\partial \delta\theta_{b_{k}b^{\prime}_{k} } }=I-[w\delta t]^{\land}\tag{29}</script>]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>预积分理论</tag>
      </tags>
  </entry>
  <entry>
    <title>三、预积分模型以及残差的构建</title>
    <url>/posts/285413d6.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="IMU的误差模型"><a href="#IMU的误差模型" class="headerlink" title="IMU的误差模型"></a>IMU的误差模型</h1><ul>
<li><strong>加速度计的误差模型</strong></li>
</ul>
<p>设导航系$G$为东北天，$g^G=(0,0,-9.81)^T$。</p>
<p>理论测量值：</p>
<script type="math/tex; mode=display">
a_m^B=R_{BG}(a^G-g^G)
\tag{1}</script><p>如果考虑高斯白噪声，bias，以及尺度因子(通常假设尺度因子为单位矩阵。)，则为：</p>
<script type="math/tex; mode=display">
a_m^B=S_aR_{BG}(a^G-g^G)+n_a+b_a\tag{2}</script><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423171217806.png" alt="image-20220423171217806" style="zoom:50%;" /></p>
<ul>
<li><strong>陀螺仪的误差模型</strong></li>
</ul>
<p>考虑尺度因子，高斯白噪声，以及 bias, 陀螺仪的误差模型如下：</p>
<script type="math/tex; mode=display">
w^b_m=S_gw^b+n_g+b_g\tag{3}</script><p>低端传感器，考虑加速度对陀螺仪的影响，即 g-灵敏度：</p>
<script type="math/tex; mode=display">
w^b_m=S_gw^b+S_{ga}a^b+n_g+b_g\tag{4}</script><p>陀螺仪受四种噪声的影响分别如下图所示：</p>
<p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423190440715.png" alt="image-20220423190440715" style="zoom: 50%;" /></p>
<h1 id="IMU模型与运动积分"><a href="#IMU模型与运动积分" class="headerlink" title="IMU模型与运动积分"></a>IMU模型与运动积分</h1><p>忽略 scale 的影响，根据imu的误差模型我们可以假设：角速度读数会在真实值的基础上受到<strong>bias和白噪声</strong>的影响，加速度除了受到<strong>bias和白噪声</strong>的影响，还会受到<strong>重力</strong>的影响。因此我们可以从IMU中得到角速度和加速度的读数，如公式$(5)(6)$的等式左边，它们都是基于IMU坐标系的。</p>
<script type="math/tex; mode=display">
\begin{align*}
\tilde{w}^b&=w^b+b_g+n_g\tag{5}
\end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
\tilde{a}^b&=q_{bw}(a^w-g^w)+b_a+n_a\tag{6}
\end{align*}</script><p>上标$ g$ 表示 gyro，a 表示 acc，$^w $表示在世界坐标系 world，$^b$表示imu 机体坐标系 body。IMU 的真实值为$w, a$, 测量值为$\tilde w, \tilde a$，测量值即为IMU的读数。 </p>
<p>我们知道<strong>角速度$w$</strong>积分得到<strong>姿态$q$</strong>，<strong>加速度$a$</strong>积分得到<strong>速度$v$</strong>，<strong>速度$v$</strong>积分得到<strong>位移$p$</strong>。而现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型， <strong>P(ose)（位置），V(elocity)（速度），Q(uaternion) （旋转）</strong>对时间的导数可写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot p_{wb}&=v^w_t\\
\dot v^w_t &=a^w_t\\
\dot q_{wb_t} &=q_{wb_t} \otimes 
\begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}
\end{align*}\tag{7}</script><p>它描述了 IMU坐标系 的姿势和速度的演变。</p>
<p>第三项，四元数求导参考 <a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0">一、VIO概述以及三维刚体运动知识点回顾</a></p>
<p> $t + \Delta t $时刻的状态是通过积分方程$(7)$获得的：</p>
<script type="math/tex; mode=display">
\begin{align*}
p_{wb}(t+\Delta t)&=p_{wb}(t)+\int^{t+\Delta t}_t v^w(\tau)d\tau+\iint^{t+\Delta t}_t a^w d\tau^2\\
v^w(t+\Delta t)&=v^w(t)+\int^{t+\Delta t}_t a^w d\tau\\
q_{wb}(t+\Delta t)&=\int^{t+\Delta t}_t q_{wb}(\tau)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(\tau)\end{bmatrix}d\tau
\end{align*}\tag{8}</script><p>根据积分的性质，这里的 $\tau$ 是把 $[t,t+\Delta t]$分割的无限小部分。</p>
<p>假设 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2} a^w \Delta t^2\\
v^w(t+\Delta t)&=v^w(t)+ a^w \Delta t\\
q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(t)\Delta t\end{bmatrix}
\end{align*}\tag{9}</script><p>根据公式$(5)(6)$可以将 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 写成 IMU 测量的函数，因此 $(9)$ 变为:</p>
<script type="math/tex; mode=display">
\begin{align*}
p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t^2\\
v^w(t+\Delta t)&=v^w(t)+g^w\Delta t+ q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t\\
q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}(\tilde{w}^b(t)-b_g(t)-n_g(t))\Delta t\end{bmatrix}
\end{align*}\tag{10}</script><p>方程 $(10)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。<strong>这样就可以得到旋转，速度，平移与 IMU 读数之间的关系，进而可以根据IMU 的读数来估计位姿。</strong></p>
<h1 id="IMU预积分模型"><a href="#IMU预积分模型" class="headerlink" title="IMU预积分模型"></a>IMU预积分模型</h1><h2 id="IMU-预积分"><a href="#IMU-预积分" class="headerlink" title="IMU 预积分"></a>IMU 预积分</h2><p>如图所示，相机的采样频率是明显低于 IMU 的采样频率的，相机或激光一般在几十 HZ，而 IMU 可以达到几百 HZ，而在 SLAM 中我们通常是求解每一帧图像/激光的位姿，因此需要对两帧图像/激光之间的所有IMU观测进行累加，可以得到 $i$ 帧和 $j$ 帧两个关键帧之间的单个复合的测量值，我们称之为<strong>预积分</strong>。</p>
<p><img src="/images/3-预积分模型以及误差递推方程的推导/image-20220507202527649-16521033725156.png" alt="image-20220507202527649"></p>
<p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 $(10)$，我们发现：</p>
<script type="math/tex; mode=display">
\begin{align*}
{p_{wb} }_j&={p_{wb} }_i+\sum^{j-1}_{k=i}\left[
v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb_k}\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t^2\right]\\
v^w_j&=v^w_i+g^w\Delta t_{ij}+ \prod^{j-1}_{k=i} q_{wb_k}(t)\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t\\
q_{wb_j}&= q_{wb_i}\otimes \begin{bmatrix}0\\ \frac{1}{2}\prod^{j-1}_{k=i}(\tilde{w}^b_k-b_{gk}-n_{gk})\Delta t\end{bmatrix}
\end{align*}\tag{11}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。 $(11)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(11)$ 中的积分（直观地说，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_k}、k = i,…,j-1$ 的变化，因此有必要重新评估 $(11)$ 中的求和和乘积。</p>
<blockquote>
<p>这里没有找到离散形势下使用四元数的预积分推导相关资料，而在高博等人的《从零开始手写VIO》课程中，用的是如下连续形式进行推导的，事实上，我认为 $(12)$ 中的连续形式中在递推 $p_{wb_j}$的时候，对速度没有积分是不对的，此处暂且留疑点。</p>
</blockquote>
<p>同样的，连续形式下，可以得到:</p>
<script type="math/tex; mode=display">
\begin{align*}
p_{wb_j}&=p_{wb_i}+v^w_i \Delta t+\iint_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t^2\\
v^w_j&=v^w_i+\int_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t\\
q_{wb_j}&=\int_{t\in[i,j]}q_{wb_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t
\end{align*}\tag{12}</script><p>其中，不难发现，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_t}、t \in [i,j]$ 的变化，导致对 $(12)$中的积分进行重复计算。</p>
<p>一个很简单的公式转换，就可以将积分模型转为预积分模型：  </p>
<script type="math/tex; mode=display">
q_{wb_t}=q_{wb_i}\otimes q_{b_ib_t}\tag{13}</script><p>其中 $\otimes$ 表示四元数的乘法，具体可以可以参考，<a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0"><strong>四元数的乘法运算</strong></a></p>
<p>那么， PVQ 积分公式中的积分项则变成相对于第 $i$ 时刻的姿态，而不是相对于世界坐标系的姿态，则公式$(12)$变换为：</p>
<script type="math/tex; mode=display">
\begin{align*}
p_{wb_j}&=p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+
q_{wb_i}\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\
v^w_j&=v^w_i-g^w\Delta t+q_{wb_i}\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\
q_{wb_j}&=q_{wb_i}\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t
\end{align*}\tag{14}</script><p>这样的话，积分里的把相对于世界坐标系的状态量 $q_{wb_i}$ 移出去了，积分里面都是相对于第 $i$ 时刻的状态量 $q_{b_ib_t}$。</p>
<p>定义预积分量如下，预积分量仅仅跟 IMU 测量值有关，它将一段时间内的 IMU 数据直接积分起来就得到了<strong>预积分量</strong>：  </p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\
\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\
q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t
\end{align*}\tag{15}</script><p>由公式$(14)$与$(15)$重新整理PVQ的积分公式，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
\begin{bmatrix}
p_{wb_j}\\v^w_{j}\\q_{wb_j}\\b^a_j\\b^g_j
\end{bmatrix}=
\begin{bmatrix}
p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+
q_{wb_i}\alpha_{b_ib_j}\\
v^w_i-g^w\Delta t+q_{wb_i}\beta_{b_ib_j}\\
q_{wb_i}q_{b_ib_j}\\b^a_i\\b^g_i
\end{bmatrix}
\end{align*}\tag{16}</script><h2 id="IMU-预积分残差"><a href="#IMU-预积分残差" class="headerlink" title="IMU 预积分残差"></a>IMU 预积分残差</h2><p>定义：一段时间内 <strong>IMU 构建的预积分量作为测量值</strong>，对两时刻之间的状态量进行约束，  </p>
<script type="math/tex; mode=display">
\begin{align*}
\begin{bmatrix}
r_p\\r_v\\r_q\\r_{ba}\\r_{bg}
\end{bmatrix}_{15\times1}=
\begin{bmatrix}
q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-
{\color{red}\alpha_{b_ib_j} }\\
q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{red}\beta_{b_ib_j} }\\
2[{\color{red}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\
b^a_j-b^a_i\\
b^g_j-b^g_i
\end{bmatrix}
\end{align*}\tag{16}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第三项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p>
<h2 id="IMU-预积分残差的离散形式"><a href="#IMU-预积分残差的离散形式" class="headerlink" title="IMU 预积分残差的离散形式"></a>IMU 预积分残差的离散形式</h2><p>使用 mid-point 方法，即两个相邻时刻$ k$到$ k+1$ 的位姿是用两个时刻的测量值$ a,w $的平均值来计算。参考公式$(11)(12)$:</p>
<script type="math/tex; mode=display">
\begin{align*}
a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\\
w&=\frac{1}{2}[(w^{b_k}-b^g_k)+(w^{b_{k+1} }-b^g_k)]\\
{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\
{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\
{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\
b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\
b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t
\end{align*}\tag{17}</script>]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>预积分理论</tag>
      </tags>
  </entry>
  <entry>
    <title>【文献阅读】On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</title>
    <url>/posts/e6b6704d.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry"><a href="#On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry" class="headerlink" title="On-Manifold Preintegration for Real-Time Visual-Inertial Odometry"></a>On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</h1><p>摘要：当前的视觉惯性里程计（VIO）方法能够通过非线性优化获得高度准确的状态估计。然而，随着轨迹随着时间的推移，实时优化很快变得不可行。尤其是惯性测量以高速率出现的时候，这个问题变得更加突出，因此导致优化中变量数量的快速增长。在本文中，我们<strong>通过预积分关键帧之间的惯性测量以得到单个相对运动约束</strong>。</p>
<p>我们的第一个贡献是一个预积分理论，它正确地解决了<strong>旋转群的流形结构</strong>。我们正式讨论生成测量模型以及旋转噪声的性质，并推导出最大后验状态估计器的表达式。我们的理论发展能够计算所有必要的雅可比矩阵，以分析形式的优化和后验偏差校正。</p>
<p>第二个贡献是表明预积分的 IMU 模型可以在因子图的统一框架下被整合到视觉-惯性流程中。这使得<strong>增量平滑算法</strong>的应用和<strong>视觉测量的无结构模型</strong>的使用成为可能，避免了对 3D 点的优化，进一步加速了计算。</p>
<p>我们在真实和模拟数据集上对我们的单目 VIO 流程进行了广泛的评估。结果证实，我们的建模工作可以实时进行准确的状态估计，优于最先进的方法。</p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>使用相机和惯性传感器进行三维结构和运动估计已经受到机器人界的极大关注。两种传感器类型都便宜、无处不在且互补。<strong>移动相机</strong>是一种外感知传感器，它允许我们测量三维场景的外观和几何形状，直至未知的度量尺度；<strong>惯性测量单元 (IMU)</strong> 是一种本体感受传感器，可呈现单目视觉和重力可视化的度量尺度 [1]，并提供稳健且准确的帧间运动估计。<strong>视觉惯性里程计（VIO）</strong>的应用范围从无GPS环境的自动驾驶到3D重建和增强现实。</p>
<p>现有的关于 VIO 的文献在准确性和计算效率之间进行了权衡（第 II 节给出了详细的回顾）。一方面，<strong>滤波方法</strong>可以实现快速推断，但其准确性会因线性化误差的累积而下降。另一方面，<strong>基于非线性优化的完全平滑方法</strong>是准确的，但计算量很大。固定滞后平滑（$Fixed-lag\ Smoothing$）在精度和效率之间提供折中；但是，尚不清楚如何设置估计窗口的长度以保证给定的性能水平。</p>
<p>在这项工作中，我们表明可以克服这种权衡。我们设计了一个 VIO 系统，可以实现快速增量平滑并实时计算最优的最大后验 (MAP) 估计。第IV给出了我们方法的概述。</p>
<p>实现这一目标的第一步是发展一个新的预积分理论。在 [2] 中首次提出使用预积分 IMU 测量，其组合两个关键帧间的许多惯性测量为单个相对运动约束。我们在这项工作的基础上提出了一个预积分理论，该理论正确地<strong>解决了旋转群 $SO(3)$ 的流形结构</strong>。我们的预积分理论在第 V-VI 节中介绍。与[2]相比，我们的理论对旋转噪声提供了更正式的处理，并避免了旋转表示中的奇异性。此外，我们能够以解析形式推导出所有必要的雅可比矩阵：具体来说，我们在本文的附录中报告了残差、噪声传播和后验偏差校正的解析雅可比矩阵。</p>
<p>我们的第二个贡献是<strong>将 IMU 预积分理论框架化为因子图模型</strong>。这使得增量平滑算法的应用成为可能，如 iSAM2 [3]，它避免了线性化误差的累积，并提供了一种优雅的方式来权衡精度和效率。受 [4, 5] 的启发，我们还<strong>采用无结构模型进行视觉测量</strong>，允许在增量平滑期间消除大量变量（即所有 3D 点），从而进一步加速计算（第 VII 节）。与 [5] 相比，我们在增量平滑框架中使用无结构模型。这有两个主要优点：我们不需要延迟视觉测量的处理，我们可以多次重新线性化视觉测量。</p>
<p>为了证明我们模型的有效性，我们将提议的 IMU 预积分集成到最先进的 VIO 流程中，并在真实和模拟数据集 2（第 VIII 节）上对其进行了测试。我们的理论发展带来了切实的实际优势：本文提出的方法的实现以 100 Hz 的速率执行完全平滑，并相对于具有竞争力的最先进的过滤和优化方法实现了卓越的精度。</p>
<p>除了技术贡献，论文还为实践者提供了教程贡献。在第III部分和整篇论文中，我们对流形上的不确定性表示以及不确定性传播和雅可比计算的示例推导进行了简短而简洁的总结。所有方程和雅可比矩阵的完整推导——实现我们的模型所必需的——在附录中给出。</p>
<p>本文是我们之前工作 [6] 的扩展，包括额外的实验、对相关工作的深入讨论和全面的技术推导。新实验的结果突出了偏差估计的准确性，证明了我们方法的一致性，并提供了与全批次估计的比较。我们在 GTSAM 4.0 优化工具箱中发布了预集成 IMU 和无结构视觉因素的实现。</p>
<h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>视觉惯性里程计的相关工作可以沿着三个主要维度进行划分。<strong>第一个维度是 在估计中涉及的相机位姿的数量。</strong>虽然完全平滑器（$full\ smoothers$）（或批量非线性最小二乘算法（$batch\ nonlinear\ least-squares\ algorithms$）估计姿势的完整历史，但固定滞后平滑器（$fixed-lag\ smoothers$）（或滑动窗口估计器（$fixed-lag\ smoothers$）考虑最新姿势的窗口，而过滤方法仅估计最新状态。固定滞后平滑器和滤波器都会<strong>边缘化</strong>旧状态并<strong>吸收</strong>高斯先验中的相应信息。</p>
<p><strong>第二个维度是 关于测量不确定性和高斯先验的表示</strong>：扩展卡尔曼滤波器 (EKF) 使用协方差矩阵表示不确定性；相反，信息滤波器和平滑器求助于信息矩阵（协方差的倒数）或信息矩阵的平方根 [3, 8]</p>
<p>最后，<strong>第三个维度 通过查看测量模型线性化的次数来区分现有方法。</strong>虽然标准 EKF（与迭代 EKF 相比）只处理一次测量，但平滑方法允许多次线性化。</p>
<p>虽然术语很多，但底层算法是紧密相关的。例如，可以证明<strong>迭代扩展卡尔曼滤波器方程等价于高斯牛顿算法</strong>，通常用于平滑 [9]</p>
<h2 id="A-滤波"><a href="#A-滤波" class="headerlink" title="A. 滤波"></a>A. 滤波</h2><p>滤波算法通过将推理过程限制在系统的最新状态来实现有效的估计。 EKF 的复杂性在估计的地标数量上呈二次增长，因此，通常会跟踪少量地标（大约 20 个）以允许实时操作 [10-12]。另一种方法是采用<strong>“无结构”方法</strong>，其中地标位置被<strong>边缘化</strong>出状态向量。这种策略的一个很好的例子是<strong>多状态约束卡尔曼滤波器</strong>（$Multi-State\ Constraint\ Kalman\ filter\ ，MSC-KF$）[5]。无结构方法需要通过<strong>随机克隆</strong>（$stochastic\ cloning$） [13] 将先前的姿势保留在状态向量中。</p>
<p>使用无结构方法进行过滤的一个缺点是，<strong>地标测量的处理</strong>需要延迟，直到获得地标的所有测量值 [5]。这会妨碍准确性，因为滤波器不能使用所有当前的视觉信息。<strong>边缘化</strong>也是错误的来源，因为它锁定了<strong>线性化误差</strong>和<strong>错误的异常值测量</strong>。因此，滤除虚假测量值尤为重要，因为单个异常值会不可逆转地破坏滤波器 [14]。此外，<strong>线性化误差</strong>会在估计中引入漂移并导致滤波器不一致。不一致的一个影响是<strong>估计器</strong>变得过于自信，导致非最优信息融合。通常，VIO 问题有四个不可观察的方向：<strong>全局位置</strong>和围绕重力方向（<strong>偏航</strong>，yaw）的方向 [15, 16]。在 [16] 中表明，<strong>错误估计的线性化</strong>仅导致三个不可观察的方向（全局位置）；因此，错误的线性化将偏航方向的虚假信息添加到高斯先验中，从而导致滤波器不一致。这个问题已通过<strong>首次估计雅可比方法</strong> （$first-estimates\ jacobian$）[17] 得到解决，<strong>该方法确保状态不会使用不同的线性化点进行更新</strong>——这是不一致的来源。在可观察性约束（$observability-constrained$）的 EKF (OC-EKF) 中，维持对不可观察方向的估计，这允许仅在可观察的方向上更新滤波器 [16, 18]。在 [1, 15, 19] 中给出了对 VIO 可观察性属性的全面分析。</p>
<h2 id="B-固定滞后平滑"><a href="#B-固定滞后平滑" class="headerlink" title="B.固定滞后平滑"></a>B.固定滞后平滑</h2><p>固定滞后平滑器（$fixed-lag\ smoothers$）估计落在给定时间窗口内的状态，同时边缘化较旧的状态[20-24]。在最大似然估计设置中，固定滞后平滑器会<strong>导致一组最近状态的优化问题</strong>。对于非线性问题，<strong>平滑方法</strong>通常比滤波更准确，因为它们会<strong>重新线性化过去的测量</strong> [25]。此外，这些方法<strong>对异常值更具弹性</strong>，可以在后验（即优化之后）丢弃，或者可以通过使用鲁棒代价函数来缓解。不利的一面是，<strong>估计窗口外的状态边缘化会导致密集的高斯先验，从而阻碍有效的推理。</strong>出于这个原因，有人提出为了<strong>稀疏性</strong>而放弃某些测量值[24]。此外，由于边缘化，固定滞后平滑器具有过滤的部分问题（一致性、线性化误差的累积）[18、22、26]。</p>
<h2 id="C-完全平滑"><a href="#C-完全平滑" class="headerlink" title="C. 完全平滑"></a>C. 完全平滑</h2><p>完全平滑（$Full\ Smoothing$）方法<strong>通过解决大型非线性优化问题来估计状态的整个历史</strong>（相机轨迹和 3D 地标）[27-31]。全平滑保证了最高精度；然而，随着轨迹和地图随着时间的推移而增长，实时操作很快变得不可行。因此，已经提出丢弃除选定<strong>关键帧</strong>之外的帧 [24, 32-34] 或使用<strong>跟踪和建图双重架构</strong> [20, 35] 在并行线程中运行优化。一项突破是<strong>增量平滑技术</strong>（$incremental\ smoothing\ techniques$）（iSAM [36]、iSAM2 [3]）的发展，该技术<strong>利用因子图的表达性来保持稀疏性，并仅识别和更新受新测量影响的通常较小的变量子集。</strong></p>
<p>尽管如此，高频率的惯性测量（通常为 $100 Hz$ 至 $1 kHz$）仍然对平滑方法构成挑战。一个简单的实现需要在每次 IMU 测量时添加一个新状态，这很快就会变得非常慢 [37]。因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。<strong>对于两帧之间的标准 IMU 集成，初始条件由第一帧的状态估计给出。</strong>因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。对于两帧之间的标准 IMU 积分，初始条件由第一帧的状态估计给出。然而，<strong>在优化的每次迭代中，状态估计都会发生变化，这需要在所有帧之间重复 IMU 积分</strong>[24]。 Lupton 和 Sukkarieh [2] 表明，<strong>通过重新参数化相对运动约束可以避免这种重复积分。这种重新参数化称为 IMU 预积分。</strong></p>
<p>在目前的工作中，我们以开创性工作 [2] 为基础，通过适当<strong>解决旋转群 SO(3) 的流形结构</strong>，使 IMU 预积分理论走向成熟。工作[2]采用欧拉角作为旋转的全局参数。在刚性变换的作用下，使用欧拉角并应用欧几里得空间的通常平均和平滑技术进行状态传播和协方差估计并不具有不变性[41, 42]。此外，欧拉角具有奇异性。我们的研究，另一方面，提供了一个正式的旋转测量的表示（和对应噪声），并提供了完整的最大后验估计量的推导。我们还推导出雅可比矩阵的解析表达式（优化所需），据我们所知，这些表达式以前没有在文献中报道过。在实验部分，我们表明旋转流形的正确表示会导致更高的准确性和鲁棒性，从而比原始提议 [2] 带来切实的优势。</p>
<h1 id="三、预备知识"><a href="#三、预备知识" class="headerlink" title="三、预备知识"></a>三、预备知识</h1><p>在本文中，我们根据 MAP 估计来制定 VIO。在我们的模型中，MAP 估计会导致非线性优化问题，该问题涉及存在于<strong>平滑流形</strong>上的量（例如，旋转、姿势）。因此，在深入研究细节之前，我们方便地回顾一些有用的几何概念。专家读者可以跳过本节。</p>
<p>我们将本节结构如下：第 III-A 节提供了与两个主要<strong>黎曼流形</strong>相关的有用概念：<strong>特殊正交群</strong> $SO(3)$ 和<strong>特殊欧几里得群</strong>$ SE(3)$。我们的介绍基于 [43, 44]。第 III-B 节描述了一个合适的模型来描述$ SO(3) $中的不确定旋转。第 III-C 节根据标准参考文献 [45] 回顾了流形上的优化。</p>
<h2 id="A-黎曼几何的概念"><a href="#A-黎曼几何的概念" class="headerlink" title="A. 黎曼几何的概念"></a>A. 黎曼几何的概念</h2><p>a) 特殊正交群：SO(3) 描述了一组 3D 旋转矩阵，正式定义为$SO(3)\doteq \{R\in\mathbb{R}^{3\times3}:R^TR=I,\det(R)=1\}.$群运算就是通常的矩阵乘法，逆运算就是矩阵转置。群 $ SO(3) $也形成一个<strong>光滑的流形</strong>。流形（恒等式）的<strong>切线空间表示</strong>为 $\mathfrak{so}(3)$，也称为<strong>李代数</strong>，与 $3\times3$ 斜对称矩阵的空间重合。我们可以使用$hat$算子在 R3 中用一个向量识别每个倾斜对称矩阵：</p>
<script type="math/tex; mode=display">
w^{\land}=\begin{bmatrix}w_1\\w_2\\w_3\end{bmatrix}^{\land}=
\begin{bmatrix}0&-w_3&w_2\\w_3&0&-w_1\\-w_2&w_1&0\end{bmatrix}\in\mathfrak{so}(3).\tag{1}</script><p>类似地，我们可以使用 $vee $算子$(\cdot)^{\lor}$ 将斜对称矩阵映射到$\mathbb{R}^3 $中的向量：对于<strong>斜对称矩阵</strong> $S= ω^{\land}$，$vee $ 算子使得 $S^{\lor}= ω$。稍后将有用的斜对称矩阵的属性是：</p>
<script type="math/tex; mode=display">
a^{\land}b=-b^{\land}a,\forall a,b\in\mathbb{R}^3.\tag{2}</script><p><strong>指数映射</strong>（恒等式）$ \exp : \mathfrak{so}(3)\rightarrow SO(3)$将李代数的一个元素与旋转相关联，并与标准矩阵指数（罗德里格斯公式）一致：</p>
<script type="math/tex; mode=display">
\exp(\phi)^{\land}=I+\frac{\sin(\parallel\phi\parallel)}{\parallel\phi\parallel}\phi^{\land}+
\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel}(\phi^{\land})^2.\tag{3}</script><p>我们稍后将使用的指数映射的一阶近似是：</p>
<script type="math/tex; mode=display">
\exp(\phi)^{\land}\approx I+\phi^{\land}.\tag{4}</script><p><strong>对数映射</strong>（恒等式）将 $SO(3)$ 中的矩阵 $R\ne I $与斜对称矩阵相关联：</p>
<script type="math/tex; mode=display">
\log(R)=\frac{\varphi\cdot(R-R^T)}{2\sin(\varphi)},\varphi=\cos^{-1}(\frac{\tr(R)-1}{2}).\tag{5}</script><p>注意$ \log(R)^{\lor}= a\varphi$，其中 $a $和 $\varphi $分别是 $R$ 的旋转轴和旋转角度。如果 $R = I$，则 $\varphi= 0 $，并且 $a$ 是不确定的，因此可以任意选择。</p>
<p>如果限制在一个开放的球内$\parallel\phi\parallel&lt;\pi$，<strong>指数映射</strong>是<strong>双射</strong>，对应的逆是<strong>对数映射</strong>。然而，如果我们不限制定义域，指数映射就会变成<strong>满射</strong>的，因为每个向量$ \phi= (\varphi + 2k\pi)a, k \in \mathbb{Z}$ 将是 $R$ 的一个可容许对数。</p>
<p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507100016617.png" alt="image-20220507100016617"></p>
<p>为了符号方便，我们采用指数和对数图的“矢量化”版本：</p>
<script type="math/tex; mode=display">
\begin{align*}
Exp&:\ \mathbb{R}^3\rightarrow SO(3)\ ;\ \phi\mapsto \exp(\phi^{\land})\\
Log&:\ SO(3)\rightarrow \mathbb{R}^3\ ;\ R\mapsto \log(R)^{\lor}
\end{align*}\tag{6}</script><p>它直接对向量进行操作，而不是对$ \mathfrak{so}(3) $中的斜对称矩阵进行操作。</p>
<p>稍后，我们将使用以下一阶近似：</p>
<script type="math/tex; mode=display">
Exp(\phi+\delta\phi)\approx Exp(\phi)\ Exp(J_r(\phi)\delta\phi).\tag{7}</script><p>$J_r(\phi)$是$SO(3)$ [43, p.40] 的右雅可比行列式，并将切线空间中的加法增量与右侧应用的乘法增量相关联（图 1）：</p>
<script type="math/tex; mode=display">
J_r(\phi)=I-\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel^2}\phi^{\land}+
\frac{\parallel\phi\parallel-\sin(\parallel\phi\parallel)}{\parallel\phi^3\parallel}(\phi^{\land})^2.\tag{8}</script><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507102404953.png" alt="image-20220507102404953" style="zoom: 50%;" /></p>
<blockquote>
<p>图 1：右雅可比$ J_r $将切线空间中的加性微扰 $\delta\phi$ 与流形$ SO(3)$ 上的乘性微扰联系起来，如方程。 (7)。</p>
</blockquote>
<p>类似的一阶近似适用于对数：</p>
<script type="math/tex; mode=display">
Log(Exp(\phi)\ Exp(\delta\phi))\approx\phi+J_r^{-1}(\phi)\delta\phi.\tag{9}</script><p>右雅可比行列式的倒数是:</p>
<script type="math/tex; mode=display">
\begin{align*}
J_r^{-1}=I+\frac{1}{2}\phi^{\land}+
\left(\frac{1}{\parallel\phi\parallel^2}+\frac{1+\cos(\parallel\phi\parallel)}{2\parallel\phi\parallel\sin(\parallel\phi\parallel)}
\right)(\phi^{\land})^2,
\end{align*}</script><p>当$\parallel\phi\parallel= 0$ 时，右雅可比 $J_r(\phi)$ 及其逆$J_r^{-1}(\phi)$简化为单位矩阵。</p>
<p>指数映射的另一个有用属性是：</p>
<script type="math/tex; mode=display">
\begin{align*}
&R \ Exp(\phi)R^T=\exp(R\phi^{\land}R^T)=Exp(R\phi)\tag{10} \\
 &\Leftrightarrow Exp(\phi)R=RExp(R^T\phi)\tag{11}
\end{align*}</script><p>b) 特殊欧几里得群：$SE(3)$ 描述了 $3D$ 中刚体运动的群，是 $SO(3)$ 和 $\mathbb{R}^3 $的半直积，定义为 $SE(3) \doteq \{(R, p ) : R \in SO(3), p \in\mathbb{R}^3\}$。给定 $T_1, T_2 ∈ SE(3)$，组运算为$ T_1 \cdot T_2 = (R_1R_2 , p_1 + R_1p_2)$，逆运算为$ T_1^{-1} = (R^T_1 , −R^T_1 p_1)$。 $SE(3)$的指数映射和对数映射在 [44] 中定义。但是，本文不需要这些，原因将在第 III-C 节中明确说明。</p>
<h2 id="B-SO-3-中的不确定性描述"><a href="#B-SO-3-中的不确定性描述" class="headerlink" title="B. SO(3) 中的不确定性描述"></a>B. SO(3) 中的不确定性描述</h2><p>$SO(3)$中不确定性的自然定义是定义切线空间中的分布，然后通过指数映射$(6)$[44, 46, 47] 将其映射到$ SO(3)$：</p>
<script type="math/tex; mode=display">
\tilde{R}=R\ Exp(\epsilon),\epsilon \sim\mathcal{N}(0,\Sigma),\tag{12}</script><p>其中 $R$是给定的无噪声旋转（平均值）并且$\epsilon$是一个小的正态分布扰动，均值为零，协方差为$\Sigma$。</p>
<p>为了获得 $R$分布的显式表达式，我们从$\mathbb{R}^3$中高斯分布的积分开始：</p>
<script type="math/tex; mode=display">
\int_{\mathbb{R}^3}p(\epsilon)d\epsilon=\int_{\mathbb{R}^3}\alpha e^{-\frac{1}{2}\parallel\epsilon\parallel^2_{\Sigma} }d\epsilon=1,\tag{13}</script><p>其中$ \alpha= 1/\sqrt{(2\pi)^3 \det(\Sigma)} $， $\parallel\epsilon\parallel^2_{\Sigma}\doteq\epsilon^T\Sigma^{-1}\epsilon$是具有协方差 $\Sigma$ 的平方<strong>马氏距离</strong>。然后，应用坐标的变化$\epsilon = Log(R^{−1}\tilde{R})$ （当$ \parallel\epsilon\parallel&lt;\pi$ 时，这是 $(12)$ 的倒数），积分 $(13)$ 变为：</p>
<script type="math/tex; mode=display">
\int_{SO(3)}\beta(\tilde{R})e^{
-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma}
}d\tilde{R}=1,\tag{14}</script><p>其中 $\beta(\tilde{R})$是归一化因子。归一化因子的形式为 $\beta(\tilde{R})= α/|\det\left(\mathcal{J} (\tilde{R})\right)|$，其中$ \mathcal{J} (\tilde{R}) \doteq J_r( Log(R^{-1}\tilde{R})) $，并且$ J_r(·)$ 是右雅可比行列式 $(8)$；$\mathcal{J} (\tilde{R})$ 是变量变化的副产品，推导参见 [46]。</p>
<p>根据$ (14) $的论点，我们可以直接读取 $SO(3)$ 中的“高斯”分布：</p>
<script type="math/tex; mode=display">
p(\tilde{R})=\beta(\tilde{R})e^{
-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma} }.\tag{15}</script><p>对于小的协方差，我们可以逼近$ β\simeqα$，因为当接$\tilde{R}$近 $R$ 时，$J_r( Log(R^{-1}\tilde{R}))$ 可以很好地由单位矩阵逼近。请注意，$(14)$ 已经假设协方差 $\Sigma$相对较小，因为它“剪裁”了半径为 $\pi$的开放球之外的概率尾部（这是由于重新参数化$\epsilon = Log(R^{−1}\tilde{R})$，将 $\epsilon $限制为 $\parallel\epsilon\parallel &lt; \pi$）。将$ β$ 近似为一个常数，给定一个如$(15)$中分布的测量值$\tilde{R}$，旋转 $R$ 的负对数似然是：</p>
<script type="math/tex; mode=display">
\mathcal{L}(R)=\frac{1}{2}\parallel Log(R^{−1}\tilde{R}) \parallel^2_{\Sigma}+const=
\frac{1}{2}\parallel Log(\tilde{R}^{−1}R) \parallel^2_{\Sigma}+const.\tag{16}</script><p>几何上可以解释为由逆不确定性$Σ^{-1}$加权的$\tilde{R}$和$R$之间的平方角（$SO(3)$中的测地线距离）。</p>
<h2 id="C-流形上的高斯-牛顿法"><a href="#C-流形上的高斯-牛顿法" class="headerlink" title="C. 流形上的高斯-牛顿法"></a>C. 流形上的高斯-牛顿法</h2><p>欧几里得空间中的标准高斯-牛顿方法通过反复优化（通常为非凸的）目标函数的二次近似来工作。求解二次近似简化为求解一组线性方程（正规方程），并且这个局部近似的解用于更新当前估计。在这里，我们回顾一下如何将这种方法扩展到（无约束的）优化问题，其变量属于某个流形 $\mathcal{M}$。让我们考虑以下优化问题：</p>
<p>让我们考虑以下优化问题：</p>
<script type="math/tex; mode=display">
\underset{x\in\mathcal{M} }{\min}f(x),\tag{17}</script><p>其中变量 $x$ 属于流形$\mathcal{M}$；为简单起见，我们在 $(17)$ 中考虑单个变量，而描述很容易推广到多个变量。</p>
<p>与欧几里得情况相反，不能直接将 $(17) $近似为 $x$ 的二次函数。这是由于两个主要原因。首先，直接在 $x$上工作会导致问题的过度参数化（例如，我们对具有 $9$ 个元素的旋转矩阵进行参数化，而 $3D$ 旋转完全由 $\mathbb{R}^3$中的向量定义），这会使正规方程不确定，其次，所得近似的解一般不属于 $\mathcal{M}$。</p>
<p>流形优化的标准方法 [45, 48] 包括定义<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$，它是切线空间（在$ x$ 处）的元素 $\delta x$ 和 $x \in\mathcal{M} $的邻域之间的<strong>双射映射</strong>。使用回缩（$retraction$），我们可以将我们的问题重新参数化如下：</p>
<script type="math/tex; mode=display">
\underset{x\in\mathcal{M} }{\min}f(x)  \Longrightarrow \underset{\delta x\in\mathbb{R}^n }{\min}f(\mathcal{R}_x(\delta x)).\tag{18}</script><p>重新参数化通常称为<strong>提升</strong>（$lifting$） [45]。粗略地说，我们在当前估计定义的切空间中工作，该空间在局部表现为欧几里得空间。使用<strong>回缩</strong>（$retraction$）允许在合适维度的欧几里德空间上构建优化问题（例如，当我们在 $SO(3) $中工作时，$\delta x ∈ \mathbb{R}^3$）。</p>
<p>我们现在可以将标准优化技术应用于 $(18) $右侧的问题。在 Gauss-Newton 框架中，我们将当前估计的成本平方。然后我们求解二次逼近得到一个向量$\delta x^{\star}$在切线空间。最后，流形上的当前猜测被更新为:</p>
<script type="math/tex; mode=display">
\hat{x}\leftarrow \mathcal{R}_{\hat{x} }(\delta x^{\star}).\tag{19}</script><p>这种“lift-solve-retract”方案可以推广到任何信任区域方法[45]。此外，它提供了错误状态模型的基础和统一概括，该模型通常用于航空航天文献中的过滤[49]，最近在机器人技术中用于优化[23, 34]。</p>
<p>我们通过讨论<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$的选择来结束本节。一个可能的<strong>回缩</strong>（$retraction$）是指数映射。众所周知，在计算上，这可能不是最方便的选择，参见 [50]。</p>
<p>这项工作中，我们对 $SO(3)$ 使用以下<strong>回缩</strong>（$retraction$），</p>
<script type="math/tex; mode=display">
\mathcal{R}_R(\phi)=R\ Exp(\delta\phi),\ \ \delta\phi\in\mathbb{R}^3,\tag{20}</script><p>对于$SE(3)$，我们使用$ T \doteq(R, p) $处的<strong>回缩</strong>（$retraction$）：</p>
<script type="math/tex; mode=display">
\mathcal{R}_T(\delta\phi,\delta p)=(R\ Exp(\delta\phi),p+R\delta p),\ \ [\delta\phi\ \delta p]\in\mathbb{R}^6,\tag{21}</script><p>这就解释了为什么在第 III-A 节中我们只定义了 $SO(3)$ 的指数映射：通过这种<strong>回缩</strong>（$retraction$）选择，我们永远不需要计算 SE(3) 的指数映射。</p>
<h1 id="四、最大后验视觉惯性状态估计"><a href="#四、最大后验视觉惯性状态估计" class="headerlink" title="四、最大后验视觉惯性状态估计"></a>四、最大后验视觉惯性状态估计</h1><p>我们考虑一个VIO问题，其中我们想跟踪一个<strong>感知系统</strong>（$sensing\ system$）（例如，一个自主机器人，一个UAV，或者一个手持设备）的状态，其装备一个IMU和一个单目相机。我们假设IMU坐标系“B”和我们想要跟踪的身体坐标系重合，相机和IMU之间的变换是固定的，并且通过之前的标定已经知道（见图2）。此外，我们假设一个前端提供在未知位置的3D路标的图片测量。前端还选择一组图片，称为<strong>关键帧</strong>[32]，我们想计算它的位姿估计。第7节-B1讨论了应用，包括我们实验的前端选择。</p>
<p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507153228526.png" alt="image-20220507153228526" style="zoom:50%;" /></p>
<blockquote>
<p>图 2：$T_{WB}\doteq  (R_{WB}, _\mathrm{W}\mathbf{p})$ 是Body坐标系相对于世界坐标系 $W$的位姿。我们假设Body坐标与 IMU 坐标系重合。 $T_{BC}$ 是相机在Body坐标中的位姿，由先验标定已知。</p>
</blockquote>
<h2 id="A-状态"><a href="#A-状态" class="headerlink" title="A. 状态"></a>A. 状态</h2><p>系统在时间 $i $的状态由 IMU 方向、位置、速度和偏差描述：</p>
<script type="math/tex; mode=display">
\mathrm{x}_i\doteq    [R_i,\mathbf{p}_i,\mathbf{v}_i,\mathbf{b}_i].\tag{22}</script><p>姿态 $(R_i,\mathbf{p}_i)$属于$ SE(3)$，而速度存在于向量空间中，即 $\mathbf{v}_i \in \mathbb{R}^3$。 IMU 偏差可以写为 $\mathbf{b}_i = [\mathbf{b}_i^g\ \ \mathbf{b}_i^a] \in \mathbb{R}^6$，其中 $\mathbf{b}_i^g\ , \mathbf{b}_i^a\in \mathbb{R}^3 $分别是陀螺仪和加速度计偏差。</p>
<p>令 $\mathcal{K}_k$ 表示直到时间 $k$ 的所有关键帧的集合。在我们的方法中，我们估计所有关键帧的状态：</p>
<script type="math/tex; mode=display">
\mathcal{X}_k\doteq    \{\mathrm{x}_i\}_{i\in\mathcal{K_k} }.\tag{23}</script><p>在我们的实现中，我们采用了<strong>无结构</strong>的方法（参见第 VII 节），因此 3D 地标不是要估计的变量。但是，提出的方法可以推广到一般方法来估计路标和相机内参以及外参。</p>
<h2 id="B-测量"><a href="#B-测量" class="headerlink" title="B. 测量"></a>B. 测量</h2><p>我们估计问题的<strong>输入是来自相机和 IMU 的测量值</strong>。我们用 $\mathcal{C}_i$表示关键帧$i$处的图像测量值。在时间 $i$，相机可以观察到多个地标 $l$，因此 $\mathcal{C}_i$包含多个图像测量值 $\mathrm{z}_{il}$。我们稍微滥用符号，我们记 $ l \in \mathcal{C}_i$ 为在 $i$ 时刻看到地标 $l$ 。</p>
<p>我们用 $\mathcal{I}_{ij}$ 表示在两个连续关键帧 $i$ 和 $j$ 之间获得的<strong>一组 IMU 测量值</strong>。根据 IMU 测量速率和所选关键帧的频率，每个集合 $\mathcal{I}_{ij}$ 可以包含从少量到数百个 IMU 测量值。到时间 $k$ 收集的测量值集是:</p>
<script type="math/tex; mode=display">
\mathcal{Z}_k\doteq\{\mathcal{C}_i,\mathcal{I}_{ij}\}_{(i,j)\in\mathcal{K}_k}.\tag{24}</script><h2 id="C-因子图和-MAP-估计"><a href="#C-因子图和-MAP-估计" class="headerlink" title="C. 因子图和 MAP 估计"></a>C. 因子图和 MAP 估计</h2><p>给定可用的视觉和惯性测量 $\mathcal{Z}_k$ 和先验 $p(\mathcal{X}_0)$，变量 $\mathcal{X}_k$ 的后验概率为：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\mathcal{X}_k|\mathcal{Z}_k)&\propto p(\mathcal{X}_0)\ p(\mathcal{X}_k|\mathcal{Z}_k)\overset{(a)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{C}_i,\mathcal{I}_{ij}|\mathcal{X}_k)\\
&\overset{(b)}{=}
p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{I}_{ij}|\mathrm{x}_i,\mathrm{x}_j)
\prod_{i\in\mathcal{K}_k}\prod_{l\in\mathcal{C}_i}p(\mathrm{z}_{il}|\mathrm{x}_i)
\end{align*}\tag{25}</script><p>分解 $(a)$ 和 $(b)$ 遵循测量之间的标准独立假设。此外，马尔可夫属性应用于$(b)$（例如，时间 $i$ 的图像测量仅取决于时间 $i$ 的状态）。</p>
<p>由于测量值 $\mathcal{Z}_k$ 是已知的，我们可以自由地将它们作为变量消除，并将它们视为<strong>实际未知数的联合概率因子</strong>的参数。这自然会导致众所周知的因子图表示，这是一类可用于表示这种因子密度的<strong>二分图模型</strong> [51, 52]。图 3 给出了 VIO 问题背后的因子图的连通性示意图（无结构视觉因子的连通性将在第 VII 节中阐明）。<strong>因子图</strong>由<strong>未知数节点</strong>和定义在其上的<strong>概率因子节点</strong>组成，<strong>图结构表示每个因子涉及哪些未知数</strong>。</p>
<p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507162306950.png" alt="image-20220507162306950"></p>
<blockquote>
<p>图 3：左：VIO 中的视觉和惯性测量。右图：因子图，其中几个 IMU 测量值汇总在单个预积分 IMU 因子中，无结构视觉因子约束关键帧观察相同的地标。</p>
</blockquote>
<p>MAP 估计 $\mathcal{X}_k^{\star}$ 对应于 $(25)$ 的最大值，或者等效地，负对数后验的最小值。在零均值高斯噪声的假设下，<strong>负对数后验</strong>可以写为<strong>残差平方和</strong>：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mathcal{X}_k^{\star}&\doteq\arg\underset{\mathcal{X}_k}{\min}-\log_ep(\mathcal{X}_k|\mathcal{Z}_k)\\
&=\arg\underset{\mathcal{X}_k}{\min}\parallel r_0 \parallel^2_{\Sigma_0}+
\sum_{(i,j)\in\mathcal{K}_k}\parallel r_{\mathcal{I}_{ij} } \parallel^2_{\Sigma_{ij} }
+\sum_{i\in\mathcal{K}_k}\sum_{j\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }
\end{align*}\tag{26}</script><p>其中 $r_0,r_{\mathcal{I}_{ij} },r_{\mathcal{C}_{il} }$ 是与测量相关的<strong>残差</strong>，而 $\Sigma_0,\Sigma_{ij} $和 $\Sigma_{\mathcal{C} }$ 是相应的<strong>协方差矩阵</strong>。粗略地说，残差是 $\mathcal{X}_k$ 的函数，其在给定状态 $\mathcal{X}_k$ 和先验的前提下，量化测量值和预测值的差。以下部分的目标是提供残差和协方差的表达式。</p>
<h1 id="五、IMU模型与运动积分"><a href="#五、IMU模型与运动积分" class="headerlink" title="五、IMU模型与运动积分"></a>五、IMU模型与运动积分</h1><p>IMU 通常包括一个 3 轴加速度计和一个 3 轴陀螺仪，，并允许我们来测量传感器相对一个惯性坐标系的旋转速度和加速度。测量值，即 $_B\tilde{a}(t)$ 和 $_B\tilde{w}_{WB}(t)$，受加性白噪声 $\eta$ 和缓慢变化的传感器偏差 $\mathbf{b}$ 的影响：</p>
<script type="math/tex; mode=display">
\begin{align*}
_\mathrm{B}\tilde{\omega}_{\mathrm{WB} }(t)&= \ _\mathrm{B}\omega_{\mathrm{WB} }(t)+\mathbf{b}^g(t)+\mathbf{\eta}^g(t)\tag{27}\\
_\mathrm{B}\tilde{a}(t)&=R^T_{\mathrm{WB} }(t)(\ _\mathrm{W}\mathbf{a}(t)-\ _\mathrm{W}\mathbf{g})+\mathbf{b}^a(t)+\mathbf{\eta}^a(t)\tag{28}
\end{align*}</script><p>在我们的符号中，前缀 $\mathrm{B}$ 表示相应的量在坐标系中 $\mathrm{B}$ 表示（参见图 2）。 IMU 的位姿由变换 $\{R_\mathrm{WB},\ _\mathrm{W}p\}$ 描述，该变换将传感器坐标系 $\mathrm{B}$ 中的一个点映射到 $\mathrm{W}$ 。向量 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)\in \mathbb{R}^3$ 是坐标系 $\mathrm{B}$ 中表示的 $\mathrm{B}$ 相对于 $\mathrm{W}$ 的<strong>瞬时角速度</strong>，而$\ _\mathrm{W}\mathbf{a}(t)\in \mathbb{R}^3$是传感器的<strong>加速度</strong>； $\ _\mathrm{W}\mathbf{g}$ 是世界坐标中的<strong>重力加速度</strong>。我们忽略了地球自转的影响，这相当于假设 $\mathrm{W}$ 是一个惯性系。</p>
<p>现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型 [49, 53]：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot{R}_\mathrm{WB}&={R}_\mathrm{WB}\ _B{\omega}^{\land}_\mathrm{WB}\\
_\mathrm{W}\dot{\mathbf{v} }&=\ _\mathrm{W}\mathbf{a}\\
_\mathrm{W}\dot{\mathbf{p} }&=\ _\mathrm{W}\mathbf{v}
\end{align*}\tag{29}</script><p>它描述了 $\mathrm{B}$ 的姿势和速度的演变。</p>
<p> $t + \Delta t $时刻的状态是通过积分方程$(29)$获得的：</p>
<script type="math/tex; mode=display">
\begin{align*}
{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\int^{t + \Delta t }_t
\ _B{\omega}_\mathrm{WB}(\tau)d\tau\right) \\
_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+ \int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau\\
_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{v}(\tau)d\tau+\iint^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau^2
\end{align*}</script><p>假设 $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(
\ _B{\omega}_\mathrm{WB}(t)\Delta t\right) \\
_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+\ _\mathrm{W}\mathbf{a}(t)\Delta t\\
_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\  _\mathrm{W}\mathbf{v}(t)\Delta t+\frac{1}{2}\  _\mathrm{W}\mathbf{a}(t)\Delta t^2
\end{align*}\tag{30}</script><p>使用方程式。 (27)–(28)，我们可以将  $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$  写为 IMU 测量的函数，因此 (30) 变为:</p>
<script type="math/tex; mode=display">
\begin{align*}
{R}(t + \Delta t )&={R}(t)Exp\left(
\ (\tilde{\omega}(t)-\mathbf{b}^g(t)-\mathbf{\eta}^{gd}(t))
\Delta t\right) \\
\mathbf{v}(t + \Delta t)&=\ \mathbf{v}(t)+\mathbf{g}\Delta t+\ R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t\\
\mathbf{p}(t + \Delta t)&=\ \mathbf{p}(t)+\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t^2
\end{align*}\tag{31}</script><p>为了便于阅读，我们删除了坐标系下标（从现在开始，符号应该是明确的）。速度和位置的这种数值积分假定两个测量之间 $R(t)$是常数，对于具有非零旋转速率的测量，这不是微分方程 $(29)$ 的精确解。在实践中，使用高速IMU 可以减轻这种近似的影响。我们采用 $(31)$ 的积分方案，<strong>因为它简单，且对于建模和不确定性传播是经得起检验的。</strong>虽然我们表明这种积分方案在实践中表现非常好，但我们注意到对于较慢的 IMU 测量速率，可以考虑使用高阶数值积分方法 [54-57]。</p>
<p>离散时间噪声 $\eta^{gd}$ 的协方差是采样率的函数，并且通过 $Cov(\eta^{gd}(t)) = \frac{1}{\Delta t}Cov(\eta^{g}(t))$ 与连续时间频谱噪声 $\eta^{g}$ 相关。同样的关系也适用于 $\eta^{ad}$（参见 [58, 附录]）。</p>
<h1 id="六、-流形上的IMU预积分"><a href="#六、-流形上的IMU预积分" class="headerlink" title="六、 流形上的IMU预积分"></a>六、 流形上的IMU预积分</h1><p>虽然等式 $(31)$  可以很容易地被视为因子图中的概率约束，它需要在因子图中以高速率包含状态。直观地说，方程。 $(31)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。因此，我们必须在每次新的 IMU 测量时在估计中添加新状态 [37]。</p>
<p>在这里，我们展示了在时间 $k = i$ 和 $k = j$（见图 4）的两个关键帧之间的所有测量值可以总结为单个复合测量值，称为预积分 IMU 测量值，它限制了连续关键帧之间的运动。这个概念最初是在 [2] 中使用欧拉角提出的，我们通过开发一种适用于流形 $SO(3)$ 上的预积分的理论来扩展它。</p>
<p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507202527649.png" alt="image-20220507202527649"></p>
<blockquote>
<p>图 4：IMU 和相机的不同速率。</p>
</blockquote>
<p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 (31)，我们发现：</p>
<script type="math/tex; mode=display">
\begin{align*}
{R}_j&={R}_i\prod^{j-1}_{k=i} Exp\left(
 (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)
\Delta t\right) \\
\mathbf{v}_j&=\ \mathbf{v}_i+\mathbf{g}\Delta t_{ij}+\ \prod^{j-1}_{k=i}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\
\mathbf{p}_j&=\mathbf{p}_i+\sum^{j-1}_{k=i}\left[\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] 
\end{align*}\tag{32}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。虽然等式。 $(32)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(32)$ 中的积分 [24]（直观地说，旋转 $R_i$ 的变化，意味着所有未来旋转 $R_k、k = i,…,j-1$ 的变化，因此有必要重新评估 $(32)$ 中的求和和乘积。</p>
<p>我们希望避免在时间 $t_i$ 的线性化点发生变化时重新计算上述积分。因此，我们遵循 [2] 并定义以下相对运动增量，这些增量与 $t_i$ 处的位姿和速度无关:</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta{R}_{ij}&\doteq{R}^T_iR_j\prod^{j-1}_{k=i} Exp\left(
 (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)
\Delta t\right) \\
\Delta\mathbf{v}_{ij}&\doteq{R}^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})\ = \sum^{j-1}_{k=i}\Delta R_{ij}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\
\Delta\mathbf{p}_{ij}&\doteq{R}^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\sum^{j-1}_{k=i}\mathbf{g}\Delta t^2)\\
&=\sum^{j-1}_{k=i}\left[\  \mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta R_{ik}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] 
\end{align*}\tag{33}</script><p>其中 $\Delta{R}_{ik}\doteq R^T_i R_k $ 和 $\Delta\mathbf{v}_{ik} \doteq R^T_i (\mathbf{v}_{k}−\mathbf{v}_{i}−\mathbf{g}\Delta t_{ik})$。我们强调，与“delta”旋转 $\Delta{R}_{ij}$ 相比， $\Delta\mathbf{v}_{ij}$  和 $\Delta\mathbf{p}_{ij}$都不对应于速度和位置的真实物理变化，而是以一种方式定义的，使得 $(33)$ 的右侧独立于时间 $i$ 的状态以及引力效应。事实上，我们将能够直接从两个关键帧之间的惯性测量中计算 $(33)$ 的右侧。</p>
<p>不幸的是，$(33)$ 中的求和和乘积仍然是偏差估计的函数。我们分两步解决这个问题。在第 VI-A 节中，我们假设$\mathbf{b}_{i}$ 是已知的；然后，在第 VI-C 节中，我们展示了如何在偏差估计发生变化时避免重复积分。</p>
<p>在本文的其余部分，我们假设两个关键帧之间的偏差保持不变：</p>
<script type="math/tex; mode=display">
\mathbf{b}^g_{i}=\mathbf{b}^g_{i+1}=···=\mathbf{b}^g_{j-1},\ \ \ \ 
\mathbf{b}^a_{i}=\mathbf{b}^a_{i+1}=···=\mathbf{b}^a_{j-1}.
\tag{34}</script><h2 id="A-预积分-IMU-测量"><a href="#A-预积分-IMU-测量" class="headerlink" title="A. 预积分 IMU 测量"></a>A. 预积分 IMU 测量</h2><p>等式 $(33)$ 将关键帧 $i$ 和 $j$ 的状态（左侧）与测量值（右侧）相关联。从这个意义上说，它已经可以理解为一种测量模型。不幸的是，它对测量噪声有相当复杂的依赖性，这使得 MAP 估计的直接应用变得复杂。直观地说，MAP 估计器需要清楚地定义测量的密度（及其对数似然）。在本节中，我们修改 $(33)$  以便更容易推导测量对数似然。在实践中，我们在 $(33)$ 中隔离了单个惯性测量的噪声项。如上所述，在本节中，假设时间 $t_i$ 的偏差是已知的。</p>
<p>让我们从 $(33)$ 中的旋转增量 $\Delta{R}_{ij}$ 开始。我们使用一阶近似 $(7)$（旋转噪声“小”）并重新排列术语，通过使用关系$(11)$将噪声“移动”到末尾：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta{R}_{ij} &\overset{eq.(7)}{\simeq}\prod^{j-1}_{k=i}\left[
Exp((\tilde{\omega}_k-\mathbf{b}^g_i)\Delta t)
Exp(-J^k_r\eta^{gd}_k\Delta t)\right]\\
&\overset{eq.(11)}{\simeq}\Delta{\tilde R}_{ij}\prod^{j-1}_{k=i}Exp(-\Delta \tilde R^T_{k+1 j} J^k_r \eta^{gd}_k \Delta t)\\
&\doteq    \Delta{\tilde R}_{ij}Exp(-\delta \phi_{ij})    
\end{align*}\tag{35}</script><p>其中，$J^k_r \doteq J^k_r(( \tilde\omega_k − b^g_i )Δt)$。在 $(35)$ 的最后一行，我们定义了预积分旋转测量 $\Delta{\tilde R}_{ij} \doteq \prod^{j−1}_{k=i} Exp (( \tilde\omega_k − b^g_i) Δt)$，及其噪声 $\delta\phi_{ij}$，将在下一节中分析。</p>
<p>将 $(35)$ 代回 $(33)$ 中 $\Delta\mathbf{v}_{ij}$ 的表达式，使用 $Exp(-\delta \phi_{ij})    $ 的一阶近似 $(4)$，并去掉高阶噪声项，我们得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta\mathbf{v}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t -\Delta{\tilde R}_{ik}\eta^{gd}_k\Delta t\\
&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{v} }_{ij}+\sum^{j-1}_{k=i}\left[
\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t - \Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t
\right]\\
&\doteq    \Delta\tilde{\mathbf{v} }_{ij}-\delta\mathbf{v}_{ij}
\end{align*}\tag{36}</script><p>其中，我们定义了预积分速度测量 $\Delta\tilde{\mathbf{v} }_{ij}\doteq\sum^{j-1}_{k=i}<br>\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\Delta t $及其噪声 $\delta\mathbf{v}_{ij}$。</p>
<p>类似地，将$(35)$ 和$(36)$ 代入$(33)$ 中的 $\Delta\mathbf{p}_{ij}$ 表达式，并使用一阶近似 $(4)$，我们得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta\mathbf{p}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\left[
(\Delta\tilde{\mathbf{v} }_{ik}-\delta\mathbf{v}_{ik})\Delta t+\frac{1}{2}
\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t^2 -\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\\
&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{p} }_{ij}+\sum^{j-1}_{k=i}\left[
-\delta\mathbf{v}_{ik}\Delta t+
\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t^2 - \frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2
\right]\\
&\doteq    \Delta\tilde{\mathbf{p} }_{ij}-\delta\mathbf{p}_{ij}
\end{align*}\tag{37}</script><p>其中我们定义了预集成的位置测量 $\Delta\tilde{\mathbf{p} }_{ij}$ 及其噪声 $\delta\mathbf{p}_{ij}$。</p>
<p>将表达式 $(35), (36), (37)$ 代入$ (33)$ 中 $\Delta{R}_{ij}, \Delta\mathbf{v}_{ij}, \Delta\mathbf{p}_{ij}$ 的原始定义，我们最终得到了我们的<strong>预积分测量模型</strong>（记住 $Exp(-\delta\phi_{ij})^T = Exp(\delta\phi_{ij})$):</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta{\tilde R}_{ij}&=R^T_iR_j\mathrm{Exp}(\delta\phi_{ij})
\\R^T_i
\Delta\tilde{\mathbf{v} }_{ij}&=R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})+\delta\mathbf{v}_{ij}
\\
\Delta\tilde{\mathbf{p} }_{ij}&=R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)+\delta\mathbf{p}_{ij}
\end{align*}\tag{38}</script><p>其中我们的复合测量被写为（待估计）状态“加上”随机噪声的函数，由随机向量 $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 描述。</p>
<p>为了总结本节的内容，我们将 $(33)$ 的测量模型重新写为 $(38)$。$(38)$ 的优势在于，对于一个合适的噪声分布，它直接定义了对数似然。例如，具有零均值加性高斯噪声（ $(38)$的最后两行）测量的（负）对数是一个二次函数。类似地，如果 $\delta\phi_{ij}$  是零均值高斯噪声，我们计算与 $\Delta\tilde R_{ij}$ 相关的（负）对数似然。噪声项的性质将在下一节中讨论。</p>
<h2 id="B-噪声传播"><a href="#B-噪声传播" class="headerlink" title="B. 噪声传播"></a>B. 噪声传播</h2><p>在本节中，我们推导出噪声向量  $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 的统计量。虽然我们已经观察到将噪声向量近似为零均值正态分布是很方便的，但准确地建模噪声协方差是至关重要的。实际上，噪声协方差对 MAP 估计器有很大的影响（逆噪声协方差用于对优化中的项进行加权 $(26)$）。因此，在本节中，我们提供了预积分测量的协方差 $\Sigma_{ij}$ 的推导：</p>
<script type="math/tex; mode=display">
\eta^{\Delta}_{ij}\doteq[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T\sim\mathcal{N}(0_{9\times1},\Sigma_{ij})\tag{39}</script><p>我们首先考虑预积分的旋转噪声 $\delta\phi_{ij}$。回想一下 $(35)$</p>
<script type="math/tex; mode=display">
\mathrm{Exp}(-\delta\phi_{ij})\doteq\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\tag{40}</script><p>取两边的对数并改变符号，我们得到：</p>
<script type="math/tex; mode=display">
\delta\phi_{ij}=-\mathrm{Log}\left(\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\right)\tag{41}</script><p>一阶近似 $(9)$ 的重复应用（回想一下，$\eta^{gd}_k$ 和 $\delta\phi_{ij}$ 都是小的旋转噪声，因此右雅可比矩阵接近恒等式）产生：</p>
<script type="math/tex; mode=display">
\delta\phi_{ij}\simeq\sum^{j-1}_{k=1}\Delta\tilde R^T_{K+1j}J^k_r\eta^{gd}_k\Delta t\tag{42}</script><p>保留到一阶，噪声  $\delta\phi_{ij}$ 是零均值和高斯的，因为它是零均值噪声项 $\eta^{gd}_k$ 的线性组合。这是可取的，因为它使旋转测量模型 $(38)$ 完全符合形式 $(12)$。</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta \mathbf{v}_{ij}&\simeq \sum^{j-1}_{k=i}\left[
-\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}
-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t 
+\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t
\right]\\
\delta\mathbf{p}_{ij} &\simeq\sum^{j-1}_{k=i}\left[
\delta\mathbf{v}_{ik}\Delta t-\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}
-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t ^2 
+\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]
\end{align*}\tag{43}</script><p>其中关系到一阶都是正确的。</p>
<p>方程。 $(42)-(43)$ 将预积分噪声 $\eta^{\Delta}_{ij}$ 表示为 IMU 测量噪声 $\eta^d_k \doteq [\eta^{gd}_k , \eta^{ad}_k ], k = 1, . . .,j − 1$, 的线性函数。因此，根据 $\eta^{d}_{k}$  的协方差知识（在 IMU 规范中给出），我们可以通过简单的线性传播计算 $\eta^{\Delta}_{ij}$ 的协方差，即 $\Sigma_{ij}$。</p>
<p>在附录 IX-A 中，我们提供了一种更巧妙的方法来计算$\Sigma_{ij}$。特别是，我们展示了 $\Sigma_{ij}$ 可以方便地以迭代形式计算：当一个新的 IMU 测量到达时，我们只更新 $\Sigma_{ij}$，而不是从头开始重新计算。迭代计算导致更简单的表达式并且更适合在线推理。</p>
<h2 id="C-组合偏差更新"><a href="#C-组合偏差更新" class="headerlink" title="C. 组合偏差更新"></a>C. 组合偏差更新</h2><p>在上一节中，我们假设在 $k = i$ 和 $k = j$ 之间的预积分期间使用的偏差 $\{\overline{b}^a_i , \overline{b}^g_i\}$ 是正确的并且不会改变。然而，更有可能的是，偏差估计在优化过程中会发生少量 $\delta\mathbf{b}$ 的变化。一种解决方案是在偏差发生变化时重新计算 delta 测量值；但是，这在计算上是昂贵的。相反，给定偏差更新 $\mathbf{b}\gets \mathbf{b} + \delta\mathbf{b}$，我们可以使用一阶展开更新 delta 测量：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta\tilde{R}_{ij}(\mathbf{b}^g_i)&\simeq\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)
\\
\Delta\tilde{\mathbf{v} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq
\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)
+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i
+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\\
\Delta\tilde{\mathbf{p} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq
\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)
+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i
+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i
\end{align*}\tag{44}</script><p>这类似于 [2] 中的偏差校正，但直接在 $SO(3)$ 上运行。雅可比矩阵 $\{ \frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g} , \frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g} , . . .\}$（在  $\overline{\mathbf{b} }_i$ 计算，积分时的偏差估计）描述了测量值如何由于偏差估计的变化而变化。雅可比矩阵保持不变，并且可以在预积分期间预先计算。雅可比矩阵的推导与我们在第 VI-A 节中用于将测量值表示为大值加上小扰动的推导非常相似，并在附录 IX-B 中给出。</p>
<h2 id="D-预积分IMU因子"><a href="#D-预积分IMU因子" class="headerlink" title="D. 预积分IMU因子"></a>D. 预积分IMU因子</h2><p>给定 $(38)$ 中的预积分测量模型，并且由于测量噪声是零均值和高斯（协方差 $\Sigma_{ij}$）直到一阶 $(39)$，现在很容易写出残差 $r_{\mathcal{I}_{ij} }\doteq [r^T_{\Delta R_{ij} }, r^T_{\Delta \mathbf{v}_{ij} },r^T_{\Delta \mathbf{p}_{ij} }]^T \in \mathbb{R}^9$, 其中:</p>
<script type="math/tex; mode=display">
\begin{align*}
r_{\Delta R_{ij} }&\doteq \mathrm{Log}\left(
\left(
\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)
\right)^TR^T_iR_j
\right)
\\
r_{\Delta \mathbf{v}_{ij} }&\doteq 
R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})-\left[
\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)
+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g
+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a
\right]
\\
r_{\Delta \mathbf{p}_{ij} }&\doteq 
R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)-\left[
\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)
+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g
+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a
\right]
\\
\end{align*}\tag{45}</script><p>其中我们还包括了方程的偏差更新 $(44)$。</p>
<p>根据“lift-solve-retract”方法（第 III-C 节），在每次 Gauss-Newton 迭代中，我们需要使用<strong>回缩($retraction$)</strong> $(21)$重新参数化 $(45)$。然后，“解决”步骤需要围绕当前估计线性化结果成本。出于线性化的目的，计算残差的雅可比行列式分析表达式很方便，我们在附录 IX-C 中推导出了该表达式。</p>
<h2 id="E-偏置模型"><a href="#E-偏置模型" class="headerlink" title="E. 偏置模型"></a>E. 偏置模型</h2><p>在介绍 IMU 模型 $(27)$ 时，我们说偏差是缓慢随时间变化的量。因此，我们用“布朗运动”对它们进行建模，即综合白噪声：</p>
<script type="math/tex; mode=display">
\dot{b}^g(t)=\eta^{bg}, \ \ \ \ \dot{b}^a(t)=\eta^{ba}\tag{46}</script><p>在两个连续关键帧 $i$ 和 $j$ 之间的时间间隔 $[t_i, t_j]$ 上对 $(46)$ 进行积分，我们得到：</p>
<script type="math/tex; mode=display">
\mathbf{b}^g_j(t)=\mathbf{b}^g_i+\eta^{bgd}, \ \ \ \ \ \mathbf{b}^a_j(t)=\mathbf{b}^a_i+\eta^{bad}\tag{47}</script><p>其中，如前所述，我们使用简写 $\mathbf{b}^g_j\doteq \mathbf{b}^g(t_i)$，我们定义离散噪声 $\eta^{bgd}$ 和 $\eta^{bad}$，它们的均值和协方差为零 $\Sigma^{bgd}\doteq \Delta t_{ij} Cov(\eta^{bg})$ 和 $\Sigma^{bad}\doteq \Delta t_{ij} Cov(\eta^{ba})$，分别（参见[58，附录]）。</p>
<p>模型 $(47)$ 可以很容易地包含在我们的因子图中，作为 $(26)$ 中所有连续关键帧的进一步附加项：</p>
<script type="math/tex; mode=display">
\parallel r_{b_{ij} } \parallel^2 \doteq\parallel \mathbf{b}^g_j- \mathbf{b}^g_i \parallel^2_{\Sigma_{bgd} }+\parallel \mathbf{b}^a_j- \mathbf{b}^a_i \parallel^2_{\Sigma_{bad} }\tag{48}</script><h1 id="七、无结构视觉因子"><a href="#七、无结构视觉因子" class="headerlink" title="七、无结构视觉因子"></a>七、无结构视觉因子</h1><p>在本节中，我们将介绍我们用于视觉测量的无结构模型。我们方法的关键特征是地标的线性消除。请注意，在每次 Gauss-Newton 迭代中都会重复消除，因此我们仍然可以保证获得最佳 MAP 估计。</p>
<p>视觉测量通过如下求和贡献到代价函数 $(26)$ 中:</p>
<script type="math/tex; mode=display">
\sum_{i\in\mathcal{K}_k}\sum_{l\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2=\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\tag{49}</script><p>其中，在右侧，我们将其重写为每个地标 $l = 1 ,. . , L$, 的贡献的总和。在 (49) 中，$\mathcal{X}(l)$ 表示看到 $l$ 的关键帧的子集。</p>
<p>单个图像测量 $\mathbf{z}_{il}$ 的残差的一个相当标准的模型是重投影误差：</p>
<script type="math/tex; mode=display">
r_{\mathcal{c}_{il} }=\mathbf{z}_{il}-\pi(R_i,\mathbf{p}_{i},ρ_l)\tag{50}</script><p>其中 $ρ_l \in \mathbb{R}^3$ 表示第 $l$ 个地标的位置，$π(·)$ 是标准透视投影，它也编码了（已知的）IMU 相机变换 $T_{BC}$。</p>
<p>直接使用 $(50)$ 将需要包括地标位置 $ρ_l, l = 1, 。 . . , L$ 在优化中，这对计算产生负面影响。因此，在下文中，我们采用了一种无结构的方法，避免对地标进行优化，从而确保检索 MAP 估计</p>
<p>正如在第 III-C 节中回顾的那样，在每次 GN 迭代中，我们使用<strong>回缩($retraction$)</strong> $(21)$来提升成本函数。对于视觉因素，这意味着原始残差 $(49)$ 变为：</p>
<script type="math/tex; mode=display">
\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel 
\mathbf{z}_{il}-\check{\pi}(\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l)
\parallel^2_{\Sigma_{\mathcal{C} } }\tag{51}</script><p>其中 $\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l$ 是欧几里得修正，$\check{\pi}(·)$ 是提升的成本函数。 GN 方法中的“求解”步骤基于残差的线性化：</p>
<script type="math/tex; mode=display">
\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel 
\mathbf{F}_{il}\delta\mathbf{T}_{i}+\mathbf{E}_{il}\delta ρ_l-\mathbf{b}_{il}
\parallel^2\tag{52}</script><p>其中 $\delta \mathbf{T}_i \doteq [\delta\phi_i,\delta\mathbf{p}_i]^T$; 雅可比矩阵 $\mathbf{F}_{il},\mathbf{E}_{il}$ 和向量 $\mathbf{b}_{il}$（均由 $\Sigma^{1/2}_{\mathcal{C}}$ 归一化）来自线性化。向量$\mathbf{b}_{il}$是线性化点处的残差。将 $(52)$ 中的第二个和写成矩阵形式，我们得到：</p>
<script type="math/tex; mode=display">
\sum^L_{l=1}\parallel 
\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}
\parallel^2\tag{53}</script><p>其中，对于所有 $i \in \mathcal{X}(l)，\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 分别通过堆叠 $\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 获得。</p>
<p>由于地标 $l$ 出现在总和 $(53)$ 的单个项中，因此对于任何给定的姿态扰动 $\delta\mathbf{T}_{\mathcal{X}(l)}$ 选择，最小化代价函数 $\parallel<br>\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}<br>\parallel^2$ 的地标扰动 $\deltaρ_l$ 是：</p>
<script type="math/tex; mode=display">
\deltaρ_l=-(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\tag{54}</script><p>将 $(54)$ 代回 $(53)$ 我们可以从优化问题中消除变量 $\deltaρ_l$ ：</p>
<script type="math/tex; mode=display">
\sum^L_{l=1}\parallel 
(\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T)
(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})
\parallel^2\tag{55}</script><p>其中 $\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T$ 是 $\mathbf{E}_{l}$的正交投影。在附录 IX-D 中，我们展示了可以进一步操纵成本 $(55)$，从而实现更有效的实施。</p>
<p>这种方法在BA文献中被称为 Schur 补码技巧($Schur\ complement\ trick$)，其中一种标准做法是通过反向替换来更新 $ρ_l$ 的线性化点 [61]。相反，我们使用快速线性三角测量从姿势的线性化点获得更新的地标位置。使用这种方法，我们将涉及姿势和地标的大量因子 $(51)$ 减少为仅涉及姿势的较小 $L$ 因子集 $(55)$。特别是，与界标 $l$ 对应的因子仅涉及观察 $l$ 的状态 $\mathcal{X}(l)$，创建图 3 的连接模式。MSCKF [5] 中也使用相同的方法来避免在状态向量中包含界标.</p>
]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>预积分理论</tag>
      </tags>
  </entry>
  <entry>
    <title>外积、内积、张量积、Kronecker积</title>
    <url>/posts/bdcf3114.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h1><p>内积又称为点积，有两种定义方式，一种是代数方式，一种是集合方式。</p>
<ul>
<li><strong>代数定义</strong></li>
</ul>
<p>两个向量$\vec{a}=[a_1,a_2,···,a_n]$和$\vec{b}=[b_1,b_2,···,b_n]$的点积定义为：</p>
<script type="math/tex; mode=display">
\vec{a}\cdot\vec{b}=\sum^{n}_{i=1}a_ib_i=a_1b_1+a_2b_2+···+a_nb_n\tag{1}</script><p>点积也可以写成$\vec{a}\vec{b}^T$</p>
<ul>
<li><strong>几何定义</strong></li>
</ul>
<p>在欧几里得空间中，点积可以直观地定义为:</p>
<script type="math/tex; mode=display">
\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\cos\theta\tag{2}</script><p>其中，$|\vec{x}|$表示$\vec{x}$的模长，$\theta$表示两个向量之间的夹角。</p>
<h1 id="叉积（Cross-product）"><a href="#叉积（Cross-product）" class="headerlink" title="叉积（Cross product）"></a>叉积（Cross product）</h1><ul>
<li><strong>定义</strong></li>
</ul>
<p>叉积又称为向量积（有时候也说是外积，这里为了区分，就不这么说，因为你会发现好多外积），是对三维空间中的两个向量的二元运算，使用符号$\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量$a$和$b$，它们的外积写作 $a\times b$，是 $ a $和$b$所在平面的法线向量，与$ a $和$b$都垂直。</p>
<p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506153837169.png" alt="image-20220506153837169" style="zoom: 25%;" /></p>
<p>两个向量$a$和$b$的叉积仅在三维空间有定义，写作 $a\times b$，叉积也可以定义为：</p>
<script type="math/tex; mode=display">
a\times b=\parallel a \parallel \parallel b\parallel \sin(\theta)n\tag{3}</script><p>其中$\theta$表示$a$和$b$在它们所定义的平面上的夹角，$\parallel a \parallel$和$\parallel b \parallel$表示向量$a$和$b$的模长，而$n$则是一个与$a$和$b$所构成的平面的垂直的单位向量，方向由右手定则决定。</p>
<ul>
<li><strong>矩阵表示</strong></li>
</ul>
<p>叉积也可以定义为：</p>
<script type="math/tex; mode=display">
a\times b=\left|\begin{matrix}i&j&k\\a_1&a_2&a_3\\b_1&b_2&b_3\end{matrix}\right|=
\begin{bmatrix}a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1\end{bmatrix}=
\begin{bmatrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\end{bmatrix}b\triangleq a^{\land}b
\tag{4}</script><p>这里引入符号$^{\land}$，成为反对称符号，这样就可以把外积$a\times b$写成了矩阵与向量的乘法$a^{\land}b$，把它变成可线性运算。在《视觉SLAM十四讲》中也有提及。</p>
<h1 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h1><p>在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的:最一般的双线性运算。在某些上下文中也叫做外积。</p>
<script type="math/tex; mode=display">
b\otimes a \rightarrow \begin{bmatrix}b_1\\b_2\\b_3\\b_4\end{bmatrix}_{4\times 1}
\begin{bmatrix}a_1&a_2&a_3\end{bmatrix}_{1\times 3}=
\begin{bmatrix}a_1b_1&a_2b_1&a_3b_1\\a_1b_2&a_2b_2&a_3b_2\\a_1b_3&a_2b_3&a_3b_3\\a_1b_4&a_2b_4&a_3b_4\\\end{bmatrix}_{4\times 3}\tag{5}</script><p>对于张量积之后的秩：</p>
<script type="math/tex; mode=display">
rank(V\otimes U)=rank(V)+rank(U)\tag{6}</script><h1 id="Kronecker积"><a href="#Kronecker积" class="headerlink" title="Kronecker积"></a>Kronecker积</h1><p>数学上，克罗内克积（英语：Kronecker product）是两个任意大小的矩阵间的运算，表示为⊗。克罗内克积是外积从向量到矩阵的推广，也是张量积在标准基下的矩阵表示。</p>
<p>如果$A$是一个$m\times n$的矩阵，$B$是一个$p\times q$的矩阵，克罗内克积为$A\otimes B$则是一个$mp\times nq$的矩阵：</p>
<p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162341626.png" alt="image-20220506162341626" style="zoom: 20%;" /></p>
<p>更具体的表示为：</p>
<p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162438902.png" alt="image-20220506162438902" style="zoom:40%;" /></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>内积与外积</tag>
      </tags>
  </entry>
  <entry>
    <title>相机模型简要分析</title>
    <url>/posts/ddbf64.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="相机成像模型"><a href="#相机成像模型" class="headerlink" title="相机成像模型"></a>相机成像模型</h1><p>相机模型基于小孔成像：</p>
<p><img src="/images/相机模型简要分析/image-20220505170737171.png" alt="image-20220505170737171" style="zoom: 67%;" /></p>
<p>这里出现了几个坐标系：</p>
<ul>
<li>世界坐标系$\{W\}$，在世界坐标系下，特征点$P$在世界坐标系下的坐标为$P_w=(X_w,Y_w,Z_w)$</li>
<li><p>相机坐标系$\{C\}$，对相机来说，也有一个相机坐标系，也可以称之为机器人本体坐标系，因为相机属于机器人，特征点$P$在相机坐标系下的坐标为$P_c=(X_c,Y_c,Z_c)$</p>
</li>
<li><p>像素平面坐标系$\{P^{\prime}\}$，这个是通过相机内部得到的投影平面坐标系，它是一个二维的平面，特征点$P$在像素平面坐标系下的坐标为$P^{\prime}=(X^{\prime},Y^{\prime})$，</p>
</li>
<li><p>像素坐标系$\{P_{uv}\}$，像素坐标系是素平面坐标系$\{P^{\prime}\}$经过缩放和平移得到的，后面介绍。</p>
</li>
</ul>
<p>那么我们需要明白这几个坐标系之间的关系：</p>
<p><img src="/images/相机模型简要分析/image-20220505171918452.png" alt="image-20220505171918452"></p>
<h2 id="世界坐标系——相机坐标系"><a href="#世界坐标系——相机坐标系" class="headerlink" title="世界坐标系——相机坐标系"></a>世界坐标系——相机坐标系</h2><p>这个很简单，两者就相差一个刚体变换，这变换矩阵为$T_{cw}$，则对于特征点$P$来说，就有：</p>
<script type="math/tex; mode=display">
P_{c}=(T_{cw}P_{w})_{(1:3)}=(T_{cw}\begin{bmatrix}X_{w}\\Y_{w}\\Z_{w}\end{bmatrix})_{(1:3)}\tag{1}</script><p>这里$(T_{cw})_{(1:3)}$指的是纯旋转的情况下，考虑他的前三项。</p>
<h2 id="相机坐标系——像平面坐标系"><a href="#相机坐标系——像平面坐标系" class="headerlink" title="相机坐标系——像平面坐标系"></a>相机坐标系——像平面坐标系</h2><p><img src="/images/相机模型简要分析/image-20220505172602891.png" alt="image-20220505172602891"></p>
<p>如图所示，展示相机内部投影的过程，</p>
<script type="math/tex; mode=display">
\begin{align*}
X^{\prime}=f\frac{X_c}{Z_c}\\
Y^{\prime}=f\frac{Y_c}{Z_c}
\end{align*}\tag{2}</script><h2 id="像平面坐标系——像素坐标系"><a href="#像平面坐标系——像素坐标系" class="headerlink" title="像平面坐标系——像素坐标系"></a>像平面坐标系——像素坐标系</h2><p>像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。我们设像素坐标在$u$ 轴上缩放了 $\alpha$倍，在 $v$上缩放了 $\beta$ 倍。同时，原点平移了$ [c_x,c_y]^T$。那么， $P^′$ 的坐标与像素坐标 $[u,v]^T $的关系为：  </p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{L}
u=\alpha X^{\prime}+c_x\\
v=\alpha Y^{\prime}+c_y
\end{array}
\right.\
\tag{3}</script><p>将$(2)$带入$(3)$:</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{L}
u=f_x \frac{X_c}{Z_c}+c_x\\
v=f_y \frac{Y_c}{Z_c}+c_y
\end{array}
\right.\
\tag{3}</script><p>其中$f_x= \alpha f$，$f_y= \beta f$，$f$ 的单位为米， $\alpha,\beta$ 的单位为像素每米，所以 $f_x,f_y $的单位为像素 。</p>
<h2 id="相机坐标系——像素坐标系"><a href="#相机坐标系——像素坐标系" class="headerlink" title="相机坐标系——像素坐标系"></a>相机坐标系——像素坐标系</h2><script type="math/tex; mode=display">
\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}
\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}
\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}
\triangleq \lambda KP_c\tag{4}</script><p>其中，$\lambda$称为逆深度，$K$表示相机的内参。</p>
<ul>
<li>采用逆深度的方式，表达一个点的坐标$(x,y,z)$变成成了$1/λ * [u,v,1]^T$，将$3$个优化变量，变成了一个优化变量（$u,v$为归一化相机坐标系下的三维点的坐标，通过观测数据是可知的），所以优化变量少。</li>
<li>同时，对于深度很大的点，在数值上很大，采用逆深度的方式，倒一下，数值上变小了，有利于优化过程中数值的稳定性，不会因为很远的点（深度值很大）导致一次优化过程中出现较大的误差函数的变换，因此再远的点（如天空中的点）也能表达了，所以能表达非常远的点。</li>
<li>将深度值倒数一下，变成小数，跟接近高斯分布的函数表达形式，方便优化。</li>
</ul>
<p><strong>归一化坐标</strong></p>
<p>另外我们引入归一化坐标的概念，它位于相机前方 $z = 1$ 处的平面上。该平面称为<strong>归一化平面</strong>。  比如对$P_c$进行归一化处理得到$\overline{P}$</p>
<script type="math/tex; mode=display">
\overline{P}=\frac{1}{Z_c}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}
=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\tag{5}</script><p>因此，可以得到像素坐标与归一化坐标之间的关系为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}
\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}
\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}
\triangleq  K\overline{P}\tag{6}</script><p>可以发现相机归一化坐标$\overline{P}$经过相机内参就可以得到像素坐标，所以我们可以把像素坐标$[u,v]^T$ ，看成对归一化平面上的点进行量化测量的结果。  </p>
<h2 id="相机坐标系——世界坐标系"><a href="#相机坐标系——世界坐标系" class="headerlink" title="相机坐标系——世界坐标系"></a>相机坐标系——世界坐标系</h2><script type="math/tex; mode=display">
\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}
\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}
(R_{cw}P_w+t)
\triangleq \lambda KT_{cw}P_w\tag{7}</script><h1 id="VO重投影误差"><a href="#VO重投影误差" class="headerlink" title="VO重投影误差"></a>VO重投影误差</h1><p>重投影误差如图示，我们通过特征匹配可知，观测值$p_1$和$p_2$是同一个空间点$P$的投影，而实际上我们利用帧间的位姿估计，可以通过观测值$p_1$求得对应的匹配$\hat{p}_2$，理论上，我们的计算值$\hat{p}_2$与观测值$p_1$应该是重合的，但是，由于我们估计的帧间位姿并不是准确的，因此就会出现误差$e$，我们称之为重投影误差。</p>
<p><img src="/images/相机模型简要分析/image-20220505202300998.png" alt="image-20220505202300998" style="zoom:50%;" /></p>
<p>按照之前的基础知识，可以推导：</p>
<script type="math/tex; mode=display">
s_iu_i=K\exp(\xi^{\land})P_i\tag{8}</script><p>其中，$u_i=[u_i,v_i]^T$表示特征点$P$的投影坐标，$s_i$表示深度，$K$表示相机内参，$\exp(\xi^{\land})$则是变换$T_{cw}$的李代数形式，这里的$P_i$是特征点的世界坐标。这里类似于公式$(7)$。</p>
<p>通过重投影误差的定义可知，我们的目的在于不断优化变量$\xi$，从而得到一个最优的$\xi$使得$e$的值达到最小，因此构建最小二乘：</p>
<script type="math/tex; mode=display">
\xi^*=\arg\underset{\xi}{\min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1}{s_i}K\exp(\xi^{\land})P_i\parallel^2_2\tag{9}</script><p>然后就是对其优化的内容了，这里可以参考：<a href="https://lukeyalvin.top/posts/20908.html#1-%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE">PnP_重投影误差</a></p>
<h1 id="VIO重投影误差"><a href="#VIO重投影误差" class="headerlink" title="VIO重投影误差"></a>VIO重投影误差</h1><p>由构建于VIO重投影误差省略了相机内参$K$，那么，我们在公式$(6)$的基础上把$K$去掉，就发现<strong>特征点在相机归一化平面的坐标就是像素坐标</strong>$[u,v]^T$，其中$[u,v]^T$是观测值，由于$T_{cw}$是估计出来的，所以等式右边是估计值，理想情况下有：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}u\\v\\1\end{bmatrix}=
T_{cw}\begin{bmatrix}\frac{X_w}{Z_w}\\\frac{Y_w}{Z_w}\\1\end{bmatrix}=
\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}
\triangleq  \overline{P}</script><p>而此时的重投影误差就变成了：</p>
<script type="math/tex; mode=display">
r_c=\begin{bmatrix}\frac{X_c}{Z_c}-u\\\frac{Y_c}{Z_c}-v\end{bmatrix}</script><p>熟悉这个之后，我们再来学习一下VIO重投影误差。</p>
<p><img src="/images/相机模型简要分析/image-20220505205125811.png" alt="image-20220505205125811" style="zoom: 33%;" /></p>
<p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p>
<script type="math/tex; mode=display">
\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=
T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}
\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{10}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p>
<script type="math/tex; mode=display">
r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u\\\frac{Y_{cj} }{Z_{cj} }-v\end{bmatrix}\tag{11}</script>]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>相机模型</tag>
        <tag>VO</tag>
      </tags>
  </entry>
  <entry>
    <title>状态估计模型与贝叶斯滤波</title>
    <url>/posts/b04da399.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><strong>滤波器的本质：</strong>结合预测和观测，得到“最精确”的后验值。这个精确值是相对的，因为实际中，预测和观测均是从传感器而来的，因此滤波器的作用就是结合各个传感器得到一个最好的融合结果。这就是一个数据融合的过程，关于数据融合的介绍可以参考：<a href="https://lukeyalvin.top/posts/8369.html#%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88">数据融合</a></p>
<p><img src="/images/滤波器基本原理/image-20220504151009319.png" alt="image-20220504151009319" style="zoom:50%;" /></p>
<p>1) 实际中预测往往从IMU、编码器等传感器递推而来；<br>2) 观测往往从GPS、雷达、相机等传感器而来；<br>3) 后验为融合后的结果，即定位模块的输出。</p>
<h1 id="状态估计模型"><a href="#状态估计模型" class="headerlink" title="状态估计模型"></a>状态估计模型</h1><p>实际状态估计任务中，待估计的后验概率密度可以表示为：</p>
<script type="math/tex; mode=display">
p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})\tag{1}</script><p>其中：$\tilde{x}_0$表示的是状态初始值；$v_{1:k}$表示从第1时刻到第$k$时刻的输入；$y_{0:k}$表示从第0时刻到第$k$时刻的观测。</p>
<p>因此，滤波问题可以直观表示为，根据所有历史数据（输入、观测、初始状态），得出的最终的融合结果。历史数据之间的关系，可以用下面的图模型表示，</p>
<p><img src="/images/滤波器基本原理/image-20220504205031587.png" alt="image-20220504205031587" style="zoom: 33%;" /></p>
<p>图模型中体现了<strong>马尔可夫性</strong>，即当前状态只跟前一时刻状态相关，和其他历史时刻状态无关。数学表达该性质，</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
运动方程：x_k&=f(x_{k-1},v_k,w_k)\\
观测方程：y_k&=g(x_k,n_k)
\end{aligned}
\right.\tag{2}</script><h1 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h1><p>根据贝叶斯公式，$k$时刻后验概率密度可以表示为</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})&=\frac
{p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}
{p(y_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}\\
&=\eta p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})
\end{align*}\tag{3}</script><p>根据观测方程，$y_k$只与$x_k$相关，因此上式可以简写为：</p>
<script type="math/tex; mode=display">
p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})=\eta p(y_k|x_k)p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\tag{4}</script><p>应用系统的马尔可夫性进一步化简公式，</p>
<script type="math/tex; mode=display">
\begin{align*}
&p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\\
&=\int p(x_k,x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\
&=\int p(x_k|x_{k-1}，\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\
&=\int p(x_k|x_{k-1},v_{k})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}
\end{align*}\tag{3}</script><p>经过以上化简，最终后验概率可以写为</p>
<p><img src="/images/滤波器基本原理/image-20220504211503741.png" alt="image-20220504211503741" style="zoom: 50%;" /></p>
<p>根据以上结果，可以画出贝叶斯滤波的信息流图如下</p>
<p><img src="/images/滤波器基本原理/image-20220504210156815.png" alt="image-20220504210156815"></p>
<p>贝叶斯滤波分为很多种实现形式：</p>
<p><img src="/images/滤波器基本原理/image-20220504211643228.png" alt="image-20220504211643228" style="zoom: 50%;" /></p>
<p>实际中，粒子滤波（PF）多用于(早期的)2D激光SLAM方案中。在高斯假设前提下，用贝叶斯滤波的原始形式比较复杂，可以利用高斯的特征得到简化形式，即广义高斯滤波，后面KF、EKF、IEKF、UKF的推导均采用这种形式，只有PF例外，因为它是针对非高斯的。</p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
      <tags>
        <tag>滤波器</tag>
        <tag>概率基础</tag>
        <tag>贝叶斯滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>点云地图的建立、畸变补偿和定位</title>
    <url>/posts/f737dac5.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>点云地图的建立</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="建图流程"><a href="#建图流程" class="headerlink" title="建图流程"></a>建图流程</h1><p>建图流程设计的核心原则是准确、高效地把<strong>里程计相对位姿</strong>、<strong>回环相对位姿</strong>、<strong>惯导先验位姿</strong>进行融合。</p>
<p><img src="/images/点云地图的建立/image-20220503190523343.png" alt="image-20220503190523343" style="zoom: 33%;" /></p>
<ul>
<li>轨迹对齐</li>
</ul>
<p>里程计的初始位姿是从激光雷达收到第一帧点云开始的，它的初始位姿就是单位阵，平移和旋转均为0；而对于惯导而言，它的旋转是以东北天坐标系为准的，因此它的初始位姿并不一定为0；因此里程计第一帧之间的位姿和惯导第一帧的位姿出现了相对旋转，这会导致里程计和先验之间出现很大的误差，所以我们求第一帧时里程计和惯导位姿之间的相对变换即可，这样就可以把里程计的轨迹拉到与惯导轨迹（一般和小车行进方向一致）一致的方向。这个过程就是<strong>轨迹对齐</strong>。</p>
<ul>
<li>回环检测</li>
</ul>
<p>这里涉及一个简单的回环检测的策略，比如如下的回环，我们检测回环不可能每一帧都进行检测，而是在一定的范围内，并且两帧之间的时间差必须大于一定的阈值，另外当某一帧被检测为闭环了，那么它相邻的一些帧则不做重复的检测，把相邻帧做“吸收化”之后，在后续段进行闭环检测。</p>
<p><img src="/images/点云地图的建立/image-20220503191428273.png" alt="image-20220503191428273" style="zoom: 50%;" /></p>
<ul>
<li>优化周期</li>
</ul>
<p>固定优化周期，可以在一定周期内进行优化，可以在误差累积相对较小的情况下进行优化，因为累积误差小，优化时间短，这样前端里程计构建过程中可以同步实现后端的优化，可以提高效率。</p>
<h1 id="畸变补偿"><a href="#畸变补偿" class="headerlink" title="畸变补偿"></a>畸变补偿</h1><ul>
<li><strong>产生原因：</strong></li>
</ul>
<p>由于一帧点云中的激光点是不同时刻采集的，激光点的坐标原点是采集时刻的雷达位姿，雷达在不同时刻的位姿有变化的时候，各个激光点原点不一致，拼接成一帧时，点云的形状便和实际物体形状不一致。</p>
<p><img src="/images/点云地图的建立/image-20220503193403250.png" alt="image-20220503193403250" style="zoom:50%;" /></p>
<p><img src="/images/loam论文深度解析/image-20220411193701848.png" alt="image-20220411193701848" style="zoom:33%;" /></p>
<ul>
<li><strong>补偿方法：</strong></li>
</ul>
<p>对于每一个激光点坐标做补偿，补偿量为激光点云与原点（即当时激光雷达坐标）相对于该帧起始时刻的变换。</p>
<h2 id="计算相对坐标"><a href="#计算相对坐标" class="headerlink" title="计算相对坐标"></a>计算相对坐标</h2><p>在匀速模型假设前提下，坐标 = 运动×时间。</p>
<p>假设第一帧点云的起始位姿为：</p>
<script type="math/tex; mode=display">
T_0=\begin{bmatrix}R_0&t_0\\0&1\end{bmatrix}\tag{1}</script><p>第$i$个激光点采集时，雷达的位姿为：</p>
<script type="math/tex; mode=display">
T_i=\begin{bmatrix}R_i&t_i\\0&1\end{bmatrix}\tag{2}</script><p>第$i$个激光点的坐标为：</p>
<script type="math/tex; mode=display">
P_i=[p_{ix} \ p_{iy} \ p_{iz}]^T\tag{3}</script><p>则第$i$个激光点补偿畸变后的坐标应该为：</p>
<script type="math/tex; mode=display">
\overline{P}_i=T_0^{-1}T_iP_i\tag{4}</script><p>上式可以理解为，只需要计算$0$到$i$时刻，激光雷达的相对旋转和相对平移变换即可。</p>
<p>实际上，雷达点云是局部坐标系下的表示，当以0时刻雷达的位姿为基准坐标系的时候，此时$T_0$为单位阵，$T_i$即为$0$到$i$时刻的相对旋转和平移。</p>
<p>此时有：</p>
<script type="math/tex; mode=display">
\begin{align*}
R_i&=\omega\nabla t\\
t_i&=V\nabla t
\end{align*}\tag{5}</script><p>即，只需要知道$0$到$i$时刻的平均角速度和平均速度即可。</p>
<p><strong>那么时间差如何进行求取呢？</strong></p>
<p>由于是顺序扫描，我们可以通过$\arctan\frac{y}{x}$来计算出该激光点相对于第一个激光点旋转过的角度$\beta$，已知雷达内部旋转$360°$用了$100ms$，那么旋转$\beta$角度所用的时间就可以计算出来了。</p>
<p>但是由于$\arctan\frac{y}{x}\in[-90°,90°]$的范围。而雷达的周期是$360°$，因此计算出来的$\arctan\frac{y}{x}$还需要进行角度补偿。</p>
<p>下面摘自：<a href="https://zhuanlan.zhihu.com/p/109379384">从零开始做自动驾驶定位(八): 点云畸变补偿</a></p>
<h2 id="点云数据排列方式"><a href="#点云数据排列方式" class="headerlink" title="点云数据排列方式"></a>点云数据排列方式</h2><p>做激光定位的多数都看过loam的程序，会发现在计算激光点采集时刻这一步上我们和它是有区别的，这就是这个点云排列方式导致的。</p>
<p>从激光雷达原理上讲，每次采集一列，边扫描边采集，所以数据应该是一列一列地存储，这样保证第一个点一定是最早时刻被采集的，最后一个点是最晚时刻被采集的，这样做有一个好处，那就是可以计算雷达真正扫描了多少度，因为它就是第一个点和最后一个点的角度差。</p>
<p>而在这个bag文件里，是按行存储的，也就是先索引第一根线上的点，再第二根，依次类推，直到最后一根，这样的缺点是，我们无法通过这个来计算雷达实际扫描角度了，因为第一个点不一定是时间最早的点，如果第一根线前半部分被遮挡，那么你就会得到错误的计算角度，所以这时候，像我们这样直接强制把扫描角度设置成360度是更稳妥的，缺点就是它不够精确。</p>
<p>这个问题的原因应该是数据的二次加工导致的，kitti先把数据存成bin文件，kitti2bag再转成bag文件，改变了原来的排列方式。一般雷达驱动中输出的数据都是按列排列的。</p>
<p>所以如果各位以后使用的数据是列排列的，那么时间计算上可以使用loam里的方法，会更准确。</p>
<h1 id="定位流程"><a href="#定位流程" class="headerlink" title="定位流程"></a>定位流程</h1><p>在地图匹配的过程中，鲁棒性和运行速度特别重要，因此实际中，基于NDT的匹配使用更为广泛。由于NDT匹配需要较准确的初始位姿，因此在定位之前需要初始化环节，给出载体的初始位姿。<br>按照难度由低到高，常见的初始化需求有这样几种：</p>
<p>1）已知位姿的初始化<br>2）位置已知而姿态未知的初始化<br>3）位置和姿态均未知的初始化</p>
<p><img src="/images/点云地图的建立/image-20220504092212456.png" alt="image-20220504092212456" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>建图</tag>
        <tag>畸变补偿</tag>
      </tags>
  </entry>
  <entry>
    <title>后端位姿图优化</title>
    <url>/posts/aed03174.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="后端优化的基本原理"><a href="#后端优化的基本原理" class="headerlink" title="后端优化的基本原理"></a>后端优化的基本原理</h1><ul>
<li><strong>后端优化的目的：</strong></li>
</ul>
<p>利用回环检测结果和惯导先验位姿修正里程计误差，而回环在此提供的是两帧之间的相对位姿。</p>
<ul>
<li><strong>后端优化的方法：</strong></li>
</ul>
<p>假设马尔可夫性，简单的一阶马氏性认为，$k $时刻状态只与$ k − 1 $时刻状态有关，而与再之前的无关。如果做出这样的假设，我们就会得到以扩展卡尔曼滤波（EKF）为代表的滤波器方法。在滤波方法中，我们会从某时刻的状态估计，推导到下一个时刻。</p>
<p>另外一种方法是依然考虑 $k$ 时刻状态与之前所有状态的关系，此时将得到非线性优化为主体的优化框架。在视觉SLAM中非线性优化如BA与图优化、位姿图优化等。</p>
<ul>
<li><strong>总结而言，后端优化的观测主要从这三个方面：</strong></li>
</ul>
<p>①连续两帧之间的相对位姿观测（里程计）</p>
<p>②闭环匹配得到的相对位姿观测（闭环检测）</p>
<p>③组合导航提供的先验位姿估计（IMU）</p>
<p>①②的观测构成了<strong>基于回环的位姿修正</strong>，①③的观测构成了<strong>基于先验观测的位姿修正，</strong>当然三者也可以结合使用。三者的关系是，②③在①的基础上对位姿进行修正，这里对里程计的平滑性有一定的要求。</p>
<h1 id="基于回环的位姿修正"><a href="#基于回环的位姿修正" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h1><h2 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h2><p><img src="/images/后端位姿图优化/fc51f93b-322d-475b-bfa5-cae57a6750f9.jpeg" alt="回环检测是什么"></p>
<p>首先我们需要了解什么是回环检测，如是上图所示，对于里程计而言，它用来估计帧与帧之间的位姿估计，而这个位姿估计会因为噪声而产生漂移，（即使每一帧之间我们都进行了BA优化，但微小的漂移仍是无法避免的），由于里程计帧之间的位姿估计有很多，因此积少成多，漂移最终累积特别大，就会导致机器人在达到初始位置是，观测显示已经回到初始位置，而位姿估计却显示与初始位置相差一段距离，如上图所示。</p>
<p>我们通过构建位姿估计的位置和初始位置的残差项，对整个回环进行优化和修正，进而得到如下的地图。（理论而言，没有漂移的情况下，位姿估计的位置和初始位置是重合的。）</p>
<p><img src="/images/后端位姿图优化/32fa19ca-c057-4ccb-8075-802d0a456991.jpeg" alt="什么是回环检测"></p>
<p>因此，回环检测的目的就是消除累积误差。</p>
<h2 id="位姿图优化"><a href="#位姿图优化" class="headerlink" title="位姿图优化"></a>位姿图优化</h2><p>与之前的BA优化不同，比如我们之前学习的重投影模型，它考虑的是相邻帧之间的位姿估计，需要优化每个相机的位姿和特征点的位置，即使我们使用关键帧，对于大场景而言，特征点的观测是非常巨大的，这种计算量也是巨大的。</p>
<p>而位姿图优化，构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。</p>
<p><img src="/images/后端位姿图优化/image-20220503095925699.png" alt="image-20220503095925699" style="zoom:50%;" /></p>
<h2 id="基于回环的位姿修正-1"><a href="#基于回环的位姿修正-1" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h2><h3 id="构建残差"><a href="#构建残差" class="headerlink" title="构建残差"></a>构建残差</h3><p>在上文，我们找到如何构建残差项，下一步就是对残差项进行修正，那么我们就需要求得残差项对相应状态量的雅可比矩阵，从而才能知道从哪个方向修正状态量能够达到优化的目的。</p>
<p>位姿图优化关心的是两帧之间的观测，这两帧并不一定是相邻的两帧，比如回环检测中的两帧。设第$i$和第$j$帧之间的观测，在李群SE3上可以表示为：</p>
<script type="math/tex; mode=display">
\Delta T_{ij}=T_i^{-1}T_j.\tag{1}</script><p>很容易理解，如果说第$i$和第$j$帧构成回环，那么$T_i^{-1}T_j=I$，也就不存在误差。</p>
<p>也可以用李代数表示：</p>
<script type="math/tex; mode=display">
\Delta \xi_{ij}=\xi^{-1}_i◦\xi_j=\ln(T_i^{-1}T_j)^{\lor}.\tag{2}</script><p>构建残差：</p>
<script type="math/tex; mode=display">
\begin{align*}
e_{ij}&=\ln(\Delta T_{ij}^{-1}T_i^{-1}T_j)^{\lor}\\
&=\ln(\exp((-\xi_{ij})^{\land})\exp((-\xi_i)^{\land})\exp(\xi^{\land}_j))^{\lor}
\end{align*}.\tag{3}</script><p>位姿图优化的思想是通过调整状态量（即位姿），使残差项的值最小化，这就是需要用残差项求雅可比矩阵，才能使用梯度下降方法进行迭代优化。</p>
<h3 id="求雅可比矩阵"><a href="#求雅可比矩阵" class="headerlink" title="求雅可比矩阵"></a>求雅可比矩阵</h3><p>我们对位姿$T_i$和$T_j$分别左乘一个扰动$\Delta T=\exp(\delta\xi^{\land})$</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{e}_{ij}&=
\ln \left(
T_{ij}^{-1}T_i^{-1}
\exp((-\delta\xi_i)^{\land})
\exp(\delta\xi_j^{\land})T_j
\right)^{\lor}\\
&=\ln \left( T_{ij}^{-1}T_i^{-1}T_j
\exp\left(  (-Ad(T_j^{-1})\delta\xi_i)^{\land}  \right)
\exp\left(    (Ad(T_j^{-1})\delta\xi_j)^{\land} \right)
\right)^{\lor}\\
&\approx\ln \left( 
\exp(e_{ij})
\exp\left(
(-Ad(T_j^{-1})\delta\xi_i)^{\land}+(Ad(T_j^{-1})\delta\xi_j)^{\land}
\right)
\right)^{\lor}\\
&\approx e_{ij}-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\delta\xi_i+\mathcal{J}_r^{-1}Ad(T_j^{-1})\delta\xi_j
\end{align*}
\tag{4}</script><hr>
<p>这里推导过程的第一步到第二步利用了李群的伴随性质：</p>
<ul>
<li><strong>SO(3)上的伴随性质</strong></li>
</ul>
<script type="math/tex; mode=display">
R\exp(p^{\land})R^T=\exp((Rp)^{\land})\\</script><ul>
<li><strong>SE(3)上的伴随性质</strong></li>
</ul>
<script type="math/tex; mode=display">
T\exp(\xi^{\land})T^{-1}=\exp((Ad(T)\xi)^{\land})\\</script><p>其中伴随矩阵的定义如下：</p>
<script type="math/tex; mode=display">
Ad(T)=\begin{bmatrix}R&t^{\land}R\\ 0&R\end{bmatrix}</script><p>第二步第三步使用的是BCH公式：</p>
<ul>
<li><strong>SO(3)上的BCH公式</strong></li>
</ul>
<script type="math/tex; mode=display">
\ln(\exp(\phi_1^{\land})\exp(\phi_2^{\land}))\approx
\left\{
\begin{aligned}
J_l(\phi_2)^{-1}\phi_1+\phi_2\ ,\ 当\phi_1为小量 \\
J_r(\phi_1)^{-1}\phi_2+\phi_1\ ,\ 当\phi_2为小量
\end{aligned}
\right.</script><p>其中左乘雅可比为：</p>
<script type="math/tex; mode=display">
J_l=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})aa^T+\frac{1-\cos\theta}{\theta}a^{\land}</script><p>所以：</p>
<script type="math/tex; mode=display">
J_l^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})aa^T-\frac{\theta}{2}a^{\land}</script><p>右乘雅可比仅需要在左乘雅可比的基础上对自变量取负号，即：</p>
<script type="math/tex; mode=display">
J_r(\phi)=J_l(-\phi)</script><ul>
<li><strong>SE(3)上的BCH公式</strong></li>
</ul>
<script type="math/tex; mode=display">
\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx
\left\{
\begin{aligned}
J_l(\xi_2)^{-1}\xi_1+\xi_2\ ,\ 当\xi_1为小量 \\
J_r(\xi_1)^{-1}\xi_2+\xi_1\ ,\ 当\xi_2为小量
\end{aligned}
\right.</script><p>其中右乘雅可比为：</p>
<script type="math/tex; mode=display">
\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi^{\land}&\rho^{\land}\\0&\phi^{\land}\end{bmatrix}</script><p>一般情况下，若$\xi$非常小，该雅克比矩阵可以直接使用单位阵，此时：</p>
<script type="math/tex; mode=display">
\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\ln(\exp(\xi_1^{\land}+\xi_2^{\land}))^{\lor}</script><p>这里第二步到第三步的推导用的就是这个式子。</p>
<hr>
<p>所以，残差关于$T_i$的雅可比为：</p>
<script type="math/tex; mode=display">
A_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_i}=-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{5}</script><p>残差关于$T_j$的雅可比为：</p>
<script type="math/tex; mode=display">
B_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_j}=\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{6}</script><p>其中：</p>
<script type="math/tex; mode=display">
\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi_e^{\land}&\rho_e^{\land}\\0&\phi_e^{\land}\end{bmatrix}\tag{7}</script><p>为了找到梯度方向，需要对残差进行一阶泰勒展开：</p>
<script type="math/tex; mode=display">
\begin{align*}
&e_{ij}(x_i+\Delta x_i,x_j+\Delta x_j)\\
=&e_{ij}(x+\Delta x)\\
\approx&e_{ij}+J_{ij}\Delta x
\end{align*}\tag{8}</script><p>其中$J_{ij}$即为前面推导的残差关于位姿的雅可比组成的矩阵：</p>
<script type="math/tex; mode=display">
J_{ij}=(0···0\ A_{ij}\ 0···0 \ B_{ij} \ 0···0)</script><p>至此，我们就把非线性优化变成了一个线性化问题。</p>
<h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><p>位姿图优化就是把所有的观测和状态放在一起优化，在实际使用中，各个残差会被分配一个权重，也就是信息矩阵，它相当于对残差进行加权，考虑信息矩阵后，总的残差可以表示为:</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i,j\in \mathcal{C} }F_{ij}=\sum_{i,j\in \mathcal{C}} e_{ij}^T\Omega_{ij}e_{ij}\tag{9}</script><blockquote>
<p>权重矩阵又称为信息矩阵，它是协方差矩阵的逆，即为：$\Omega_{ij}=\Sigma_{ij}^{-1}$，因为每个残差都看作高斯分布，而每个高斯分布都可以归一化为标准的高斯分布$N(0,1)$，这种归一化操作是减去均值求平方然后除以方差。残差预期均值为0，所以不用减只需要除以方差，扩展到多维的话就变成了信息矩阵加权形式。</p>
</blockquote>
<p>所以此时的优化问题就是：</p>
<script type="math/tex; mode=display">
x^*=\arg\underset{x}{\min}\ F(x)\tag{10}</script><p>对于每一个残差块，都有：</p>
<script type="math/tex; mode=display">
\begin{align*}
&F_{ij}(x+\Delta x)\\
&=e_{ij}(x+\Delta x)^T\Omega_{ij}e_{ij}(x+\Delta x)\\
&\approx e_{ij}^T\Omega_{ij}e_{ij}+2e_{ij}^T\Omega_{ij}J_{ij}\Delta x+\Delta x^TJ_{ij}^T\Omega_{ij}J_{ij}\Delta x\\
&=c_{ij}+2b^T_{ij}\Delta x+\Delta x^TH_{ij}\Delta x
\end{align*}\tag{11}</script><p>其中：</p>
<script type="math/tex; mode=display">
c_{ij}=e_{ij}^T\Omega_{ij}e_{ij}</script><script type="math/tex; mode=display">
H^T_{ij}=J_{ij}^T\Omega_{ij}J_{ij}=
\begin{bmatrix}
··· & ··· & ··· & ··· \\
··· &A^T_{ij}\Omega_{ij}A_{ij}&···&A^T_{ij}\Omega_{ij}B_{ij}\\
··· & ··· & ··· & ··· \\
··· &B^T_{ij}\Omega_{ij}A_{ij}&···&B^T_{ij}\Omega_{ij}B_{ij}\\
··· & ··· & ··· & ··· \\
\end{bmatrix}</script><script type="math/tex; mode=display">
b_{ij}=e_{ij}^T\Omega_{ij}J_{ij}=
\begin{bmatrix} 
···\\A^T_{ij}\Omega_{ij}e_{ij}\\···\\B^T_{ij}\Omega_{ij}e_{ij}\\···
\end{bmatrix}</script><p>所以，要使得误差最小，只需要使得：</p>
<script type="math/tex; mode=display">
H\Delta x = -b\tag{11}</script><p>根据修正量，修正$x$的值，即完成依次迭代：</p>
<script type="math/tex; mode=display">
x^*=x+\Delta x\tag{12}</script><p>多次迭代，直至残差满足收敛条件时，则终止循环，完成优化。</p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>后端优化</tag>
        <tag>位姿图优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ScanContext解析与实践</title>
    <url>/posts/3df51dc4.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><strong>Scan Context</strong> 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在<strong>IROS</strong>(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><img src="/images/ScanContext解析与实践/1-16512834289741.gif" alt="1"></p>
<p>对于SLAM来说，回环检测是重要的一步，我们知道，当机器人做一个回环时，可能会出现已经达到达起始点，但是由于漂移，位姿估计值却显示当前位置和初始位置还有相差一段距离，这时候，我们就依赖回环检测，把当前位置拉回初始位置，这样就消除了漂移，这个过程就是回环检测的目的。</p>
<p>所以回环检测的关键是，对于某一帧点云来说，它经过一个历史状态之后，我们如何去索引当前帧是否在历史帧中出现过，即检测有没有发生回环。当然，最容易想到的也是最朴素的做法就是，将这一帧的3D点云与历史所有帧做匹配，找到最接近的那一个。但是对于3D点云来这么做计算量无疑是巨大的，而且三维匹配还存在一个初值的问题。</p>
<p>因此，作者提出了ScanContext，上面的动画可以看出ScanContext的工作过程就是把3D点云通过俯视图的方式转换为2D，然后用过2D匹配找到回环，达到回环检测的目的，这样将三维降为两维进行匹配大大减小了计算量，并且它对初值相对不敏感。</p>
<p>ScanContext的主要流程如下：</p>
<p><img src="/images/ScanContext解析与实践/image-20220430131549451.png" alt="image-20220430131549451" style="zoom: 50%;" /></p>
<h1 id="点云切割"><a href="#点云切割" class="headerlink" title="点云切割"></a>点云切割</h1><p>首先是进行点云分割，如下图所示:</p>
<p>首先使用来自 3D 扫描的点云的俯视图，以扫描的中心充当全局关键点。对点云的俯视图进行圆环分割和扇区分割，可以看出以扫描中心为关键点，向外扩散形成$N_r$个同心圆，我们称之为$N_r$个环。然后以中心为关键点对圆环的$[0,2\pi]$进行均匀分割，得到$N_s$ 个扇区。论文中取 $N_s= 60$ 和 $N_r = 20$。</p>
<p><img src="/images/ScanContext解析与实践/image-20220430133756320.png" alt="image-20220430133756320" style="zoom: 33%;" /></p>
<p><img src="/images/ScanContext解析与实践/image-20220430132509355.png" alt="image-20220430132509355"></p>
<p>可以发现，沿着半径增大的方向（绿色箭头的方向），把点云分割成了$N_r$个圆环，每个圆环的宽度为：</p>
<script type="math/tex; mode=display">
d_r=\frac{L_{max} }{N_r}\tag{1}</script><p>其中$L_{max}$表示激光雷达测得点云的最远距离。</p>
<p>通过图不难发现，我们一共得到$N_r$个环和$N_s$ 个扇区，每个环都与扇区有重叠区域，这个重叠区域称之为bin，而且远离传感器的 bin 的物理面积比近的 bin 更宽。设$\mathcal{P}_{ij}$是属于第$ i $个环和第 $j$ 个扇区重叠的 bin 的点集。设激光点经过分割后的集合为$\mathcal{P}$，则：</p>
<script type="math/tex; mode=display">
\mathcal{P}=\underset{i\in[N_r],j\in[N_s]}{\cup}\mathcal{P}_{ij}\tag{2}</script><p>其中，符号 $[N_s] =\{1, 2, …, N_{s-1}, N_s\},[N_r] =\{1, 2, …, N_{r-1}, N_r\}$。</p>
<h1 id="生成ScanContext"><a href="#生成ScanContext" class="headerlink" title="生成ScanContext"></a>生成ScanContext</h1><p>经过分割后，我们发现分割后的点云的集合就是bin的集合，而bin是$N_r$个环和$N_s$ 个扇区的重叠区域，每个bin区域可能会有点云也可能没有点云（图（b）中的蓝色像素），而我们将bin的集合表示为矩阵形式，就可以得到一个$N_r\times N_s$的矩阵，其中矩阵的每一行代表一个圆环，则一共有$N_r$行，所以下图纵坐标范围为$[0,L_{max}]$；矩阵的每一列代表一个扇区，则一共有$N_s$列，所以下图横坐标范围为$[0,2\pi]$。</p>
<p><img src="/images/ScanContext解析与实践/image-20220430135402491.png" alt="image-20220430135402491" style="zoom: 67%;" /></p>
<p>那么bin的值如何确定呢？我们知道，没有点云的bin，我们对其赋值为0，图中用蓝色像素表示；那么有点云的bin如何表示呢？作者在这里使用的是<strong>最大高度</strong>。</p>
<p>设某个点云为$p$， $z(\cdot ) $是返回点 $p$ 的$ z $坐标值的函数，则任一个点云集合bin的值为：</p>
<script type="math/tex; mode=display">
\phi(\mathcal{P}_{ij})=\underset{p\in\mathcal{P}_{ij}}{\max}z(p)\tag{3}</script><p>这么做有什么好处？我们知道，在开始我们把三维点云降为二维，损失了高度信息，而这里对高度信息相当于一次补偿作用，保留了信息的完整性。</p>
<h1 id="基于ScanContext的匹配"><a href="#基于ScanContext的匹配" class="headerlink" title="基于ScanContext的匹配"></a>基于ScanContext的匹配</h1><p>在得到ScanContext数据之后，我们如何利用ScanContext进行匹配，进而完成回环检测，这是ScanContext最终的目的。</p>
<p>设</p>
<ul>
<li><p>$I^q$为当前帧的ScanContext， $c^q_j $为$I^q$中的第$j$列；</p>
</li>
<li><p>$ I^c $为历史帧的ScanContext，$c^c_j $为$I^c$中的第$j$列；</p>
</li>
</ul>
<p>两帧之间的距离函数定义为：</p>
<script type="math/tex; mode=display">
d(I^q,I^c)=\frac{1}{N_s}\sum^{N_s}_{j=1}(1-\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}).\tag{4}</script><p>通过这个距离函数可以发现，它反应了两帧之间的差异性，对于相似的两帧，它们的相同列向量的内积的模应该为1，即$\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}=1$，则距离接近为0，当然这仅仅是理想情况下，实际上，我们通过设置阈值的方式，当距离函数小于某一个阈值时，认为该历史帧为回环检测的回环帧。</p>
<p><strong>但是这里存在一个问题，就是历史帧有旋转的时候：</strong></p>
<p>这里我们定义的是当前帧与历史帧的相同列进行比较，这个条件是十分强的，假设激光雷达在经过一个地方的时候方向与之前的方向恰恰相反，或者该地方为一个十字路口，激光雷达从不同的方向经过一个地方，则雷达相对于全局坐标的坐标会发生变化，导致得到的ScanContext中的列向量顺序可能发生变化，进而使得两帧的距离函数比较大，导致经过相同地方的两帧点云的距离函数非常大，最终回环检测匹配失败。</p>
<p>如下图所示，这是经过相同地方的两帧点云，它们由于激光雷达的朝向发生了改变，导致两者的ScanContext中的列向量顺序发生变化，距离函数值随之变得非常大。</p>
<p><img src="/images/ScanContext解析与实践/image-20220430143355265.png" alt="image-20220430143355265" style="zoom:50%;" /></p>
<p>不难发现，将图(b)后半部分切割放到前面，如下图所示，就可以得到与(a)十分相似的ScanContext.</p>
<p><img src="/images/ScanContext解析与实践/image-20220430143946603.png" alt="image-20220430143946603" style="zoom:50%;" /></p>
<p>对于人而言，上述规律是非常容易发现的。但是实际程序中怎么切割，怎么移动才能达到上述效果？</p>
<p>最简单也是最朴素的做法就是，将历史帧$I^c$按列平移，得到$[N_s]$个ScanContext，依次与当前帧的ScanContext计算距离，选择距离最小的，即为闭环匹配的帧。</p>
<p>但是这种方法的计算量也是相对较大的，作者在代码中对此方法进行了优化，优化方法就是将当前帧与历史帧对应列分别求列和，然后根据列和我们找到可能的最佳切割点，但是由于我们降维之后会损失一部分信息，因此我们寻找的切割点并不是足够准确的，所以我们将在切割点附近对对应的二维$m$列依次进行切割平移，得到远远小于$n(n&lt;&lt;[N_s])$个的ScanContext，依次与当前帧的ScanContext计算距离，选择距离最小的，即为闭环匹配的帧。</p>
<p><img src="/images/ScanContext解析与实践/image-20220430153440012.png" alt="image-20220430153440012" style="zoom: 67%;" /></p>
<h1 id="计算相对位姿"><a href="#计算相对位姿" class="headerlink" title="计算相对位姿"></a>计算相对位姿</h1><p>设$I^c_n$ 是一个$\mathrm{Scan Context}$，它的第$n$列是从原始的$\mathrm{Scan Context}$偏移过来的。由于列向量代表的是分辨率为$\frac{2\pi}{N_s}$的扇区，所以每个列对应的角度为$\frac{2\pi}{N_s}$。整个过程，把历史帧切割，然后进行列平移之后，得到与当前帧的良好匹配， 良好的匹配意味着我们通过分割平移将历史帧对应的位姿旋转到当前帧对应位姿的朝向，那么，反过来，我们可以根据平移来求得旋转的角度。</p>
<p>假设距离最小时，对应的列的平移量为：</p>
<script type="math/tex; mode=display">
n^*=\underset{n\in[N_s]}{\arg\min} \ d(I^q,I^c_n)\tag{5}</script><p>因此，历史帧与当前帧之间的旋转的角度为：</p>
<script type="math/tex; mode=display">
\phi=\frac{2\pi}{N_s}\times n^*\tag{6}</script><p>这个旋转分辨率在作者代码中为$\frac{2\pi}{N_s}=\frac{2\pi}{60}=6°$，所以匹配的精确度小于$6°$，这并不是一个精确的值，需要进一步精确的话则需要使用ICP或者NDT匹配。因此可以作为ICP或者NDT匹配的初始位姿，用于<strong>精确匹配</strong>得到闭环约束相对位姿。</p>
<h1 id="解决时间复杂度问题"><a href="#解决时间复杂度问题" class="headerlink" title="解决时间复杂度问题"></a>解决时间复杂度问题</h1><p><strong>目的：</strong>ScanContext可以使用矩阵对应列的相似度来计算两帧的相似性，但是遍历所有历史帧的相似度计算量比较高，需要做一个快速初步筛选。</p>
<p><strong>思路：</strong>相似帧之间，落在同等半径的圆环中的点的数量应该相似，可以用来快速查找。</p>
<p>比如，某一帧中，在圆环$r_i,i\in[N_r]$中，被$[N_s]$个扇区分割为$[N_s]$个bin，对于相似的两帧，对应圆环中，含有点云的bin占有率应该相同，如公式$(8)$。通过这种方法可以进行<strong>第一阶段的粗略匹配</strong>。</p>
<p><strong>方法：</strong></p>
<p><img src="/images/ScanContext解析与实践/image-20220430164906076.png" alt="image-20220430164906076" style="zoom:50%;" /></p>
<p>这里作者引入了一个$ring\ key$的概念。</p>
<p><strong>（1）每一帧生成一个向量$k$</strong></p>
<p>$ring\ key$实质上就是$\mathrm{Scan Context}$的每一行$r$经过编码函数$\psi$编码成一个实数值后，$N_r$个圆环组成了一个$N_r$维向量的$ring\ key$，即为</p>
<script type="math/tex; mode=display">
k=(\psi(r_1),...,\psi(r_{N_r})),\mathrm{where}\ \psi:r_i\rightarrow\mathbb{R}\tag{7}</script><p>其中，我们使用的环编码函数$\psi$是使用 $L_0$范数的环的占用率：</p>
<script type="math/tex; mode=display">
\psi(r_i)=\frac{\parallel r_i \parallel_0}{N_s}\tag{8}</script><p>$\parallel r_i \parallel_0$表示半径$r_i$对应的圆环中非空分割单元的个数。</p>
<p><strong>（2）根据（1）中计算的向量，所有历史帧共同构建KDtree;</strong></p>
<p><strong>（3）使用当前帧对应的向量，在KDtree中查找，找到$n$个可能的相似帧，作为候选索引$\mathcal{C}$ 。</strong></p>
<p><strong>（4）使用$\mathrm{Scan Context}$进行第二阶段的精确匹配</strong></p>
<p>虽然不如$\mathrm{Scan Context}$信息丰富，但$ring\ key$支持快速搜索，以找到$n$个可能的候选闭环。使用距离公式将这些恒定数量的候选$\mathrm{Scan Context}$与要查询的$\mathrm{Scan Context}$进行比较。最接近的满足给定阈值$\tau$ 的候选项被选为重新访问的位置：</p>
<script type="math/tex; mode=display">
c^*=\underset{c_k\in\mathcal{C} }{\arg\min}\ D(I^q,I^c),s.t. \ D<\tau\tag{9}</script><p>其中 $\mathcal{C}$ 是从 KD 树中提取的一组候选索引，$\tau$ 是给定的接受阈值。 $c^∗ $是确定为闭环的位置的索引。</p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
      <tags>
        <tag>ScanContext</tag>
        <tag>激光SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>ScanContext论文翻译</title>
    <url>/posts/79ac789e.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><strong>Scan Context</strong> 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在<strong>IROS</strong>(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="mathrm-Scan-Context-用于-3D-点云地图中地点识别的以自我为中心的空间描述子"><a href="#mathrm-Scan-Context-用于-3D-点云地图中地点识别的以自我为中心的空间描述子" class="headerlink" title="$\mathrm{Scan Context}$:用于 3D 点云地图中地点识别的以自我为中心的空间描述子"></a>$\mathrm{Scan Context}$:用于 3D 点云地图中地点识别的以自我为中心的空间描述子</h1><p><img src="/images/Scan-Context论文阅读/1-16512834289741.gif" alt="1"></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>与用于视觉场景的各种特征检测器和描述子相比，使用结构信息描述地点的研究相对较少。同时定位和建图 (SLAM) 的最新进展提供了环境的密集 3D 地图，并且定位是由不同的传感器提出的。针对基于结构信息的全局定位，我们提出了 $\mathrm{Scan Context}$，这是一种来自 3D 光检测和测距（激光雷达） (Light Detection and Ranging ，LiDAR) 扫描的基于非直方图的全局描述子。与先前研究的方法不同，所提出的方法直接从传感器记录可见空间的 3D 结构，而不依赖于直方图或先前的训练。此外，该方法提出了使用相似度分数来计算两个$\mathrm{Scan Context}$之间的距离，以及一种两阶段搜索算法来有效地检测回环。$\mathrm{Scan Context}$及其搜索算法使回环检测不受激光雷达视点变化的影响，从而可以在重新访问同一个地点和拐角等地方检测到闭环。$\mathrm{Scan Context}$性能已经通过 3D激光雷达扫描的各种基准数据集进行了评估，并且所提出的方法显示出充分改进的性能。</p>
<h1 id="Ⅰ-引言"><a href="#Ⅰ-引言" class="headerlink" title="Ⅰ.引言"></a>Ⅰ.引言</h1><p>在许多机器人应用中，位置识别是重要的问题。特别是对于 SLAM，这种识别为闭环提供了候选项，这对于纠正漂移误差和构建全局一致的地图至关重要 [1]。虽然闭环对机器人导航至关重要，但错误的匹配可能是灾难性的，需要仔细匹配。视觉识别随着相机传感器的广泛使用而流行，然而，由于光照变化和短期（例如，移动的物体）或长期（例如，季节）的变化，它本质上是困难的。因此，最近的文献集中在通过检查表示 [2] 和弹性后端 [3] 的鲁棒位置识别。</p>
<p>与这些视觉传感器不同，激光雷达最近因其对感知方差的强不变性而受到关注。早期，传统的局部关键点描述子 [4, 5, 6, 7] 最初是为计算机视觉中的 3D 模型设计的，尽管它们容易受到噪声的影响，但已被用于位置识别。基于激光雷达的位置识别方法已在机器人文献中广泛提出 [8, 9, 10]。这些工作侧重于从结构信息（例如点云）中以局部 [8] 和全局方式 [10] 开发描述子。</p>
<p>现有的基于 LiDAR 的位置识别方法一直试图克服两个问题。首先，无论视点变化如何，都需要描述子来实现旋转不变性。其次，噪声处理是这些空间描述子的另一个主题，因为点云的分辨率随距离而变化，并且法线是有噪声的。现有方法主要使用直方图[9,11,12]来解决上述两个问题。然而，由于直方图方法只提供场景的随机索引，描述场景的详细结构并不简单。这种限制使得描述子对于地点识别问题的可识别性降低，从而导致潜在的误匹配。</p>
<p><img src="/images/Scan-Context论文阅读/image-20220429164041335-16512834289762.png" alt="image-20220429164041335" style="zoom:50%;" /></p>
<p><img src="/images/Scan-Context论文阅读/image-20220429164059389-16512834289774.png" alt="image-20220429164059389" style="zoom:50%;" /></p>
<blockquote>
<p>图 1. 两步$\mathrm{Scan Context}$创建。使用来自 3D 扫描的点云的俯视图 (a)，我们将地面区域划分为 bin，根据方位角（在 LiDAR 框架内从 0 到 2π）和径向（从中心到最大感应范围）进行划分方向。我们将黄色区域称为一个环，将青色区域称为一个扇区，将黑色填充区域称为一个 bin。$\mathrm{Scan Context}$是（b）中的矩阵，它明确地保留了点云的绝对几何结构。 (a) 中描述的环和扇区在 (b) 中分别由相同颜色的列和行表示。从位于每个 bin 中的点中提取的代表值用作 (b) 的对应像素值。在本文中，我们使用 bin 中点的最大高度。</p>
</blockquote>
<p>在本文中，我们提出了 $\mathrm{Scan Context}$，这是一种具有匹配算法的新型空间描述子，专门针对使用单个 3D 扫描的户外地点识别。我们的表示将 3D 扫描中的整个点云编码为矩阵（图 1）。所提出的表示描述了以自我为中心的 2.5D 信息。该方法的贡献点是：</p>
<ul>
<li><strong>高效的 bin 编码功能。</strong>与现有的点云描述子 [7, 10] 不同，所提出的方法不需要计算 bin 中的点数，而是提出了一种更有效的用于位置识别的 bin 编码函数。这种编码对点云的密度和法线具有不变性。</li>
<li><strong>保留点云的内部结构。</strong>如图 1 所示，矩阵的每个元素值仅由属于 bin 的点云确定。因此，与将点的相对几何描述为直方图并丢失点的绝对位置信息的[9]不同，我们的方法通过有意避免使用直方图来保留点云的绝对内部结构。这提高了判别能力，还可以在计算距离时将查询扫描与候选扫描（在我们的实验中，6°方位角分辨率）进行视点对齐。因此，也可以通过使用$\mathrm{Scan Context}$来检测反向闭环。</li>
<li><strong>有效的两相匹配算法。</strong>为了实现可行的搜索时间，我们为第一个最近邻搜索提供了一个旋转不变的子描述子，并将其与成对相似度评分分层结合，从而避免搜索所有数据库进行闭环检测。</li>
<li><strong>针对其他最先进的空间描述子进行彻底验证。</strong>与其他现有的全局点云描述子相比，例如 M2DP [8]、形状函数集合 (ESF) [11] 和 Z 投影 [12]，所提出的方法具有实质性的改进。</li>
</ul>
<h1 id="Ⅱ-相关工作"><a href="#Ⅱ-相关工作" class="headerlink" title="Ⅱ.相关工作"></a>Ⅱ.相关工作</h1><p>移动机器人的位置识别方法可以分为基于视觉和基于激光雷达的方法。视觉方法已普遍用于 SLAM 文献中的地点识别 [13, 14, 15]。 FAB-MAP [13] 通过学习视觉词袋的生成模型，使用概率方法提高了鲁棒性。然而，视觉表示具有局限性，例如易受光照条件变化的影响[16]。已经提出了几种方法来克服这些问题。 SeqSLAM [17] 提出了基于道路的方法，并显示出比 FAB-MAP 大大提高的性能。 SRAL [2] 融合了几种不同的表示，例如颜色、GIST [18] 和 HOG [19]，用于长期视觉位置识别。</p>
<p>LiDAR 对上述这些感知变化具有很强的鲁棒性。基于 LiDAR 的方法被进一步分类为局部和全局描述子。局部描述子，例如 PFH [4]、SHOT [5]、shape context[7]或 spin image [6]，首先找到一个关键点，将附近的点分成 bin，并将周围 bin 的模式编码为直方图。Steder 等人提出了以词袋的方式利用点特征和完形描述子（gestalt descriptor） [20] 的位置识别方法[8]。</p>
<p>然而，这些关键点描述子显示出局限性，因为它们最初是为 3D 模型部分匹配而不是为位置识别而设计的。例如，与 3D 模型不同，3D 扫描（例如，来自 VLP-16）中的点云密度会随着与传感器的距离而变化。此外，由于现实世界中的非结构化对象（例如树），点的法线比模型噪声更大。因此，局部方法通常需要关键点的法线，因此不太适合户外的地点识别。</p>
<p>全局描述子不包括关键点检测阶段。 GLARE [9] 及其变体 [21, 22] 将点之间的几何关系编码为直方图，以代替搜索关键点和提取描述子。 ESF [11] 使用了由形状函数制成的直方图的串联。 Muhammad 和 Lacroix 提出了 Z 投影 [12]，它是法向量的直方图，以及具有两个距离函数的双阈值方案。Heet 等人提出了 M2DP [10]，它将扫描的整个 3D 点云投影到多个 2D 平面并提取 192 维紧凑的全局表示。M2DP 表现出比现有点云描述子更高的性能以及对噪声和分辨率变化的鲁棒性。如本段所述，全局描述子通常使用直方图。最近，SegMatch [23] 引入了一种基于分段的匹配算法。这是一种高级感知，但需要一个训练步骤，并且需要在全局参考框架中表示点。</p>
<p>在本文中，我们提出了一种新的位置描述子，称为$\mathrm{Scan Context}$，它将 3D 扫描的点云编码为矩阵。$\mathrm{Scan Context}$可以被认为是Shape Context [7] 的扩展，用于定位 3D LiDAR 扫描数据的位置识别。具体来说，$\mathrm{Scan Context}$包含三个组成部分：在每个 bin 中保留点云的绝对位置信息的表示、高效的 bin 编码函数和两步搜索算法。</p>
<h1 id="Ⅲ-mathrm-Scan-Context-进行地点识别"><a href="#Ⅲ-mathrm-Scan-Context-进行地点识别" class="headerlink" title="Ⅲ.$\mathrm{Scan Context}$进行地点识别"></a>Ⅲ.$\mathrm{Scan Context}$进行地点识别</h1><p>在本节中，我们描述了给定来自 3D 扫描的点云的$\mathrm{Scan Context}$创建，并提出了一种计算两个$\mathrm{Scan Context}$之间距离的度量。接下来，介绍两步搜索过程。使用$\mathrm{Scan Context}$进行位置识别的整体流程如图 2 所示。$\mathrm{Scan Context}$的创建和验证也可以在 scancontext.mp4 中找到。</p>
<h2 id="A-mathrm-Scan-Context"><a href="#A-mathrm-Scan-Context" class="headerlink" title="A.$\mathrm{Scan Context}$"></a>A.$\mathrm{Scan Context}$</h2><p>我们为户外地点识别定义了一个名为 $\mathrm{Scan Context}$ 的地点描述子。</p>
<p><img src="/images/Scan-Context论文阅读/image-20220429192701251-16512834289773.png" alt="image-20220429192701251" style="zoom: 50%;" /></p>
<blockquote>
<p>图 2. 算法概述。首先，将单个 3D 扫描中的点云编码到$\mathrm{Scan Context}$中。然后，从$\mathrm{Scan Context}$中对 $N_t$（环数）维向量进行编码，并用于检索最近的候选项以及 KD 树的构造。最后，将检索到的候选与查询$\mathrm{Scan Context}$进行比较。满足接受阈值并最接近查询的候选被认为是闭环。</p>
</blockquote>
<p>$\mathrm{Scan Context}$的关键思想受到 Belongie 等人提出的 Shape Context [7] 的启发，它将局部关键点周围的点云的几何形状编码为图像。然而他们的方法只是简单地计算点的数量来总结点的分布，我们的方法与他们的不同之处在于我们使用每个 bin 中点云的高度。使用高度的原因是为了有效地总结周围结构的垂直形状，而不需要大量的计算来分析点云的特征。此外，最大高度表示从传感器可以看到周围结构的哪一部分。这种以自我为中心的可视化在城市设计文献中一直是一个众所周知的概念，用于分析一个地方的身份[24, 25]。</p>
<p>与Shape Context [7] 类似，我们首先将 3D 扫描划分为传感器坐标中的方位角和径向 bin，但采用等间距的方式，如图 1(a) 所示。扫描的中心充当全局关键点，因此我们将$\mathrm{Scan Context}$称为以自我为中心的位置描述子。$N_s$ 和 $N_r$ 分别是扇区和环的数量。也就是说，如果我们将 LiDAR 传感器的最大感应范围设置为 $L_{max}$，则环之间的径向间隙为 $\frac{L_{max} }{N_r}$，扇形的中心角等于$\frac{2\pi}{N_s}$。在本文中，我们使用 $N_s= 60$ 和 $N_r = 20$。</p>
<p>因此，制作$\mathrm{Scan Context}$的第一个过程是将 3D 扫描的整个点划分为相互排斥的点云，如图 1(a) 所示。$\mathcal{P}_{ij}$是属于第$ i $个环和第 $j$ 个扇区重叠的 bin 的点集。符号 $[N_s]$ 等于$ \{1, 2, …, N_{s-1}, N_s\}$。因此，分区在数学上是</p>
<script type="math/tex; mode=display">
\mathcal{P}=\underset{i\in[N_r],j\in[N_s]}{\cup}\mathcal{P}_{ij}\tag{1}</script><p>因为点云是按固定间隔划分的，所以远离传感器的 bin 的物理面积比近的 bin 更宽。但是，两者都被同等地编码到$\mathrm{Scan Context}$的单个像素中。因此，$\mathrm{Scan Context}$补偿了由于远点稀疏导致的信息量不足，并将附近的动态对象视为稀疏噪声。</p>
<p>在点云分区之后，使用该 bin 中的点云为每个 bin 分配一个实数值：</p>
<script type="math/tex; mode=display">
\phi:\mathcal{P}_{ij}\rightarrow\mathbb{R}\tag{2}</script><p>我们使用最大高度，其灵感来自城市能见度分析 [24, 25]。因此，bin 编码函数为:</p>
<script type="math/tex; mode=display">
\phi(\mathcal{P}_{ij})=\underset{p\in\mathcal{P}_{ij}}{\max}z(p)\tag{3}</script><p>其中 $z(\cdot ) $是返回点 $p$ 的$ z $坐标值的函数。我们为空的bin分配零。例如，如图 1(b) 所示，$\mathrm{Scan Context}$中的蓝色像素意味着与其 bin 对应的空间是空闲的，或者由于遮挡而未观察到。</p>
<p>通过上述过程，最终将$\mathrm{Scan Context}$ $I$ 表示为$ N_r\times N_s$ 矩阵:</p>
<script type="math/tex; mode=display">
I=(a_{ij})\in\mathbb{R}^{N_r\times N_s},a_{ij}=\phi(\mathcal{P}_{ij})\tag{4}</script><p>为了对变换进行鲁棒的识别，我们通过$\mathit{ root\ shifting}$ 来增强 $\mathrm{Scan Context}$。通过这样做，在轻微运动扰动下从原始扫描中获取各种$\mathrm{Scan Context}$变得可行。</p>
<p>在重新访问到过的地方时，单个$\mathrm{Scan Context}$可能对平移运动下的扫描中心位置敏感。例如，当重新访问不同通道中的相同位置时，可能不会保留$\mathrm{Scan Context}$的行顺序。为了克服这种情况，我们根据水平间隔将原始点云转换为 $N_{trans}$ 个邻居（本文中使用$N_{trans}=8$  ），并将从这些$\mathit{ root\ shifting}$ 点云获得的$\mathrm{Scan Context}$存储在一起。我们假设即使在实际移动的位置也能获得类似的点云，这是有效的，除了少数情况下，比如一个新空间突然出现的交叉点。</p>
<h2 id="B-mathrm-Scan-Context-之间的相似度得分"><a href="#B-mathrm-Scan-Context-之间的相似度得分" class="headerlink" title="B. $\mathrm{Scan Context}$之间的相似度得分"></a>B. $\mathrm{Scan Context}$之间的相似度得分</h2><p>给定一个$\mathrm{Scan Context}$对，我们需要一个距离度量来衡量两个地方的相似性。$I^q$ 和$ I^c $分别是从查询点云和候选点云获取的$\mathrm{Scan Context}$。它们以列方式进行比较。也就是说，距离是同一索引处的列之间的距离之和。余弦距离用于计算相同索引处的两个列向量 $c^q_j $和 $c^c_j $之间的距离。此外，我们将总和除以总列数$N_s$用于归一化。因此，距离函数为:</p>
<script type="math/tex; mode=display">
d(I^q,I^c)=\frac{1}{N_s}\sum^{N_s}_{j=1}(1-\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}).\tag{5}</script><p>考虑到贯穿扇区的一致性，基于列的比较对动态物体特别有效。然而，候选$\mathrm{Scan Context}$的列甚至可以在相同的地方移动，因为激光雷达的视角对于不同的地方是不同的(例如，在相反的方向或角落重新访问一个地方)。图3说明了这种情况。由于$\mathrm{Scan Context}$是依赖于传感器位置的表示，因此行顺序始终是一致的。但是，如果 LiDAR 传感器相对于全局坐标的坐标发生变化，则列顺序可能会有所不同。</p>
<p><img src="/images/Scan-Context论文阅读/image-20220429201446582-16512834290096.png" alt="image-20220429201446582" style="zoom:50%;" /></p>
<blockquote>
<p>图 3. 具有时间间隔的同一地点的$\mathrm{Scan Context}$示例。重新访问时传感器视点的变化导致$\mathrm{Scan Context}$的列移位，如 (a) 所示。但是，这两个矩阵包含相似的形状并显示相同的行顺序。</p>
</blockquote>
<p>为了解决这个问题，我们使用所有可能的列移位后的$\mathrm{Scan Context}$来计算距离，并找到最小距离。$I^c_n$ 是一个$\mathrm{Scan Context}$，它的第$n$列是从原始的$\mathrm{Scan Context}$偏移过来的。这与以$\frac{2\pi}{N_s}$分辨率粗略对齐两个点云以获取旋转分量中的偏航角的任务相同。然后，我们确定最佳对齐的列移位数量$(7)$和对应的距离$(6)$:</p>
<script type="math/tex; mode=display">
\begin{align*}
D(I^q,I^c)&=\underset{n\in[N_s]}{\min}d(I^q,I^c_n),\tag{6}\\
n^*&=\underset{n\in[N_s]}{\arg\min}\ d(I^q,I^c_n),\tag{7}
\end{align*}</script><p>请注意，此附加移位信息可以作为进一步定位细化的良好初始值，例如迭代最近点 (ICP)，如第 IV-C 节所示。</p>
<h2 id="C-两阶段搜索算法"><a href="#C-两阶段搜索算法" class="headerlink" title="C. 两阶段搜索算法"></a>C. 两阶段搜索算法</h2><p>当在位置识别的ScanContext搜索时，有三个主要的典型工作流：成对相似性评分、最近邻搜索和稀疏优化[26]。我们的搜索算法将成对评分和最近邻搜索分层融合，以获得可接受的搜索时间。</p>
<p>由于我们在(6)中的距离计算比其他全局描述子如[12，10]更加耗时，我们通过引入ring key提供了一个两阶段分层搜索算法。Ring key是一个具有旋转不变性的描述子，它是从$\mathrm{Scan Context}$中提取的。$\mathrm{Scan Context}$的每一行，$r$，都通过环形编码函数$\psi$编码成一个实数值。矢量<strong>$k$</strong>的第一个元素来自距离传感器最近的环，随后的元素来自下一个环，如图4所示。因此，ring key成为一个 $N_r$ 维向量，如 (8)：</p>
<script type="math/tex; mode=display">
k=(\psi(r_1),...,\psi(r_{N_r})),\mathrm{where}\ \psi:r_i\rightarrow\mathbb{R}\tag{8}</script><p>我们使用的环编码函数$\psi$是使用 $L_0$范数的环的占用率：</p>
<script type="math/tex; mode=display">
\psi(r_i)=\frac{\parallel r_i \parallel_0}{N_s}\tag{9}</script><p>由于占用率与视点无关，因此ring key实现了旋转不变性。</p>
<p><img src="/images/Scan-Context论文阅读/image-20220429203142763-16512834290095.png" alt="image-20220429203142763" style="zoom:50%;" /></p>
<blockquote>
<p>图 4. 快速搜索的ring key生成。</p>
</blockquote>
<p>虽然不如$\mathrm{Scan Context}$信息丰富，但ring key支持快速搜索，以找到可能的候选闭环。向量$k$用作构建KD树的key。同时，要查询扫描的ring key用于查找相似的key及其对应的扫描索引。将被检索的相似key的数量由用户决定。使用距离(6)将这些恒定数量的候选$\mathrm{Scan Context}$与要查询的$\mathrm{Scan Context}$进行比较。最接近的满足给定阈值的候选项被选为重新访问的位置:</p>
<script type="math/tex; mode=display">
c^*=\underset{c_k\in\mathcal{C} }{\arg\min}\ D(I^q,I^c),s.t. \ D<\tau\tag{10}</script><p>其中 $\mathcal{C}$ 是从 KD 树中提取的一组候选索引，$\tau$ 是给定的接受阈值。 $c^∗ $是确定为闭环的位置的索引。</p>
<h1 id="Ⅳ-实验评估"><a href="#Ⅳ-实验评估" class="headerlink" title="Ⅳ.实验评估"></a>Ⅳ.实验评估</h1><p>略…….</p>
<h1 id="Ⅴ-结论"><a href="#Ⅴ-结论" class="headerlink" title="Ⅴ.结论"></a>Ⅴ.结论</h1><p>在这篇文章中，我们提出了一个空间描述子——$\mathrm{Scan Context}$，将一个地方概括为一个矩阵，这个矩阵明确描述了以自我为中心的环境的2.5D结构信息。与使用点云的现有全局描述子相比，$\mathrm{Scan Context}$在各种数据集上显示出更高的闭环检测性能。</p>
<p>在未来的工作中，我们计划通过引入额外的层来扩展$\mathrm{Scan Context}$。也就是说，其他bin编码函数(例如，bin的语义信息)可被用于提高性能，即使对于具有高度重复结构的数据集，如复杂城市激光雷达数据集。</p>
<p>Lidar定位：Scan Context<a href="https://zhuanlan.zhihu.com/p/359523177">https://zhuanlan.zhihu.com/p/359523177</a></p>
<p>Scan Context 介绍及理解<a href="https://zhuanlan.zhihu.com/p/393353116">https://zhuanlan.zhihu.com/p/393353116</a></p>
<p>从零开始做自动驾驶定位(二): 数据集<a href="https://zhuanlan.zhihu.com/p/104875159">https://zhuanlan.zhihu.com/p/104875159</a></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>ScanContext</tag>
        <tag>激光SLAM</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>前端里程计方案-基于直接匹配的ICP&amp;NDT</title>
    <url>/posts/eb43aafd.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文主要介绍两种基于直接匹配的前端里程计方案，ICP以及NDT，重点介绍公式推导以及代码实现。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a><a href="https://lukeyalvin.top/posts/12311.html">ICP</a></h1><p>ICP即迭代最近点$（Iterative\ Closest\  Point）$的实现以及公式推导在视觉SLAM中已经提及，并进行了相关的公式推导和代码实现，详细查看：<a href="https://lukeyalvin.top/posts/12311.html">求解ICP</a>，这里不做具体展示。</p>
<p><img src="/images/前端里程计方案-基于直接匹配/image-20220428161431509.png" alt="image-20220428161431509" style="zoom: 67%;" /></p>
<h1 id="经典NDT"><a href="#经典NDT" class="headerlink" title="经典NDT"></a>经典NDT</h1><p>由于ICP迭代法一般般需要提供一个较好的初值，也就是需要粗配准，最终可能导致迭代结果可能会陷入局部最优，导致配准失败，往往达不到我们想要的效果。目前，实际工程之中，大多数使用另一种比较好的配准算法，NDT配准。</p>
<p>所谓NDT就是正态分布变换，作用与ICP一样用来估计两个点云之间的刚体变换。NDT算法主要的思路就是<strong>将目标点云刻画成多个概率分布</strong>，然后通过位姿变换关系将待配准点云转换到目标点云坐标系下，计算转换后待配准点云的总概率，并将此概率的负值作为目标函数，通过高斯牛顿迭代法优化该目标函数以求获得负的最小概率值(即最大概率值)．</p>
<p>由于其在配准过程中<strong>不利用对应点的特征计算和匹配</strong>，所以时间比其他方法快。这个配准算法耗时稳定，跟初值相关不大，初值误差大时，也能很好的纠正过来。因此，NDT算法因其具有较强的鲁棒性而被广泛的应用。</p>
<p><img src="/images/前端里程计方案-基于直接匹配/image-20220428161900963.png" alt="image-20220428161900963" style="zoom: 50%;" /></p>
<center>NDT算法流程</center>

<p>对点云进行相应的预处理之后，我们将空间划分为栅格（2D图像中的正方形或3D中的立方体），并统计落在栅格中的点，如图所示</p>
<p><img src="/images/前端里程计方案-基于直接匹配/image-20220428170225779.png" alt="image-20220428170225779" style="zoom:50%;" /></p>
<p>同样的，我们设上一帧点集和当前点集分别为：</p>
<script type="math/tex; mode=display">
X=\{x_1,x_2,...,x_{N_x}\} \\
Y=\{y_1,y_2,...,y_{N_y}\}</script><p>求$X$的均值：</p>
<script type="math/tex; mode=display">
\mu=\frac{1}{N_x}\sum^{N_x}_{i=1}x_i</script><p>求$X$的协方差：</p>
<script type="math/tex; mode=display">
\Sigma=\frac{1}{N_x-1}\sum^{N_x}_{i=1}(x_i-\mu)(x_i-\mu)^T</script><p>根据预测的位姿$R,t$，对点进行旋转和平移，得到上一帧的点云投影到当前帧下的点云$y_i^{\prime}$：</p>
<script type="math/tex; mode=display">
y_i^{\prime}=T(p,y_i)=Ry_i+t</script><blockquote>
<p> 其中对于2D模型的点：$p=[t_x\ t_y\ \phi_z]^T$，对于3D模型的点：$p=[t_x\ t_y\ t_z\ \phi_x\ \phi_y\ \phi_z]^T$</p>
</blockquote>
<p>将当前点集$X$的均值$\mu$和协方差$\sum$，与投影点集$y_i^\prime$的每一个点做联系，构建如下的概率分布：</p>
<script type="math/tex; mode=display">
f(X,y_i^\prime)=\frac{1}{\sqrt{2\pi}\sqrt{|\Sigma|} }\exp(-\frac{(y_i^\prime-\mu)^T\Sigma^{-1}(y_i^\prime-\mu)}{2})\tag{1}</script><p>然后求所有点的<strong>联合概率分布：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
\Psi&=\prod_{i=1}^{N_y}f(X,y_i^\prime)\\
&=\prod_{i=1}^{N_y}\frac{1}{\sqrt{2\pi}\sqrt{|\Sigma|} }\exp(-\frac{(y_i^\prime-\mu)^T\Sigma^{-1}(y_i^\prime-\mu)}{2})
\end{align*}\tag{2}</script><p>取对数，简化问题：</p>
<script type="math/tex; mode=display">
\ln\Psi=\sum^{N_y}_{i=1}(-\frac{(y_i^\prime-\mu)^T\Sigma^{-1}(y_i^\prime-\mu)}{2}+\ln(\frac{1}{\sqrt{2\pi}\sqrt{|\Sigma|} }))\tag{3}</script><p>去除常数项：</p>
<script type="math/tex; mode=display">
\max\Psi=\max\ln\Psi=\min\Psi_1=\min\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)\tag{4}</script><p>所以我们的目标函数就变成了：$\min\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)$，而接下来的任务就是根据这个目标函数求得对应的参数$R,t$。</p>
<p>令：</p>
<script type="math/tex; mode=display">
\begin{align*}
e_i(p)&=y_i^\prime-\mu\\
F_i(p)&=\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)\\
&=e_i(p)^T\Sigma^{-1}e_i(p)
\end{align*}\tag{5}</script><p>因此目标函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\min\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)\\
&=\min\sum^{N_y}_{i=1}F_i(p)
\end{align*}\tag{6}</script><p>迭代优化，即找到$\Delta p$使得下式中的值达到最小：</p>
<script type="math/tex; mode=display">
\min\sum^{N_y}_{i=1}F_i(p+\Delta p)=\sum^{N_y}_{i=1}e_i(p+\Delta p)^T\Sigma^{-1}e_i(p+\Delta p)\tag{7}</script><p>其中对$e_i(p+\Delta p)$进行一阶泰勒展开：</p>
<script type="math/tex; mode=display">
\begin{align*}
e_i(p+\Delta p)&\approx e_i(p)+\frac{de_i}{dp}\Delta p\\
&=e_i(p)+J_i\Delta p
\end{align*}\tag{8}</script><p>故而：</p>
<script type="math/tex; mode=display">
\begin{align*}
F_i(p+\Delta p)&=e_i(p+\Delta p)^T\Sigma^{-1}e_i(p+\Delta p)\\
&\approx (e_i(p)+J_i\Delta p)^T\Sigma^{-1}(e_i(p)+J_i\Delta p)\\
&=e_i(p)^T\Sigma^{-1}e_i(p)+2e_i(p)^T\Sigma^{-1}J_i\Delta p+\Delta p^TJ_i^T\Sigma^{-1}J_i\Delta p\\
&=F_i(p)+2b_i^T\Delta p+\Delta p^TH_i\Delta p
\end{align*}\tag{9}</script><p>其中：</p>
<script type="math/tex; mode=display">
b_i^T=e_i(p)^T\Sigma^{-1}J_i，\ H_i=J_i^T\Sigma^{-1}J_i\tag{10}</script><p>因此，目标函数随自变量的变化为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta F_i(p)
&=F_i(p+\Delta p)-F_i(p)\\
&=2b_i^T\Delta p+\Delta p^TH_i\Delta p
\end{align*}\tag{11}</script><p>上述优化问题转换为：找到$\Delta p$使得$\Delta F_i(p)$取得极小值，令其导数为零：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{d\Delta F_i(p)}{d\Delta p}&=2b_i+2H_i\Delta p=0\\
即：H_i\Delta p&=-b_i
\end{align*}\tag{12}</script><p>根据$(10)$中的定义，只需要求$J_i$，即可求得$\Delta p $</p>
<script type="math/tex; mode=display">
J_i=\frac{de_i}{dp}</script><h2 id="2D场景"><a href="#2D场景" class="headerlink" title="2D场景"></a>2D场景</h2><p>已知对于2D场景$p=[t_x\ t_y\ \phi_z]^T$，</p>
<script type="math/tex; mode=display">
\begin{align*}
y_i^{\prime}&=T(p,y_i)\\
&=Ry_i+t\\
&=\begin{bmatrix}
\cos\phi_z&-\sin\phi_z\\
\sin\phi_z&\cos\phi_z
\end{bmatrix}y_i+\begin{bmatrix}t_x\\t_y\end{bmatrix}\\
e_i&=y_i^{\prime}-\mu
\end{align*}</script><p>雅可比矩阵：</p>
<script type="math/tex; mode=display">
J_i=\begin{bmatrix}
1&0&-y_{i1}\sin\phi_z-y_{i2}\cos\phi_z\\
0&1&y_{i1}\cos\phi_z-y_{i2}\sin\phi_z\end{bmatrix}</script><h2 id="3D场景"><a href="#3D场景" class="headerlink" title="3D场景"></a>3D场景</h2><p>已知对于3D场景$p=[t_x\ t_y\ t_z\ \phi_x\ \phi_y\ \phi_z]^T$，</p>
<script type="math/tex; mode=display">
\begin{align*}
y_i^{\prime}&=T(p,y_i)\\
&=Ry_i+t\\
&=R_xR_yR_zy_i+t\\
&=
\begin{bmatrix}
c_yc_z&-c_ys_z&s_y\\
c_xs_z+s_xs_yc_z&c_xc_z-s_xs_ys_z&-s_xc_y\\
s_xs_z-c_xs_yc_z&c_xs_ys_z+s_xc_z&c_xc_y
\end{bmatrix}y_i+\begin{bmatrix}t_x\\t_y\\t_z\end{bmatrix}\\
e_i&=y_i^{\prime}-\mu
\end{align*}</script><p>雅可比矩阵：</p>
<script type="math/tex; mode=display">
J_i=\begin{bmatrix}
1&0&0&0&c&f\\
0&1&0&a&d&g\\
0&0&1&b&e&h
\end{bmatrix}</script><p>其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
a&=y_{i1}(-s_xs_z+c_xs_yc_z)+y_{i2}(-s_xc_z-c_xs_ys_z)+y_{i3}(-c_xc_y)\\
b&=y_{i1}(c_xs_z+s_xs_yc_z)+y_{i2}(c_xc_z-s_xs_ys_z)+y_{i3}(-s_xc_y)\\
c&=y_{i1}(-s_yc_z)+y_{i2}(s_ys_z)+y_{i3}(c_y)\\
d&=y_{i1}(s_xc_yc_z)+y_{i2}(-s_xc_ys_z)+y_{i3}(s_xs_y)\\
e&=y_{i1}(-c_xc_yc_z)+y_{i2}(c_xc_ys_z)+y_{i3}(-c_xs_y)\\
f&=y_{i1}(-c_ys_z)+y_{i2}(-c_yc_z)\\
g&=y_{i1}(c_xc_z-s_xs_ys_z)+y_{i2}(-c_xs_z-s_xs_yc_z)\\
h&=y_{i1}(s_xc_z+c_xs_ys_z)+y_{i2}(c_xs_yc_z-s_xs_z)
\end{align*}</script><h1 id="其他NDT"><a href="#其他NDT" class="headerlink" title="其他NDT"></a>其他NDT</h1><p><img src="/images/前端里程计方案-基于直接匹配/image-20220428210054855.png" alt="image-20220428210054855" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>ICP</tag>
        <tag>NDT</tag>
      </tags>
  </entry>
  <entry>
    <title>LeGO-LOAM论文翻译</title>
    <url>/posts/3766cfd.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LeGO-LOAM是Tixiao Shan 和 Brendan Englot于2018年提出的使用激光雷达完成定位与三维建图的算法，全称为：Lightweight and Groud-Optimized Lidar Odometry and Mapping on Variable Terrain，从标题可以看出 LeGO-LOAM 为应对<strong>可变地面</strong>进行了地面优化，同时保证了轻量级。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块"><a href="#LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块" class="headerlink" title="LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块"></a>LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们提出了一种轻量级和基于地面优化的激光雷达里程计和建图方法 LeGO-LOAM，用于地面车辆的实时六自由度姿态估计。LeGO-LOAM 是轻量级的，因为它可以在低功耗嵌入式系统上实现实时姿态估计。LeGOLOAM 是基于地面优化的，因为它在其分割和优化步骤中利用了地平面的存在。我们首先应用点云分割来滤除噪声，并进行特征提取以获得独特的平面和边缘特征。然后，使用两步 Levenberg-Marquardt 优化方法，使用平面和边缘特征来解决连续扫描中六自由度变换的不同分量。我们使用地面车辆的可变地形环境中收集的数据集，将 LeGO-LOAM 的性能与最先进的方法 LOAM 进行比较，并表明 LeGO-LOAM 在降低计算成本的情况下实现了相似或更好的精度。我们还将 LeGO-LOAM 集成到 SLAM 框架中，以消除漂移引起的位姿估计误差，并使用 KITTI 数据集进行了测试。</p>
<h1 id="Ⅰ-介绍"><a href="#Ⅰ-介绍" class="headerlink" title="Ⅰ.介绍"></a>Ⅰ.介绍</h1><p>在智能机器人的能力中，地图构建和状态估计是最基本的先决条件。人们一直致力于通过基于视觉和基于激光雷达的方法实现实时 6 自由度同时定位和建图 (SLAM)。尽管基于视觉的方法在闭环检测方面具有优势，但由于它们对照明和视点变化的敏感性，如果用作唯一的导航传感器，可能会使这些能力不可靠。另一方面，基于激光雷达的方法即使在夜间也能发挥作用，而且许多 3D 激光雷达的高分辨率允许在大光圈下远距离捕捉环境的精细细节。因此，本文重点介绍使用 3D 激光雷达来支持实时状态估计和建图。</p>
<p>寻找两次激光雷达扫描之间转换的典型方法是迭代最近点 (ICP) [1]。通过逐点查找对应关系，ICP 迭代对齐两组点，直到满足停止条件为止。但是当扫描包括大量点时，ICP 可能会遭受过高的计算成本。已经提出了许多 ICP 变体来提高其效率和准确性 [2]。 [3] 引入了一种点到平面 ICP 变体，将点与局部平面补丁匹配。Generalized-ICP [4] 提出了一种匹配来自两次扫描的局部平面补丁的方法。此外，一些 ICP 变体利用并行计算来提高效率 [5]-[8]。</p>
<p>基于特征的匹配方法越来越受到关注，因为它们通过提取环境中的代表性特征来减少计算资源。这些特征应该适用于有效匹配和视角不变。这些特征应适用于有效匹配和视点不变性。社区已经提出了许多检测器，例如点特征直方图（PFH）[9] 和视点特征直方图（VFH）[10]，用于使用简单有效的技术从点云中提取此类特征。[11] 中介绍了一种使用 Kanade-Tomasi 角点检测器从点云中提取通用特征的方法。[12] 中讨论了从密集点云中提取线和平面特征的框架。</p>
<p>社区还提出了许多使用特征进行点云配准的算法。 [13] 和 [14] 提出了一种在局部集群中执行点曲率计算的关键点选择算法，然后使用选定的关键点进行匹配和位置识别。通过将点云投影到距离图像（a range image）上并分析深度值的二阶导数，[15] 从具有高曲率的点中选择特征进行匹配和位置识别。假设环境由平面组成，在[16]中提出了一种基于平面的配准算法。户外环境，例如森林，可能会限制这种方法的应用。 [17] 中介绍了一种专为Velodyne 激光雷达设计的项圈线段 (collar line segments, CLS) 方法。CLS 使用扫描的两个连续“环”中的点随机生成线。因此生成了两条线云并用于配准，然而，这种方法受到随机生成线条的挑战。 [18]中提出了一种基于分割的配准算法。SegMatch 首先将分割应用于点云，然后根据其特征值和形状直方图为每个段计算一个特征向量。随机森林用于匹配来自两次扫描的片段。虽然这种方法可以用于在线姿态估计，但它只能提供大约 1Hz 的定位更新。</p>
<p>在 [19] 和 [20] 中提出了一种低漂移和实时激光雷达里程计和建图(LOAM) 方法。 LOAM 执行点特征到边缘/平面扫描匹配以找到扫描之间的对应关系。通过计算其局部区域中点的曲率（roughness）值来提取特征。选择具有高曲率（roughness）值值的点作为边缘特征。类似地，具有低曲率（roughness）值的点被指定为平面特征。通过将估计问题新颖地划分为两个单独的算法来实现实时性能。一种算法以高频率运行并以低精度估计传感器速度，另一种算法运行频率较低，但可以以高精度获得运动估计。将这两个估计融合在一起以产生高频和高精度的单个运动估计。在 KITTI 里程计基准站点 [21] 上，通过仅使用激光雷达的估算方法，LOAM 的结果精度达到最佳[21]。</p>
<p>在这项工作中，我们为配备 3D 激光雷达的地面车辆寻求可靠、实时的六自由度姿态估计，其方式适合在小型嵌入式系统上有效实施。由于几个原因，这样的任务并不简单。由于尺寸有限，许多无人地面车辆 (UGV) 没有悬架或强大的计算单元。小型 UGV 在多变的地形上行驶时经常遇到非平稳运动，因此，获取的数据往往会带有运动畸变。由于在较大的运动下，只有有限的重叠区域，因此，在两次连续扫描之间也很难找到可靠的特征对应。此外，从 3D 激光雷达接收到的大量点对使用有限的车载计算资源进行实时处理提出了挑战。</p>
<p>当我们为此类任务实施 LOAM 时，当 UGV 以平滑运动具有稳定的特征运行并由足够的计算资源支持时，我们可以获得低漂移运动估计。但是，当资源有限时，LOAM 的性能会下降。由于需要计算密集 3D 点云中每个点的曲率（roughness）值，轻量级嵌入式系统上特征提取的更新频率无法始终跟上传感器更新频率。无人车在嘈杂环境中的运行也对 LOAM 提出了挑战。由于激光雷达的安装位置在小型 UGV 上通常靠近地面，因此来自地面的传感器噪声可能会持续存在。例如，从草地返回的范围可能会导致高曲率（roughness）值。因此，可能会从这些点中提取不可靠的边缘特征。类似地，边缘或平面特征也可以从树叶返回的点中提取。这些特征对于扫描匹配通常不可靠，因为在两次连续扫描中可能看不到相同的草叶或叶子。使用这些功能可能会导致不准确的配准和大的漂移。</p>
<p>因此，我们提出了一种轻量级和地面优化的 LOAM (LeGO-LOAM)，用于在具有可变地形的复杂环境中对 UGV 进行姿态估计。LeGO-LOAM 是轻量级的，因为可以在嵌入式系统上实现实时姿态估计和建图。执行点云分割以丢弃在地面分离后可能代表不可靠特征的点。LeGO-LOAM 也是地面优化的，因为我们为姿势估计引入了两步优化。在第一步中，从地面提取的平面特征用于获得 $[t_z, θ_{roll}, θ_{pitch}]$。在第二步中，通过匹配从分割点云中提取的边缘特征来获得其余的变换$[t_x, t_y, θ_{yaw}]$。我们还集成了执行闭环以纠正运动估计漂移的能力。本文的其余部分安排如下。第二节介绍了用于实验的硬件。第三节详细描述了所提出的方法。第四节介绍了一系列在各种户外环境中的实验。</p>
<h1 id="Ⅱ-系统硬件"><a href="#Ⅱ-系统硬件" class="headerlink" title="Ⅱ.系统硬件"></a>Ⅱ.系统硬件</h1><p>本文提出的框架使用从 Velodyne VLP-16 和 HDL-64E 3D 激光雷达收集的数据集进行了验证。VLP-16 的测量范围可达 $100m$，精度为$ ± 3cm$。它的垂直视野 (FOV) 为 $30°(±15°)$，水平视野 (FOV) 为$360°$。$16 $通道传感器提供 $2° $的垂直角分辨率。水平角分辨率根据旋转速率从 $0.1° $到$ 0.4°$ 变化。在整篇论文中，我们选择了 $10Hz $的扫描速率，它提供了$ 0.2° $的水平角分辨率。 HDL-64E（在这项工作中通过 KITTI 数据集进行了探索）也具有 $360° $的水平 FOV，但还有$ 48 $个通道。 HDL-64E 的垂直 FOV 为$ 26.9°$。</p>
<p>本文中使用的 UGV 是 Clearpath Jackal。它由$ 270 $瓦时锂电池供电，最大速度为$ 2.0m/s$，最大有效载荷为 $20kg$。 Jackal 还配备了低成本惯性测量单元 (IMU)，即 CH Robotics UM6 方向传感器。</p>
<p>提议的框架在两台计算机上得到验证：一台 Nvidia Jetson TX2 和一台配备 2.5GHz i74710MQ CPU 的笔记本电脑。Jetson TX2 是一款配备 ARM Cortex-A57 CPU 的嵌入式计算设备。选择笔记本电脑 CPU 以匹配 [19] 和 [20] 中使用的计算硬件。本文所示的实验仅使用这些系统的 CPU。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220426195127090.png" alt="image-20220426195127090" style="zoom: 50%;" /></p>
<blockquote>
<p>图 1：LeGO-LOAM 的硬件和系统概览</p>
</blockquote>
<h1 id="Ⅲ-轻型激光雷达测距和建图"><a href="#Ⅲ-轻型激光雷达测距和建图" class="headerlink" title="Ⅲ.轻型激光雷达测距和建图"></a>Ⅲ.轻型激光雷达测距和建图</h1><h2 id="A-系统概述"><a href="#A-系统概述" class="headerlink" title="A.系统概述"></a>A.系统概述</h2><p>所提出框架的概述如图 $1$ 所示。系统从 3D 激光雷达接收输入并输出 6 DOF 姿态估计。整个系统分为五个模块。第一个是分割，采用单次扫描的点云并将其投影到范围图像上进行分割。然后将分割后的点云发送到特征提取模块。然后，激光雷达里程计使用从前一个模块中提取的特征来找到与连续扫描相关的变换。这些特征在激光雷达建图中得到进一步处理，将它们注册到全局点云地图。最后，变换积分模块将激光雷达里程计和激光雷达建图的姿态估计结果进行融合，输出最终的姿态估计。相对于 [19] 和 [20] 的原始通用 LOAM 框架，所提出的系统旨在提高地面车辆的效率和准确性。下面介绍这些模块的详细信息。</p>
<h2 id="B-分割"><a href="#B-分割" class="headerlink" title="B. 分割"></a>B. 分割</h2><p>令$ P_t = \{p_1, p_2, …, p_n\} $为在时间 $t $获取的点云，其中$p_i$ 是 $P_t $中的一个点。$ P_t$ 首先投影到范围图像上。投影距离图像的分辨率为 $1800 \times 16$，因为 VLP-16 的水平和垂直角分辨率分别为 $0.2° $和$ 2°$。$ P_t$ 中的每个有效点 $p_i$现在由范围图像中的唯一像素表示。与 $p_i$关联的范围值$r_i$表示从对应点 $p_i$到传感器的欧氏距离。由于斜坡地形在许多环境中都很常见，因此我们不认为地面是平坦的。在分割之前，对距离图像进行列式评估（可视为地平面估计 [22]），以提取地面点。在此过程之后，可能代表地面的点被标记为地面点，不用于后续分割（分类）。</p>
<p>然后，将基于图像的分割方法[23]应用于范围图像，将点分组为许多簇。来自同一簇的点被分配了一个唯一的标签。请注意，地面点是一种特殊类型的集群。将分割应用于点云可以提高处理效率和特征提取精度。假设机器人在嘈杂的环境中运行，小物体（例如树叶）可能会形成微不足道且不可靠的特征，因为在两次连续扫描中不太可能看到相同的叶子。为了使用分段点云进行快速可靠的特征提取，我们省略了少于 30 个点的集群。分割前后点云的可视化如图 2 所示。原始点云包含许多点，这些点是从周围的植被中获得的，这些点可能会产生不可靠的特征。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220426194420416.png" alt="image-20220426194420416" style="zoom: 67%;" /></p>
<blockquote>
<p>图 2：噪声环境中扫描的特征提取过程。原始点云如$(a)$所示。在$(b)$中，红点被标记为地面点，其余的点是分割后剩下的点。在$(c)$中，蓝色和黄色点表示 $F_e$ 和 $F_p$ 中的边缘和平面特征。在 $(d)$中，绿色和粉色点分别代表 $\mathbb{F}_e$ 和 $\mathbb{F}_p$ 中的边缘和平面特征。</p>
</blockquote>
<p>在这个过程之后，只有可能代表大物体的点（图$2(b)$ ）被保留下来，例如树干和地面点，以供进一步处理。同时，只有这些点保存在距离图像中。我们还获得每个点的三个属性：$(1) $其作为地面点或分割点的标签，$(2) $其在范围图像中的列和行索引，以及 $(3)$ 其范围值。这些属性将在以下模块中使用。</p>
<h2 id="C-特征提取"><a href="#C-特征提取" class="headerlink" title="C.特征提取"></a>C.特征提取</h2><p>特征提取过程类似于[20]中使用的方法。然而，我们不是从原始点云中提取特征，而是从地面点和分割点中提取特征。令 $S$ 为范围图像同一行中 $p_i$ 的连续点的集合。 $S$ 中的一半点位于 $p_i$ 的两侧。在本文中，我们设置 $|S|$设置为 $10$。 使用分割期间计算的范围值，我们可以评估点 $p_i$在$S$中的曲率（roughness）值，</p>
<script type="math/tex; mode=display">
c=\frac{1}{|S|\cdot\parallel r_i \parallel} \parallel \underset{j\in S,j\ne i}{\sum}(r_j-r_i) \parallel \tag{1}</script><p>为了从各个方向均匀地提取特征，我们将距离图像水平划分为几个相等的子图像。然后我们根据它们的曲率（roughness）值$ c $，对子图像的每一行中的点进行排序。与 LOAM 类似，我们使用阈值$ c_{th}$来区分不同类型的特征。我们称$c$大于$ c_{th}$为边缘特征的点，$c$小于$ c_{th}$为平面特征的点。</p>
<p>然后从子图像的每一行中选取<strong>不属于地面</strong>，且有最大<code>c</code>值的$n_{\mathbb{F}_e}$个特征边。以相同方式选择具有最小$c$值的$n_{\mathbb{F}_p}$平面特征点（可以标记为地面点或分段点）。设 $\mathbb{F}_e$ 和$\mathbb{F}_p$是所有子图像的所有边缘和平面特征的集合，这些特征如图 $2(d)$所示。然后，我们从子图像的每一行中提取<strong>不属于地面</strong>的具有最大$c$的$n_{F_e}$个边缘特征。类似地，我们从子图像的每一行中提取<strong>必须是地面点</strong>的具有最小$c$的 $n_{F_p} $个平面特征。设$ F_e$ 和 $F_p$ 分别是这个过程中所有边缘和平面特征的集合。在这里，我们有 $F_e\subset  \mathbb{F}_e$和 $F_p \subset \mathbb{F}_p$。$ F_e$ 和 $F_p$ 的特征如图$ 2(c)$ 所示。在本文中，我们将 $360° $范围图像划分为 $6 $个子图像。每个子图像的分辨率为 $300 \times 16$。$n_{F_e}、n_{F_p}、n_{\mathbb{F}_e} $和$n_{\mathbb{F}_p}$ 分别选择为 $2、4、40$ 和 $80$。</p>
<h2 id="D-激光雷达里程计"><a href="#D-激光雷达里程计" class="headerlink" title="D.激光雷达里程计"></a>D.激光雷达里程计</h2><p>激光雷达里程计模块估计两次连续扫描之间的传感器运动。通过执行点到边缘和点到平面的扫描匹配来找到两次扫描之间的变换。换句话说，我们需要从前一次扫描的特征集 $\mathbb{F}^{t-1}_e$ 和$\mathbb{F}^{t-1}_p$ 中找到 $F^t_e$和 $F^t_p$中点的对应特征。为了简洁起见，找到这些对应关系的详细过程可以在[20]中找到。</p>
<p>但是，我们注意到可以进行一些更改以提高特征匹配的准确性和效率：</p>
<p>$1) $标签匹配：由于$F^t_e$和 $F^t_p$中的每个特征在分割后都用其标签进行编码，我们只能从 $\mathbb{F}^{t-1}_e$ 和$\mathbb{F}^{t-1}_p$中找到具有相同标签的对应关系。对于 $F^t_p$ 中的平面特征，只有在$\mathbb{F}^{t-1}_p$中标记为地面点的点才会被用于寻找对应的平面贴片(patch)。对于$F^t_e$中的边缘特征，在分割簇的$\mathbb{F}^{t-1}_e$中寻找对应的边缘线。以这种方式找到对应关系有助于提高匹配精度。换句话说，同一对象的匹配对应关系更有可能在两次扫描之间找到。这一过程也缩小了潜在匹配对象的范围。</p>
<p>$2)$两步L-M优化：在[20]中，将当前扫描的边缘和平面特征点之间的距离及其与前一次扫描的对应关系的一系列非线性表达式编译为单个综合距离向量。应用 Levenberg-Marquardt (L-M) 方法来找到两个连续扫描之间的最小距离变换。</p>
<p>我们在这里介绍一种两步 L-M 优化方法。最佳变换 $T $分两步找到：</p>
<p>$(1)$ 通过匹配$F^t_p$中的平面特征及其在 $\mathbb{F}^{t-1}_p$ 中的对应关系来估计$ [t_z, θ_{roll}, θ_{pitch}]$</p>
<p>$(2) $然后使用 $F^t_e$中的边缘特征及其在 $\mathbb{F}^{t-1}_e$ 中的对应关系，并同时使用 $[t_z, θ_{roll}, θ_{pitch}]$ 作为约束一起来估计剩余的 $[t_x, t_y, θ_{yaw}]$。需要注意的是，虽然$[t_x, t_y, θ_{yaw}]$也可以从第一个优化步骤中获得，但它们的准确度较低，得到的结果也不能继续放在第二步中使用。最后，通过融合 $[t_z, θ_{roll}, θ_{pitch}]$ 和$[t_x, t_y, θ_{yaw}]$找到两个连续扫描之间的$ 6D$ 变换。通过使用所提出的两步优化方法，我们观察到在计算时间减少约 $35\% $的同时可以实现类似的精度（表 III）。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427165436363.png" alt="image-20220427165436363" style="zoom: 33%;" /></p>
<blockquote>
<p>图 3：激光雷达里程计模块的两步优化。首先通过匹配从地面点提取的平面特征来获得$[t_z, θ_{roll}, θ_{pitch}]$。 然后使用从分割点提取的边缘特征进行估计，同时应用$[t_z, θ_{roll}, θ_{pitch}]$作为约束，从而获得$[t_x, t_y, θ_{yaw}]$</p>
</blockquote>
<h2 id="E-激光雷达建图"><a href="#E-激光雷达建图" class="headerlink" title="E. 激光雷达建图"></a>E. 激光雷达建图</h2><p>激光雷达建图模块运行频率较低，它将$\{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$中的特征与周围的点云图 $\overline Q^{t-1}$匹配，以进一步细化位姿变换，然后这里再次使用 L-M 方法得到最终的变换。我们请读者参考 [20] 中的描述，了解详细的匹配和优化过程。 LeGO-LOAM 的主要区别在于最终点云图的存储方式。我们不是保存单个点云图，而是保存每个单独的特征集$ \{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$。令 $M^{t−1} = \{\{\mathbb{F}^{1}_e, \mathbb{F}^{1}_p\}, …, \{\mathbb{F}^{t-1}_e, \mathbb{F}^{t-1}_p\}\} $是保存所有先前特征集的集合。 $M^{t−1}$中的每个特征集也与扫描时传感器的位姿相关联。那么 $\overline Q^{t-1}$可以通过两种方式从$M^{t−1}$获得。</p>
<p>在第一种方法中，通过选择传感器视野中的特征集来获得 $\overline Q^{t-1}$。为简单起见，我们可以选择传感器位姿在传感器当前位置 $100m$ 以内的特征集。然后将所选特征集转换并融合到单个周围地图$\overline Q^{t-1}$中。这种地图选择技术类似于[20]中使用的方法。</p>
<p>我们还可以将位姿图 SLAM 集成到 LeGO-LOAM 中。每个特征集的传感器位姿可以建模为位姿图中的一个节点。特征集$ \{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$可以看作是该节点的传感器测量数据。由于激光雷达建图模块的位姿估计漂移非常低，我们可以假设在短时间内没有漂移。这样，$\overline Q^{t-1}$可以通过选择最近的一组特征集来形成，即 $\overline Q^{t-1}= \{\{\mathbb{F}^{t-k}_e, \mathbb{F}^{t-k}_p\}, …, \{\mathbb{F}^{t-1}_e, \mathbb{F}^{t-1}_p\}\} $ ，其中$ k $定义了$\overline Q^{t-1}$的大小。然后，可以使用 L-M 优化后获得的变换添加$\overline Q^{t-1}$​中新节点和所选节点之间的空间约束。我们可以通过执行闭环检测来进一步消除该模块的漂移，在这种情况下，如果使用 ICP 在当前特征集和先前特征集之间找到匹配项，则会添加新约束。然后通过将位姿图发送到优化系统（例如 [24]）来更新传感器的估计位姿。请注意，只有 Sec 中的实验。 IV(D) 使用这种技术来创建它的周围地图。注意，只有第四节（D）中的实验使用此技术来创建其周围的地图。</p>
<h1 id="Ⅳ-实验"><a href="#Ⅳ-实验" class="headerlink" title="Ⅳ.实验"></a>Ⅳ.实验</h1><p>我们现在描述一系列实验，以定性和定量分析两种比较方法，LOAM 和 LeGO-LOAM，在两种硬件安排上，一个 Jetson TX2 和一个 Cortex-A57，一个笔记本电脑和一个 i7-4710MQ。这两种算法都是用 C++ 实现的，并使用 Ubuntu Linux1 中的机器人操作系统 (ROS) [25] 执行$^1$。</p>
<blockquote>
<p>$^1$LeGO-LOAM 的代码可在 <a href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">https://github.com/RobustFieldAutonomyLab/LeGO-LOAM</a> 获得</p>
</blockquote>
<h2 id="A-小型-UGV-测试"><a href="#A-小型-UGV-测试" class="headerlink" title="A. 小型 UGV 测试"></a>A. 小型 UGV 测试</h2><p>我们在植被覆盖的室外环境中手动驱动机器人。我们首先展示了在这种环境下特征提取的定性比较。使用这两种方法从同一扫描中提取的边缘和平面特征如图 4 所示。这些特征对应于第 III 节中发送到激光雷达建图模块的$\{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$。如图$4(d)$ 所示，LeGO-LOAM 的特征数量在点云分割后大大减少。从树叶返回的大部分点被丢弃，因为它们在多次扫描中不是稳定的特征。另一方面，由于从草地返回的点也非常嘈杂，因此在评估后会得出较大的粗曲率值。因此，使用原始 的LOAM， 不可避免地会从这些点中提取边缘特征。如图$4(c)$ 所示，从地面提取的边缘特征通常不可靠。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427090416034.png" alt="image-20220427090416034" style="zoom: 80%;" /></p>
<blockquote>
<p>图 4：在植被覆盖的室外环境中，从两种不同的激光雷达里程计和制图框架获得的边缘和平面特征。边缘和平面特征分别为绿色和粉红色。从 LOAM 获得的特征显示在$ (b) $和$ (c) $中。从 LeGO-LOAM 获得的特征如 $(d) $和$ (e)$ 所示。标签 (i) 表示树，(ii) 表示石墙， (iii) 表示机器人。</p>
</blockquote>
<p>虽然我们可以更改 LOAM 中提取边缘和平面特征的曲率阈值 $c_{th}$ 以减少特征数量并从草和树叶中过滤掉不稳定的特征，但在应用这些更改后我们会遇到更糟糕的结果。例如，我们可以增加$c_{th}$以从环境中提取更稳定的边缘特征，但如果机器人进入相对干净的环境，这种变化可能会导致有用的边缘特征数量不足。同样，当机器人从清洁环境移动到嘈杂环境时，减小$c_{th}$也会导致缺乏有用的平面特征。在这里的所有实验中，我们对 LOAM 和 LeGO-LOAM 使用相同的$c_{th}$。</p>
<p>现在我们在测试环境中比较两种方法的建图结果。为了模拟具有挑战性的潜在 UGV 操作场景，我们执行了一系列激进的偏航操作。请注意，在本文的所有实验中，这两种方法都提供了相同的初始平移和旋转估计（guess），该估计（guess）是从 IMU 获得的。运行60秒后得到的点云图如图5所示。由于不稳定特征导致的错误特征关联，LOAM 的地图在操作过程中会发散两次。图 $5(a)$中用白色箭头突出显示的三棵树干代表现实中的同一棵树。两种里程计方法的完整映射过程的可视化可以在视频附件中找到$^2$。</p>
<blockquote>
<p>$^2$<a href="https://youtu.be/O3tz_ftHV48">https://youtu.be/O3tz_ftHV48</a></p>
</blockquote>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427090607185.png" alt="image-20220427090607185" style="zoom:80%;" /></p>
<blockquote>
<p>图 5：LOAM 和 LeGO-LOAM 在图 $4(a) $所示地形上的地图。 $(a) $中用白色箭头标记的树代表同一棵树。</p>
</blockquote>
<h2 id="B-大规模-UGV-测试"><a href="#B-大规模-UGV-测试" class="headerlink" title="B. 大规模 UGV 测试"></a>B. 大规模 UGV 测试</h2><p>接下来，我们在三个大规模数据集上对 LOAM 和 LeGO-LOAM 进行定量比较，这将被称为实验$ 1、2 $和$ 3$。前两个是在史蒂文斯理工学院校园收集的，那里有许多建筑物、树木、道路和人行道。这些实验及其环境如图 6(a) 所示。实验 3 跨越了一条森林覆盖的远足小径，其中有树木、柏油路和被草和土壤覆盖的小径。执行实验 3 的环境如图 8 所示。每个实验的详细信息列在表 I 中。为了进行公平比较，每个实验显示的所有性能和准确度结果均在每个数据集的 10 次实时回放试验中平均得出。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427102855741.png" alt="image-20220427102855741" style="zoom: 50%;" /></p>
<p>1)实验1：第一个实验旨在证明LOAM和LeGO-LOAM都可以在具有平滑运动的城市环境中实现低漂移姿态估计。我们避免了激进的偏航动作，并且我们避免驾驶机器人穿过只能获得一些稳定特征的稀疏区域。在整个数据记录过程中，机器人在平坦的道路上运行。机器人的初始位置，如图6(b)所示，位于斜坡上。机器人以平均 1.35m/s 的平均速度行驶 807 秒后返回同一位置。</p>
<p>为了评估这两种方法的姿态估计精度，我们比较了最终姿态和初始姿态之间的平移和旋转差异。这里，通过所有实验，初始位姿定义为$ [0, 0, 0, 0, 0, 0]$。如表 V 所示，LOAM 和 LeGO-LOAM 在两种不同的硬件安排上都实现了相似的低漂移姿态估计。当在 Jetson 上运行时，来自 LeGO-LOAM 的最终地图如图 6(b) 所示。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427101541012.png" alt="image-20220427101541012"></p>
<blockquote>
<p>图 6：实验$1$和$2$的 LeGO-LOAM 图。$(c)$中的颜色变化表示真实的高程变化。由于实验 $1$ 中机器人的初始位置在斜坡上，因此 $(b)$ 中的颜色变化并不代表真实的高程变化。</p>
</blockquote>
<p>2)实验2：虽然实验2是在与实验1相同的环境中进行的，但它的轨迹略有不同，行驶在如图7(a)所示的人行道上。这条人行道代表了 LOAM 可能经常失败的环境。人行道的一端有一堵墙和柱子——从这些结构中提取的边缘和平面特征是稳定的。人行道的另一端是一片开阔的区域，上面覆盖着嘈杂的物体，即草和树，这将导致特征提取不可靠。因此，LOAM 的姿态估计在驶过这条人行道后会发散（图 7(b)和(d)）。LeGO-LOAM 没有这样的问题：1）没有从被草覆盖的地面中提取边缘特征，2）在分割后过滤掉来自树叶的噪声传感器读数。两种方法的精度比较如表 V 所示。在本实验中，LeGO-LOAM 的精度比 LOAM 高一个数量级。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427101616762.png" alt="image-20220427101616762"></p>
<blockquote>
<p>图 $7$：实验$ 2 $中 LOAM 在穿过史蒂文斯校园的人行道上发生故障的场景（上图 $(a)$ 中最左侧的人行道）。人行道的一端由附近建筑物的特征支撑。人行道的另一端主要被嘈杂的物体包围，即草和树。如果没有点云分割，将从这些对象中提取不可靠的边缘和平面特征。图像 $(b)$ 和 $(d)$ 显示 LOAM 在经过人行道后失效。</p>
</blockquote>
<p>3)实验 3：实验 3 的数据集是从森林远足小径记录的，其中 UGV 以 1.3m/s 的平均速度行驶。机器人行驶 35 分钟后返回初始位置。这种环境下的海拔变化约为 19 米。UGV 在三个路面上行驶：泥土覆盖的小径、沥青和被草覆盖的地面。这些表面的代表性图像分别显示在图 8 的底部。树木或灌木丛始终存在于道路的至少一侧。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427101634370.png" alt="image-20220427101634370" style="zoom:67%;" /></p>
<blockquote>
<p>图 8：实验$3$ LeGO-LOAM 建图结果。</p>
</blockquote>
<p>我们首先在这种环境下测试 LOAM 的准确性。生成的地图在所使用的两台计算机上的不同位置存在分歧。相对于 UGV 初始位置的最终平移和旋转误差在 Jetson 上为 69.40m 和 27.38°，在笔记本电脑上为 62.11m 和 8.50°。图 9(a) 和 (b) 显示了对两种硬件安排进行 10 次试验的结果轨迹。</p>
<p>当 LeGO-LOAM 应用于该数据集时，Jetson 上的最终相对平移和旋转误差为 13.93m 和 7.73°，笔记本电脑上为 14.87m 和 7.96°。 Jetson 上 LeGO-LOAM 的最终点云图如图 8 所示，叠加在卫星图像上。在图 8 的中心放大的局部地图显示，来自 LeGO-LOAM 的点云图与开放中可见的三棵树匹配得很好。在两台计算机上从 LeGO-LOAM 获得的所有路径之间显示出高度一致性。图 9(c) 和 (d) 显示了在每台计算机上运行的十次试验。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427103924914.png" alt="image-20220427103924914" style="zoom:50%;" /></p>
<blockquote>
<p>图 9：LOAM 和 LeGO-LOAM 在 10 次试验和 2 台计算机上生成的路径，以及实验 3 数据集。</p>
</blockquote>
<h2 id="C-基准测试结果"><a href="#C-基准测试结果" class="headerlink" title="C. 基准测试结果"></a>C. 基准测试结果</h2><p><strong>1)特征数量比较</strong>：我们在表II中展示了两种方法的特征提取比较。每次扫描的特征内容平均超过每个数据集的 10 次试验。点云分割后，对于集合$ F_e、F_p、\mathbb{F}_e $和$\mathbb{F}_p$，需要 LeGO-LOAM 处理的特征数量分别减少了至少$ 29\%、40\%、68\%$ 和 $72\%$。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427105750858.png" alt="image-20220427105750858" style="zoom:50%;" /></p>
<p><strong>2)迭代次数比较：</strong>应用提出的两步L-M优化方法的结果如表III所示。我们首先使用 LeGO-LOAM 应用原始 L-M 优化，这意味着我们最小化从边缘和平面特征一起获得的距离函数。然后我们对 LeGO-LOAM 应用两步 L-M 优化：①$F_p$中的平面特征用于获得$[t_z, θ_{roll}, θ_{pitch}]$，②利用$F_e$中的边缘特征得到$[t_x, t_y, θ_{yaw}]$。记录 L-M 方法在处理一次扫描后终止时的平均迭代次数以进行比较。当使用两步优化时，第一步优化在实验 1 和 2 的两次迭代中完成。虽然第二步优化的迭代次数与原始L-M方法的数量相似，但处理的特征较少。因此，在使用两步 L-M 优化后，激光雷达里程计的运行时间减少了 $34\%$ 至 $48\%$。两步优化的运行时间如表 IV 所示。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427105906074.png" alt="image-20220427105906074" style="zoom:50%;" /></p>
<p><strong>3)运行时间比较：</strong>LOAM 和$\rm{LeGO-LOAM}$ 的每个模块在两台计算机上的运行时间如表 IV 所示。使用所提出的框架，<strong>特征提取</strong>和<strong>激光雷达里程计</strong>模块的运行时间在 LeGO-LOAM 中减少了一个数量级。请注意，在 Jetson 上,这两个模块在 LOAM 中的运行时间超过 100 毫秒。导致许多扫描被跳过，因为 LOAM 在嵌入式系统上无法实现实时性能。使用 LeGO-LOAM 时，激光雷达建图的运行时间也减少了至少 $60\%$。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427110536203.png" alt="image-20220427110536203" style="zoom:50%;" /></p>
<p><strong>4)位姿误差比较：</strong>通过在所有实验中将初始位姿设置为$[0, 0, 0, 0, 0, 0]$，我们通过将最终位姿与初始位姿进行比较来计算相对位姿估计误差。表 V 列出了两台计算机上两种方法的旋转误差（以度为单位）和平移误差（以米为单位）。通过使用所提出的框架，LeGO-LOAM 可以以更少的计算时间实现相当或更好的位置估计精度。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427111646072.png" alt="image-20220427111646072" style="zoom:50%;" /></p>
<h2 id="D-使用-KITTI-数据集的闭环测试"><a href="#D-使用-KITTI-数据集的闭环测试" class="headerlink" title="D. 使用 KITTI 数据集的闭环测试"></a>D. 使用 KITTI 数据集的闭环测试</h2><p>我们的最终实验将 LeGO-LOAM 应用于 KITTI 数据集 [21]。由于在 [20] 中对 KITTI 数据集的 LOAM 测试以 10% 的实时速度运行，我们只探索 LeGO-LOAM 及其在嵌入式系统实时应用中的潜力，其中行程长度足够大需要完整的 SLAM 解决方案。LeGO-LOAM 在 Jetson 上使用序列 00 的结果如图 10 所示。为了在 Jetson 上实现实时性能，我们将 HDL-64E 的扫描下采样到与第 III 节中使用的相同范围图像VLP-16。换言之，每次扫描的 75% 的点在处理前都被省略掉了。 ICP在这里用于在位姿图中的节点之间添加约束。然后使用 iSAM2 [24] 优化该图。最后，我们使用优化后的图来校正传感器位姿和地图。更多闭环测试可以在视频附件中找到。</p>
<p><img src="/images/LeGO-LOAM论文翻译/image-20220427111714790.png" alt="image-20220427111714790" style="zoom:50%;" /></p>
<blockquote>
<p>图 10：LeGO-LOAM，KITTI 数据集闭环测试，使用 Jetson。颜色变化表示海拔变化。</p>
</blockquote>
<h1 id="Ⅴ-结论与讨论"><a href="#Ⅴ-结论与讨论" class="headerlink" title="Ⅴ.结论与讨论"></a>Ⅴ.结论与讨论</h1><p>我们提出了 LeGO-LOAM，一种轻量级和地面优化的激光雷达里程计和建图方法，用于在复杂环境中执行 UGV 的实时姿态估计。 LeGO-LOAM 是轻量级的，因为它可以在嵌入式系统上使用并实现实时性能。LeGO-LOAM 也是地面优化的，利用地面分离、点云分割和改进的 L-M 优化。在此过程中过滤掉可能代表不可靠特征的无价值点。两步 L-M 优化分别计算姿势变换的不同分量。所提出的方法在室外环境中收集的一系列 UGV 数据集上进行了评估。结果表明，与最先进的算法 LOAM 相比，LeGO-LOAM 可以达到相似或更好的精度。LeGO-LOAM 的计算时间也大大减少。未来的工作包括探索其在其他类型车辆中的应用。尽管 LeGO-LOAM 特别针对地面车辆的姿态估计进行了优化，但它的应用可能会扩展到其他车辆，例如无人机 (unmanned aerial vehicles，UAVs)，只需稍作改动。将 LeGO-LOAM 应用于 UAV 时，我们不会假设地面存在于扫描中。扫描的点云将在没有地面提取的情况下被分割。对于$ F_e、\mathbb{F}_e$ 和 $\mathbb{F}_p $的选择，特征提取过程是相同的。不是从标记为地面点的点中提取 $F_p$ 的平面特征，而是从所有分割点中选择 $F_p$ 中的特征，然后将使用原始的 L-M 方法来获得两次扫描之间的转换，而不是使用两步优化方法。尽管在这些变化之后计算时间会增加，但 LeGO-LOAM 仍然是有效的，因为在分割后在嘈杂的室外环境中会省略大量的点。估计的特征对应的准确性可能会提高，因为它们受益于分割。此外，使用 LeGO-LOAM 在线执行循环闭合的能力使其成为长时间导航任务的有用工具。</p>
]]></content>
      <categories>
        <category>激光SLAM</category>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>文献阅读</tag>
        <tag>LeGO-LOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>二、IMU工作原理、误差及其标定</title>
    <url>/posts/19228.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本节主要对IMU的工作原理做详细的介绍，分析IMU中的确定性误差以及随机误差，并给出误差标定的方法，如确定性误差使用六面法标定，随机误差使用艾伦方差标定等。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="Ⅰ-旋转运动学"><a href="#Ⅰ-旋转运动学" class="headerlink" title="Ⅰ.旋转运动学"></a>Ⅰ.旋转运动学</h1><h2 id="A-线速度与角速度"><a href="#A-线速度与角速度" class="headerlink" title="A.线速度与角速度"></a>A.线速度与角速度</h2><p>如图所示，粒子在坐标系中的$z=h$的平面内做圆周运动，坐标为$r=(a\cos\theta,a\sin\theta,h)$，对坐标求导得：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot r&=(-a\dot\theta\sin\theta,a\dot\theta\cos\theta,0)^T\\
&=\begin{bmatrix}
0&-\dot\theta&0\\\dot\theta&0&0\\0&0&0
\end{bmatrix}
\begin{bmatrix}a\cos\theta\\a\sin\theta\\h\end{bmatrix}\\
&=w^{\land} r
\end{align*}\tag{1}</script><p>其中$w$是角速度，它是一个矢量，即$w=\begin{bmatrix}0\\0\\ \dot\theta\end{bmatrix}=\dot\theta z$,其中$|\dot\theta|$是角速度的大小。对公式$(1)$取模：</p>
<script type="math/tex; mode=display">
|\dot r|=|w||r|sin\phi=a|\dot\theta|</script><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422093936869.png" alt="image-20220422093936869" style="zoom:50%;" /></p>
<h2 id="B-旋转坐标系下的运动学"><a href="#B-旋转坐标系下的运动学" class="headerlink" title="B.旋转坐标系下的运动学"></a>B.旋转坐标系下的运动学</h2><p>如图，考虑两个坐标系，一个是世界坐标系(惯性坐标系)$W$，它本身是静止不动的；一个是机器人本体坐标系$B$，它本身在做角速度为$w_B$的纯旋转，设质量块在坐标系$B$下做速度为$v_B$，加速度为$a_B$的匀加速直线运动，它在$B$坐标系下坐标为$r_B=(x_1,x_2,x_3)^T$，设从坐标系世界坐标系$W$到是机器人本体坐标系$B$只考虑旋转的时候，旋转矩阵$R_{WB}$。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422155242434.png" alt="image-20220422155242434"></p>
<p>这里定义一些变量：</p>
<blockquote>
<p>①设物体在坐标系$B$下做速度为$v_B$，加速度为$a_B$，对应在坐标系$W$下的速度为$v_W$，加速度为$a_W$</p>
<p>并且设坐标系$B$下的速度和加速度在坐标系$W$下的表示分别为：$v=R_{WB}v_B$，$a=R_{WB}a_B$，一定注意这里的$v\ne v_W,a\ne a_W$</p>
<p>②设坐标轴$B$旋转的角速度为$w_B$，对应在世界坐标系中其旋转的角速度变为$w_W$，且$w_W=R_{WB}w_B$</p>
<p>③设物体在坐标系$B$下的坐标为$r_B$，对应在坐标系$W$下的坐标为$r_W$，且$r_W=R_{WB}r_B$</p>
</blockquote>
<p>则对应到世界坐标系下：</p>
<script type="math/tex; mode=display">
r_W(t)=x_1(t)i+x_2(t)j+x_3(t)k=R_{WB}r_B</script><p>一般简写为：$r_B=x_ie_i$</p>
<p>经过一番定义之后，我们考虑几个问题:</p>
<ul>
<li><strong>求物体在$W$坐标系下的速度</strong></li>
</ul>
<p>对时间求导：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot r_W=v_W&=R_{WB}\dot r_B+\dot R_{WB} r_B\\
&=R_{WB}v_B+w_W^{\land} r_W \ \ \ \ 参见公式(3) \\ 
&=v+w_W^{\land} r_W\Leftrightarrow v=v_W-w_W^{\land} r_W\\
\end{align*}\tag{2}</script><p>其中$w_W=R_{WB}w_b$表示body坐标系$B$的角速度在世界坐标系$W$下的表示。具体推导参见公式$(3)$.</p>
<p>这里可以明显看出$v\ne v_W$，两者之间相差一个$w_W^{\land} r_W$项。</p>
<hr>
<p>推导$\dot R_{WB} r_B$，使用右乘扰动模型:</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot R_{WB} r_B&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}\exp([w_B\Delta t]^{\land})r_B-R_{WB}r_B}{\Delta t}\\
&\approx\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}(I+[w_B\Delta t]^{\land})r_B-R_{WB}r_B}{\Delta t}\\
&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}[w_B\Delta t]^{\land}r_B}{\Delta t}\\
&=\underset{\Delta t \rightarrow0}{lim}\frac{-R_{WB}r_B^{\land}[w_B\Delta t]}{\Delta t}\\
&=-R_{WB}r_B^{\land}w_B\\ 
&=R_{WB}w_B^{\land}r_B\\
&=(R_{WB}w_B)^{\land}R_{WB}r_B\\
&=w^{\land}_Wr_W
\end{align*}\tag{3}</script><hr>
<ul>
<li><strong>求物体在$W$坐标系下的加速度</strong></li>
</ul>
<p>对时间求导：</p>
<script type="math/tex; mode=display">
\begin{align*}
\ddot r_W =\dot v_W = a_W&=\frac{d(R_{WB}v_B+w_W^{\land}\dot r_W)}{dt}\\
&=R_{WB}\dot v_B+\dot R_{WB} v_B+w_W^{\land}\dot r_W+\dot w_W^{\land}r_W\\
&=a+w^{\land}v+(w^{\land}v+w^{\land}(w^{\land} r_W))+\dot w^{\land}r_W\\
&=a+2w^{\land}v+w^{\land}(w^{\land} r_W)+\dot w^{\land}r_W\\
\end{align*}\tag{4}</script><p>上式的每一项的推导见下面。这里可以明显看出$a\ne a_W$，两者之间相差三个项，分别是<strong>科氏力：$2w^{\land}v$，离心力：$w^{\land}(w^{\land} r_W)$、欧拉力：$\dot w^{\land}r_W$。</strong></p>
<hr>
<ul>
<li>第一项：</li>
</ul>
<script type="math/tex; mode=display">
R_{WB}\dot v_B=R_{WB}a_B=a</script><ul>
<li>第二项：</li>
</ul>
<p>参考公式$(3)$，很容易就可以推出来：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot R_{WB} v_B&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}\exp([w_B\Delta t]^{\land})v_B-R_{WB}v_B}{\Delta t}\\

&=(R_{WB}w_B)^{\land}R_{WB}r_B\\
&=w^{\land}_Wv
\end{align*}</script><ul>
<li>第三项：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
w_W^{\land}\dot r_W&=w_W^{\land}(v+w_W^{\land}r_W)\\
&=w_W^{\land}v+w_W^{\land}(w_W^{\land}r_W)
\end{align*}</script><hr>
<p><strong>整个过程的作用是什么？</strong></p>
<p>我们在<strong>已知$B$坐标系下的物体的加速度、速度以及旋转轴的角速度</strong>，（这里的B就是我们今天的”IMU”），我们就可以求得对应世界坐标系下的相应的物理量，那么相应的求可以求得世界坐标系下的位姿（速度积分得到位姿）、四元数（根据角速度）。</p>
<p>大篇幅地介绍这个案例，主要是使读者明白，三维世界中的运动物体，在旋转的坐标系下（IMU坐标系）,如何将其状态量转换到世界坐标系下。以及转换之后各个状态量多出来了什么？</p>
<h1 id="Ⅱ-IMU-工作原理"><a href="#Ⅱ-IMU-工作原理" class="headerlink" title="Ⅱ.IMU 工作原理"></a>Ⅱ.IMU 工作原理</h1><h2 id="A-加速度计工作原理"><a href="#A-加速度计工作原理" class="headerlink" title="A.加速度计工作原理"></a>A.加速度计工作原理</h2><p>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示:</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422191601477.png" alt="image-20220422191601477.png" style="zoom:33%;" /></p>
<p>注意这里的加速度计测量值$a_m$为弹簧拉力对应的加速度，所以有：</p>
<script type="math/tex; mode=display">
a_m=\frac{f}{m}=a-g\tag{5}</script><p>其中$f $为弹簧拉力，$a$ 为物体在惯性系下的加速度，$g$为重力加速度。</p>
<p>另外，实际的加速度计大都是$MEMS $加速度计，它利用电容或者电阻桥来等原理来测量$ a_m$</p>
<p>其原理可以参考：<a href="https://m.elecfans.com/article/596137.html"><strong>MEMS 加速度传感器的原理与构造介绍</strong></a></p>
<p>通常情况下我们假设地球表面为惯性参考系，但是对于高端的测量单元来说，这种精度远远不够（需要考虑地球自转的影响），所以就将惯性参考系的原点记为地球的质心，而位于地球表面的坐标系称为地面参考系或东北天坐标系（ENU坐标系）, 如下图所示。在此坐标系下$g=(0,0,-9.81)^T$</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422192532908.png" alt="image-20220422192532908.png" style="zoom:33%;" /></p>
<p>假设 IMU 坐标系就是 ENU 坐标系，$R_{WB }= I$，静止时有$a=0,a_m=-g$，自由落体时有$a=g,a_m=0$</p>
<h2 id="B-陀螺仪测量原理"><a href="#B-陀螺仪测量原理" class="headerlink" title="B.陀螺仪测量原理"></a>B.陀螺仪测量原理</h2><p>陀螺仪侦测的是角速度。其工作原理基于科里奥利力的原理：当一个物体在坐标系中直线移动时，假设坐标系做一个旋转，那么在旋转的过程中，物体会感受到一个垂直的力和垂直方向的加速度。</p>
<p>按测量原理分有<strong>振动陀螺</strong>，<strong>光纤陀螺</strong>等。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/陀螺仪.gif" alt="陀螺仪.gif"></p>
<p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 科氏力（Coriolis force ）来间接得到角速度。MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴，比如，如图示，高速运动的物体速度为$v$，在旋转坐标系下，物体会受到科氏力的影响，我们通过求科氏力就可以求得角速度$w$的大小。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422195814350.png" alt="image-20220422195814350.png" style="zoom:33%;" /></p>
<p>但是实际制作的过程中我们不只是使用一个质量块，而是使用两个质量块，就是<strong>音叉陀螺仪</strong>，如图所示，叉子的中间为旋转轴，叉子左右两个质量块，做方反的正弦运动，质量块受到的科氏力方向相反。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/20210905220130.png" alt="20210905220130.png" style="zoom: 33%;" /></p>
<p>当两个完全相同的质量块的运动方向相反，但是旋转相同的时候，它们就会受到相反的科氏力以及相同的外部加速度影响力。将两个质量块所受到该方向上的力做差，就会得到两倍的科氏力。</p>
<p><strong>但是为啥要用这么做呢? 一个质量块不行么？</strong></p>
<p>①利用二倍的科氏力对应的电压指数更大，测量也变得更准确；②因为有可能在科氏力方向上物体本身具有一定的加速度，所以利用音叉陀螺仪构成差分模型，可以将两个外部力相互抵消（科氏力方向物体本身的加速度），消除自身的影响，是的获得的科氏力更准。</p>
<p>但是，实际上，两个质量块不可能完全一致，也就是说陀螺仪的测量可能会受到外部加速度的影响，即常称的 <strong>G-sensitivity</strong>，一般的IMU手册里面都会有这个指数，它的含义就是告诉你IMU受加速度影响的系数有多大。</p>
<h1 id="Ⅲ-IMU-中的误差及其标定"><a href="#Ⅲ-IMU-中的误差及其标定" class="headerlink" title="Ⅲ.IMU 中的误差及其标定"></a>Ⅲ.IMU 中的误差及其标定</h1><p>误差的分类：加速度计和陀螺仪的误差可以分为：确定性误差以及随机的误差，确定性的误差一般是事先通过标定确定，但是随机误差通常情况下假设噪声服从的是高斯分布。</p>
<h2 id="A-确定性误差与标定"><a href="#A-确定性误差与标定" class="headerlink" title="A.确定性误差与标定"></a>A.确定性误差与标定</h2><h3 id="1-确定性误差"><a href="#1-确定性误差" class="headerlink" title="1.确定性误差"></a>1.确定性误差</h3><ul>
<li><strong>Bias</strong></li>
</ul>
<p>理论上，当没有外部作用时，IMU 传感器的输出应该为$0$。但是，实际数据存在一个偏置$ b$。加速度计 bias 对位姿估计的影响：</p>
<script type="math/tex; mode=display">
v_{err}=b_at,\ \ \ p_{err}=\frac{1}{2}b_at^2</script><p>这里的$p_{err}$指的是位移，因为有时间$t$的存在，为了区分，将位移定义为$p$.</p>
<ul>
<li><strong>Scale(刻度系数误差)</strong></li>
</ul>
<p>scale 可以看成是实际数值和传感器输出值之间的比值。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422204953295.png" alt="image-20220422204953295.png" style="zoom:33%;" /></p>
<ul>
<li><strong>Nonorthogonality/Misalignment Errors(安装误差)</strong></li>
</ul>
<p>特别的在多轴的IMU传感器中，由于制作工艺的问题，有可能对导致$xyz$轴并不是严格意义的正交，如下图所示，$z$轴并不是严格意义上与$xOy$平面垂直，则会影响对应的$x,y$上的分量。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422204127003.png" alt="image-20220422204127003.png" style="zoom:33%;" /></p>
<p>加上之前的scale的影响：</p>
<script type="math/tex; mode=display">
\begin{align*}
scale+Misalignment:&\\
&\begin{bmatrix}
l_{ax}\\l_{ay}\\l_{az}
\end{bmatrix}=
\begin{bmatrix}
s_{xx}&m_{xy}&m_{xz}\\
m_{yx}&s_{yy}&m_{yz}\\
m_{zx}&m_{zy}&s_{zz}
\end{bmatrix}
\begin{bmatrix}
a_{x}\\a_{y}\\a_{z}
\end{bmatrix}
\end{align*}</script><h3 id="2-确定性误差的标定"><a href="#2-确定性误差的标定" class="headerlink" title="2.确定性误差的标定"></a>2.确定性误差的标定</h3><h4 id="六面法标定加速度计和陀螺仪"><a href="#六面法标定加速度计和陀螺仪" class="headerlink" title="六面法标定加速度计和陀螺仪"></a>六面法标定加速度计和陀螺仪</h4><p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。<br>如果各个轴都是正交的，那很容易得到 bias 和 scale：</p>
<p>因为静止状态下，向上和向下所得到IMU的示数相加正好抵消掉了重力的影响，所以两次测量相加得到两倍的bias；</p>
<p>向上和向下所得到IMU的示数相减可以抵消bias;</p>
<script type="math/tex; mode=display">
b=\frac{l^{up}_f+l^{down}_f}{2}\\
S=\frac{l^{up}_f-l^{down}_f}{2g}\tag{6}</script><p>其中，$l $为加速度计某个轴的测量值，$g$ 为当地的重力加速度</p>
<p><strong>考虑轴间误差的时候，实际加速度和测量值之间的关系为：</strong></p>
<p>当考虑轴间的误差的时候，就变成$L = S · a + b$，其中$S$为$3\times3$的矩阵，</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
l_{ax}\\l_{ay}\\l_{az}
\end{bmatrix}=
\begin{bmatrix}
s_{xx}&m_{xy}&m_{xz}\\
m_{yx}&s_{yy}&m_{yz}\\
m_{zx}&m_{zy}&s_{zz}
\end{bmatrix}
\begin{bmatrix}
a_{x}\\a_{y}\\a_{z}
\end{bmatrix}+
\begin{bmatrix}
b_{ax}\\b_{ay}\\b_{az}
\end{bmatrix}\tag{7}</script><p>水平放置$6$面，就会得到$6$个$a$向量，加速度的理论值为</p>
<script type="math/tex; mode=display">
a_1=\begin{bmatrix}
g\\0\\0
\end{bmatrix},
a_2=\begin{bmatrix}
-g\\0\\0
\end{bmatrix},
a_3=\begin{bmatrix}
0\\g\\0
\end{bmatrix},
a_4=\begin{bmatrix}
0\\-g\\0
\end{bmatrix},
a_5=\begin{bmatrix}
0\\0\\g
\end{bmatrix},
a_6=\begin{bmatrix}
0\\0\\-g
\end{bmatrix}</script><p>对应的$L$为$L=\begin{bmatrix}l_1&amp;l_2&amp;l_3&amp;l_4&amp;l_5&amp;l_6\end{bmatrix}$</p>
<p>在得知六组数据$(a_1,l_1)…(a_6.l_6)$，我们就可以利用最小二乘就可以得出$S$和$b$的具体值。线性最小二乘可以参考：<a href="https://lukeyalvin.top/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/">线性最小二乘</a></p>
<p><strong>同理陀螺仪的六面法标定与其类似，和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这里的$6 $面是指各个轴顺时针和逆时针旋转。</strong></p>
<h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><p>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</p>
<p>两种标定方法：</p>
<ul>
<li>soak method：控制恒温室的温度值，然后读取传感器数值进行标定。</li>
<li>ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</li>
</ul>
<h2 id="B-随机误差与标定"><a href="#B-随机误差与标定" class="headerlink" title="B.随机误差与标定"></a>B.随机误差与标定</h2><h3 id="1-随机误差"><a href="#1-随机误差" class="headerlink" title="1.随机误差"></a>1.随机误差</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>IMU 数据<strong>连续时间</strong>上受到一个均值为$ 0$，方差为$\sigma$，各时刻之间相互独立的高斯过程$ n(t)$：</p>
<script type="math/tex; mode=display">
\begin{align*}
&E[n(t)]\equiv0\\
&E[n(t_1)n(t_2)]=\sigma^2\delta(t_1-t_2)
\end{align*}\tag{8}</script><p>其中$\delta()$表示狄拉克函数。</p>
<p>实际上，IMU 传感器获取的数据为<strong>离散采样</strong>，离散和连续高斯白噪声的方差之间存在如下转换关系：</p>
<p>定义$n_d[k]$</p>
<script type="math/tex; mode=display">
\begin{align*}
n_d[k]\triangleq n(t_0+t_1)≃\frac{1}{\Delta t}\int^{t_0+\Delta t}_{t_0}{n(\tau)}dt
\end{align*}</script><p>对其求方差$Var(X)=E[(X-\mu)^2]$,已知均值为$0$，$X=n_d[k]$：</p>
<script type="math/tex; mode=display">
\begin{align*}
E(n_d[k]^2)&=E(\frac{1}{\Delta t^2}\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{n(\tau)}{n(t)}d\tau dt)\\
&=E(\frac{\sigma^2}{\Delta t^2}\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{\delta(t-\tau)}d\tau dt)\\
&=E(\frac{\sigma^2}{\Delta t})
\end{align*}\tag{9}</script><p>对应相等，可得：</p>
<script type="math/tex; mode=display">
n_d[k]=\sigma_dw[k]\tag{10}</script><p>其中，</p>
<script type="math/tex; mode=display">
w[k]\sim N(0,1)\\
\sigma_d=\sigma\frac{1}{\sqrt{\Delta t} }\tag{11}</script><p><strong>也就是说高斯白噪声的连续时间到离散时间之间差一个$\frac{1}{\sqrt{\Delta t} }$ ，$\sqrt{\Delta t} $是传感器的采样时间。</strong></p>
<h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走。</p>
<script type="math/tex; mode=display">
\dot b(t)=n(t)=\sigma_bw(t)\tag{12}</script><p>其中$ w $是方差为$ 1 $的白噪声。</p>
<p>同样，离散和连续之间的转换：</p>
<p>定义$b_d[k]$</p>
<script type="math/tex; mode=display">
b_d[k]\triangleq b(t_0)+\int^{t_0+\Delta t}_{t_0}{n(t)}dt</script><p>求方差：</p>
<script type="math/tex; mode=display">
\begin{align*}
E((b_d[k]-b_d[k-1])^2)&=E(\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{n(t)}{n(\tau)}d\tau dt)\\
&=E(\sigma_b^2\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}\delta (t-\tau)d\tau dt)\\
&=E(\sigma_b^2\Delta t)
\end{align*}\tag{13}</script><p>所以：</p>
<script type="math/tex; mode=display">
b_d[k]=b_d[k-1]+\sigma_{bd}w[k]\tag{14}</script><p>其中：</p>
<script type="math/tex; mode=display">
w[k]\sim N(0,1)\\
\sigma_{bd}=\sigma_b \sqrt{\Delta t}\tag{15}</script><p><strong>bias 随机游走的噪声方差从连续时间到离散之间需要乘以</strong>$\sqrt{\Delta t}$</p>
<h3 id="2-随机误差的标定"><a href="#2-随机误差的标定" class="headerlink" title="2.随机误差的标定"></a>2.随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><blockquote>
<p>在统计学中描述随机变量的两个经典参数是均值和方差，早期在定量表征原子钟的频率稳定度时采用的就是经典方差方法。1996 年，学者 D.W.Allan 在分析铯原子钟频标的频率稳定度时发现经典方差随着时间的增长而发散，为了解决该问题，提出了一种新的评定方法，后来称为艾伦方差。由于惯性器件也具有振荡器的特征，Allan 方差分析也被广泛应用于惯性器件的随机误差建模，IEEE 标准中就将 Allan 方差方法引入到了激光陀螺的建模分析。</p>
</blockquote>
<p>具体的流程如下：</p>
<p>①保持传感器绝对静止获取数据。</p>
<p>②对数据进行分段，设定时间段的时长，如下图所示。</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220423162306358.png" alt="image-20220423162306358" style="zoom:50%;" /></p>
<p>③将传感器数据按照时间段进行平均。</p>
<p>④计算方差，绘制艾伦曲线。</p>
<p>得到的艾伦曲线如下图所示：</p>
<p><img src="/images/2-IMU运动学模型以及误差模型/image-20220423162352964.png" alt="image-20220423162352964" style="zoom: 33%;" /></p>
<p>从艾伦方差曲线中可以辨识出 IMU 的五种噪声，分别为：量化噪声、角度随机游走、零偏不稳定性噪声，角速率随机游走，速率斜坡，一般在 IMU 噪声辨识中用的比较多的是中间 3 种。</p>
]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>IMU误差模型</tag>
      </tags>
  </entry>
  <entry>
    <title>一、VIO概述以及三维刚体运动知识点回顾</title>
    <url>/posts/28639.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本节主要通过引言部分，提出问什么引入VIO以及它的作用是什么，其次介绍VIO的基本概念，并为了后续内容的展开，回顾了一些基本的数学基础。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="引言：Why-VIO"><a href="#引言：Why-VIO" class="headerlink" title="引言：Why VIO ?"></a>引言：Why VIO ?</h1><h2 id="VO-的缺陷"><a href="#VO-的缺陷" class="headerlink" title="VO 的缺陷"></a>VO 的缺陷</h2><p>结合之前所学，我们首先考虑纯视觉的SLAM，即VO；</p>
<p>首先是<strong>单目视觉SLAM:</strong> 它的优点就是便宜，简单易用，但是缺点也很明显，就是单目没有深度信息，主要存在三个方面的缺陷：①初度不确定性；②需要初始化；③存在尺度漂移；基于这些问题，这里不做详细的展开；</p>
<p>为了解决单目视觉存在的问题，我们开始使用<strong>双目相机和 RGBD 相机</strong>，因为它们可以测量深度，这样的话就不存在初始化和尺度上的问题了，但是双目相机的标定很复杂，且视差计算深度比较消耗资源，而RGBD对环境的要求也比较苛刻、测量距离也很有限，其标定也比较复杂。</p>
<p>但是由于传感器主要是相机，因此，<strong>纯视觉</strong>存在一些共性的弊端：比如在<strong>光照变化较大时，纹理特征缺失、快速运动导致模糊的情况下无法使用</strong>等缺陷；其中快速运动导致无法使用，主要是因为快速运动可能会导致跟丢，由于纯视觉不做任何处理，大部分都是基于第一帧作为世界坐标系而建立的，而不是相对于地球水平面 (世界坐标系) 的位姿，后者却是导航中真正需要的位姿，换言之，<strong>视觉方法估计的位姿不能和重力方向对齐</strong>。这可能会出现车在地上开，运动轨迹天上飞的现象。</p>
<h2 id="VIO-的优点"><a href="#VIO-的优点" class="headerlink" title="VIO 的优点"></a>VIO 的优点</h2><p>VIO 就是一种非常优美的解决方式，因为 IMU 可以提供物理世界的尺度，短时间内也能提供比较准确的<strong>位姿估计</strong>，还能<strong>估计出惯性坐标系</strong>。这种互补的性质，让 VIO 在近几年得到了极大的关注。VIO能够解决这些问题的基础是它的初始化，VIO 初始化会把视觉 SLAM 所缺的东西全部都先估计出来，包括<strong>尺度信息，重力向量，位姿速度</strong>。</p>
<p>通过将 IMU 估计的位姿序列和相机估计的位姿序列对齐可以<strong>估计出相机轨迹的真实尺度</strong>，而且 IMU 可以很好地预测出图像帧的位姿以及上一时刻特征点在下帧图像的位置，<strong>提高特征跟踪算法匹配速度和应对快速旋转的算法鲁棒性</strong>，最后 IMU 中加速度计提供的重力向量可以<strong>将估计的位置转为实际导航需要的世界坐标系中</strong>。</p>
<p>另外还需要通过视觉 SLAM 帮助 IMU 去搞定陀螺仪和加速度计的初始 bias。如果这些东西一开始估计的很差，那整个系统的准确性会急剧下降。基于滤波的很可能很快就发散得很远了，基于非线性优化的可能经常会陷入局部最优解。</p>
<p>综合以上，融合 IMU 和视觉信息的 VINS 算法可以很大程度地提高单目 SLAM 算法性能，是一种低成本高性能的导航方案，在机器人、AR/VR 领域得到了很大的关注。</p>
<h1 id="Ⅰ-VIO-概述"><a href="#Ⅰ-VIO-概述" class="headerlink" title="Ⅰ.VIO 概述"></a>Ⅰ.VIO 概述</h1><h2 id="A-IMU与视觉里程"><a href="#A-IMU与视觉里程" class="headerlink" title="A.IMU与视觉里程"></a>A.IMU与视觉里程</h2><p>IMU（Inertial Measurement Unit），惯性测量单元，用于测量物体三轴姿态角(或角速率)以及加速度的装置。一般情况下，一个IMU内会装有三轴的陀螺仪和三个方向的加速度计，分别用来测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。为了提高可靠性，还可以为每个轴配备更多的传感器。一般而言IMU要安装在被测物体的重心上。</p>
<ul>
<li>典型 6 轴 IMU 本身由一个陀螺仪和一个加速度计组成，分别测量自身的角速度和加速度，并以较高频率（≥ 100Hz）返回。</li>
</ul>
<p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420150139375.png" alt="image-20220420150139375" style="zoom: 33%;" /></p>
<ul>
<li>但是IMU，受自身温度、零偏、振动等因素干扰，积分得到的平移和旋转容易漂移</li>
</ul>
<p>手机等电子产品多使用价格低廉的 MEMS IMU（如 MPU 6050），自动驾驶类则多使用几万元的 IMU（如 Apollo 中使用的 Novatel SPAN-IGM-A1）</p>
<p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420150543613.png" alt="image-20220420150543613" style="zoom: 50%;" /></p>
<p>视觉 Visual Odometry</p>
<ul>
<li>以图像形式记录数据，频率较低（15 − 60Hz 居多）</li>
<li>通过图像特征点或像素推断相机运动，因此容易受成像质量的影响。</li>
</ul>
<p><strong>IMU 与视觉定位方案优势与劣势对比：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方案</th>
<th style="text-align:center">IMU</th>
<th style="text-align:center">视觉</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">优势</td>
<td style="text-align:center">快速响应<br/>不受成像质量影响<br/>角速度普遍比较准确<br/>可估计绝对尺度</td>
<td style="text-align:center">（静止）不产生漂移<br/>直接测量旋转与平移</td>
</tr>
<tr>
<td style="text-align:center">劣势</td>
<td style="text-align:center">存在零偏<br/>低精度 IMU 积分位姿发散<br/>高精度价格昂贵</td>
<td style="text-align:center">受图像遮挡、运动物体干扰<br/>单目视觉无法测量尺度<br/>单目纯旋转运动无法估计<br/>快速运动时易丢失</td>
</tr>
</tbody>
</table>
</div>
<p>整体上，视觉和 IMU 定位方案存在一定互补性质：</p>
<ul>
<li>IMU 适合计算短时间、快速的运动；</li>
<li>视觉适合计算长时间、慢速的运动。</li>
</ul>
<p>同时，可利用视觉定位信息来估计 IMU 的零偏，减少 IMU 由零偏导致的发散和累积误差；反之，IMU 可以为视觉提供快速运动时的定位。</p>
<h2 id="B-VIO"><a href="#B-VIO" class="headerlink" title="B.VIO"></a>B.VIO</h2><p>VIO：（Visual-Inertial Odometry）视觉惯性里程计，有时候也叫视觉惯性系统（VINS，visual-inertial system），是融合相机和IMU数据实现SLAM的算法。</p>
<p>IMU 数据可与多种定位方案融合，比如自动驾驶中通常用 IMU+GPS/差分 GPS/RTK 的融合定位方案，<br>形成 GNSS-INS 组合导航系统，达到厘米组定位精度；头戴式 AR/VR 头盔则多使用视觉 +IMU 的 VIO 定位系统，形成高帧率定位方案。</p>
<p>根据融合框架的区别VIO可以分为紧耦合和松耦合：</p>
<ul>
<li><strong>松耦合</strong></li>
</ul>
<p>松耦合将 IMU 定位与视觉/GNSS 的位姿直接进行融合，融合过程对二者本身不产生影响，作为后处理方式输出。典型方案为卡尔曼滤波器。</p>
<p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420151628700.png" alt="image-20220420151628700" style="zoom: 33%;" /></p>
<ul>
<li><strong>紧耦合</strong></li>
</ul>
<p>紧耦合则是<strong>使用两个传感器的原始数据共同估计一组变量，传感器噪声也是相互影响的</strong>，紧耦合算法上比较复杂，但充分利用了传感器数据，可以实现更好的效果，是目前研究的重点。典型方案为 MSCKF 和非线性优化。</p>
<p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420151708384.png" alt="image-20220420151708384" style="zoom:33%;" /></p>
<p><strong>为什么要使用紧耦合？</strong></p>
<ul>
<li>单纯凭（单目）视觉或 IMU 都不具备估计 Pose 的能力：视觉存在尺度不确定性、IMU 存在零偏导致漂移；</li>
<li>松耦合中，视觉内部 BA 没有 IMU 的信息，在整体层面来看不是最优的。</li>
<li>紧耦合可以一次性建模所有的运动和测量信息，更容易达到最优。</li>
</ul>
<h1 id="Ⅱ-知识点回顾"><a href="#Ⅱ-知识点回顾" class="headerlink" title="Ⅱ.知识点回顾"></a>Ⅱ.知识点回顾</h1><h2 id="A-三维刚体运动"><a href="#A-三维刚体运动" class="headerlink" title="A.三维刚体运动"></a>A.三维刚体运动</h2><p>在三维刚体运动中，我们定义机器人上的各种坐标系，世界坐标系$W$，IMU坐标系(Body系)$I$，相机坐标系$C$。通过十四讲的学习我们可以知道，坐标系之间的转换可以通过$SE(3)$给出，比如$I$到$W$坐标系的变换矩阵为$T_{WI}$:</p>
<script type="math/tex; mode=display">
T_{WI}=\begin{bmatrix}
R_{WI}&t_{WI}\\
0^T&1
\end{bmatrix}\in\mathbb{R}^{4×4}\tag{1}</script><p>其中，$R_{WI}$为$3×3$的旋转矩阵，$t_{WI}$为平移向量。我们可以用$T_{WI}$右乘一个$I$坐标系下的坐标，将得到该点$W$系下的坐标。</p>
<h2 id="B-四元数"><a href="#B-四元数" class="headerlink" title="B.四元数"></a>B.四元数</h2><p>三维刚体的运动可以有旋转矩阵来表达，也可以用四元数$q$描述。四元数有一个实部和三个虚部。我们把实部写在前：</p>
<script type="math/tex; mode=display">
q=[q_0,q_1,q_2,q_3]^T或q=[w,x,y,z]^T\tag{2}</script><p>其中 $q_0$ 为实部，$[q_1, q_2, q_3]^T$为虚部。因为实部为标量，虚部为矢量，所以也可记为：</p>
<script type="math/tex; mode=display">
q=[s,\pmb{v}]^T\tag{3}</script><p>其中 $s $为标量，$\pmb{v}$为虚部的矢量。</p>
<p><strong>四元数的乘法运算：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
q_a\otimes q_b&=w_aw_b − x_ax_b − y_ay_b − z_az_b\\
&+ (w_ax_b + x_aw_b + y_az_b − z_ay_b)i\\
&+ (w_ay_b − x_az_b + y_aw_b + z_ax_b) j\\
&+ (w_az_b + x_ay_b − y_ax_b + z_aw_b) k.
\end{align*}\tag{4}</script><p>或者是：</p>
<script type="math/tex; mode=display">
q_a\otimes q_b=[s_as_b-\pmb{v}_a^T\pmb{v}_b,s_a\pmb{v}_b+s_b\pmb{v}_a+\pmb{v}_a\times\pmb{v}_b]^T\tag{5}</script><p>四元数的其他四则运算，不作具体展开，参阅《视觉SLAM十四讲》。</p>
<p><strong>四元数表示旋转：</strong></p>
<p>另外单位四元数可表达任意三维旋转，且无奇异性。如设轴角为$w$和$\theta$，那么它对应的四元数为：</p>
<script type="math/tex; mode=display">
q=[cos\frac{\theta}{2},wsin\frac{\theta}{2}]^T\tag{6}</script><p>利用此性质可推导四元数求导。</p>
<p><strong>四元数的求导：</strong></p>
<p>四元数时间导数：设初始旋转为 $q = [s, \pmb{v}]$，然后，发生了角轴为 $w, \theta$ 的旋转（右乘，对应四元数记作$\Delta q=[cos\frac{\theta}{2},wsin\frac{\theta}{2}]^T$），那么 $q $相对该旋转的导数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\underset{\theta \rightarrow 0}{lim}\frac{q\otimes \Delta q-q}{\theta}
&=\underset{\theta \rightarrow 0}{lim}\frac{[s \cos\frac{\theta}{2}-\pmb{v}^Tw \sin\frac{\theta}{2},sw \sin\frac{\theta}{2}+cos\frac{\theta}{2}\pmb{v}+\pmb{v}\times w \sin\frac{\theta}{2}]^T-q}{\theta}\\
&=\underset{\theta \rightarrow 0}{lim}\frac{[s (\cos\frac{\theta}{2}-1)-\pmb{v}^Tw \sin\frac{\theta}{2},sw \sin\frac{\theta}{2}+(\cos\frac{\theta}{2}-1)\pmb{v}+\pmb{v}\times w \sin\frac{\theta}{2}]^T}{\theta}\\
&=[-\frac{1}{2}\pmb{v}^Tw,\frac{1}{2}sw+\frac{1}{2}\pmb{v}\times w]^T\\
&=q\otimes[0,\frac{1}{2}w]^T
\end{align*}\tag{7}</script><p>因此，若角速度为 $w$，那么旋转的时间导数即为：</p>
<script type="math/tex; mode=display">
\dot q= q\otimes[0,\frac{1}{2}w]^T\tag{8}</script><h2 id="C-李代数"><a href="#C-李代数" class="headerlink" title="C.李代数"></a>C.李代数</h2><p>除了利用四元数求导，亦可利用李代数进行旋转求导。<br>使用旋转矩阵$R$时，角速度为 $w$，那么 $R$ 相对于时间的导数可写作：</p>
<script type="math/tex; mode=display">
\dot R= Rw^{\land}\tag{9}</script><p>该式被称为<strong>泊松公式</strong>（Possion’s equation），其中${\land}$为反对称矩阵算子：</p>
<script type="math/tex; mode=display">
w^{\land}=\begin{bmatrix}
0&-w_3&w_2\\
w_3&0&-w_1\\
-w_2&w_1&0
\end{bmatrix}\tag{10}</script><p>其实结合之前的知识，可以发现，这里的$w^{\land}$不就是旋转矩阵对应的李代数$\mathfrak{so}(3)$嘛，十四讲里面用的是$\phi^{\land}$。</p>
<p><strong>$\mathfrak{so}(3)$导数：</strong></p>
<p>在优化带有旋转的函数时，通常计算一个增量 $\phi\in \mathfrak{so}(3)$，然后用它更新当前估计值：</p>
<script type="math/tex; mode=display">
R\leftarrow R\ exp(\phi^{\land})\tag{11}</script><p>其中$exp$为$\mathfrak{so}(3)$至$SO(3)$上的指数映射。</p>
<blockquote>
<p>注意：</p>
<blockquote>
<p>①不同的$R$函数，具体的导数形式也不同</p>
<p>②在程序中，不必区分$R$是以矩阵存储或是以四元数存储，只需按照该式更新即可。</p>
</blockquote>
</blockquote>
<h2 id="D-扰动模型的雅可比"><a href="#D-扰动模型的雅可比" class="headerlink" title="D.扰动模型的雅可比"></a>D.扰动模型的雅可比</h2><p><strong>常见的一些雅可比：</strong>（以自变量为$R$举例）</p>
<ul>
<li>旋转点的左扰动雅可比：</li>
</ul>
<p>这里将对$R$进行一次的扰动$\Delta R$加在其对应的李代数$\varphi $上，而非李群上。</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial(Rp)}{\partial \varphi}
&=\underset{\varphi\rightarrow0}{lim}\frac{exp(\varphi^{\land})\cdot exp(\phi^{\land})p-exp(\phi^{\land})p}{\varphi}\\
&\approx \underset{\varphi\rightarrow0}{lim}\frac{(I+\varphi^{\land})\cdot exp(\phi^{\land})p-exp(\phi^{\land})p}{\varphi} \ \ \ 一阶泰勒展开\\
&=\underset{\varphi\rightarrow0}{lim}\frac{\varphi^{\land}Rp}{\varphi} \ \ \ 根据 a^{\land}b=-b^{\land}a\\
&=\underset{\varphi\rightarrow0}{lim}\frac{-(Rp)^{\land}\varphi}{\varphi}\\
&=-(Rp)^{\land}
\end{align*}\tag{12}</script><ul>
<li>旋转点的右扰动雅可比：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial(Rp)}{\partial \varphi}
&=\underset{\varphi\rightarrow0}{lim}\frac{ exp(\phi^{\land})\cdot exp(\varphi^{\land})p-exp(\phi^{\land})p}{\varphi}\\
&\approx \underset{\varphi\rightarrow0}{lim}\frac{ exp(\phi^{\land})\cdot(I+\varphi^{\land})p-exp(\phi^{\land})p}{\varphi} \ \ \ 一阶泰勒展开\\
&=\underset{\varphi\rightarrow0}{lim}\frac{R\varphi^{\land}p}{\varphi} \ \ \ 根据 a^{\land}b=-b^{\land}a\\
&=\underset{\varphi\rightarrow0}{lim}\frac{-Rp^{\land}\varphi}{\varphi}\\
&=-Rp^{\land}
\end{align*}\tag{13}</script><ul>
<li>旋转连乘的雅可比：</li>
</ul>
<p>①这里将对$R_2$进行一次的扰动$\Delta R_2$加在其对应的李代数$\phi $上，而非李群上。</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{d\ ln(R_1R_2)^{\lor} }{dR_2}
&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\cdot exp(\phi^{\land}))^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\
&\approx\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2)^{\lor}+J^{-1}_r\phi-ln(R_1R_2)^{\lor} }{\phi}\\
&=J^{-1}_r(ln(R_1R_2)^{\lor})
\end{align*}\tag{14}</script><p>第一步到第二步使用的是$BCH$近似公式：</p>
<script type="math/tex; mode=display">
\ln (\exp(\phi_{1}^{\land})\exp(\phi_{2}^{\land}) )^{\lor} \approx
\left\{ \begin{array}{l}
J_l(\phi_{2})^{-1}\phi_{1}+\phi_{2}\ \ \ \ 当\phi_{1}为小量\\
J_r(\phi_{1})^{-1}\phi_{2}+\phi_{1}\ \ \ \ 当\phi_{2}为小量    \\
\end{array} \right.\tag{15}</script><p>此处就是：对任意$R$</p>
<script type="math/tex; mode=display">
\ln (R\exp(\phi^{\land}) )^{\lor} \approx\ln(R)^{\lor}+J_r^{-1}\phi\tag{16}</script><p>其中$J_r^{-1}$为$SO(3)$上的右雅可比：</p>
<script type="math/tex; mode=display">
J_r^{-1}(\theta w)=\frac{1}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})ww^T+\frac{\theta}{2}w^{\land}\tag{17}</script><p>②这里将对$R_1$进行一次的扰动$\Delta R_1$加在其对应的李代数$\phi $上，而非李群上。</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{d\ ln(R_1R_2)^{\lor} }{dR_2}
&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1\cdot \exp(\phi^{\land})\ R_2)^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\
&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\cdot[R_2^T\cdot \exp(\phi^{\land})\ R_2])^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\
&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\exp((R_2^T\phi)^{\land}))^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\
&=J^{-1}_r(ln(R_1R_2)^{\lor})R_2^T
\end{align*}\tag{18}</script><p>第一步到第二步用到了$sO(3)$的伴随性质：</p>
<script type="math/tex; mode=display">
R^T\exp(\phi^{\land})R=\exp((R^T\phi)^{\land})\tag{19}</script><p>有关 $SE(3)$：由于$ SE(3)$ 李代数性质复杂，在 VIO 中，我们通常使用$SO(3) + t $的形式表达旋转和平移。对平移部分使用矢量更新而非$SE(3) $上的更新。</p>
]]></content>
      <categories>
        <category>从零开始手写VIO</category>
      </categories>
      <tags>
        <tag>VIO</tag>
        <tag>刚体运动</tag>
      </tags>
  </entry>
  <entry>
    <title>aloam_velodyney源代码深度解析</title>
    <url>/posts/60089.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>体验过LOAM代码之后，大多数人应该对源代码有种不太好的印象，我觉得更多是因为LOAM作者受当时发展的局限，没有使用像现在流行的李代数、Eigen、Ceres等，A-LOAM就在其基础上对源代码进行了改进，最明显的就是坐标变化部分引入了Eigen，优化部分使用Ceres自动求导代替LOAM作者手推的ICP优化部分，代码变得十分简洁，但是同时也降低了LOAM算法的效率。尽管如此，这位香港大学的秦师兄写的代码还是很让人佩服的。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>首先看一下ROS节点图，明显可以发现比LOAM的简洁太多了：</p>
<p><img src="/images/aloam源码解析/1308994-20200506202232477-859678963.png" alt="img"></p>
]]></content>
      <categories>
        <category>SLAM项目实践</category>
      </categories>
      <tags>
        <tag>ALOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>LOAM源代码深度解析</title>
    <url>/posts/49015.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>对于LOAM的论文以及原理清晰之后，我们还需要对论文算法的具体实现做深度剖析，做到将论文的每一部分与代码相对应，并学习LOAM实现的方式。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ.概述"></a>Ⅰ.概述</h1><p>由于LOAM使用机器人操作系统(ROS)进行管理，所以我们比较关注节点和消息发布与接收的关系，我们可以通过rqt_graph查看所有的节点以及消息之间的关系，代码的框架图：</p>
<p><img src="/images/LOAM源代码解析/rosgraph_loam-16498556914162.png" alt="rosgraph_loam"></p>
<p>其中椭圆框代表节点(node)，矩形框代表消息(Message)。</p>
<h1 id="Ⅱ-scanRegistration"><a href="#Ⅱ-scanRegistration" class="headerlink" title="Ⅱ.scanRegistration"></a>Ⅱ.scanRegistration</h1><p> <span style="color:red;"><strong>节点的主要功能:</strong></span> <span style="color:blue;"><strong>对点云和IMU数据进行预处理，用于特征点的配准。</strong></span> </p>
<p><img src="/images/LOAM源代码解析/image-20220416144530168.png" alt="image-20220416144530168"></p>
<h2 id="A-laserCloudHandler"><a href="#A-laserCloudHandler" class="headerlink" title="A.laserCloudHandler"></a>A.laserCloudHandler</h2><p><img src="/images/LOAM源代码解析/image-20220414193914478.png" alt="image-20220414193914478"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扫描周期, velodyne频率10Hz，周期0.1s</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> scanPeriod = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化控制变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> systemDelay = <span class="number">20</span>; <span class="comment">//弃用前20帧初始数据</span></span><br><span class="line"><span class="keyword">int</span> systemInitCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> systemInited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//激光雷达线数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_SCANS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点云曲率, 40000为一帧点云中点的最大数量</span></span><br><span class="line"><span class="keyword">float</span> cloudCurvature[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//曲率点对应的序号</span></span><br><span class="line"><span class="keyword">int</span> cloudSortInd[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点是否筛选过标志：0-未筛选过，1-筛选过</span></span><br><span class="line"><span class="keyword">int</span> cloudNeighborPicked[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点分类标号:2-代表曲率很大，1-代表曲率比较大,-1-代表曲率很小，0-曲率比较小(其中1包含了2,0包含了1,0和1构成了点云全部的点)</span></span><br><span class="line"><span class="keyword">int</span> cloudLabel[<span class="number">40000</span>];</span><br></pre></td></tr></table></figure>
<p><code>N_SCANS</code> 是将 <code>3D</code> 的激光点云按照激光的接受器做了个划分，比如 <code>N_SCANS</code>是 $16 $表明是 $16 $线的激光（程序中的默认值，作者用过 <code>velodyne16</code>）。</p>
<p>论文中存储每个点的曲率用的是数组，因此需要考虑数组的大小，这里设置为了$40000$，另外使用<code>cloudLabel</code>来标记论文中提到的将扫描分割成四个相同的子区域，2-代表曲率很大(sharp)，1-代表曲率比较大(less_sharp)，-1-代表曲率很小(flat)，0-曲率比较小(less_flat)。</p>
<h3 id="1-线束模型"><a href="#1-线束模型" class="headerlink" title="1.线束模型"></a>1.线束模型</h3><p>对于一堆点云并不是像 LaserScan（二维的数据结构）那样按照角度给出个距离值，保证每次的扫描都能够有相同大小的数据量。PointCloud2 接受到的点云的大小在变化，因此在数据到达需要一些运算来判断点的一些特性。例如下面这段通过计算 pitch 角度判断该点属于哪个<code>Scan</code>。</p>
<p>(具体查看：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#A-%E7%BA%BF%E6%9D%9F%E6%A8%A1%E5%9E%8B">loam论文深度解析-Ⅲ.特征提取（点云注册）A.线束模型</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lidar扫描线是否旋转过半</span></span><br><span class="line"><span class="keyword">bool</span> halfPassed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> count = cloudSize;</span><br><span class="line">PointType point;</span><br><span class="line">std::vector&lt;pcl::PointCloud&lt;PointType&gt;&gt; <span class="built_in">laserCloudScans</span>(N_SCANS);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//坐标轴交换，velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系</span></span><br><span class="line">    point.x = laserCloudIn.points[i].y;</span><br><span class="line">    point.y = laserCloudIn.points[i].z;</span><br><span class="line">    point.z = laserCloudIn.points[i].x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算点的仰角(根据lidar文档垂直角计算公式),根据仰角排列激光线号，velodyne每两个scan之间间隔2度</span></span><br><span class="line">    <span class="keyword">float</span> angle = <span class="built_in">atan</span>(point.y / <span class="built_in">sqrt</span>(point.x * point.x + point.z * point.z)) * <span class="number">180</span> / M_PI;</span><br><span class="line">    <span class="keyword">int</span> scanID;</span><br><span class="line">    <span class="comment">//仰角四舍五入(加减0.5截断效果等于四舍五入)</span></span><br><span class="line">    <span class="keyword">int</span> roundedAngle = <span class="built_in"><span class="keyword">int</span></span>(angle + (angle &lt; <span class="number">0.0</span> ? <span class="number">-0.5</span> : +<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">if</span> (roundedAngle &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	scanID = roundedAngle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	scanID = roundedAngle + (N_SCANS - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤点，只挑选[-15度，+15度]范围内的点,scanID属于[0,15]</span></span><br><span class="line">    <span class="keyword">if</span> (scanID &gt; (N_SCANS - <span class="number">1</span>) || scanID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解析】这里8-11行的坐标轴变换，有点绕，作者的意思就是把velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系：</p>
<p><img src="/images/LOAM源代码解析/image-20220414153416294.png" alt="image-20220414153416294" style="zoom:50%;" /></p>
<p>然后就是利用勾股定理与三角函数相关的知识求出仰角$Pitch=atan(z/\sqrt{x^2+y^2})$，即可根据该角度判断点云属于哪条<code>Scan</code>，这样就可以计算出每个点的<code>scanID</code>。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扫描周期, velodyne频率10Hz，周期0.1s</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> scanPeriod = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">typedef</span> pcl::PointXYZI PointType;</span><br><span class="line">PointType point;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//-0.5 &lt; relTime &lt; 1.5（点旋转的角度与整个周期旋转角度的比率, 即点云中点的相对时间）</span></span><br><span class="line"><span class="keyword">float</span> relTime = (ori - startOri) / (endOri - startOri);</span><br><span class="line"><span class="comment">//点强度=线号+点相对时间（即一个整数+一个小数，整数部分是线号，小数部分是该点的相对时间）,匀速扫描：根据当前扫描的角度和扫描周期计算相对扫描起始位置的时间</span></span><br><span class="line">point.intensity = scanID + scanPeriod * relTime;</span><br></pre></td></tr></table></figure>
<p>【解析】点云中点的相对时间是用当前的点旋转的角度占整个周期旋转角度的比，然后使用<code>PointXYZI</code>点云类型存储点云数据，整数部分：scan ID，小数部分：每个点扫描的时间。</p>
<blockquote>
<p><code>PointXYZI</code>是一个简单的<code>XYZ</code>坐标加<code>intensity</code>的<code>point</code>类型，理想情况下，这四个变量将新建单独一个结构体，并且满足存储对齐，然而，由于<code>point</code>的大部分操作会把<code>data[4]</code>元素设置成$0$或$1$（用于变换），不能让<code>intensity</code>与<code>xyz</code>在同一个结构体中，如果这样的话其内容将会被覆盖。例如，两个点的点积会把他们的第四个元素设置成0，否则该点积没有意义，等等。因此，对于兼容存储对齐，用三个额外的浮点数来填补intensity，这样在存储方面效率较低，但是符合存储对齐要求，运行效率较高。</p>
</blockquote>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//IMU部分代码.......</span></span><br><span class="line">    laserCloudScans[scanID].<span class="built_in">push_back</span>(point);<span class="comment">//将每个补偿矫正（IMU部分代码）的点放入对应线号的容器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得有效范围内的点的数量</span></span><br><span class="line">cloudSize = count;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_SCANS; i++)</span><br><span class="line">&#123; 	<span class="comment">//将所有的点按照线号从小到大放入一个容器</span></span><br><span class="line">    *laserCloud += laserCloudScans[i];<span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解析】将点压入到每个线中，然后循环迭代每一条<code>Scan</code>,更新到总的点云<code>laserCloud</code>。</p>
<hr>
<h3 id="2-插入IMU数据"><a href="#2-插入IMU数据" class="headerlink" title="2.插入IMU数据"></a>2.插入IMU数据</h3><p>插入<code>IMU</code>数据的目的就是校正点云畸变，论文中提到蓝色线段表示扫描$k$时感知到的点云 $P_k$，在$k$次扫描结束时，经过<strong>畸变校正</strong>之后将$P_k$重新投影到时间戳$t_{k+1}$，得到绿色线段$\overline{P}_k$，这里的畸变校正使用的就是插入<code>IMU</code>数据进行补偿来进行校正的。通过代码看一下如何使用<code>IMU</code>进行校正的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lidar扫描线是否旋转过半</span></span><br><span class="line"><span class="keyword">bool</span> halfPassed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> count = cloudSize;</span><br><span class="line">PointType point;</span><br><span class="line">std::vector&lt;pcl::PointCloud&lt;PointType&gt;&gt; <span class="built_in">laserCloudScans</span>(N_SCANS);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 线束模型部分的代码....</span></span><br><span class="line">  <span class="keyword">float</span> relTime = (ori - startOri) / (endOri - startOri);</span><br><span class="line">  <span class="comment">//点强度=线号+点相对时间（即一个整数+一个小数，整数部分是线号，小数部分是该点的相对时间）,匀速扫描：根据当前扫描的角度和扫描周期计算相对扫描起始位置的时间</span></span><br><span class="line">  point.intensity = scanID + scanPeriod * relTime;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点时间=点云时间+周期时间</span></span><br><span class="line">  <span class="keyword">if</span> (imuPointerLast &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;                                         <span class="comment">//如果收到IMU数据,使用IMU矫正点云畸变</span></span><br><span class="line">    <span class="keyword">float</span> pointTime = relTime * scanPeriod; <span class="comment">//计算点的周期时间</span></span><br><span class="line">    <span class="comment">//寻找是否有点云的时间戳小于IMU的时间戳的IMU位置:imuPointerFront</span></span><br><span class="line">    <span class="keyword">while</span> (imuPointerFront != imuPointerLast)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeScanCur + pointTime &lt; imuTime[imuPointerFront])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      imuPointerFront = (imuPointerFront + <span class="number">1</span>) % imuQueLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeScanCur + pointTime &gt; imuTime[imuPointerFront])</span><br><span class="line">    &#123; <span class="comment">//没找到,此时imuPointerFront==imtPointerLast,只能以当前收到的最新的IMU的速度，位移，欧拉角作为当前点的速度，位移，欧拉角使用</span></span><br><span class="line">      imuRollCur = imuRoll[imuPointerFront];</span><br><span class="line">      imuPitchCur = imuPitch[imuPointerFront];</span><br><span class="line">      imuYawCur = imuYaw[imuPointerFront];</span><br><span class="line"></span><br><span class="line">      imuVeloXCur = imuVeloX[imuPointerFront];</span><br><span class="line">      imuVeloYCur = imuVeloY[imuPointerFront];</span><br><span class="line">      imuVeloZCur = imuVeloZ[imuPointerFront];</span><br><span class="line"></span><br><span class="line">      imuShiftXCur = imuShiftX[imuPointerFront];</span><br><span class="line">      imuShiftYCur = imuShiftY[imuPointerFront];</span><br><span class="line">      imuShiftZCur = imuShiftZ[imuPointerFront];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//找到了点云时间戳小于IMU时间戳的IMU位置,则该点必处于imuPointerBack和imuPointerFront之间，据此线性插值，计算点云点的速度，位移和欧拉角</span></span><br><span class="line">      <span class="keyword">int</span> imuPointerBack = (imuPointerFront + imuQueLength - <span class="number">1</span>) % imuQueLength;</span><br><span class="line">      <span class="comment">//按时间距离计算权重分配比率,也即线性插值</span></span><br><span class="line">      <span class="keyword">float</span> ratioFront = (timeScanCur + pointTime - imuTime[imuPointerBack]) / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);</span><br><span class="line">      <span class="keyword">float</span> ratioBack = (imuTime[imuPointerFront] - timeScanCur - pointTime) / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);</span><br><span class="line"></span><br><span class="line">      imuRollCur = imuRoll[imuPointerFront] * ratioFront + imuRoll[imuPointerBack] * ratioBack;</span><br><span class="line">      imuPitchCur = imuPitch[imuPointerFront] * ratioFront + imuPitch[imuPointerBack] * ratioBack;</span><br><span class="line">      <span class="keyword">if</span> (imuYaw[imuPointerFront] - imuYaw[imuPointerBack] &gt; M_PI)</span><br><span class="line">      &#123;</span><br><span class="line">        imuYawCur = imuYaw[imuPointerFront] * ratioFront + (imuYaw[imuPointerBack] + <span class="number">2</span> * M_PI) * ratioBack;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (imuYaw[imuPointerFront] - imuYaw[imuPointerBack] &lt; -M_PI)</span><br><span class="line">      &#123;</span><br><span class="line">        imuYawCur = imuYaw[imuPointerFront] * ratioFront + (imuYaw[imuPointerBack] - <span class="number">2</span> * M_PI) * ratioBack;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        imuYawCur = imuYaw[imuPointerFront] * ratioFront + imuYaw[imuPointerBack] * ratioBack;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//本质:imuVeloXCur = imuVeloX[imuPointerback] + (imuVelX[imuPointerFront]-imuVelX[imuPoniterBack])*ratioFront</span></span><br><span class="line">      imuVeloXCur = imuVeloX[imuPointerFront] * ratioFront + imuVeloX[imuPointerBack] * ratioBack;</span><br><span class="line">      imuVeloYCur = imuVeloY[imuPointerFront] * ratioFront + imuVeloY[imuPointerBack] * ratioBack;</span><br><span class="line">      imuVeloZCur = imuVeloZ[imuPointerFront] * ratioFront + imuVeloZ[imuPointerBack] * ratioBack;</span><br><span class="line"></span><br><span class="line">      imuShiftXCur = imuShiftX[imuPointerFront] * ratioFront + imuShiftX[imuPointerBack] * ratioBack;</span><br><span class="line">      imuShiftYCur = imuShiftY[imuPointerFront] * ratioFront + imuShiftY[imuPointerBack] * ratioBack;</span><br><span class="line">      imuShiftZCur = imuShiftZ[imuPointerFront] * ratioFront + imuShiftZ[imuPointerBack] * ratioBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//如果是第一个点,记住点云起始位置的速度，位移，欧拉角</span></span><br><span class="line">      imuRollStart = imuRollCur;</span><br><span class="line">      imuPitchStart = imuPitchCur;</span><br><span class="line">      imuYawStart = imuYawCur;</span><br><span class="line"></span><br><span class="line">      imuVeloXStart = imuVeloXCur;</span><br><span class="line">      imuVeloYStart = imuVeloYCur;</span><br><span class="line">      imuVeloZStart = imuVeloZCur;</span><br><span class="line"></span><br><span class="line">      imuShiftXStart = imuShiftXCur;</span><br><span class="line">      imuShiftYStart = imuShiftYCur;</span><br><span class="line">      imuShiftZStart = imuShiftZCur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//计算之后每个点相对于第一个点的由于加减速非匀速运动产生的位移速度畸变，并对点云中的每个点位置信息重新补偿矫正</span></span><br><span class="line">      <span class="built_in">ShiftToStartIMU</span>(pointTime);</span><br><span class="line">      <span class="built_in">VeloToStartIMU</span>();</span><br><span class="line">      <span class="built_in">TransformToStartIMU</span>(&amp;point);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  laserCloudScans[scanID].<span class="built_in">push_back</span>(point); <span class="comment">//将每个补偿矫正的点放入对应线号的容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截止到现在，我们已经把一帧杂乱的点云数据有条理的放在了容器里</p>
<h3 id="3-曲率计算"><a href="#3-曲率计算" class="headerlink" title="3.曲率计算"></a>3.曲率计算</h3><p>在前面的论文深度剖析中，我们提到点云的注册就是进行特征提取，而LOAM进行特征提取采用的是曲率$c$进行判断的，提取的特征主要为边缘点和平面点两种特征。</p>
<p><strong>平面光滑度</strong>$c$：</p>
<script type="math/tex; mode=display">
c=\frac{1}{|S|·\parallel X^L_{(k,i)}\parallel} \sum_{j\in S,j\ne i} \parallel (X^L_{(k,i)}-X^L_{(k,j)}) \parallel \tag{1}</script><p><strong>代码部分：</strong></p>
<p>这里计算曲率的方式和论文中有点不同，计算以某点与其相邻的$10$个点所构成的平面在该点出的曲率：</p>
<p>由曲率公式知：$K=1/R$，因此为简化计算可通过$10$个向量的和向量的模长表示其在该点处曲率半径的长，因此$R×R$可用来表示曲率的大小 $R×R$越大，该点处越不平坦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> scanCount = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 选取该点周围十个点（向前找五个，向后找五个），将这十个点的坐标分别和该点作差，得到每一维坐标的差值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">5</span>; i++) </span><br><span class="line">&#123;<span class="comment">//使用每个点的前后五个点计算曲率，因此前五个与最后五个点跳过</span></span><br><span class="line">    <span class="keyword">float</span> diffX = laserCloud-&gt;points[i - <span class="number">5</span>].x + laserCloud-&gt;points[i - <span class="number">4</span>].x </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">3</span>].x + laserCloud-&gt;points[i - <span class="number">2</span>].x </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">1</span>].x - <span class="number">10</span> * laserCloud-&gt;points[i].x </span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">1</span>].x + laserCloud-&gt;points[i + <span class="number">2</span>].x</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">3</span>].x + laserCloud-&gt;points[i + <span class="number">4</span>].x</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">5</span>].x;</span><br><span class="line">    <span class="keyword">float</span> diffY = laserCloud-&gt;points[i - <span class="number">5</span>].y + laserCloud-&gt;points[i - <span class="number">4</span>].y </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">3</span>].y + laserCloud-&gt;points[i - <span class="number">2</span>].y </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">1</span>].y - <span class="number">10</span> * laserCloud-&gt;points[i].y </span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">1</span>].y + laserCloud-&gt;points[i + <span class="number">2</span>].y</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">3</span>].y + laserCloud-&gt;points[i + <span class="number">4</span>].y</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">5</span>].y;</span><br><span class="line">    <span class="keyword">float</span> diffZ = laserCloud-&gt;points[i - <span class="number">5</span>].z + laserCloud-&gt;points[i - <span class="number">4</span>].z </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">3</span>].z + laserCloud-&gt;points[i - <span class="number">2</span>].z </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">1</span>].z - <span class="number">10</span> * laserCloud-&gt;points[i].z </span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">1</span>].z + laserCloud-&gt;points[i + <span class="number">2</span>].z</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">3</span>].z + laserCloud-&gt;points[i + <span class="number">4</span>].z</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">5</span>].z;</span><br><span class="line">    <span class="comment">//曲率计算（将三个维度的差值求平方和得到R×R）</span></span><br><span class="line">    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;</span><br><span class="line">    <span class="comment">//记录曲率点的索引</span></span><br><span class="line">    cloudSortInd[i] = i;</span><br><span class="line">    <span class="comment">//初始时，点全未筛选过</span></span><br><span class="line">    cloudNeighborPicked[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化为less flat点</span></span><br><span class="line">    cloudLabel[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个scan，只有第一个符合的点会进来，因为每个scan的点都在一起存放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloud-&gt;points[i].intensity) != scanCount) </span><br><span class="line">    &#123;</span><br><span class="line">      scanCount = <span class="built_in"><span class="keyword">int</span></span>(laserCloud-&gt;points[i].intensity);<span class="comment">//控制每个scan只进入第一个点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//曲率只取同一个scan计算出来的，跨scan计算的曲率非法，排除，也即排除每个scan的前后五个点</span></span><br><span class="line">      <span class="keyword">if</span> (scanCount &gt; <span class="number">0</span> &amp;&amp; scanCount &lt; N_SCANS) </span><br><span class="line">      &#123;</span><br><span class="line">        scanStartInd[scanCount] = i + <span class="number">5</span>;	<span class="comment">// 该scan的起始点位置的索引（滤出前5个点）</span></span><br><span class="line">        scanEndInd[scanCount - <span class="number">1</span>] = i - <span class="number">5</span>;  <span class="comment">// 该scan的终止点位置的索引(滤出后5个点)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个scan曲率点有效点序从第5个开始，最后一个激光线结束点序size-5</span></span><br><span class="line">scanStartInd[<span class="number">0</span>] = <span class="number">5</span>;				<span class="comment">// 第一条线的起始位置</span></span><br><span class="line">scanEndInd.<span class="built_in">back</span>() = cloudSize - <span class="number">5</span>;  <span class="comment">// 最后一条线的终止位置</span></span><br></pre></td></tr></table></figure>
<p>【解析】：这里对所有的点云的曲率进行了计算，由于这里使用的方法是某个点云的前后各五点与该点进行作差处理，所以循环的开始就跳过了前后各5个点云的计算。因为是按照线的序列存储，因此接下来能够得到起始和终止的 index。</p>
<h3 id="4-排除不可考点"><a href="#4-排除不可考点" class="headerlink" title="4.排除不可考点"></a>4.排除不可考点</h3><p>参照论文对与点位筛选的条件：1. 平面/直线与激光近似平行的点不能要； 2. 被遮挡的边缘点不能要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挑选点，排除容易被斜面挡住的点以及离群点，有些点容易被斜面挡住，而离群点可能出现带有偶然性，这些情况都可能导致前后两次扫描不能被同时看到</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; i++)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/*2. 被遮挡的边缘点不能要*/</span></span><br><span class="line">    <span class="comment">//与后一个点差值，所以减6</span></span><br><span class="line">    <span class="keyword">float</span> diffX = laserCloud-&gt;points[i + <span class="number">1</span>].x - laserCloud-&gt;points[i].x;</span><br><span class="line">    <span class="keyword">float</span> diffY = laserCloud-&gt;points[i + <span class="number">1</span>].y - laserCloud-&gt;points[i].y;</span><br><span class="line">    <span class="keyword">float</span> diffZ = laserCloud-&gt;points[i + <span class="number">1</span>].z - laserCloud-&gt;points[i].z;</span><br><span class="line">    <span class="comment">//计算有效曲率点与后一个点之间的距离平方和</span></span><br><span class="line">    <span class="keyword">float</span> diff = diffX * diffX + diffY * diffY + diffZ * diffZ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0.1</span>)</span><br><span class="line">    &#123; <span class="comment">//前提:两个点之间距离要大于0.1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//点的深度</span></span><br><span class="line">      <span class="keyword">float</span> depth1 = <span class="built_in">sqrt</span>(laserCloud-&gt;points[i].x * laserCloud-&gt;points[i].x +</span><br><span class="line">                          laserCloud-&gt;points[i].y * laserCloud-&gt;points[i].y +</span><br><span class="line">                          laserCloud-&gt;points[i].z * laserCloud-&gt;points[i].z);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//后一个点的深度</span></span><br><span class="line">      <span class="keyword">float</span> depth2 = <span class="built_in">sqrt</span>(laserCloud-&gt;points[i + <span class="number">1</span>].x * laserCloud-&gt;points[i + <span class="number">1</span>].x +</span><br><span class="line">                          laserCloud-&gt;points[i + <span class="number">1</span>].y * laserCloud-&gt;points[i + <span class="number">1</span>].y +</span><br><span class="line">                          laserCloud-&gt;points[i + <span class="number">1</span>].z * laserCloud-&gt;points[i + <span class="number">1</span>].z);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//按照两点的深度的比例，将深度较大的点拉回后计算距离</span></span><br><span class="line">      <span class="keyword">if</span> (depth1 &gt; depth2)</span><br><span class="line">      &#123;</span><br><span class="line">        diffX = laserCloud-&gt;points[i + <span class="number">1</span>].x - laserCloud-&gt;points[i].x * depth2 / depth1;</span><br><span class="line">        diffY = laserCloud-&gt;points[i + <span class="number">1</span>].y - laserCloud-&gt;points[i].y * depth2 / depth1;</span><br><span class="line">        diffZ = laserCloud-&gt;points[i + <span class="number">1</span>].z - laserCloud-&gt;points[i].z * depth2 / depth1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边长比也即是弧度值，若小于0.1，说明夹角比较小，斜面比较陡峭,点深度变化比较剧烈,点处在近似与激光束平行的斜面上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>(diffX * diffX + diffY * diffY + diffZ * diffZ) / depth2 &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123; <span class="comment">//排除容易被斜面挡住的点</span></span><br><span class="line">          <span class="comment">//该点及前面五个点（大致都在斜面上）全部置为筛选过</span></span><br><span class="line">          cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        diffX = laserCloud-&gt;points[i + <span class="number">1</span>].x * depth1 / depth2 - laserCloud-&gt;points[i].x;</span><br><span class="line">        diffY = laserCloud-&gt;points[i + <span class="number">1</span>].y * depth1 / depth2 - laserCloud-&gt;points[i].y;</span><br><span class="line">        diffZ = laserCloud-&gt;points[i + <span class="number">1</span>].z * depth1 / depth2 - laserCloud-&gt;points[i].z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>(diffX * diffX + diffY * diffY + diffZ * diffZ) / depth1 &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*1. 平面/直线与激光近似平行的点不能要；*/</span></span><br><span class="line">    <span class="keyword">float</span> diffX2 = laserCloud-&gt;points[i].x - laserCloud-&gt;points[i - <span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">float</span> diffY2 = laserCloud-&gt;points[i].y - laserCloud-&gt;points[i - <span class="number">1</span>].y;</span><br><span class="line">    <span class="keyword">float</span> diffZ2 = laserCloud-&gt;points[i].z - laserCloud-&gt;points[i - <span class="number">1</span>].z;</span><br><span class="line">    <span class="comment">//与前一个点的距离平方和</span></span><br><span class="line">    <span class="keyword">float</span> diff2 = diffX2 * diffX2 + diffY2 * diffY2 + diffZ2 * diffZ2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点深度的平方和</span></span><br><span class="line">    <span class="keyword">float</span> dis = laserCloud-&gt;points[i].x * laserCloud-&gt;points[i].x + laserCloud-&gt;points[i].y * laserCloud-&gt;points[i].y + laserCloud-&gt;points[i].z * laserCloud-&gt;points[i].z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与前后点的平方和都大于深度平方和的万分之二，这些点视为离群点，包括陡斜面上的点，强烈凸凹点和空旷区域中的某些点，置为筛选过，弃用</span></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0.0002</span> * dis &amp;&amp; diff2 &gt; <span class="number">0.0002</span> * dis)</span><br><span class="line">    &#123;</span><br><span class="line">      cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>【解析】：遍历所有点（除去前五个和后六个），判断该点及其周边点是否可以作为为特征点位：当某点及其后点间的距离平方大于某阈值$a$（说明这两点有一定距离），且两向量夹角小于某阈值$b$时（夹角小就可能存在遮挡），将其一侧的临近$6$个点设为不可标记为特征点的点；若某点到其前后两点的距离均大于$c$倍的该点深度，则该点判定为不可标记特征点的点（入射角越小，点间距越大，即激光发射方向与投射到的平面越近似水平）。</p>
<h3 id="5-边缘点-平面点判断与存储"><a href="#5-边缘点-平面点判断与存储" class="headerlink" title="5.边缘点/平面点判断与存储"></a>5.边缘点/平面点判断与存储</h3><p>这部分代码比较长，现把整个代码结构概览一下：</p>
<ul>
<li>首先是相关的变量定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个scan曲率点有效点序从第5个开始，最后一个激光线结束点序size-5</span></span><br><span class="line">scanStartInd[<span class="number">0</span>] = <span class="number">5</span>;				<span class="comment">// 第一条线的起始位置</span></span><br><span class="line">scanEndInd.<span class="built_in">back</span>() = cloudSize - <span class="number">5</span>;  <span class="comment">// 最后一条线的终止位置</span></span><br><span class="line"><span class="comment">// 用于提取边缘点</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; cornerPointsSharp;     <span class="comment">//曲率特别大的边缘点（sharp）</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; cornerPointsLessSharp; <span class="comment">//曲率大的边缘点（less_sharp）</span></span><br><span class="line"><span class="comment">// 用于提取平面点</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; surfPointsFlat;        <span class="comment">//曲率特别小的平面点（flat）</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; surfPointsLessFlat;    <span class="comment">//曲率特小的平面点（less_flat）</span></span><br></pre></td></tr></table></figure>
<p>【解析】：至此，我们得到了一组有条理的点云，且把那些与我们想提取的特征不符的点标记了出来，但是为了使得特征点均匀分布在环境中，将一次扫描划分为$4$个独立的子区域，每个子区域最多提供$2$个边缘点和$4$个平面点。我们只需要预先设定好阈值，就可以轻松加随意的将这些点分类了。</p>
<hr>
<ul>
<li>最主要的部分就是下面这个循环：</li>
</ul>
<p><img src="/images/LOAM源代码解析/image-20220414184417130.png" alt="image-20220414184417130"></p>
<p>【解析】：这里作者将每一线划分为等间距的 $6 $段分别处理，每一段的点按照曲率升序排列。<code>cloudSortInd</code>是对曲率排序得到的序列。</p>
<blockquote>
<p>为啥分成六等份？</p>
<p>这里作者将360°分成六等份，每一份去提取相同的特征点。这样做的目的主要是为了使得特征点的分配更加均匀。如果不这么操作，很容易出现某一个视角区域大曲率的点特别多，而某些视角区域却特别少，造成特征点提取的不均匀，大都集中在某个特别窄的视角内，这会使得在求解或优化的时候造成病态。</p>
</blockquote>
<ul>
<li>按曲率从小到大冒泡排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sp + <span class="number">1</span>; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &gt;= sp + <span class="number">1</span>; l--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果后面曲率点大于前面，则交换</span></span><br><span class="line">        <span class="keyword">if</span> (cloudCurvature[cloudSortInd[l]] &lt; cloudCurvature[cloudSortInd[l - <span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cloudSortInd[l - <span class="number">1</span>];</span><br><span class="line">            cloudSortInd[l - <span class="number">1</span>] = cloudSortInd[l];</span><br><span class="line">            cloudSortInd[l] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>挑选边缘特征点：每个分段的曲率很大和比较大的点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//曲率点对应的序号</span></span><br><span class="line"><span class="keyword">int</span> cloudSortInd[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点是否筛选过标志：0-未筛选过，1-筛选过</span></span><br><span class="line"><span class="keyword">int</span> cloudNeighborPicked[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点分类标号:2-代表曲率很大，1-代表曲率比较大,-1-代表曲率很小，0-曲率比较小(其中1包含了2,0包含了1,0和1构成了点云全部的点)</span></span><br><span class="line"><span class="keyword">int</span> cloudLabel[<span class="number">40000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//挑选每个分段的曲率很大和比较大的点</span></span><br><span class="line"><span class="keyword">int</span> largestPickedNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = ep; k &gt;= sp; k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = cloudSortInd[k]; <span class="comment">//曲率最大点的点序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果曲率大的点，曲率的确比较大（阈值大于0.1），并且未被筛选过滤掉（cloudNeighborPicked=0）</span></span><br><span class="line">    <span class="keyword">if</span> (cloudNeighborPicked[ind] == <span class="number">0</span> &amp;&amp; cloudCurvature[ind] &gt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largestPickedNum++;</span><br><span class="line">        <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;                      <span class="comment">//挑选曲率最大的前2个点放入sharp点集合</span></span><br><span class="line">            cloudLabel[ind] = <span class="number">2</span>; <span class="comment">// 2代表点曲率很大</span></span><br><span class="line">            cornerPointsSharp.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line">            cornerPointsLessSharp.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">20</span>)</span><br><span class="line">        &#123;                      <span class="comment">//挑选曲率最大的前20个点放入less sharp点集合</span></span><br><span class="line">            cloudLabel[ind] = <span class="number">1</span>; <span class="comment">// 1代表点曲率比较尖锐</span></span><br><span class="line">            cornerPointsLessSharp.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cloudNeighborPicked[ind] = <span class="number">1</span>; <span class="comment">//筛选标志置位</span></span><br><span class="line">        <span class="comment">//将曲率比较大的点的前后各5个连续距离比较近的点筛选出去，防止特征点聚集，使得特征点在每个方向上尽量分布均匀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l - <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l - <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l - <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l + <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l + <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l + <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解析】：对每个段进行循环迭代，将曲率比较大的（代码中定义阈值为0.1），而且要求该点并且未被筛选过滤掉，经过冒泡排序后，所有的曲率都已经完成排序，我们将前2个曲率最大的存入为“sharp”点集合，将前20曲率最大存入“less_sharp”点集合；为了使得特征点在每个方向上尽量分布均匀，不聚集，将曲率比较大的点的前后各5个连续距离比较近的点筛选出去。</p>
<ul>
<li>挑选平面特征点：每个分段的曲率很小比较小的点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挑选每个分段的曲率很小比较小的点</span></span><br><span class="line"><span class="keyword">int</span> smallestPickedNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = cloudSortInd[k];</span><br><span class="line">    <span class="comment">//如果曲率的确比较小，并且未被筛选出</span></span><br><span class="line">    <span class="keyword">if</span> (cloudNeighborPicked[ind] == <span class="number">0</span> &amp;&amp; cloudCurvature[ind] &lt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cloudLabel[ind] = <span class="number">-1</span>; <span class="comment">//-1代表曲率很小的点</span></span><br><span class="line">        surfPointsFlat.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line"></span><br><span class="line">        smallestPickedNum++;</span><br><span class="line">        <span class="keyword">if</span> (smallestPickedNum &gt;= <span class="number">4</span>)</span><br><span class="line">        &#123; <span class="comment">//只选最小的四个，剩下的Label==0,就都是曲率比较小的</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cloudNeighborPicked[ind] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">        &#123; <span class="comment">//同样防止特征点聚集</span></span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l - <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l - <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l - <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l + <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l + <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l + <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解析】：这里与边缘特征点的选取大同小异，只不过这里选择了四个平面特征点。</p>
<ul>
<li>将剩余的点（包括之前被排除的点）全部归入平面点中less flat类别中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将剩余的点（包括之前被排除的点）全部归入平面点中less flat类别中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        surfPointsLessFlatScan-&gt;<span class="built_in">push_back</span>(laserCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后对每个分段less flat的点进行体素栅格滤波</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于less flat点最多，对每个分段less flat的点进行体素栅格滤波</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; surfPointsLessFlatScanDS;</span><br><span class="line">pcl::VoxelGrid&lt;PointType&gt; downSizeFilter;</span><br><span class="line">downSizeFilter.<span class="built_in">setInputCloud</span>(surfPointsLessFlatScan);</span><br><span class="line">downSizeFilter.<span class="built_in">setLeafSize</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);</span><br><span class="line">downSizeFilter.<span class="built_in">filter</span>(surfPointsLessFlatScanDS);</span><br><span class="line"><span class="comment">// less flat点汇总</span></span><br><span class="line">surfPointsLessFlat += surfPointsLessFlatScanDS;</span><br></pre></td></tr></table></figure>
<p>收尾部分：最后作者用 4 个 pcl::Point XYZ 类型的数组来存储 IMU 的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">laserCloudHandler</span><span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">  <span class="comment">// publish消除非匀速运动畸变后的所有的点</span></span><br><span class="line">  sensor_msgs::PointCloud2 laserCloudOutMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(*laserCloud, laserCloudOutMsg);</span><br><span class="line">  laserCloudOutMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  laserCloudOutMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubLaserCloud.<span class="built_in">publish</span>(laserCloudOutMsg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// publish消除非匀速运动畸变后的平面点和边沿点</span></span><br><span class="line">  sensor_msgs::PointCloud2 cornerPointsSharpMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(cornerPointsSharp, cornerPointsSharpMsg);</span><br><span class="line">  cornerPointsSharpMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  cornerPointsSharpMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubCornerPointsSharp.<span class="built_in">publish</span>(cornerPointsSharpMsg);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 cornerPointsLessSharpMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(cornerPointsLessSharp, cornerPointsLessSharpMsg);</span><br><span class="line">  cornerPointsLessSharpMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  cornerPointsLessSharpMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubCornerPointsLessSharp.<span class="built_in">publish</span>(cornerPointsLessSharpMsg);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 surfPointsFlat2;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(surfPointsFlat, surfPointsFlat2);</span><br><span class="line">  surfPointsFlat2.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  surfPointsFlat2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubSurfPointsFlat.<span class="built_in">publish</span>(surfPointsFlat2);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 surfPointsLessFlat2;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(surfPointsLessFlat, surfPointsLessFlat2);</span><br><span class="line">  surfPointsLessFlat2.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  surfPointsLessFlat2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubSurfPointsLessFlat.<span class="built_in">publish</span>(surfPointsLessFlat2);</span><br><span class="line">    <span class="comment">// publich IMU消息,由于循环到了最后，因此是Cur都是代表最后一个点，即最后一个点的欧拉角，畸变位移及一个点云周期增加的速度</span></span><br><span class="line">  <span class="function">pcl::PointCloud&lt;pcl::PointXYZ&gt; <span class="title">imuTrans</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//起始点欧拉角</span></span><br><span class="line">  imuTrans.points[<span class="number">0</span>].x = imuPitchStart;</span><br><span class="line">  imuTrans.points[<span class="number">0</span>].y = imuYawStart;</span><br><span class="line">  imuTrans.points[<span class="number">0</span>].z = imuRollStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最后一个点的欧拉角</span></span><br><span class="line">  imuTrans.points[<span class="number">1</span>].x = imuPitchCur;</span><br><span class="line">  imuTrans.points[<span class="number">1</span>].y = imuYawCur;</span><br><span class="line">  imuTrans.points[<span class="number">1</span>].z = imuRollCur;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最后一个点相对于第一个点的畸变位移和速度</span></span><br><span class="line">  imuTrans.points[<span class="number">2</span>].x = imuShiftFromStartXCur;</span><br><span class="line">  imuTrans.points[<span class="number">2</span>].y = imuShiftFromStartYCur;</span><br><span class="line">  imuTrans.points[<span class="number">2</span>].z = imuShiftFromStartZCur;</span><br><span class="line"></span><br><span class="line">  imuTrans.points[<span class="number">3</span>].x = imuVeloFromStartXCur;</span><br><span class="line">  imuTrans.points[<span class="number">3</span>].y = imuVeloFromStartYCur;</span><br><span class="line">  imuTrans.points[<span class="number">3</span>].z = imuVeloFromStartZCur;</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 imuTransMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(imuTrans, imuTransMsg);</span><br><span class="line">  imuTransMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  imuTransMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubImuTrans.<span class="built_in">publish</span>(imuTransMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Ⅲ-laserOdometry"><a href="#Ⅲ-laserOdometry" class="headerlink" title="Ⅲ.laserOdometry"></a>Ⅲ.laserOdometry</h1><p><img src="/images/LOAM源代码解析/image-20220415103708452.png" alt="image-20220415103708452"></p>
<p>这部分是里程计部分，对应的是论文中的特征匹配问题，通过对论文的阅读，我们知道特征匹配主要是将$t$时刻的点云和$t+1$时刻的点云联系起来（如果有<code>IMU</code>或者里程计可以先进行一个初步的变换，作为初始信息用于匹配）;</p>
<p>我们知道$t$时刻讲过校正的点云为$\overline{P}_k$，将该集合中的边缘点生成的线和$t+1$时刻提取的边缘点对应起来，我们需要找到一个$t$时刻到$t+1$时刻的最优位姿$T$，使得损失最小，对应的就是求点到直线的最短距离，在论文中我们已经通过求偏导的方式把雅可比矩阵做了详细的推导，把它应用在代码中即可。（对于平面点特征，同样的考虑点到面的距离。）详细推导查看：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3">LOAM-SLAM深度剖析-Ⅳ.特征点匹配-C.雅可比矩阵求解</a></p>
<p>在看代码中的函数之前，首先熟悉定义的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收到的sharp点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">cornerPointsSharp</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的less_sharp点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">cornerPointsLessSharp</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的flat点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">surfPointsFlat</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的less_flat点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">surfPointsLessFlat</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一帧所有边缘点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudCornerLast</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//上一帧所有平面点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudSurfLast</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存前一个节点发过来的未经处理过的特征点</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudOri</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">coeffSel</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的所有的点云数据</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudFullRes</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的IMU信息</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">imuTrans</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;())</span></span>;</span><br><span class="line"><span class="comment">//使用上一帧的 less_sharp 点云构造kd-tree</span></span><br><span class="line">pcl::KdTreeFLANN&lt;PointType&gt;::<span class="function">Ptr <span class="title">kdtreeCornerLast</span><span class="params">(<span class="keyword">new</span> pcl::KdTreeFLANN&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//使用上一帧的 less_flat 点云构造kd-tree</span></span><br><span class="line">pcl::KdTreeFLANN&lt;PointType&gt;::<span class="function">Ptr <span class="title">kdtreeSurfLast</span><span class="params">(<span class="keyword">new</span> pcl::KdTreeFLANN&lt;PointType&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> laserCloudCornerLastNum;</span><br><span class="line"><span class="keyword">int</span> laserCloudSurfLastNum;</span><br></pre></td></tr></table></figure>
<h2 id="A-main"><a href="#A-main" class="headerlink" title="A.main"></a>A.main</h2><p><img src="/images/LOAM源代码解析/image-20220416145103548.png" alt="image-20220416145103548"></p>
<p>这里的main函数足足600多行代码……，人都傻了，，，</p>
<p>开始定义了ROS节点和订阅的消息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;laserOdometry&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Subscriber subCornerPointsSharp = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_sharp&quot;</span>, <span class="number">2</span>, laserCloudSharpHandler);</span><br><span class="line">  ros::Subscriber subCornerPointsLessSharp = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_less_sharp&quot;</span>, <span class="number">2</span>, laserCloudLessSharpHandler);</span><br><span class="line">  ros::Subscriber subSurfPointsFlat = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_flat&quot;</span>, <span class="number">2</span>, laserCloudFlatHandler);</span><br><span class="line">  ros::Subscriber subSurfPointsLessFlat = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_less_flat&quot;</span>, <span class="number">2</span>, laserCloudLessFlatHandler);</span><br><span class="line">  ros::Subscriber subLaserCloudFullRes = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/velodyne_cloud_2&quot;</span>, <span class="number">2</span>, laserCloudFullResHandler);</span><br><span class="line">  ros::Subscriber subImuTrans = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/imu_trans&quot;</span>, <span class="number">5</span>, imuTransHandler);</span><br><span class="line">  ros::Publisher pubLaserCloudCornerLast = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/laser_cloud_corner_last&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  ros::Publisher pubLaserCloudSurfLast = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/laser_cloud_surf_last&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  ros::Publisher pubLaserCloudFullRes = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/velodyne_cloud_3&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  ros::Publisher pubLaserOdometry = nh.advertise&lt;nav_msgs::Odometry&gt; (<span class="string">&quot;/laser_odom_to_init&quot;</span>, <span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  nav_msgs::Odometry laserOdometry;</span><br><span class="line">  laserOdometry.header.frame_id = <span class="string">&quot;camera_init&quot;</span>;</span><br><span class="line">  laserOdometry.child_frame_id = <span class="string">&quot;/laser_odom&quot;</span>;</span><br><span class="line"></span><br><span class="line">  tf::TransformBroadcaster tfBroadcaster;</span><br><span class="line">  tf::StampedTransform laserOdometryTrans;</span><br><span class="line">  laserOdometryTrans.frame_id_ = <span class="string">&quot;camera_init&quot;</span>;</span><br><span class="line">  laserOdometryTrans.child_frame_id_ = <span class="string">&quot;/laser_odom&quot;</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; pointSearchInd;<span class="comment">//搜索到的点序</span></span><br><span class="line">  std::vector&lt;<span class="keyword">float</span>&gt; pointSearchSqDis;<span class="comment">//搜索到的点平方距离</span></span><br><span class="line"></span><br><span class="line">  PointType pointOri, pointSel<span class="comment">/*选中的特征点*/</span>, tripod1, tripod2, tripod3<span class="comment">/*特征点的对应点*/</span>, pointProj<span class="comment">/*unused*/</span>, coeff;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//退化标志</span></span><br><span class="line">  <span class="keyword">bool</span> isDegenerate = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//P矩阵，预测矩阵</span></span><br><span class="line">  <span class="function">cv::Mat <span class="title">matP</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> frameCount = skipFrameNum;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> status = ros::<span class="built_in">ok</span>();</span><br><span class="line">  <span class="keyword">while</span> (status) &#123;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newCornerPointsSharp &amp;&amp; newCornerPointsLessSharp &amp;&amp; newSurfPointsFlat &amp;&amp; </span><br><span class="line">        newSurfPointsLessFlat &amp;&amp; newLaserCloudFullRes &amp;&amp; newImuTrans &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeCornerPointsSharp - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeCornerPointsLessSharp - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeSurfPointsFlat - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeLaserCloudFullRes - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeImuTrans - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span>) &#123;  <span class="comment">//同步作用，确保同时收到同一个点云的特征点以及IMU信息才进入</span></span><br><span class="line">      newCornerPointsSharp = <span class="literal">false</span>;</span><br><span class="line">      newCornerPointsLessSharp = <span class="literal">false</span>;</span><br><span class="line">      newSurfPointsFlat = <span class="literal">false</span>;</span><br><span class="line">      newSurfPointsLessFlat = <span class="literal">false</span>;</span><br><span class="line">      newLaserCloudFullRes = <span class="literal">false</span>;</span><br><span class="line">      newImuTrans = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/***** 一、初始化 *****/</span></span><br><span class="line">      <span class="comment">/***** 二、点云匹配与运动估计 *****/</span></span><br><span class="line">      <span class="comment">/***** 三、坐标转换 *****/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment">* 1、初始化   * </span></span><br><span class="line"><span class="comment">*************/</span></span><br><span class="line"><span class="comment">//将第一个点云数据集发送给laserMapping,从下一个点云数据开始处理</span></span><br><span class="line"><span class="keyword">if</span> (!systemInited) &#123;</span><br><span class="line">    <span class="comment">// 将cornerPointsLessSharp（接收到的less_sharp点云）与laserCloudCornerLast（上一帧所有边缘点云）交换,</span></span><br><span class="line">    <span class="comment">// 目的保存cornerPointsLessSharp（接收到的less_sharp点云）的值下轮使用</span></span><br><span class="line">    pcl::PointCloud&lt;PointType&gt;::Ptr laserCloudTemp = cornerPointsLessSharp;</span><br><span class="line">    cornerPointsLessSharp = laserCloudCornerLast;</span><br><span class="line">    laserCloudCornerLast = laserCloudTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将surfPointLessFlat（接收到的less_flat点云）与laserCloudSurfLast（上一帧所有平面点云）交换，</span></span><br><span class="line">    <span class="comment">// 目的保存surfPointsLessFlat（接收到的less_flat点云）的值下轮使用</span></span><br><span class="line">    laserCloudTemp = surfPointsLessFlat;</span><br><span class="line">    surfPointsLessFlat = laserCloudSurfLast;</span><br><span class="line">    laserCloudSurfLast = laserCloudTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上一帧的特征点构建kd-tree</span></span><br><span class="line">    kdtreeCornerLast-&gt;<span class="built_in">setInputCloud</span>(laserCloudCornerLast);<span class="comment">//所有的边沿点集合</span></span><br><span class="line">    kdtreeSurfLast-&gt;<span class="built_in">setInputCloud</span>(laserCloudSurfLast);<span class="comment">//所有的平面点集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将cornerPointsLessSharp（上一帧所有边缘点云）发送给laserMapping</span></span><br><span class="line">    sensor_msgs::PointCloud2 laserCloudCornerLast2;</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*laserCloudCornerLast, laserCloudCornerLast2);</span><br><span class="line">    laserCloudCornerLast2.header.stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">    laserCloudCornerLast2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">    pubLaserCloudCornerLast.<span class="built_in">publish</span>(laserCloudCornerLast2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将surfPointLessFlat（上一帧所有平面点云）发送给laserMapping</span></span><br><span class="line">    sensor_msgs::PointCloud2 laserCloudSurfLast2;</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*laserCloudSurfLast, laserCloudSurfLast2);</span><br><span class="line">    laserCloudSurfLast2.header.stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">    laserCloudSurfLast2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">    pubLaserCloudSurfLast.<span class="built_in">publish</span>(laserCloudSurfLast2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记住原点的翻滚角和俯仰角</span></span><br><span class="line">    transformSum[<span class="number">0</span>] += imuPitchStart;</span><br><span class="line">    transformSum[<span class="number">2</span>] += imuRollStart;</span><br><span class="line"></span><br><span class="line">    systemInited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T平移量的初值赋值为加减速的位移量，为其梯度下降的方向（沿用上次转换的T（一个sweep匀速模型），同时在其基础上减去匀速运动位移，即只考虑加减速的位移量）</span></span><br><span class="line">transform[<span class="number">3</span>] -= imuVeloFromStartX * scanPeriod;</span><br><span class="line">transform[<span class="number">4</span>] -= imuVeloFromStartY * scanPeriod;</span><br><span class="line">transform[<span class="number">5</span>] -= imuVeloFromStartZ * scanPeriod;</span><br></pre></td></tr></table></figure>
<p>【解析】：这部分主要做了两件事，①将订阅的数据保存为上一时刻的数据。作者做了两次数据交换：将<code>cornerPointsLessSharp</code>（接收到的<code>less_sharp</code>点云）与<code>laserCloudCornerLast</code>（上一帧所有边缘点云）交换，将<code>surfPointLessFlat</code>（接收到的<code>less_flat</code>点云）与<code>laserCloudSurfLast</code>（上一帧所有平面点云）交换，目的就是将接收的数据保存为上一时刻的数据，并将上一时刻的数据构建<code>kd-tree</code>，供下轮使用。</p>
<p>②将上一时刻的数据发布出去。将<code>cornerPointsLessSharp</code>（上一帧所有边缘点云）和<code>surfPointLessFlat</code>（上一帧所有平面点云）也即边沿点和平面点分别发送给<code>laserMapping</code>。</p>
<h3 id="2-帧间匹配与运动估计"><a href="#2-帧间匹配与运动估计" class="headerlink" title="2.帧间匹配与运动估计"></a>2.帧间匹配与运动估计</h3><p>这部分代码人给我看麻了，通过对代码的折叠和前人的知道，我们可以清晰的看到这部分主要干了什么，先看一下整体的结构。</p>
<p><img src="/images/LOAM源代码解析/image-20220415151916947.png" alt="image-20220415151916947"></p>
<p>【解析】：这部分首先进行了一个总的判断，在进行初始化之后，首先要求上一时刻的点的个数必须达到边缘点大于10、平面特征点大于100的要求，才能进行之后的点云匹配以及运动估计。</p>
<p>然后做了一步操作<code>removeNaNFromPointCloud</code>，它的主要作用是<strong>去除无效点</strong>，参数分别是（输入点云，输出点云，对应保留的索引），所以这里将含有<code>NaN</code>的（无效的）边缘点云去除了，并统计了边缘点和平面点的个数。</p>
<p>做好上面的初始工作之后，就开始进行迭代优化了，这部分使用的是非线性最小二乘法中的列文伯格（<code>LM</code>）算法，做了25次迭代。当然优化并不是这么简单的事情，所以红色框里的内容就是重点了，它们是优化必不可少的步骤，下面依次介绍每一部分的对应的论文内容。</p>
<h4 id="①点线匹配与雅可比求解"><a href="#①点线匹配与雅可比求解" class="headerlink" title="①点线匹配与雅可比求解"></a>①点线匹配与雅可比求解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">laserCloudOri-&gt;<span class="built_in">clear</span>();</span><br><span class="line">coeffSel-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前点云中的曲率最大的特征点,从上个点云中曲率比较大的特征点中找两个最近距离点，一个点使用kd-tree查找，另一个根据找到的点在其相邻线找另外一个最近距离的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cornerPointsSharpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TransformToStart</span>(&amp;cornerPointsSharp-&gt;points[i], &amp;pointSel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每迭代五次，重新查找最近点</span></span><br><span class="line">    <span class="keyword">if</span> (iterCount % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">        pcl::<span class="built_in">removeNaNFromPointCloud</span>(*laserCloudCornerLast, *laserCloudCornerLast, indices);</span><br><span class="line">        <span class="comment">// kd-tree查找一个最近距离点，边沿点未经过体素栅格滤波，一般边沿点本来就比较少，不做滤波</span></span><br><span class="line">        kdtreeCornerLast-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">1</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line">        <span class="keyword">int</span> closestPointInd = <span class="number">-1</span>, minPointInd2 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找相邻线距离目标点距离最小的点</span></span><br><span class="line">        <span class="comment">//再次提醒：velodyne是2度一线，scanID相邻并不代表线号相邻，相邻线度数相差2度，也即线号scanID相差2</span></span><br><span class="line">        <span class="keyword">if</span> (pointSearchSqDis[<span class="number">0</span>] &lt; <span class="number">25</span>)</span><br><span class="line">        &#123; <span class="comment">//找到的最近点距离的确很近的话</span></span><br><span class="line">            closestPointInd = pointSearchInd[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//提取最近点线号</span></span><br><span class="line">            <span class="keyword">int</span> closestPointScan = <span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[closestPointInd].intensity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> pointSqDis, minPointSqDis2 = <span class="number">25</span>; <span class="comment">//初始门槛值5米，可大致过滤掉scanID相邻，但实际线不相邻的值</span></span><br><span class="line">            <span class="comment">//寻找距离目标点最近距离的平方和最小的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd + <span class="number">1</span>; j &lt; cornerPointsSharpNum; j++)</span><br><span class="line">            &#123; <span class="comment">//向scanID增大的方向查找</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &gt; closestPointScan + <span class="number">2.5</span>)</span><br><span class="line">                &#123; <span class="comment">//非相邻线</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudCornerLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &gt; closestPointScan)</span><br><span class="line">                &#123; <span class="comment">//确保两个点不在同一条scan上（相邻线查找应该可以用scanID == closestPointScan +/- 1 来做）</span></span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123; <span class="comment">//距离更近，要小于初始值5米</span></span><br><span class="line">                        <span class="comment">//更新最小距离与点序</span></span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123; <span class="comment">//向scanID减小的方向查找</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &lt; closestPointScan - <span class="number">2.5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudCornerLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &lt; closestPointScan)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记住组成线的点序</span></span><br><span class="line">        pointSearchCornerInd1[i] = closestPointInd; <span class="comment">// kd-tree最近距离点，-1表示未找到满足的点</span></span><br><span class="line">        pointSearchCornerInd2[i] = minPointInd2;    <span class="comment">//另一个最近的，-1表示未找到满足的点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSearchCornerInd2[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//大于等于0，不等于-1，说明两个点都找到了</span></span><br><span class="line">        tripod1 = laserCloudCornerLast-&gt;points[pointSearchCornerInd1[i]];</span><br><span class="line">        tripod2 = laserCloudCornerLast-&gt;points[pointSearchCornerInd2[i]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择的特征点记为O，kd-tree最近距离点记为A，另一个最近距离点记为B</span></span><br><span class="line">        <span class="keyword">float</span> x0 = pointSel.x;</span><br><span class="line">        <span class="keyword">float</span> y0 = pointSel.y;</span><br><span class="line">        <span class="keyword">float</span> z0 = pointSel.z;</span><br><span class="line">        <span class="keyword">float</span> x1 = tripod1.x;</span><br><span class="line">        <span class="keyword">float</span> y1 = tripod1.y;</span><br><span class="line">        <span class="keyword">float</span> z1 = tripod1.z;</span><br><span class="line">        <span class="keyword">float</span> x2 = tripod2.x;</span><br><span class="line">        <span class="keyword">float</span> y2 = tripod2.y;</span><br><span class="line">        <span class="keyword">float</span> z2 = tripod2.z;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量OA = (x0 - x1, y0 - y1, z0 - z1), 向量OB = (x0 - x2, y0 - y2, z0 - z2)，向量AB = （x1 - x2, y1 - y2, z1 - z2）</span></span><br><span class="line">        <span class="comment">//向量OA OB的向量积(即叉乘)为：</span></span><br><span class="line">        <span class="comment">//|  i      j      k  |</span></span><br><span class="line">        <span class="comment">//|x0-x1  y0-y1  z0-z1|</span></span><br><span class="line">        <span class="comment">//|x0-x2  y0-y2  z0-z2|</span></span><br><span class="line">        <span class="comment">//模为：</span></span><br><span class="line">        <span class="keyword">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) + ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) + ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1)) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个最近距离点之间的距离，即向量AB的模</span></span><br><span class="line">        <span class="keyword">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AB方向的单位向量与OAB平面的单位法向量的向量积在各轴上的分量（d的方向）</span></span><br><span class="line">        <span class="comment">// x轴分量i</span></span><br><span class="line">        <span class="keyword">float</span> la = ((y1 - y2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) + (z1 - z2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1))) / a012 / l12;</span><br><span class="line">        <span class="comment">// y轴分量j</span></span><br><span class="line">        <span class="keyword">float</span> lb = -((x1 - x2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) - (z1 - z2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br><span class="line">        <span class="comment">// z轴分量k</span></span><br><span class="line">        <span class="keyword">float</span> lc = -((x1 - x2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) + (y1 - y2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点到线的距离，d = |向量OA 叉乘 向量OB|/|AB|</span></span><br><span class="line">        <span class="keyword">float</span> ld2 = a012 / l12;</span><br><span class="line">        <span class="comment">//权重计算，距离越大权重越小，距离越小权重越大，得到的权重范围&lt;=1</span></span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iterCount &gt;= <span class="number">5</span>)</span><br><span class="line">        &#123; <span class="comment">// 5次迭代之后开始增加权重因素</span></span><br><span class="line">            s = <span class="number">1</span> - <span class="number">1.8</span> * <span class="built_in">fabs</span>(ld2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑权重</span></span><br><span class="line">        coeff.x = s * la;</span><br><span class="line">        coeff.y = s * lb;</span><br><span class="line">        coeff.z = s * lc;</span><br><span class="line">        coeff.intensity = s * ld2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0.1</span> &amp;&amp; ld2 != <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">//只保留权重大的，也即距离比较小的点，同时也舍弃距离为零的</span></span><br><span class="line">            laserCloudOri-&gt;<span class="built_in">push_back</span>(cornerPointsSharp-&gt;points[i]);</span><br><span class="line">            coeffSel-&gt;<span class="built_in">push_back</span>(coeff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【 <span style="color:red;">点线匹配</span> 解析】：这部分主要任务是进行点和线的匹配，通过论文的解析我们知道，我们的特征匹配做的就是对$\overline{P}_k$中的线与$k+1$时刻投影到$k$时刻的点$i,i\in\tilde\xi_{k+1}$之间的匹配。这里对论文中的内容做一个简单的回顾：</p>
<p>详细查看：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E7%82%B9%E5%92%8C%E5%AF%B9%E5%BA%94%E7%89%B9%E5%BE%81%E5%8C%BA%E5%9F%9F%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97">C.点和对应特征区域距离的计算</a><br>论文中提到，边线是由两个点构成的，即$j,l$且$j,l\in \overline{P}_k$，其中$j$是$i$在$\overline{P}_k$中的最近邻，$l$是$i$在连续两次扫描$j$时的最近邻，$(j, l)$构成$i$的对应关系。所以关键就是这两个点要怎么找，只有找到这两个点之后才能得到一条线，进而才能做点线匹配。由于我们的$j,l$所在的ScanID可能比$i$的大，也可能比$i$的小，因此，代码中是往两头找。</p>
<p>代码中，通过处理上一帧中曲率最大的特征点，从该特征点中找到两个最近距离的点$j$，一个点使用kd-tree查找，然后根据找到的点在其相邻线找另外一个最近距离的点$l$。并且由于迭代过程中最近的点的匹配是随着 transform 的更新逐渐变化的，因此作者采用了 5 次迭代（计算量的一种平衡吧，每次更新 transform 后都更新一次最近匹配计算资源消耗大？）后再计算一次对应的最近点。这样下次通过更新的最近点匹配对来完成新的计算。</p>
<p>找到两个点之后定义$i$坐标$O(x_0 , y_0, z_0 )$，$j$的坐标$A(x_1 , y_1, z_1 )$，$l$的坐标$B(x_2 , y_2, z_2)$，由论文可知：</p>
<script type="math/tex; mode=display">
d_\xi=\frac{|\overrightarrow{OA}×\overrightarrow {OB}|}{|\overrightarrow{AB}|}=a012 / l12;</script><p>【 <span style="color:red;">雅可比求解</span> 解析】：</p>
<p><img src="/images/LOAM源代码解析/image-20220415214835849.png" alt="image-20220415214835849"></p>
<p>对应代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AB方向的单位向量与OAB平面的单位法向量的向量积在各轴上的分量（d的方向）</span></span><br><span class="line"><span class="comment">// x轴分量i</span></span><br><span class="line"><span class="keyword">float</span> la = ((y1 - y2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) + (z1 - z2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1))) / a012 / l12;</span><br><span class="line"><span class="comment">// y轴分量j</span></span><br><span class="line"><span class="keyword">float</span> lb = -((x1 - x2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) - (z1 - z2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br><span class="line"><span class="comment">// z轴分量k</span></span><br><span class="line"><span class="keyword">float</span> lc = -((x1 - x2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) + (y1 - y2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br></pre></td></tr></table></figure>
<p>求得梯度方向向量：</p>
<script type="math/tex; mode=display">
\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\mathcal{H},b_\mathcal{H},c_\mathcal{H}]^T=[la,lb,lc]^T</script><h4 id="②点面匹配与雅可比求解"><a href="#②点面匹配与雅可比求解" class="headerlink" title="②点面匹配与雅可比求解"></a>②点面匹配与雅可比求解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对本次接收到的曲率最小的点,从上次接收到的点云曲率比较小的点中找三点组成平面，一个使用kd-tree查找，另外一个在同一线上查找满足要求的，第三个在不同线上查找满足要求的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; surfPointsFlatNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TransformToStart</span>(&amp;surfPointsFlat-&gt;points[i], &amp;pointSel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iterCount % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// kd-tree最近点查找，在经过体素栅格滤波之后的平面点中查找，一般平面点太多，滤波后最近点查找数据量小</span></span><br><span class="line">        kdtreeSurfLast-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">1</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line">        <span class="keyword">int</span> closestPointInd = <span class="number">-1</span>, minPointInd2 = <span class="number">-1</span>, minPointInd3 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pointSearchSqDis[<span class="number">0</span>] &lt; <span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            closestPointInd = pointSearchInd[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> closestPointScan = <span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[closestPointInd].intensity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> pointSqDis, minPointSqDis2 = <span class="number">25</span>, minPointSqDis3 = <span class="number">25</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd + <span class="number">1</span>; j &lt; surfPointsFlatNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &gt; closestPointScan + <span class="number">2.5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudSurfLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &lt;= closestPointScan)</span><br><span class="line">                &#123; <span class="comment">//如果点的线号小于等于最近点的线号(应该最多取等，也即同一线上的点)</span></span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123; <span class="comment">//如果点处在大于该线上</span></span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis3)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis3 = pointSqDis;</span><br><span class="line">                        minPointInd3 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &lt; closestPointScan - <span class="number">2.5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudSurfLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &gt;= closestPointScan)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis3)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis3 = pointSqDis;</span><br><span class="line">                        minPointInd3 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pointSearchSurfInd1[i] = closestPointInd; <span class="comment">// kd-tree最近距离点,-1表示未找到满足要求的点</span></span><br><span class="line">        pointSearchSurfInd2[i] = minPointInd2;    <span class="comment">//同一线号上的距离最近的点，-1表示未找到满足要求的点</span></span><br><span class="line">        pointSearchSurfInd3[i] = minPointInd3;    <span class="comment">//不同线号上的距离最近的点，-1表示未找到满足要求的点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSurfInd2[i] &gt;= <span class="number">0</span> &amp;&amp; pointSearchSurfInd3[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;                                                               <span class="comment">//找到了三个点</span></span><br><span class="line">        tripod1 = laserCloudSurfLast-&gt;points[pointSearchSurfInd1[i]]; <span class="comment">// A点</span></span><br><span class="line">        tripod2 = laserCloudSurfLast-&gt;points[pointSearchSurfInd2[i]]; <span class="comment">// B点</span></span><br><span class="line">        tripod3 = laserCloudSurfLast-&gt;points[pointSearchSurfInd3[i]]; <span class="comment">// C点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量AB = (tripod2.x - tripod1.x, tripod2.y - tripod1.y, tripod2.z - tripod1.z)</span></span><br><span class="line">        <span class="comment">//向量AC = (tripod3.x - tripod1.x, tripod3.y - tripod1.y, tripod3.z - tripod1.z)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量AB AC的向量积（即叉乘），得到的是法向量</span></span><br><span class="line">        <span class="comment">// x轴方向分向量i</span></span><br><span class="line">        <span class="keyword">float</span> pa = (tripod2.y - tripod1.y) * (tripod3.z - tripod1.z) - (tripod3.y - tripod1.y) * (tripod2.z - tripod1.z);</span><br><span class="line">        <span class="comment">// y轴方向分向量j</span></span><br><span class="line">        <span class="keyword">float</span> pb = (tripod2.z - tripod1.z) * (tripod3.x - tripod1.x) - (tripod3.z - tripod1.z) * (tripod2.x - tripod1.x);</span><br><span class="line">        <span class="comment">// z轴方向分向量k</span></span><br><span class="line">        <span class="keyword">float</span> pc = (tripod2.x - tripod1.x) * (tripod3.y - tripod1.y) - (tripod3.x - tripod1.x) * (tripod2.y - tripod1.y);</span><br><span class="line">        <span class="keyword">float</span> pd = -(pa * tripod1.x + pb * tripod1.y + pc * tripod1.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//法向量的模</span></span><br><span class="line">        <span class="keyword">float</span> ps = <span class="built_in">sqrt</span>(pa * pa + pb * pb + pc * pc);</span><br><span class="line">        <span class="comment">// pa pb pc为法向量各方向上的单位向量</span></span><br><span class="line">        pa /= ps;</span><br><span class="line">        pb /= ps;</span><br><span class="line">        pc /= ps;</span><br><span class="line">        pd /= ps;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点到面的距离：向量OA与与法向量的点积除以法向量的模</span></span><br><span class="line">        <span class="keyword">float</span> pd2 = pa * pointSel.x + pb * pointSel.y + pc * pointSel.z + pd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同理计算权重</span></span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iterCount &gt;= <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="number">1</span> - <span class="number">1.8</span> * <span class="built_in">fabs</span>(pd2) / <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(pointSel.x * pointSel.x + pointSel.y * pointSel.y + pointSel.z * pointSel.z));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑权重</span></span><br><span class="line">        coeff.x = s * pa;</span><br><span class="line">        coeff.y = s * pb;</span><br><span class="line">        coeff.z = s * pc;</span><br><span class="line">        coeff.intensity = s * pd2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0.1</span> &amp;&amp; pd2 != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//保存原始点与相应的系数</span></span><br><span class="line">            laserCloudOri-&gt;<span class="built_in">push_back</span>(surfPointsFlat-&gt;points[i]);</span><br><span class="line">            coeffSel-&gt;<span class="built_in">push_back</span>(coeff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【 <span style="color:red;">点面匹配</span> 解析】：点面匹配与点线匹配如出一辙，通过论文的解析我们知道，我们的特征匹配做的就是对$\overline{\mathcal{P} }_k$中的面与$k+1$时刻投影到$k$时刻的点$i,i\in\tilde{\mathcal{H} }_{k+1}$之间的匹配。这里对论文中的内容做一个简单的回顾：</p>
<p>在$\overline{\mathcal{P} }_k$中找到$ i $的最近邻，记为$j$。 然后，我们找到另外两个点 $l$ 和$ m$，作为$ i $的最近邻，一个在$j $的同一扫描中，另一个在 $j $的两次连续扫描中，其中 $j,l,m\in \overline{\mathcal{P} }_k$。所以关键就是这三个点要怎么找，只有找到这三个点之后才能确定一个面，进而才能做点面匹配。</p>
<p>同样参考点线匹配，这段代码也是首先通过kd-tree最近点查找，找到点$j $，然后在选择同一线号上的距离最近的点$l$ 以及不同线号上的距离最近的点$ m$。</p>
<p>找到三个点之后，求解点到面的距离。这里的公式就不赘述了。上图：</p>
<p><img src="/images/LOAM源代码解析/image-20220415200837885.png" alt="image-20220415200837885" style="zoom:50%;" /></p>
<p>所以：</p>
<script type="math/tex; mode=display">
\begin{align*}
d_\mathcal{H}&=\frac
{\begin{vmatrix}
(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})·((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)}))
\end{vmatrix}
}
{\begin{vmatrix}
(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)})
\end{vmatrix} }\\
&=\frac{|\overrightarrow{OA}·(\overrightarrow{AB}×\overrightarrow{AC})|}{|\overrightarrow{AB}×\overrightarrow{AC}|}
\end{align*}</script><p>【 <span style="color:red;">雅可比求解</span> 解析】：</p>
<p><img src="/images/LOAM源代码解析/image-20220416090513137.png" alt="image-20220416090513137"></p>
<p>这里由于距离通过体积除以面积计算，而体积的梯度方向就是地面对应的法向量，所以面特征的梯度方向就是平面的法向量方向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向量AB AC的向量积（即叉乘），得到的是法向量</span></span><br><span class="line"><span class="comment">// x轴方向分向量i</span></span><br><span class="line"><span class="keyword">float</span> pa = (tripod2.y - tripod1.y) * (tripod3.z - tripod1.z) - (tripod3.y - tripod1.y) * (tripod2.z - tripod1.z);</span><br><span class="line"><span class="comment">// y轴方向分向量j</span></span><br><span class="line"><span class="keyword">float</span> pb = (tripod2.z - tripod1.z) * (tripod3.x - tripod1.x) - (tripod3.z - tripod1.z) * (tripod2.x - tripod1.x);</span><br><span class="line"><span class="comment">// z轴方向分向量k</span></span><br><span class="line"><span class="keyword">float</span> pc = (tripod2.x - tripod1.x) * (tripod3.y - tripod1.y) - (tripod3.x - tripod1.x) * (tripod2.y - tripod1.y);</span><br><span class="line"><span class="keyword">float</span> pd = -(pa * tripod1.x + pb * tripod1.y + pc * tripod1.z);</span><br></pre></td></tr></table></figure>
<h4 id="③L-M运动估计求解"><a href="#③L-M运动估计求解" class="headerlink" title="③L-M运动估计求解"></a>③L-M运动估计求解</h4><p>假设：雷达的运动是连续的。将所有<strong>对应到的点求到直线的距离到面的距离之和最短然后按照 Levenberg-Marquardt 算法迭代计算</strong>，得到两帧之间的变换$T$，最后通过累计计算里程计。在这里，需要得到的是距离对坐标变换的偏导数。</p>
<p>具体查看之前的文章，已经说的非常清楚了：<br><a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#B-%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1">B.运动估计</a></p>
<p><a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3">C.雅可比矩阵求解</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***** 3. L-M运动估计求解 *****/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> region</span></span><br><span class="line"><span class="keyword">int</span> pointSelNum = laserCloudOri-&gt;points.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//满足要求的特征点至少10个，特征匹配数量太少弃用此帧数据</span></span><br><span class="line"><span class="keyword">if</span> (pointSelNum &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">matA</span><span class="params">(pointSelNum, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAt</span><span class="params">(<span class="number">6</span>, pointSelNum, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtA</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matB</span><span class="params">(pointSelNum, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtB</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matX</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算matA,matB矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointSelNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pointOri = laserCloudOri-&gt;points[i];</span><br><span class="line">    coeff = coeffSel-&gt;points[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> srx = <span class="built_in">sin</span>(s * transform[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">float</span> crx = <span class="built_in">cos</span>(s * transform[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">float</span> sry = <span class="built_in">sin</span>(s * transform[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">float</span> cry = <span class="built_in">cos</span>(s * transform[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">float</span> srz = <span class="built_in">sin</span>(s * transform[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">float</span> crz = <span class="built_in">cos</span>(s * transform[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">float</span> tx = s * transform[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">float</span> ty = s * transform[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">float</span> tz = s * transform[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> arx = (-s * crx * sry * srz * pointOri.x + s * crx * crz * sry * pointOri.y + s * srx * sry * pointOri.z + s * tx * crx * sry * srz - s * ty * crx * crz * sry - s * tz * srx * sry) * coeff.x + (s * srx * srz * pointOri.x - s * crz * srx * pointOri.y + s * crx * pointOri.z + s * ty * crz * srx - s * tz * crx - s * tx * srx * srz) * coeff.y + (s * crx * cry * srz * pointOri.x - s * crx * cry * crz * pointOri.y - s * cry * srx * pointOri.z + s * tz * cry * srx + s * ty * crx * cry * crz - s * tx * crx * cry * srz) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> ary = ((-s * crz * sry - s * cry * srx * srz) * pointOri.x + (s * cry * crz * srx - s * sry * srz) * pointOri.y - s * crx * cry * pointOri.z + tx * (s * crz * sry + s * cry * srx * srz) + ty * (s * sry * srz - s * cry * crz * srx) + s * tz * crx * cry) * coeff.x + ((s * cry * crz - s * srx * sry * srz) * pointOri.x + (s * cry * srz + s * crz * srx * sry) * pointOri.y - s * crx * sry * pointOri.z + s * tz * crx * sry - ty * (s * cry * srz + s * crz * srx * sry) - tx * (s * cry * crz - s * srx * sry * srz)) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> arz = ((-s * cry * srz - s * crz * srx * sry) * pointOri.x + (s * cry * crz - s * srx * sry * srz) * pointOri.y + tx * (s * cry * srz + s * crz * srx * sry) - ty * (s * cry * crz - s * srx * sry * srz)) * coeff.x + (-s * crx * crz * pointOri.x - s * crx * srz * pointOri.y + s * ty * crx * srz + s * tx * crx * crz) * coeff.y + ((s * cry * crz * srx - s * sry * srz) * pointOri.x + (s * crz * sry + s * cry * srx * srz) * pointOri.y + tx * (s * sry * srz - s * cry * crz * srx) - ty * (s * crz * sry + s * cry * srx * srz)) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> atx = -s * (cry * crz - srx * sry * srz) * coeff.x + s * crx * srz * coeff.y - s * (crz * sry + cry * srx * srz) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> aty = -s * (cry * srz + crz * srx * sry) * coeff.x - s * crx * crz * coeff.y - s * (sry * srz - cry * crz * srx) * coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> atz = s * crx * sry * coeff.x - s * srx * coeff.y - s * crx * cry * coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> d2 = coeff.intensity;</span><br><span class="line"></span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">0</span>) = arx;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">1</span>) = ary;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span>) = arz;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">3</span>) = atx;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">4</span>) = aty;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">5</span>) = atz;</span><br><span class="line">    matB.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">0</span>) = <span class="number">-0.05</span> * d2;</span><br><span class="line">&#125;</span><br><span class="line">cv::<span class="built_in">transpose</span>(matA, matAt);</span><br><span class="line">matAtA = matAt * matA;</span><br><span class="line">matAtB = matAt * matB;</span><br><span class="line"><span class="comment">//求解matAtA * matX = matAtB</span></span><br><span class="line">cv::<span class="built_in">solve</span>(matAtA, matAtB, matX, cv::DECOMP_QR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iterCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特征值1*6矩阵</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matE</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">//特征向量6*6矩阵</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV2</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求解特征值/特征向量</span></span><br><span class="line">    cv::<span class="built_in">eigen</span>(matAtA, matE, matV);</span><br><span class="line">    matV.<span class="built_in">copyTo</span>(matV2);</span><br><span class="line"></span><br><span class="line">    isDegenerate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//特征值取值门槛</span></span><br><span class="line">    <span class="keyword">float</span> eignThre[<span class="number">6</span>] = &#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123; <span class="comment">//从小到大查找</span></span><br><span class="line">        <span class="keyword">if</span> (matE.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) &lt; eignThre[i])</span><br><span class="line">        &#123; <span class="comment">//特征值太小，则认为处在兼并环境中，发生了退化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">            &#123; <span class="comment">//对应的特征向量置为0</span></span><br><span class="line">                matV2.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isDegenerate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算P矩阵</span></span><br><span class="line">    matP = matV.<span class="built_in">inv</span>() * matV2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDegenerate)</span><br><span class="line">&#123; <span class="comment">//如果发生退化，只使用预测矩阵P计算</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matX2</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    matX.<span class="built_in">copyTo</span>(matX2);</span><br><span class="line">    matX = matP * matX2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//累加每次迭代的旋转平移量</span></span><br><span class="line">transform[<span class="number">0</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">1</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">2</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">3</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">4</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">5</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isnan</span>(transform[i])) <span class="comment">//判断是否非数字</span></span><br><span class="line">        transform[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算旋转平移量，如果很小就停止迭代</span></span><br><span class="line"><span class="keyword">float</span> deltaR = <span class="built_in">sqrt</span>(</span><br><span class="line">    <span class="built_in">pow</span>(<span class="built_in">rad2deg</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(<span class="built_in">rad2deg</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(<span class="built_in">rad2deg</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)), <span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> deltaT = <span class="built_in">sqrt</span>(</span><br><span class="line">    <span class="built_in">pow</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deltaR &lt; <span class="number">0.1</span> &amp;&amp; deltaT &lt; <span class="number">0.1</span>)</span><br><span class="line">&#123; <span class="comment">//迭代终止条件</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> endregion</span></span><br></pre></td></tr></table></figure>
<p>这段代码对应公式部分真的看的一团麻…….一点点看：</p>
<p>【解析】：首先作者定义了几个矩阵：$A,A^T,A^TA,B,A^TB,X$，然后定义一串变量，代码中的$T$是前三项是旋转角，后三项是平移向量，即$[ θ_x， θ_y， θ_z,t_x, t_y, t_z]^T$，所以定义：</p>
<script type="math/tex; mode=display">
srx=sin\theta_x=s_x\\crx=cos\theta_x=c_x\\
sry=sin\theta_y=s_y\\cry=cos\theta_y=c_y\\
srz=sin\theta_z=s_z\\crz=cos\theta_z=c_z\\</script><p>然后结合之前推导的公式，读者自己对应（这是基于欧拉角的，现在并不常用，现在基本上使用李代数……）</p>
<p><img src="/images/LOAM源代码解析/image-20220415204826886.png" alt="image-20220415204826886"></p>
<h3 id="3-坐标变换"><a href="#3-坐标变换" class="headerlink" title="3.坐标变换"></a>3.坐标变换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> rx, ry, rz, tx, ty, tz;</span><br><span class="line"><span class="comment">//求相对于原点的旋转量,垂直方向上1.05倍修正?</span></span><br><span class="line"><span class="built_in">AccumulateRotation</span>(transformSum[<span class="number">0</span>], transformSum[<span class="number">1</span>], transformSum[<span class="number">2</span>],</span><br><span class="line">                   -transform[<span class="number">0</span>], -transform[<span class="number">1</span>] * <span class="number">1.05</span>, -transform[<span class="number">2</span>], rx, ry, rz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x1 = <span class="built_in">cos</span>(rz) * (transform[<span class="number">3</span>] - imuShiftFromStartX) - <span class="built_in">sin</span>(rz) * (transform[<span class="number">4</span>] - imuShiftFromStartY);</span><br><span class="line"><span class="keyword">float</span> y1 = <span class="built_in">sin</span>(rz) * (transform[<span class="number">3</span>] - imuShiftFromStartX) + <span class="built_in">cos</span>(rz) * (transform[<span class="number">4</span>] - imuShiftFromStartY);</span><br><span class="line"><span class="keyword">float</span> z1 = transform[<span class="number">5</span>] * <span class="number">1.05</span> - imuShiftFromStartZ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x2 = x1;</span><br><span class="line"><span class="keyword">float</span> y2 = <span class="built_in">cos</span>(rx) * y1 - <span class="built_in">sin</span>(rx) * z1;</span><br><span class="line"><span class="keyword">float</span> z2 = <span class="built_in">sin</span>(rx) * y1 + <span class="built_in">cos</span>(rx) * z1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求相对于原点的平移量</span></span><br><span class="line">tx = transformSum[<span class="number">3</span>] - (<span class="built_in">cos</span>(ry) * x2 + <span class="built_in">sin</span>(ry) * z2);</span><br><span class="line">ty = transformSum[<span class="number">4</span>] - y2;</span><br><span class="line">tz = transformSum[<span class="number">5</span>] - (-<span class="built_in">sin</span>(ry) * x2 + <span class="built_in">cos</span>(ry) * z2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据IMU修正旋转量</span></span><br><span class="line"><span class="built_in">PluginIMURotation</span>(rx, ry, rz, imuPitchStart, imuYawStart, imuRollStart,</span><br><span class="line">                  imuPitchLast, imuYawLast, imuRollLast, rx, ry, rz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到世界坐标系下的转移矩阵</span></span><br><span class="line">transformSum[<span class="number">0</span>] = rx;</span><br><span class="line">transformSum[<span class="number">1</span>] = ry;</span><br><span class="line">transformSum[<span class="number">2</span>] = rz;</span><br><span class="line">transformSum[<span class="number">3</span>] = tx;</span><br><span class="line">transformSum[<span class="number">4</span>] = ty;</span><br><span class="line">transformSum[<span class="number">5</span>] = tz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//欧拉角转换成四元数</span></span><br><span class="line">geometry_msgs::Quaternion geoQuat = tf::<span class="built_in">createQuaternionMsgFromRollPitchYaw</span>(rz, -rx, -ry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// publish四元数和平移量</span></span><br><span class="line">laserOdometry.header.stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">laserOdometry.pose.pose.orientation.x = -geoQuat.y;</span><br><span class="line">laserOdometry.pose.pose.orientation.y = -geoQuat.z;</span><br><span class="line">laserOdometry.pose.pose.orientation.z = geoQuat.x;</span><br><span class="line">laserOdometry.pose.pose.orientation.w = geoQuat.w;</span><br><span class="line">laserOdometry.pose.pose.position.x = tx;</span><br><span class="line">laserOdometry.pose.pose.position.y = ty;</span><br><span class="line">laserOdometry.pose.pose.position.z = tz;</span><br><span class="line">pubLaserOdometry.<span class="built_in">publish</span>(laserOdometry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播新的平移旋转之后的坐标系(rviz)</span></span><br><span class="line">laserOdometryTrans.stamp_ = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">laserOdometryTrans.<span class="built_in">setRotation</span>(tf::<span class="built_in">Quaternion</span>(-geoQuat.y, -geoQuat.z, geoQuat.x, geoQuat.w));</span><br><span class="line">laserOdometryTrans.<span class="built_in">setOrigin</span>(tf::<span class="built_in">Vector3</span>(tx, ty, tz));</span><br><span class="line">tfBroadcaster.<span class="built_in">sendTransform</span>(laserOdometryTrans);</span><br></pre></td></tr></table></figure>
<p>【解析】：得到帧间点云的相对运动之后，由于它们是在这两帧点云的局部坐标系下的，所以需要进行转换，把它转换到世界坐标系下。</p>
<h1 id="Ⅳ-laserMapping"><a href="#Ⅳ-laserMapping" class="headerlink" title="Ⅳ.laserMapping"></a>Ⅳ.laserMapping</h1><p><img src="/images/LOAM源代码解析/image-20220416150539893.png" alt="image-20220416150539893"></p>
<h2 id="A-mian函数"><a href="#A-mian函数" class="headerlink" title="A.mian函数"></a>A.mian函数</h2><p><img src="/images/LOAM源代码解析/image-20220416145505400.png" alt="image-20220416145505400"></p>
<p>开始定义了ROS节点及其发布的消息，通过思维导图可以作为观察，代码类似第二节。然后来吧，痛苦并快乐着…..</p>
<h3 id="1-坐标变换"><a href="#1-坐标变换" class="headerlink" title="1.坐标变换"></a>1.坐标变换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***** ①坐标转换 *****/</span></span><br><span class="line"><span class="keyword">if</span> (frameCount &gt;= stackFrameNum) &#123;</span><br><span class="line">    <span class="comment">//获取世界坐标系转换矩阵，将相关坐标转移到世界坐标系下-&gt;得到可用于建图的Lidar坐标</span></span><br><span class="line">    <span class="built_in">transformAssociateToMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将最新接收到的平面点和边沿点进行旋转平移转换到世界坐标系下(这里和后面的逆转换应无必要)</span></span><br><span class="line">    <span class="comment">// 将上一时刻所有边特征转到世界坐标系下</span></span><br><span class="line">    <span class="keyword">int</span> laserCloudCornerLastNum = laserCloudCornerLast-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; laserCloudCornerLastNum; i++) &#123;</span><br><span class="line">        <span class="built_in">pointAssociateToMap</span>(&amp;laserCloudCornerLast-&gt;points[i], &amp;pointSel);</span><br><span class="line">        laserCloudCornerStack2-&gt;<span class="built_in">push_back</span>(pointSel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上一时刻所有面特征转到世界坐标系下</span></span><br><span class="line">    <span class="keyword">int</span> laserCloudSurfLastNum = laserCloudSurfLast-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; laserCloudSurfLastNum; i++) &#123;</span><br><span class="line">        <span class="built_in">pointAssociateToMap</span>(&amp;laserCloudSurfLast-&gt;points[i], &amp;pointSel);</span><br><span class="line">        laserCloudSurfStack2-&gt;<span class="built_in">push_back</span>(pointSel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解析】：这部分就是坐标变换，把点和面特征全部都转换到世界坐标系$\left\{W \right\}$下，具体转换函数调用的是<code>pointAssociateToMap</code>，并且转换用的是欧拉角表示的位姿。</p>
<h3 id="2-优化处理"><a href="#2-优化处理" class="headerlink" title="2.优化处理"></a>2.优化处理</h3><h4 id="①定义Cube"><a href="#①定义Cube" class="headerlink" title="①定义Cube"></a>①定义Cube</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> laserCloudCenWidth = <span class="number">10</span>;    <span class="comment">// cube宽度, cm为单位</span></span><br><span class="line"><span class="keyword">int</span> laserCloudCenHeight = <span class="number">5</span>;    <span class="comment">// cube高度</span></span><br><span class="line"><span class="keyword">int</span> laserCloudCenDepth = <span class="number">10</span>;    <span class="comment">// cube深度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudWidth = <span class="number">21</span>; <span class="comment">// 子cube沿宽方向的分割个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudHeight = <span class="number">11</span>;<span class="comment">// 子cube沿高方向个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudDepth = <span class="number">21</span>; <span class="comment">// 子cube沿深度方向个数</span></span><br><span class="line"><span class="comment">// 子cube总数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudNum = laserCloudWidth * laserCloudHeight * laserCloudDepth;<span class="comment">//4851</span></span><br></pre></td></tr></table></figure>
<p>cube相关操作的代码还不是特别明白……</p>
<h4 id="②迭代优化"><a href="#②迭代优化" class="headerlink" title="②迭代优化"></a>②迭代优化</h4><ul>
<li>迭代边缘点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代边缘点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; laserCloudCornerStackNum; i++) &#123;</span><br><span class="line">    pointOri = laserCloudCornerStack-&gt;points[i];</span><br><span class="line">    <span class="comment">//转换回世界坐标系</span></span><br><span class="line">    <span class="built_in">pointAssociateToMap</span>(&amp;pointOri, &amp;pointSel);</span><br><span class="line">    kdtreeCornerFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);<span class="comment">//寻找最近距离五个点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSqDis[<span class="number">4</span>] &lt; <span class="number">1.0</span>) &#123;<span class="comment">//5个点中最大距离不超过1才处理</span></span><br><span class="line">        <span class="comment">//将五个最近点的坐标加和求平均</span></span><br><span class="line">        <span class="keyword">float</span> cx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> cy = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">float</span> cz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            cx += laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">            cy += laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">            cz += laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">        &#125;</span><br><span class="line">        cx /= <span class="number">5</span>;</span><br><span class="line">        cy /= <span class="number">5</span>; </span><br><span class="line">        cz /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求均方差</span></span><br><span class="line">        <span class="keyword">float</span> a11 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> a12 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">float</span> a13 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> a22 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> a23 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">float</span> a33 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">float</span> ax = laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].x - cx;</span><br><span class="line">            <span class="keyword">float</span> ay = laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].y - cy;</span><br><span class="line">            <span class="keyword">float</span> az = laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].z - cz;</span><br><span class="line"></span><br><span class="line">            a11 += ax * ax;</span><br><span class="line">            a12 += ax * ay;</span><br><span class="line">            a13 += ax * az;</span><br><span class="line">            a22 += ay * ay;</span><br><span class="line">            a23 += ay * az;</span><br><span class="line">            a33 += az * az;</span><br><span class="line">        &#125;</span><br><span class="line">        a11 /= <span class="number">5</span>;</span><br><span class="line">        a12 /= <span class="number">5</span>; </span><br><span class="line">        a13 /= <span class="number">5</span>;</span><br><span class="line">        a22 /= <span class="number">5</span>;</span><br><span class="line">        a23 /= <span class="number">5</span>; </span><br><span class="line">        a33 /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建矩阵</span></span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = a11;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>) = a12;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) = a13;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>) = a12;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>) = a22;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) = a23;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>) = a13;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">1</span>) = a23;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) = a33;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特征值分解</span></span><br><span class="line">        cv::<span class="built_in">eigen</span>(matA1, matD1, matV1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matD1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">3</span> * matD1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//如果最大的特征值大于第二大的特征值三倍以上</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> x0 = pointSel.x;</span><br><span class="line">            <span class="keyword">float</span> y0 = pointSel.y;</span><br><span class="line">            <span class="keyword">float</span> z0 = pointSel.z;</span><br><span class="line">            <span class="keyword">float</span> x1 = cx + <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">float</span> y1 = cy + <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">float</span> z1 = cz + <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> x2 = cx - <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">float</span> y2 = cy - <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">float</span> z2 = cz - <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1))</span><br><span class="line">                              * ((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                              + ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))</span><br><span class="line">                              * ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                              + ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))</span><br><span class="line">                              * ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> la = ((y1 - y2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                        + (z1 - z2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> lb = -((x1 - x2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                         - (z1 - z2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> lc = -((x1 - x2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                         + (y1 - y2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> ld2 = a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//权重系数计算</span></span><br><span class="line">            <span class="keyword">float</span> s = <span class="number">1</span> - <span class="number">0.9</span> * <span class="built_in">fabs</span>(ld2);</span><br><span class="line"></span><br><span class="line">            coeff.x = s * la;</span><br><span class="line">            coeff.y = s * lb;</span><br><span class="line">            coeff.z = s * lc;</span><br><span class="line">            coeff.intensity = s * ld2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s &gt; <span class="number">0.1</span>) &#123;<span class="comment">//距离足够小才使用</span></span><br><span class="line">                laserCloudOri-&gt;<span class="built_in">push_back</span>(pointOri);</span><br><span class="line">                coeffSel-&gt;<span class="built_in">push_back</span>(coeff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解析】：</p>
<p><strong>首先解释一下这里使用最近邻的方法找到了五个点的做法起什么作用？</strong></p>
<p>我们这一对应代码部分做推导，设五个点分别是：$(x_1,y_1,z_1),(x_2,y_2,z_2),(x_3,y_3,z_3),(x_4,y_4,z_4),(x_5,y_5,z_5),$</p>
<p>求平均值：</p>
<script type="math/tex; mode=display">
\begin{align*}
\overline{x}&=\frac{x_1+x_2+x_3+x_4+x_5}{5}\\
\overline{y}&=\frac{y_1+y_2+y_3+y_4+y_5}{5}\\
\overline{z}&=\frac{z_1+z_2+z_3+z_4+z_5}{5}\\
\end{align*}</script><p>求协方差：</p>
<script type="math/tex; mode=display">
\begin{align*}
Cov(x,x)&=\sigma_{x}^2=E[(x-\overline{x})]^2\\
Cov(y,y)&=\sigma_{y}^2=E[(y-\overline{y})]^2\\
Cov(z,z)&=\sigma_{z}^2=E[(z-\overline{z})]^2\\
Cov(x,y)&=\sigma_{x}\sigma_{y}=E[(x-\overline{x})(y-\overline{y})]\\
Cov(x,z)&=\sigma_{x}\sigma_{z}=E[(x-\overline{x})(z-\overline{z})]\\
Cov(y,z)&=\sigma_{y}\sigma_{z}=E[(y-\overline{y})(z-\overline{z})]
\end{align*}</script><p>得到协方差矩阵：</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
\sigma_{x}^2&\sigma_{x}\sigma_{y}&\sigma_{x}\sigma_{z}\\
\sigma_{y}\sigma_{x}&\sigma_{y}^2&\sigma_{y}\sigma_{z}\\
\sigma_{z}\sigma_{x}&\sigma_{z}\sigma_{y}&\sigma_{z}^2
\end{bmatrix}</script><p>对$A$矩阵进行特征值分解：</p>
<p>如果这五个点<strong>共线</strong>的话，则分解出来的最大的特征值是另外两个的三倍以上；</p>
<p>如果这五个点<strong>共面</strong>的话，则分解出来的两个比较大的特征值是第三大的三倍以上；</p>
<p>总结为一句话就是：<span style="color:red;"><strong>线特征的特征值是一大两小，面特征的特征值是两大一小</strong></span></p>
<p>对于边缘点来说，当我们确定这五个点是共线的，则进行<code>if (matD1.at&lt;float&gt;(0, 0) &gt; 3 * matD1.at&lt;float&gt;(0, 1))&#123;....&#125;</code>内容下的操作；</p>
<p>与之前的点线匹配类似，这里用点$(x_0,y_0,z_0)$以及使用最大的特征值生成的两个虚拟点，利用这三个点，求得梯度方向向量：</p>
<p>参考链接：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3">LOAM-SLAM深度剖析-C.雅可比矩阵求解</a></p>
<script type="math/tex; mode=display">
\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\mathcal{H},b_\mathcal{H},c_\mathcal{H}]^T=[la,lb,lc]^T</script><p>这里和之前的里程计一致。</p>
<ul>
<li>迭代平面点</li>
</ul>
<p>平面点的代码就不贴了，与边缘点大同小异，不同的地方就是特征值的要求不一样，还有就是梯度方向的对应里程计中梯度方向的求法。</p>
<p>到此为止，我们得到了$\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }$（损失函数对点云的偏导）的求解。</p>
<h1 id="Ⅴ-参考文献"><a href="#Ⅴ-参考文献" class="headerlink" title="Ⅴ.参考文献"></a>Ⅴ.参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/29719106">LOAM:3D激光里程计及环境建图的方法和实现（一）</a></p>
<p><a href="https://blog.csdn.net/nksjc/article/details/76401092">3D 激光 SLAM -&gt;loam_velodyne 论文与代码解析</a></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
        <category>SLAM项目实践</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>LOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>LOAM&amp;&amp;ALOAM源码编译与数据集运行</title>
    <url>/posts/15478.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文主要把loam_velodyne与aloam_velodyne源码进行编译运行，感受一下在数据集下两者的运行效果。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<blockquote>
<p> 基本环境:ubuntu20.04; ROS1:noetic;你首先得熟悉十四讲吧……</p>
</blockquote>
<h1 id="LOAM"><a href="#LOAM" class="headerlink" title="LOAM"></a>LOAM</h1><p><img src="https://github.com/laboshinl/loam_velodyne/raw/master/capture.bmp" alt="Screenshot"></p>
<p>由于LOAM在机器人操作系统上进行搭建，所以需要构建工作空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建工作空间</span></span><br><span class="line">mkdir -p LOAM_WS/src</span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; catkin_init_workspace </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/laboshinl/loam_velodyne.git</span><br><span class="line"><span class="built_in">cd</span> .. &amp;&amp; catkin_make</span><br><span class="line"><span class="comment"># 编译和运行</span></span><br><span class="line">catkin_make -DCMAKE_BUILD_TYPE=Release </span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>如果你是用的vscode记得把引用放入<code>c_cpp_properties.json</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/opt/ros/noetic/include/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/alvin/workspace/slam_ws/LOAM/LOAM_WS/src/loam_velodyne/include/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span></span><br><span class="line">                ],</span><br></pre></td></tr></table></figure>
<p>LOAM_WS/src下运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 窗口1 </span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">roslaunch loam_velodyne loam_velodyne.launch</span><br><span class="line"><span class="comment"># 窗口2 </span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">rosbag play nsh_indoor_outdoor.bag <span class="comment"># 这里下载的数据集放在了工作空间下</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/loam-velodyne源码编译与数据集运行/image-20220412211213586.png" alt="image-20220412211213586" style="zoom:50%;" /></p>
<p>错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ERROR] [1628642694.176070835]: Error transforming odometry <span class="string">&#x27;Odometry&#x27;</span> from frame <span class="string">&#x27;/camera_init&#x27;</span> to frame <span class="string">&#x27;camera_init&#x27;</span></span><br><span class="line">[ERROR] [1628642694.509388228]: Error transforming odometry <span class="string">&#x27;Odometry&#x27;</span> from frame <span class="string">&#x27;/camera_init&#x27;</span> to frame <span class="string">&#x27;camera_init&#x27;</span></span><br></pre></td></tr></table></figure>
<p>解决办法参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/laboshinl/loam_velodyne/issues/157">https://github.com/laboshinl/lo</a></p>
<p>修改LaserMapping.cpp, LaserOdomertyr.cpp, TransformMaintenance.cpp这三个文件中的“/camera_int”为“camera_init”</p>
<p><img src="/images/loam-velodyne源码编译与数据集运行/image-20220412212407985.png" alt="image-20220412212407985"></p>
<h1 id="ALOAM"><a href="#ALOAM" class="headerlink" title="ALOAM"></a>ALOAM</h1><p>源代码地址：<a href="https://github.com/HKUST-Aerial-Robotics/A-LOAM">https://github.com/HKUST-Aerial-Robotics/A-LOAM</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建工作空间</span></span><br><span class="line">mkdir -p ALOAM_WS/src</span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; catkin_init_workspace </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/HKUST-Aerial-Robotics/A-LOAM</span><br><span class="line"><span class="built_in">cd</span> .. &amp;&amp; catkin_make</span><br><span class="line"><span class="comment"># 编译和运行</span></span><br><span class="line">catkin_make -DCMAKE_BUILD_TYPE=Release </span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>当然会遇到一些问题</p>
<p>①把你的CMakeLists.txt文件中的C++11声明改成C++14</p>
<p>ALOAM_WS/src/A-LOAM/CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## set(CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>②同LOAM，由于rviz版本问题，修改src下文件中的“/camera_int”为“camera_init”</p>
<p>③将<code>ALOAM_WS/src/A-LOAM/src/kittiHelper.cpp</code>下的<code>CV_LOAD_IMAGE_GRAYSCALE</code>修改为<code>cv::IMREAD_GRAYSCALE</code></p>
<p>这是由于pencv2 和 3 的命名规范产生了出入，具体查看 <a href="https://blog.csdn.net/qq_28660035/article/details/80772071"><strong>opencv3 与 opencv2 代码区别总结</strong></a></p>
<p>然后重新编译运行即可：</p>
<p><img src="/images/loam-velodyne源码编译与数据集运行/image-20220418094922467.png" alt="image-20220418094922467"></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
        <category>SLAM项目实践</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>ALOAM</tag>
        <tag>LOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>LOAM论文深度剖析</title>
    <url>/posts/33314.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LOAM这篇论文是发表于2014年RSS的文章，全称为：LOAM: Lidar Odometry and Mapping in Real-time . LOAM是基于激光雷达而搭建的在ROS平台下的SLAM系统。之后许多激光SLAM算法借鉴了LOAM中的一些思想，可以说学习LOAM对学习3D激光SLAM很有帮助。本文对LOAM原论文进行了解析。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ.概述"></a>Ⅰ.概述</h1><p>如图所示，整个<code>LOAM</code>的流程为：<code>Lidar</code>接收数据，首先进行<code>Point Cloud Registration</code>，<code>Lidar Odometry</code>以$10Hz$的频率进行运动估计和坐标转换，<code>Lidar Mapping</code>以$1Hz$的频率构建三维地图。这样做主要是为了保证系统的实时性。</p>
<p><img src="/images/loam论文深度解析/image-20220410153142890.png" alt="image-20220410153142890"></p>
<p>本文的核心主要在于两个部分：<strong>特征提取（Lidar Registration）</strong>和<strong>里程计解算（Odometry and Mapping）</strong>。<br>当提取出特征后，通过高频率的里程计（Odometry）实现<strong>粗定位</strong>，即为高频低精度；低频率的里程计（Mapping）实现<strong>精定位</strong>，即为低频高精度。 </p>
<h1 id="Ⅱ-符号约定"><a href="#Ⅱ-符号约定" class="headerlink" title="Ⅱ.符号约定"></a>Ⅱ.符号约定</h1><ul>
<li><p>一个sweep代表了一次扫描周期，$k$表示第$k$次扫描周期，$k\in Z^+$</p>
</li>
<li><p>一个扫描周期内获取到的所有点云记作 $P_k$， 代表了第$k$个扫描周期的点云</p>
</li>
<li><p>激光雷达坐标系$\left\{L\right\}$是一个以激光雷达几何中心为原点的三维坐标系。$x$轴是向左的，$y$轴是向上的，$z$轴是向前的。点$i, i\in P_k$在$\left\{L\right\}$中的坐标表示为$X^L_{(k,i)}$。</p>
</li>
<li><p>世界坐标系$\left\{W\right\}$是在初始位置与$\left\{L\right\}$重合的三维坐标系。点$i, i\in P_k$在$\left\{W\right\}$中的坐标为$X^W_{(k,i)}$。</p>
</li>
</ul>
<p><strong>已知一段点云序列$P_k,k\in Z^+$ ，计算在前$k$个时期内的雷达位姿以及构建全局地图。</strong></p>
<h1 id="Ⅲ-特征提取（点云注册）"><a href="#Ⅲ-特征提取（点云注册）" class="headerlink" title="Ⅲ.特征提取（点云注册）"></a>Ⅲ.特征提取（点云注册）</h1><h2 id="A-线束模型"><a href="#A-线束模型" class="headerlink" title="A.线束模型"></a>A.线束模型</h2><p>要读懂代码中特征提取中的一些处理，需要弄清楚<code>VLP16</code>扫描时的运动模型,论文中称单个线束为一个<code>Scan</code>，对全部$16$线组成的一帧点云称为一个<code>Sweep</code>，虽然是用的多线激光雷达,但是LOAM是针对单个<code>Scan</code>提取特征点的，这里主要考虑到线束间角分辨率(竖直分辨率)与单个线内点间角分辨率(水平分辨率)存在的差异。以VLP$16$为例, 竖直分辨率约为$2^\circ$，而水平分辨率最大为$0.4^\circ$。</p>
<p>角分辨率越大， 代表越远的物体，反射的两点距离越大，中间丢失的信息越多。因此， LOAM没有针对Scan和<code>Scan</code>之间的点的关联性提取和描述特征， 而是直接针对单个<code>Scan</code>提取特征。</p>
<p><img src="/images/loam论文深度解析/image-20220413152223146.png" alt="image-20220413152223146" style="zoom:50%;" /></p>
<p><strong>一个Sweep数据的采集如何完成的？</strong></p>
<p>一帧内所有的点， 都是按顺序穿行扫描的，比如开始的时候水平的第一个角度为$0^\circ$左右，扫描水平角度为$0^\circ$上的竖直方向所有$16$个点（对应$16$个<code>Scan</code>）的深度，并且这$16$个点也是串行按顺序排列的，然后转到下一个水平角度；设水平分辨率为$0.4^\circ$，则下一个水平角度为$0.4^\circ$，其次水平角度为$0.8^\circ$，依次顺时针扫完一圈(论文中是$[-\pi,\pi]$)，这就完成了一个<code>Sweep</code>数据的采集。</p>
<p><img src="/images/loam论文深度解析/image-20220413162337900.png" alt="image-20220413162337900" style="zoom:50%;" /></p>
<p>由于从驱动得到的一个<code>Sweep</code>是以点云的形式输出（也就是一堆点，每个点有$XYZ$的信息，点和点之间无其他关系信息），因此我们并不知道每个点属于哪个<code>Scan</code>， 对应哪个水平角度。因此，我们需要根据上面的扫描模型去计算每个点的竖直角度和水平角度。点坐标与竖直角度/水平角度的换算关系如下图所示。[详细翻阅<a href="https://velodynelidar.com/wp-content/uploads/2019/12/63-9243-Rev-E-VLP-16-User-Manual.pdf">vlp-16 sensor coordinate system文档</a>]</p>
<p><img src="/images/loam论文深度解析/image-20220413151359585.png" alt="image-20220413151359585" style="zoom:50%;" /></p>
<p>通过这个图很容易就能理解如何确定某个点属于哪个<code>Scan</code>，我们使用激光点的垂直距离除以它的水平距离，就可以得到雷达到该点的射线和水平面的夹角，用过这个夹角我们就可以很容易的判断该点属于哪个<code>Scan</code>。但是，实际上，在多线雷达（比如$32$线，$64$线），由于竖直方向的点更密集，<code>Scan</code>与<code>Scan</code>之间的距离很小，很容易出现把<code>Scan10</code>分配到<code>Scan13</code>这样的误差。当然，如果有条件，可以修改数据存储格式，建议把某个点属于哪个<code>Scan</code>直接保存的该点对应的数据中去。</p>
<p>摘取对应代码（src/loam_velodyne/src/scanRegistration.cpp）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++) &#123;</span><br><span class="line">    <span class="comment">//坐标轴交换，velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系</span></span><br><span class="line">    point.x = laserCloudIn.points[i].y;</span><br><span class="line">    point.y = laserCloudIn.points[i].z;</span><br><span class="line">    point.z = laserCloudIn.points[i].x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算点的仰角(根据lidar文档垂直角计算公式),根据仰角排列激光线号，velodyne每两个scan之间间隔2度</span></span><br><span class="line">    <span class="keyword">float</span> angle = <span class="built_in">atan</span>(point.y / <span class="built_in">sqrt</span>(point.x * point.x + point.z * point.z)) * <span class="number">180</span> / M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-区分边缘点和平面点"><a href="#B-区分边缘点和平面点" class="headerlink" title="B.区分边缘点和平面点"></a>B.区分边缘点和平面点</h2><p>常见的特征点提取方法：特征向量、直方图、旋转图片等。这些方法虽然能很精准的涵盖一帧数据的大部分信息，但是由于计算量大，很难在激光slam的相邻帧的匹配中使用。 因此，需要想一些更好的方法。</p>
<p>LOAM的特征提取基于曲率，只提取两种特征点：边缘点和平面点，分别对应场景的平面区域和曲折区域。作者根据点的曲率来计算<strong>平面光滑度</strong>作为提取当前帧的特征信息的指标。如下图所示，边缘点的矢量和的模一般较大，矢量<strong>和不为零</strong>向量，而对应平面点的矢量和的模一般较小，矢量<strong>和为零</strong>向量。</p>
<ul>
<li>平面点：在三维空间中处于平滑平面上的点，其和周围点的大小差距不大，曲率较低，平滑度较低。</li>
<li>边缘点：在三维空间中处于尖锐边缘上的点，其和周围点的大小差距较大，曲率较高，平滑度较高。</li>
</ul>
<p><img src="/images/loam论文深度解析/image-20220411152638255.png" alt="image-20220411152638255" style="zoom:33%;" /></p>
<p>可以发现，LOAM没有使用特征描述子(连曲率都没有参与后续的匹配)。从代码中的边缘点与平面点的曲率判断阈值可以看出，LOAM提取的边缘点和平面点特征点的曲率，并没有特别大的差别，这使得LOAM有较强的场景适应性，在场景中比较曲折的区域，边缘点点会占据主导,而在较为平缓的区域，平面点点占据主导。 在激光扫描到的一块区域，总会提取出几个特征点。</p>
<hr>
<p>定义<strong>平面光滑度</strong>$c$：</p>
<script type="math/tex; mode=display">
c=\frac{1}{|S|·\parallel X^L_{(k,i)}\parallel} \sum_{j\in S,j\ne i} \parallel (X^L_{(k,i)}-X^L_{(k,j)}) \parallel \tag{1}</script><p>根据$c$值对扫描中的点进行排序，选择$c$值最大的点为边缘点，$c$值最小的点为平面点的特征点。论文中为了在环境中均匀分布特征点，将扫描分割成四个相同的子区域。每个子区域最多可提供$2$个边缘点和$4$个平面点。只有当点$i$的$c$值大于或小于一个阈值，且所选点的个数不超过最大值时，才能将点$i$选择为边缘点或平面点。</p>
<p>通过代码可以知道这四个相同的子区域分别为：</p>
<ul>
<li>曲率特别大的点（sharp）</li>
<li>曲率大的点（less_sharp）</li>
<li>曲率特别小的点（flat）</li>
<li>曲率小的点（less_flat）</li>
</ul>
<p>代码中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点分类标号:2-代表曲率很大，1-代表曲率比较大,-1-代表曲率很小，0-曲率比较小(其中1包含了2,0包含了1,0和1构成了点云全部的点)</span></span><br><span class="line"><span class="keyword">int</span> cloudLabel[<span class="number">40000</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样操作的主要作用是，在进行后面的优化的时候，我们能根据这样的“等级”划分获得更明显</p>
</blockquote>
<h2 id="C-不可靠点的删除"><a href="#C-不可靠点的删除" class="headerlink" title="C.不可靠点的删除"></a>C.不可靠点的删除</h2><p>如图所示，对位于平行于激光束的表面上的点，以及被遮挡区域(虚线橙线段)的边界上的点，可以被检测为边缘点。它们都是不可靠的。</p>
<p><img src="/images/loam论文深度解析/image-20220410153159251.png" alt="image-20220410153159251" style="zoom:50%;" /></p>
<p>选取点的三要素：</p>
<ul>
<li>选择的边缘点或平面点的数量不能超过子区域的最大值</li>
<li>它周围的点都没有被选中</li>
<li>它不能在大致平行于激光束的表面上，也不能在被遮挡区域的边界上。</li>
</ul>
<p>经过特征点的提取，就可以得到论文中的帧数据对应的特征信息（边缘点和平面点分别用黄色和红色标记。）：</p>
<p><img src="/images/loam论文深度解析/image-20220410153221345.png" alt="image-20220410153221345" style="zoom:50%;" /></p>
<h1 id="Ⅳ-特征点匹配"><a href="#Ⅳ-特征点匹配" class="headerlink" title="Ⅳ.特征点匹配"></a>Ⅳ.特征点匹配</h1><p>将点云重新投影到扫描的末端。蓝色线段表示扫描$k$时感知到的点云 $P_k$，在$k$次扫描结束时，经过<strong>畸变校正</strong>之后将$P_k$重新投影到时间戳$t_{k+1}$，得到绿色线段$\overline{P}_k$。然后，在$k+1$次扫描时，重投影点云数据(经过畸变校正)$\overline{P}_k$和新感知的点云$P_{k+1}$(橙色线段)一起估计激光雷达运动。</p>
<p><img src="/images/loam论文深度解析/image-20220410153230555.png" alt="image-20220410153230555" style="zoom:50%;" /></p>
<p>我们根据论文中的描述：</p>
<ul>
<li><p>$P_k$是$k$时刻激光雷达感知的点云集合， 根据上文的特征提取规则，得到边缘点的集合$\xi_{k}$和平面点的集合$H_{k}$；</p>
</li>
<li><p>$\overline{P}_k$是将$k$时刻激光雷达感知的点云集合$P_k$，经过畸变校正得到的点云集合；</p>
</li>
<li>$P_{k+1}$是$k+1$时刻激光雷达感知的点云集合， 类似$P_k$，边缘点的集合$\xi_{k+1}$以及平面点的集合$H_{k+1}$；</li>
<li>在每次迭代中，使用当前估计的变换将$\xi_{k+1}$和$H_{k+1}$重新投影到扫描的开始，记$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$为重投影的点集。</li>
</ul>
<blockquote>
<p>这里我们将$k$时刻的扫描点云$P_k$经过畸变校正，得到了$\overline{P}_k$，然后$k+1$时刻的扫描点云$P_{k+1}$的$\xi_{k+1}$和$H_{k+1}$重投影到了扫描的开始，得到$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$，这样就使得$\overline{P}_k$与$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$统一在同一坐标系下，进而我们才可以计算下面的距离。</p>
</blockquote>
<hr>
<h2 id="A-激光雷达数据的畸变"><a href="#A-激光雷达数据的畸变" class="headerlink" title="A.激光雷达数据的畸变"></a>A.激光雷达数据的畸变</h2><p>激光雷达数据产生的畸变又叫<strong>激光雷达自运动畸变</strong>，对于多数激光雷达而言，尽管激光的发射与接收很快，但构成点云的每一个点仍非同一时刻生成的。一般我们会将$100ms $(对应典型值$10Hz$) 内累积的数据作为一帧点云输出。若在这$100ms$内，激光雷达本体或安装所在的机体发生绝对位置的变化，那么<strong>此帧点云中每一个点的坐标系就是不同的。</strong>直观上看，这一帧点云数据就会发生一定的“变形”，不能真实对应所探测到的环境信息，类似于拍照时手抖了，拍出来的照片就会糊。这便是激光雷达的自运动畸变。</p>
<p>举一个例子，激光雷达对面有一面平行的墙面，理想状况下激光处于位置A或者位置B位置墙面的点云应该一样，但实际上，由于在这$100ms$内，激光雷达本身在运动，所以这一帧的墙面的点云中，某些点的坐标系就变得不同了，进而失去了原始平行墙面的特征，所以说，AB位置的差距必须要考虑，或者说激光在这期间的运动必须要考虑。</p>
<p><img src="/images/loam论文深度解析/image-20220411193701848.png" alt="image-20220411193701848" style="zoom:33%;" /></p>
<h2 id="B-将点与线和面匹配的原因"><a href="#B-将点与线和面匹配的原因" class="headerlink" title="B.将点与线和面匹配的原因"></a>B.将点与线和面匹配的原因</h2><p>理想情况下，没有畸变，激光雷达在短时间里获取的相邻帧数据是<strong>含有大量同一特征点</strong>的，也就是$P_k$和$P_{k+1}$中很多特征点只是雷达在不同位置下观察的同一个点。所以只要找到一个变化关系$T$使得$P_k$和$P_{k+1}$对应的点的匹配，这个$T$就是表示激光雷达的帧间运动。为了减少计算量，增加鲁棒性，不直接使用点与点的匹配，而是使用边缘点和对应的线特征，平面点和对应的面特征，这样也可以得到变换关系 $T$。</p>
<p>但是实际情况下，激光雷达的点云数据是含有畸变的，所以作者将矫正的$P_k$重新投影到时间戳$t_{k+1}$，得到$\overline{P}_k$。我们的目的就是：从$\overline{P}_k$中找到与$\xi_{k+1}$中的点对应的边线，从平面图中找到与$H_{k+1}$中的点对应的平面贴片(patch)。那么现在就是一边进行矫正，一边进行匹配，然后进行迭代。迭代过程中，$T$的值不断变化，直到寻找到一个$T$使得<strong>所有点和对应特征区域距离和最小</strong>。</p>
<h2 id="C-点和对应特征区域距离的计算"><a href="#C-点和对应特征区域距离的计算" class="headerlink" title="C.点和对应特征区域距离的计算"></a>C.点和对应特征区域距离的计算</h2><p><img src="/images/loam论文深度解析/image-20220411202023128.png" alt="image-20220411202023128" style="zoom:50%;" /></p>
<p>其中：$i\in \tilde{\xi}_{k+1}$，$j,l,m\in \overline{P}_k$</p>
<p>图$7(a)$给出了寻找边缘点对应的边线的过程。设$i$是属于$\tilde{\xi}_{k+1}$的点，即$ i \in \tilde{\xi}_{k+1}$。边线由两个点表示。设$j$是$i$在$\overline{P}_k$中的最近邻，$j\in \overline{P}_k$，设$l$是$i$在连续两次扫描$j$时的最近邻，$(j, l)$构成$i$的对应关系。然后，为了验证$j$和$l$都是边缘点，我们根据公式$(1)$来检查局部表面的平滑度。这里，我们特别要求$j$和$l$来自不同的扫描，考虑到一次扫描不能包含来自同一边线的多个点。</p>
<p>图$7(b)$显示了寻找平面贴片(patch)作为平面点对应的过程。设$ i$ 为$\tilde{H}_{k+1}$中的一个点，即$i \in  \tilde{H}_{k+1}$。平面贴片(patch)由三个点表示。与上一段类似，我们在$\overline{P}_k$中找到$ i $的最近邻，记为$j$。 然后，我们找到另外两个点 $l$ 和$ m$，作为$ i $的最近邻，一个在$j $的同一扫描中，另一个在 $j $的两次连续扫描中。 这保证了三个点是非共线的。 为了验证 $j$、$l$和 $m$ 都是平面点，我们根据$ (1) $再次检查局部表面的平滑度。</p>
<p>根据匹配的原理，可以构造优化问题：求解变换关系$T$，使边缘点和边缘线距离最短，平面点和平面距离最短</p>
<ul>
<li><p>$\tilde{X}^L_{(k+1,i)}$    ：表示$i， i \in \tilde{\xi}_{k+1}$在$\left\{L\right\}$中的坐标;</p>
</li>
<li><p>$\overline{X}^L_{(k,j)}$：表示$j， j \in \overline{P}_k$在$\left\{L\right\}$中的坐标;</p>
</li>
<li><p>$\overline{X}^L_{(k,l)}$：表示$l， l\in \overline{P}_k$在$\left\{L\right\}$中的坐标;</p>
</li>
<li><p>$\overline{X}^L_{(k,m)}$：表示$m， m\in \overline{P}_k$在$\left\{L\right\}$中的坐标;</p>
</li>
</ul>
<h3 id="a-点到线的距离"><a href="#a-点到线的距离" class="headerlink" title="a.点到线的距离"></a>a.点到线的距离</h3><p>主要原理是利用“<strong>两向量叉积的模等于以这两个向量为边形成的平行四边形的面积</strong>”这条定理。</p>
<p>如下图：</p>
<script type="math/tex; mode=display">
S=OD·AB=|\overrightarrow{OA}×\overrightarrow {OB}|=|\overrightarrow{OA}|·|\overrightarrow{OB}|·sin\theta</script><p>如果我们需要求高：</p>
<script type="math/tex; mode=display">
OD = \frac{S}{|\overrightarrow{AB}|}=\frac{|\overrightarrow{OA}×\overrightarrow {OB}|}{|\overrightarrow{AB}|}</script><p><img src="/images/loam论文深度解析/image-20220411204216656.png" alt="image-20220411204216656" style="zoom: 25%;" /></p>
<p>所以对于：</p>
<p><img src="/images/loam论文深度解析/image-20220411204829280.png" alt="image-20220411204829280" style="zoom: 50%;" /></p>
<p>得到点到线的距离$d_\xi$为：</p>
<script type="math/tex; mode=display">
d_{\xi}=\frac{|(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})×(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,l)})|}
{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|}. \tag{2}</script><h3 id="b-点到面的距离"><a href="#b-点到面的距离" class="headerlink" title="b.点到面的距离"></a>b.点到面的距离</h3><p> 主要原理是<strong>点与平面内一点形成的向量与该平面的单位法向量的点积的模即为该点到平面的距离</strong>。</p>
<p><img src="/images/loam论文深度解析/image-20220411210656962.png" alt="image-20220411210656962" style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
d_\mathcal{H}=\frac
{\begin{vmatrix}
(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})·((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)}))
\end{vmatrix}
}
{\begin{vmatrix}
(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)})
\end{vmatrix} }. \tag{3}</script><h1 id="Ⅴ-运动估计"><a href="#Ⅴ-运动估计" class="headerlink" title="Ⅴ.运动估计"></a>Ⅴ.运动估计</h1><h2 id="A-线性插值"><a href="#A-线性插值" class="headerlink" title="A.线性插值"></a>A.线性插值</h2><p><img src="/images/loam论文深度解析/Linear_interpolation.png" alt="Linear interpolation.png"></p>
<p>假设我们已知坐标 $(x_0,y_0)$ 与$(x_1,y_1)$，要得到$[x_0.x_1]$区间内某一位置 $x$ 在直线上的值。根据图中所示，我们得到:</p>
<script type="math/tex; mode=display">
\frac{y-y_0}{x-x_0}=\frac{y_1-y_0}{x_1-x_0}</script><p>由于 $x$值已知，所以可以从公式得到 $y $的值:</p>
<script type="math/tex; mode=display">
y=y_0+\frac{y_1-y_0}{x_1-x_0}(x-x_0)</script><p>线性插值经常用于已知函数$ f $在两点的值要近似获得其它点数值的方法，这种近似方法的误差定义为:</p>
<script type="math/tex; mode=display">
R_T=f(x)-p(x)</script><p>其中 $p$ 表示上面定义的线性插值多项式</p>
<script type="math/tex; mode=display">
p(x)=f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x-x_0). \tag{4}</script><p>根据罗尔定理，我们可以证明：如果 f 有二阶连续导数，那么误差范围是：</p>
<script type="math/tex; mode=display">
|R_T|\leq \frac{(x_1-x_0)^2}{8}\underset{x_0\leq x\leq x_1}{max}|f^{\prime\prime}(x)|</script><h2 id="B-运动估计"><a href="#B-运动估计" class="headerlink" title="B.运动估计"></a>B.运动估计</h2><p>激光雷达运动在扫描期间以<strong>恒定的角速度和线速度建模</strong>。这允许我们在一个扫描中对在不同时间接收到的点进行线性插值。</p>
<p>假设$t$是当前的时间戳，$t_{k+1}$是扫描$k+1$的开始时间。</p>
<p>设$T^L_{k+1}$为$[t_{k+1}, t]$之间的激光雷达位姿变换。$T^L_{k+1}$包含$6$自由度激光雷达的刚性运动，$T^L_{k+1} = [t_x, t_y, t_z， θ_x， θ_y， θ_z]^T$，其中我们用$T^L_{k+1}(1:3)$表示 $t_x$、$t_y$和$t_z$，它们分别是$\left\{L\right\}$沿$x-$、$y-$和$z-$轴的平移，我们用$T^L_{k+1}(4:6)$表示$θ_x$、$θ_y$和$θ_z$，它们是旋转角度，遵循右手规则。</p>
<p>给定点$i，i \in P_k$，设$t_i$为其时间戳，设为$[t_{k+1}, t_i]$之间的$T^L_{(k+1,i)}$位姿变换。</p>
<p><img src="/images/loam论文深度解析/image-20220429100816545.png" alt="image-20220429100816545" style="zoom:67%;" /></p>
<p>$T^L_{(k+1,i)}$可以通过$T^L_{k+1}$的线性插值得到：</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{T^L_{(k+1,i)} }{t_i-t_{k+1} }&=\frac{ T^L_{k+1}}{t-t_{k+1} }.
\end{align}</script><p>整理一下即为论文中的公式:</p>
<script type="math/tex; mode=display">
T^L_{(k+1,i)}=\frac{t_i-t_{k+1} }{t-t_{k+1} }T^L_{k+1}. \tag{5}</script><p>由前文：在每次迭代中，使用当前估计的变换将$\xi_{k+1}$和$H_{k+1}$重新投影到扫描的开始，记$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$为重投影的点集。由于激光雷达位姿的变化，设旋转矩阵为$R$，平移向量$t=T^L_{(k+1,i)}(1:3)$我们可以得到：</p>
<script type="math/tex; mode=display">
X^L_{(k+1,i)}=R\tilde X^L_{(k+1,i)}+T^L_{(k+1,i)}(1:3). \tag{6}</script><p>由罗德里格斯公式：</p>
<script type="math/tex; mode=display">
R=e^{\hat{w} \theta}=I + \hat{w}sin\theta+\hat{w}^2(1-cos\theta).\tag{7}</script><p>在上式中，$θ$为旋转的大小，</p>
<script type="math/tex; mode=display">
\theta = \parallel T^L_{(k+1,i)}(4:6) \parallel. \tag{8}</script><p>$w$是表示旋转方向的单位向量，</p>
<script type="math/tex; mode=display">
w=\frac{T^L_{(k+1,i)}(4:6)}{\parallel T^L_{(k+1,i)}(4:6) \parallel}. \tag{9}</script><p>$\hat{w}$为$w$的斜对称矩阵[25]。</p>
<p>忆$(2)$和$(3)$计算属于$\tilde \xi_{k+1} $ 和$\tilde H_{k+1}$ 的点之间的距离及其对应关系。结合$(2)$和$(5)-(8)$，我们可以推导出$\xi_{k+1}$中的一个边点与相应的边线之间的几何关系，</p>
<script type="math/tex; mode=display">
f_{\xi}(X^L_{(k+1,i)},T^L_{k+1})=d_\xi,i\in \xi_{k+1}.\tag{10}</script><p>合$(3)(5)-(8)$，我们可以在$H_{k+1}$中的一个平面点与对应的平面贴片(patch)建立另一个几何关系，</p>
<script type="math/tex; mode=display">
f_H(X^L_{(k+1,i)},T^L_{k+1})=d_H,i\in H_{k+1}.\tag{11}</script><p>最后，我们用<code>Levenberg-Marquardt</code>方法[26]求解激光雷达运动。将$\xi_{k+1}$和$H_{k+1}$中每个特征点$(10)$和$(11)$叠加，得到一个非线性函数:</p>
<script type="math/tex; mode=display">
f(T^L_{k+1})=d,\tag{12}</script><p>其中每一行$f$对应一个特征点，$d$包含相应的距离。我们计算$f$关于$T^L_{k+1}$的雅可比矩阵，记作$J$，其中$J =\partial f /\partial T^L_{k+1}$。然后，$(12)$通过非线性迭代，使$d$趋近于$0$，</p>
<script type="math/tex; mode=display">
T^L_{k+1}\gets T^L_{k+1}-(J^TJ+\lambda diag(J^TJ))^{-1}J^Td.\tag{13}</script><p>$\lambda$是由<code>Levenberg-Marquardt</code>方法确定的因子</p>
<h2 id="C-雅可比矩阵求解"><a href="#C-雅可比矩阵求解" class="headerlink" title="C.雅可比矩阵求解"></a>C.雅可比矩阵求解</h2><p>LOAM中代价函数主要由两部分组成，即点到面的距离与点到线的距离，因此LOAM的代价函数不难写出：</p>
<script type="math/tex; mode=display">
loss= \sum^{N_{\xi} }_{i=1}d_{\xi_i}+\sum^{N_{H} }_{i=1}d_{H_i}=D(\tilde{X}^L_{(k+1,i)}).\tag{14}</script><blockquote>
<p>我们的目的就是残差对位姿求偏导，进而求得一个使得残差最小的最优位姿。</p>
</blockquote>
<p>定义$t+1$时刻的位姿：$T^L_{k+1} = [t_x, t_y, t_z， θ_x， θ_y， θ_z]^T$，其中我们用$t=T^L_{k+1}(1:3)=[t_x, t_y, t_z]^T$表示位移 $t_x$、$t_y$和$t_z$，同时$R$也可以通过$T^L_{k+1}$经罗德里格斯公式求解。</p>
<p>特征点从当前雷达坐标系投影到目标坐标系：</p>
<script type="math/tex; mode=display">
\tilde X^L_{(k+1,i)}=R X^L_{(k+1,i)}+t=G(X^L_{(k+1,i)},T^L_{k+1})</script><blockquote>
<p>这里与论文略有不同，这里$t_{k+1}$时刻的点经过位姿变化投影到$t_{k}$时刻，进而将两帧的点云统一在一个坐标系下，论文中是相反的（公式6），但是含义是一样的。</p>
</blockquote>
<p>将旋矩阵转换成欧拉角：</p>
<script type="math/tex; mode=display">
\begin{align*}
R &= R_yR_xR_z\\
&=
\begin{bmatrix}
c_yc_z+s_ys_xs_z &c_zs_ys_x-c_ys_z &c_xs_y\\
c_xs_z&c_xc_z&-s_x\\
c_ys_xs_z-c_zs_y&c_yc_zs_x+s_ys_z&c_yc_x
\end{bmatrix}
\end{align*}.\tag{15}</script><p>其中$c_x=cos(\theta_x),c_y=cos(\theta_y),c_z=cos(\theta_z),s_x=sin(\theta_x),s_y=sin(\theta_y),s_z=sin(\theta_z)$</p>
<p>将$(14)(15)$合并：</p>
<script type="math/tex; mode=display">
loss=F(X^L_{(k+1,i)},T^L_{k+1})=D(G(X^L_{(k+1,i)},T^L_{k+1})).\tag{16}</script><p>损失函数建立之后，我们就可以优化位姿，求损失对于位姿的偏导：</p>
<script type="math/tex; mode=display">
\begin{align*}
J&=\frac{\partial F(X^L_{(k+1,i)},T^L_{k+1}) }{\partial T^L_{k+1} }\\
&=\frac{\partial D(G(X^L_{(k+1,i)},T^L_{k+1})) }{\partial T^L_{k+1} }\\
&=\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }·
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial T^L_{k+1} }
\end{align*}.
\tag{17}</script><p>我们分别对这两部分进行推导：</p>
<ul>
<li>$\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }$的求解</li>
</ul>
<p>这部分表示的是损失函数对点云的偏导，这部分没有必要通过变量求导的方式去推导，我们知道求偏导就是求梯度方向，梯度方向就是使得残差减小的最快的方向；对于点云来说，残差减小最快的方向就是垂直于特征区域的方向：</p>
<p>​    ①对于线特征，梯度方向为通过特征点的垂直于直线的方向：</p>
<script type="math/tex; mode=display">
\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\xi,b_\xi,c_\xi]^T</script><p>​    ②对于面特征，梯度方向为通过特征点的垂直于平面的方向：</p>
<script type="math/tex; mode=display">
\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\mathcal{H},b_\mathcal{H},c_\mathcal{H}]^T</script><ul>
<li>$\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial T^L_{k+1} }$的求解</li>
</ul>
<p>这部分表示的是点云对位姿的偏导，主要是对平移和旋转的求导：</p>
<p>​    ①对平移求导</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial t_x}
=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial t_x}
=\begin{bmatrix} 1\\0\\0 \end{bmatrix}
\end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial t_y}
=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial t_y}
=\begin{bmatrix} 0\\1\\0 \end{bmatrix}
\end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial t_z}
=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial t_z}
=\begin{bmatrix} 0\\0\\1 \end{bmatrix}
\end{align*}</script><p>​    ②对角度求导</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial \theta_x }
&=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial \theta_x }
=\frac{\partial G(R X^L_{(k+1,i)})}{\partial \theta_x }\\
&=\begin{bmatrix}
s_yc_xs_z&c_zs_yc_x &-s_xs_y\\
-s_xs_z &-s_xc_z&-c_x\\
c_yc_xs_z&c_yc_zc_x&-c_ys_x
\end{bmatrix}
\begin{bmatrix}x_{(k+1,i)}\\y_{(k+1,i)}\\z_{(k+1,i)}\end{bmatrix}
\end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial \theta_y }
&=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial \theta_y }
=\frac{\partial G(R X^L_{(k+1,i)})}{\partial \theta_y }\\
&=\begin{bmatrix}
-s_yc_z+c_ys_xs_z&c_zc_ys_x+s_ys_z &c_xc_y\\0&0&0\\
-s_ys_xs_z-c_zc_y&-s_yc_zs_x+c_ys_z&-s_yc_x
\end{bmatrix}
\begin{bmatrix}x_{(k+1,i)}\\y_{(k+1,i)}\\z_{(k+1,i)}\end{bmatrix}
\end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial \theta_z }
&=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial \theta_z}
=\frac{\partial G(R X^L_{(k+1,i)})}{\partial \theta_z }\\
&=\begin{bmatrix}
-c_ys_z+s_ys_xc_z&-s_zs_ys_x &0\\
c_xc_z &-c_xs_z&0\\
c_ys_xc_z+s_zs_y&-c_ys_zs+s_yc_z&0
\end{bmatrix}
\begin{bmatrix}x_{(k+1,i)}\\y_{(k+1,i)}\\z_{(k+1,i)}\end{bmatrix}
\end{align*}</script><h1 id="Ⅵ-构建地图"><a href="#Ⅵ-构建地图" class="headerlink" title="Ⅵ.构建地图"></a>Ⅵ.构建地图</h1><h2 id="A-概览"><a href="#A-概览" class="headerlink" title="A.概览"></a>A.概览</h2><p><strong>①为什么使用建图节点？</strong></p>
<p>通过前面的步骤，我们计算出了帧间的里程计，可以对激光雷达的运动做粗略的估计，但是由于收到噪声的影响，位姿估计并不是准确，经过长时间的累积漂移会直接导致最终拼接的地图不成样子，因此，我们还需要依靠其他的方式对位姿进行估计进一步优化。</p>
<p>在SLAM领域，一般会采用与地图匹配的方式来优化这一结果。其实道理也很简单，我们始终认为后一时刻的观测较前一时刻带有更多的误差，换而言之，我们更加信任前一时刻结果。因此我们对已经构建地图的信任程度远高于临帧点云配准后的Lidar运动估计。所以我们可以利用已构建地图对位姿估计结果进行修正。</p>
<p>因此建图的作用就是 <span style="color:red;">优化Lidar里程计的位姿估计结果</span></p>
<p><strong>②建图节点如何工作的？</strong></p>
<p>如何利用地图进行优化呢？在文章的开始，我们就说里程计部分是高频率低精度，而地图部分是低频率高精度，所以才说里程计估计的位姿仅仅是粗略的估计，而利用地图的优化则是高精度的，但考虑资源消耗，所以调用频率相对于里程计的十分之一。</p>
<ul>
<li><p>首先，假设激光雷达在第一帧的时候得到数万个点云，此时Lidar的位置我们把它作为$(0,0,0)$，（此时记雷达位姿为$T^W_k$，地图 $ Q_k$），此时如果不考虑测量误差，则这数万个点都是精确的，我们把这数万个点所构成的环境作为此时的地图。</p>
</li>
<li><p>然后，假如激光雷达运动了一小段，得到了第二帧的点云，我们通过激光雷达里程计的方法估计了帧间的相对运动（就是$T^L_{k+1}$），但我们说了里程计的位姿估计是一个粗略的、低精度的、高频率的，因此我们做下一步操作。</p>
</li>
<li>最后，我们利用里程计得到的粗略的位姿估计，把第二帧的点云转换到第一帧（建立地图时的坐标系）的坐标系下，很显然，由于里程计不准确，就会导致地图拼歪了（就是论文中的$ \overline{Q}_{k+1}$），而建图节点的作用就是把歪的地图扶正后完整的拼上去，这就从另一个角度优化的雷达的位姿。</li>
</ul>
<p>但是，我们要清楚，拿当前的点云和地图中所有的点云去配准，这个计算量十分巨大，消耗也非常大，但是又要保证算法的实时性，所以调用建图节点的频率仅为调用里程计节点频率的十分之一。</p>
<p><img src="/images/loam论文深度解析/image-20220416101236496.png" alt="image-20220416101236496"></p>
<p>建图过程如右图示意。 蓝色曲线表示地图上的激光雷达位姿$T^W_k$ ，由建图算法在扫描 $k $处生成。 橙色曲线表示扫描 $k + 1$期间的激光雷达运动$T^L_{k+1}$，由里程计算法计算得出。 使用$ T^W_k$和$T^L_{k+1}$，将里程计算法发布的未失真点云投影到地图上，表示为（绿色线段）$\overline{Q}_{k+1}$，并与地图上现有的云$ Q_k$（黑色线段）进行匹配。</p>
<h2 id="B-合并地图点"><a href="#B-合并地图点" class="headerlink" title="B.合并地图点"></a>B.合并地图点</h2><p>合并地图点并没有在论文中提及，但是在代码中体现出来了，它更多的是一种工程实验的手段。在上文，我们知道第二帧的地图点在往第一帧做匹配然后去合并到第一帧，这样就能够形成一个地图，但是应该如何合并这是一个问题。</p>
<p>合并的规则：就是把场景看成一个立方体，然后划分成一定的小网格，将落入小网格的特征点进行合并，等下一帧的点云进来的时候，找对应的栅格即可。</p>
<ul>
<li>把关键帧的特征点按照位姿转到地图坐标系中</li>
<li>按照位置和<code>cube</code>尺寸划分到对应的<code>cube</code>中</li>
</ul>
<h2 id="C-优化位姿"><a href="#C-优化位姿" class="headerlink" title="C.优化位姿"></a>C.优化位姿</h2><p>优化位姿与里程计相同。</p>
<h1 id="Ⅶ-参考链接"><a href="#Ⅶ-参考链接" class="headerlink" title="Ⅶ.参考链接"></a>Ⅶ.参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/111388877/">LOAM-SLAM原理深度解析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/260012025/">LOAM SLAM原理之论文原理解读</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTM1MTQwMw==&amp;mid=2247530490&amp;idx=1&amp;sn=7d1c84b1a4b338887d9c9061da1bd0e3&amp;chksm=ec13c9fedb6440e87aeec427609c2c8592590353565c307e6bd046b1f168af75918871b457b4&amp;scene=132#wechat_redirect">【泡泡点云时空LOAM专题-3】LOAM 代价函数设计与雅可比求解详细推导（上）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/57351961">LOAM细节分析</a></p>
<p><a href="https://www.bilibili.com/video/BV1744y1J7ov/?spm_id_from=333.788.recommend_more_video.1">任务4 前端里程计LOAM系列</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29939195">LOAM:3D激光里程计及环境建图的方法和实现（三）</a></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>LOAM</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>LOAM论文翻译</title>
    <url>/posts/36439.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LOAM是Ji Zhang于2014年提出的使用激光雷达完成定位与三维建图的算法，即Lidar Odometry and Mapping。之后许多激光SLAM算法借鉴了LOAM中的一些思想，可以说学习LOAM对学习3D激光SLAM很有帮助。本文对LOAM原论文进行了翻译。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们提出了一种实时里程测量和地图绘制方法，该方法使用$ 6$ 自由度移动的$ 2$ 轴激光雷达的距离测量。这个问题很难解决，因为距离测量是在不同的时间接收的，运动估计中的错误可能会导致结果点云的错误配准。迄今为止，我们可以通过离线批处理方法构建连贯的 $3D$ 地图，通常使用循环闭合来校正随时间的漂移。我们的方法实现了低漂移和低计算复杂度，无需高精度测距或惯性测量。获得这一性能水平的关键思想是通过两种算法来划分同时定位和建图的复杂问题，该问题寻求同时优化大量变量。一种算法以高频但低保真度进行里程测量，以估计激光雷达的速度。另一种算法以较低数量级的频率运行，用于点云的精细匹配和配准。这两种算法的结合允许该方法实时建图。该方法已通过大量实验以及 KITTI 里程计基准进行了评估。结果表明，该方法可以达到离线批处理方法的精度水平。</p>
<h1 id="I-介绍"><a href="#I-介绍" class="headerlink" title="I. 介绍"></a>I. 介绍</h1><p>$3D$ 建图仍然是一种流行的技术 [1]–[3]。使用激光雷达进行建图是常见的，因为激光雷达可以提供高频范围测量，无论测量的距离如何，误差都相对恒定。在激光雷达的唯一运动是旋转激光束的情况下，点云的配准很简单。然而，如果激光雷达本身在许多环境的应用中都在移动，则精确建图需要在连续激光测距期间了解激光雷达的位姿。解决这个问题的一种常见方法是使用独立的位置估计(例如通过GPS/INS)将激光点注册到一个固定的坐标系中。另一组方法使用里程计测量，如从轮编码器或视觉里程计系统[4]，[5]记录激光点。由于里程计集成了随时间推移的微小增量运动，它必然会发生漂移，因此人们非常关注如何减少漂移(例如使用环路闭合)。</p>
<p>在这里，我们考虑使用$6$自由度移动的$2$轴激光雷达创建低漂移里程计地图的情况。使用激光雷达的一个关键优势是它对场景中的环境光线和光学纹理不敏感。随着激光雷达的发展，它们的尺寸和重量缩小了很多。激光雷达在人手持的情况下穿越环境 [6]，也可以连接到微型飞行器 [7]。由于我们的方法旨在推动里程计估计中的最小化漂移相关的问题，因此目前不涉及回环问题。</p>
<p><img src="/images/loam论文翻译/image-20220410153023132.png" alt="image-20220410153023132"></p>
<blockquote>
<p>图1所示。该方法的目标是利用移动两轴激光雷达进行运动估计和建图。由于接收激光点的时间不同，激光雷达的运动导致点云出现失真(如图左侧的激光雷达云所示)。我们提出的方法是将问题分解为两个并行运行的算法。里程计算法估计激光雷达的速度和校正点云中的失真，然后建图算法匹配并注册点云以创建地图。两种算法的结合保证了问题的实时可行性。</p>
</blockquote>
<p>该方法实现了低漂移和低计算复杂度，无需高精度测距惯性测量。获得这一性能水平的关键思想是用两种算法将通常复杂的同时定位与建图(SLAM)[8]问题分割开来，该问题旨在同时优化大量变量。其中一种算法采用高频但保真度较低的里程计来估计激光雷达的速度。另一种算法以较低数量级的频率运行，用于点云的精细匹配和配准。虽然没有必要，但如果IMU可用，可以提供一个运动先验来帮助描述高频运动。两种算法分别提取尖锐边缘和平面表面上的特征点，并将其分别与边缘线段和平面表面斑块进行匹配。里程计算法在保证快速计算的前提下，找到特征点的对应关系。在建图算法中，通过相关特征值和特征向量检查局部点簇的几何分布来确定对应关系。</p>
<p>通过对原问题的分解，首先解决了一个简单的问题，即在线运动估计。之后，建图作为批量优化（类似于迭代最近点（ICP）方法 [9]）进行，以生成高精度运动估计和地图。并行算法结构保证了问题实时求解的可行性。此外，由于运动估计是在更高的频率下进行的，因此给建图足够的时间来提高精度。当以较低的频率运行时，建图算法能够包含大量的特征点，并使用足够多的迭代进行收敛。</p>
<h1 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II.相关工作"></a>II.相关工作</h1><p>激光雷达已经成为机器人导航中应用广泛的传感器 [10]。对于定位和建图，大多数都使用 $2D $激光雷达[11]。当激光雷达扫描速率远高于其外部运动时，扫描中的运动失真通常可以忽略。在这种情况下，标准$ICP $方法[12] 可用于匹配不同扫描之间的激光数据。此外，提出了一种两步法来消除失真[13]:基于$ICP$的速度估计步骤，然后使用计算的速度进行失真补偿步骤。类似的技术也用于补偿单轴 $3D$激光雷达引入的失真[14]。然而，如果扫描运动相对缓慢，则运动失真可能严重。这也是为什么使用两轴激光雷达，因为一个轴通常比另一个轴慢得多。通常，其他传感器用于提供速度测量，通过这些测量，可以消除运动失真。例如，激光雷达点云可以通过与 IMU[15] 集成的视觉里程计的状态估计来注册。当多个传感器（如 GPS/INS 和车轮编码器）同时可用时，问题通常通过扩展卡尔曼滤波器[16] 或粒子滤波器 [1] 解决。这些方法可以实现实时建图，以辅助机器人导航中的路径规划和避障。</p>
<p>如果在不借助其他传感器的情况下使用双轴激光雷达，运动估计和失真校正将成为一个问题。Barfoot 等人使用的一种方法是从返回激光强度创建视觉图像，并在图像之间匹配视觉上不同的特征 [17]，以恢复地面车辆的运动[18]–[21]。在[18]、[19] 中，车辆运动被建模为恒定速度，在 [20]、[21] 中，车辆运动被建模为高斯过程。我们的方法使用了与 [18]、[19] 中类似的里程计算法线性运动模型，但具有不同类型的特征。方法 [18]–[21] 涉及强度图像的视觉特征，需要稠密点云。该方法在笛卡尔空间中提取和匹配几何特征，对点云密度要求较低。最接近我们的方法是Bosse和Zlot的[3]、[6]、[22]。利用两轴激光雷达获取点云，通过匹配局部点簇[22]的几何结构进行配准。此外，他们使用多个 2 轴激光雷达绘制地下矿井地图 [3]。此方法融合了 IMU，并使用回环检测构建大型地图。由同一作者提出的Zebedee是一个由2D激光雷达和IMU组成的建图设备，IMU通过弹簧[6]连接到手杆上。通过手动操作装置进行建图。采用批量优化方法对分段数据集进行处理，并在分段数据集之间添加边界约束。该方法利用IMU的测量值对激光点进行配准，并通过优化来校正IMU的偏差。从本质上说，Bosse和Zlot的方法需要批处理来开发精确的地图，因此不适用于需要实时地图的应用。相比之下，该方法在实时生成的地图在定性上与Bosse和Zlot的方法相似。区别在于，我们的方法可以为自动驾驶汽车的引导提供运动估计。此外，该方法利用了激光雷达扫描模式和点云分布。在里程计和建图算法中，分别实现了保证计算速度和精度的特征匹配。</p>
<h1 id="III-符号和任务描述"><a href="#III-符号和任务描述" class="headerlink" title="III.符号和任务描述"></a>III.符号和任务描述</h1><p>本文所要解决的问题是利用三维激光雷达感知的点云进行自动估计，并建立所经过环境的地图。我们假设激光雷达是预先校准的。我们还假设激光雷达的角速度和线速度随时间的变化是平滑和连续的，没有突变。第二个假设将在第VII-B节中通过使用IMU来释放。</p>
<p>在本文中，我们习惯用大写右标来表示坐标系。我们定义扫描(a sweep)为激光雷达完成一次扫描覆盖，我们使用正确的订阅$k,k\in Z^+$表示扫描，$P_k$表示扫描为$k$时感知的点云。让我们如下定义两个坐标系。</p>
<ul>
<li><p>激光雷达坐标系$\left\{L\right\}$是一个以激光雷达几何中心为原点的三维坐标系。$x$轴是向左的，$y$轴是向上的，$z$轴是向前的。点$i, i\in P_k$在$\left\{L\right\}$中的坐标表示为$X^L_{(k,i)}$。</p>
</li>
<li><p>世界坐标系$\left\{W\right\}$是在初始位置与$\left\{L\right\}$重合的三维坐标系。点$i, i\in P_k$在$\left\{W\right\}$中的坐标为$X^W_{(k,i)}$。</p>
</li>
</ul>
<p>有了假设和符号，我们的激光雷达里程测量和建图问题可以定义为:</p>
<p>​    <strong>问题:</strong>给定一个激光雷达云序列$i, i\in P_k$，计算每次扫描$k$时激光雷达的帧间运动(ego-motion)，用$P_k$构建遍历环境的地图。</p>
<h1 id="IV-系统总览"><a href="#IV-系统总览" class="headerlink" title="IV.系统总览"></a>IV.系统总览</h1><h2 id="A-激光雷达硬件"><a href="#A-激光雷达硬件" class="headerlink" title="A.激光雷达硬件"></a>A.激光雷达硬件</h2><p>本文的研究是在基于Hokuyo UTM-30LX激光扫描仪的定制3D激光雷达上进行验证的，但并不限于此。通过本文，我们将使用从激光雷达收集的数据来说明该方法。该激光扫描仪的视场为$180^◦$，分辨率为$0.25^◦$以及$40$行/秒扫描速率。所述激光扫描仪与电机相连，电机被控制以$180^◦/s$的角速度旋转，在$−90^◦$和$90^◦$之间，激光扫描仪的水平方向为零。对于这个特定的单位，扫描是从$−90^◦$旋转到$90^◦$或在相反的方向(持续1秒)。这里，请注意，对于一个连续旋转的激光雷达，扫描只是一个简单的半球面旋转。板载编码器以$0.25^◦$的分辨率测量电机旋转角度，利用该分辨率将激光点投影到激光雷达坐标$\left\{L\right\}$中。</p>
<p><img src="/images/loam论文翻译/image-20220410153045839.png" alt="image-20220410153045839" style="zoom:33%;" /></p>
<blockquote>
<p> 图$2$所示。三维激光雷达在本研究中使用的是一个由马达驱动旋转运动的Hokuyo激光扫描仪，以及一个测量旋转角度的编码器。该激光扫描仪的视场为$180^◦$的分辨率为$0.25^◦$。扫描速度为$40$行/秒。电机被控制从$−90^◦$旋转到$90^◦$与激光扫描仪的水平方向为零。</p>
</blockquote>
<p><img src="/images/loam论文翻译/image-20220410153142890.png" alt="image-20220410153142890"></p>
<blockquote>
<p>图$3$所示。激光雷达测程与建图软件系统框图。</p>
</blockquote>
<h2 id="B-软件系统概述"><a href="#B-软件系统概述" class="headerlink" title="B.软件系统概述"></a>B.软件系统概述</h2><p>图$3$显示了软件系统的示意图。设$\hat{P}$为激光扫描接收到的点。在每次扫描期间，$\hat{P}$在$\left\{L\right\}$中注册。扫描$k$时合并的点云形成$P_k$，然后用两种算法处理$P_k$。激光雷达里程计取点云并计算激光雷达在两次连续扫描之间的运动。在$P_k$中使用估计的运动来校正失真，算法运行在$10Hz$左右的频率。激光雷达建图进一步处理输出，以$1Hz$的频率匹配并将未失真的云注册到地图上。最后，将两种算法发布的位姿变换集成在一起，生成一个关于激光雷达相对于地图的位姿的约$10Hz$的变换输出。第V、VI节详细介绍了软件框图中的模块</p>
<h1 id="V-激光雷达里程计"><a href="#V-激光雷达里程计" class="headerlink" title="V.激光雷达里程计"></a>V.激光雷达里程计</h1><h2 id="A-特征点提取"><a href="#A-特征点提取" class="headerlink" title="A.特征点提取"></a>A.特征点提取</h2><p>我们首先从激光雷达云$P_k$中提取特征点，如图$3$所示的激光雷达在$P_k$中自然地产生了分布不均匀的点。在一个扫描中，从激光扫描仪返回的分辨率为$0.25^◦$，这些点位于扫描平面上。然而，当激光扫描仪以$180^◦/s$的角速度旋转，并产生40Hz的扫描，在垂直方向的扫描平面的分辨率是$180^◦/40 = 4.5^◦$。考虑到这一事实，在$P_k$中提取特征点时，仅使用单个扫描的信息，且具有共面几何关系。</p>
<p>我们选择尖锐边缘上的特征点和平面表面的特征点。设$i$是$P_k$中的一个点，$i\in P_k$，设$S$是激光扫描仪在同一次扫描中返回的$i$的连续点的集合。由于激光扫描器以$CW$或$CCW$顺序生成点返回，$S$包含一半位于$i$和两点之间$0.25^◦$间隔的每一边上的点。定义一个术语来评估局部表面的平滑度，</p>
<script type="math/tex; mode=display">
c=\frac{1}{|S|·\parallel X^L_{(k,i)}\parallel} \sum_{j\in S,j\ne i} \parallel (X^L_{(k,i)}-X^L_{(k,j)}) \parallel \tag{1}</script><p>根据$c$值对扫描中的点进行排序，选择$c$值最大的点为边缘点，$c$值最小的点为平面点的特征点。为了在环境中均匀分布特征点，我们将扫描分割成四个相同的子区域。每个子区域最多可提供$2$个边缘点和$4$个平面点。只有当点$i$的$c$值大于或小于一个阈值，且所选点的个数不超过最大值时，才能将点$i$选择为边或平面点。</p>
<p><img src="/images/loam论文翻译/image-20220410153159251.png" alt="image-20220410153159251" style="zoom:50%;" /></p>
<blockquote>
<p>图4所示。$(a)$实线段表示局部表面贴片。点$A$位于与激光束有一定角度的表面上(虚线橙色线段)。点$B$在一个大致平行于激光束的表面上。我们将$B$作为一个不可靠的激光返回点，不选择它作为特征点。$(b)$实线段是激光的可观测对象。点$A$位于被遮挡区域(虚线橙线段)的边界上，可以被检测为边缘点。然而，如果从不同的角度看，被遮挡的区域会发生变化，变得可以观察到。我们不把$A$作为显著边缘点，也不选择它作为特征点。</p>
</blockquote>
<p>在选择特征点时，我们希望避免选择周围点被选择的点，或者大致平行于激光束的局部平面上的点(图$4(a)$中的点$B$)。这些观点通常被认为是不可靠的。此外，我们希望避免在被遮挡区域边界上的点[23]。如图$4(b)$所示为一个例子。点$A$是激光雷达云中的边缘点，因为它的连接面(虚线段)被另一个物体遮挡。然而，如果激光雷达移动到另一个视点，被遮挡区域就会发生变化，成为可观测的。为了避免前面提到的待选点，我们再次找到点$S$的集合。只有当$S$它不能在大致平行于激光束的表面上，也不能在被遮挡区域的边界上。不形成一个大致平行于激光束的表面贴片时，点$i$才能被选择。在$S$中，没有一个点在激光束方向上通过间隙与$i$断开，同时比$i$更靠近激光雷达(如图$4(b)$中的B点)。</p>
<p>综上所述，从$c$值的最大值开始选取特征点作为边缘点，从$c$值的最小值开始选取特征点作为平面点，如果选取一个点，</p>
<ul>
<li>选择的边缘点或平面点的数量不能超过子区域的最大值</li>
<li>它周围的点都没有被选中</li>
<li>它不能在大致平行于激光束的表面上，也不能在被遮挡区域的边界上。</li>
</ul>
<p>从走廊场景中提取特征点的示例如图$5$所示。边缘点和平面点分别用黄色和红色标记。</p>
<p><img src="/images/loam论文翻译/image-20220410153221345.png" alt="image-20220410153221345" style="zoom:50%;" /></p>
<blockquote>
<p>图$5$所示。从走廊的激光雷达云中提取边缘点(黄色)和平面点(红色)的例子。同时，激光雷达以$0.5m/s$的速度向图左侧的壁面移动，导致壁面运动失真。</p>
</blockquote>
<h2 id="B-寻找特征点对应"><a href="#B-寻找特征点对应" class="headerlink" title="B.寻找特征点对应"></a>B.寻找特征点对应</h2><p>里程计算法估计激光雷达在扫描范围内的运动。设$t_k$为扫描$k$的起始时间。在每次扫描结束时，将扫描过程中感知到的点云$P_k$重新投影到时间戳$t_{k+1}$，如图$6$所示。我们将重新投影的点云表示为$\overline{P}_k$。在下一次扫描$k+1$时，$\overline{P}_k$和新接收到的点云$P_{k+1}$一起使用，来估计激光雷达的运动。</p>
<p><img src="/images/loam论文翻译/image-20220410153230555.png" alt="image-20220410153230555" style="zoom:50%;" /></p>
<blockquote>
<p>图$6$所示。将点云重新投影到扫描的末端。蓝色线段表示扫描$k$时感知到的点云 $P_k$，在扫描$k$结束时，将$P_k$重新投影到时间戳$t_{k+1}$，得到绿色线段$\overline{P}_k$。然后，在扫描$k+1$时，$\overline{P}_k$和新感知的点云$P_{k+1}$(橙色线段)一起估计激光雷达运动。</p>
</blockquote>
<p>让我们假设$\overline{P}_k$和$P_{k+1}$现在都是可用的，然后从找到两个激光雷达云之间的对应关系开始。对于$P_{k+1}$，我们使用上一节讨论的方法从激光雷达云中找到边缘点和平面点。设$\xi_{k+1}$和$H_{k+1}$分别为边点和平面点的集合。我们将从$\overline{P}_k$中找到与$\xi_{k+1}$中的点对应的边线，从平面图中找到与$H_{k+1}$中的点对应的平面贴片(patch)。</p>
<p>请注意，在扫描$k+1$开始时，$P_{k+1}$是一个空集，它在扫描过程中随着接收到更多点数而增长。激光雷达里程计递归地估计了扫描期间的$6-DOF$运动，并随着$P_{k+1}$的增加逐渐包含更多的点。在每次迭代中，使用当前估计的变换将$\xi_{k+1}$和$H_{k+1}$重新投影到扫描的开始，记$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$为重投影的点集。对于每个点在$\xi_{k+1}$和$H_{k+1}$，我们将在$\overline{P}_k$中找到最近的邻居点。在这里，$\overline{P}_k$被存储在$3D$  $ KD-tree$[24]中，用于快速索引。</p>
<p>图$7(a)$给出了寻找边缘点对应的边线的过程。设$i$是属于$\tilde{\xi}_{k+1}$的点，即$ i \in \tilde{\xi}_{k+1}$。边线由两个点表示。设$j$是$i$在$\overline{P}_k$中的最近邻，$j\in \overline{P}_k$，设$l$是$i$在连续两次扫描$j$时的最近邻，$(j, l)$构成$i$的对应关系。然后，为了验证$j$和$l$都是边缘点，我们根据公式$(1)$来检查局部表面的平滑度。这里，我们特别要求$j$和$l$来自不同的扫描，考虑到一次扫描不能包含来自同一边线的多个点。只有一个例外，即边缘线在扫描平面上。然而，如果是这样，边缘线就会退化且<br>在扫描平面上显示为一条直线，并且特征点在边缘线上不应该首先被提取。</p>
<p><img src="/images/loam论文翻译/image-20220410153242817.png" alt="image-20220410153242817" style="zoom:50%;" /></p>
<blockquote>
<p>图7所示。在$\tilde{\xi}_{k+1}$中找到一条边缘线作为边缘点的对应关系，如图$(a)$，以及作为$\tilde{H}_{k+1}$中平面点的对应关系的平面贴片(patch)，如图$(b)$。在$(a)$和$(b)$中，$j $是距离特征点最近的点，在$\overline{P}_k$中找到。橙色的线表示对j的相同扫描，蓝色的线表示连续的两次扫描。为了找出$(a)$中的边线对应关系，我们在蓝色的直线上找到另一个点$l$，对应关系用$(j, l)$表示。为了找到$(b)$中的平面贴片(patch)对应关系，我们发现另外两个点，$l $和 $m$，分别位于橙色和蓝色线上。对应关系为$(j, l, m)$。</p>
</blockquote>
<p>图$7(b)$显示了寻找平面贴片(patch)作为平面点对应的过程。设$ i$ 为$\tilde{H}_{k+1}$中的一个点，即$i \in  \tilde{H}_{k+1}$。平面贴片(patch)由三个点表示。与上一段类似，我们在$\overline{P}_k$中找到$ i $的最近邻，记为$j$。 然后，我们找到另外两个点 $l$ 和$ m$，作为$ i $的最近邻，一个在$j $的同一扫描中，另一个在 $j $的两次连续扫描中。 这保证了三个点是非共线的。 为了验证 $j$、$l$和 $m$ 都是平面点，我们根据$ (1) $再次检查局部表面的平滑度。</p>
<p>根据特征点的对应关系，推导出特征点到对应关系的距离表达式。在下一节中，我们将通过最小化特征点的整体距离来恢复激光雷达运动。我们从边点开始。对于点$ i \in \tilde{\xi}_{k+1}$，如果$(j, l)$是对应的边线，$j,l \in \overline{P}_k$，则点到线的距离可以计算为</p>
<script type="math/tex; mode=display">
d_{\xi}=\frac{|(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})×(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,l)})|}
{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|},\tag{2}</script><p>其中$\tilde{X}^L_{(k+1,i)},\overline{X}^L_{(k,j)}$， 和$\overline{X}^L_{(k,l)}$分别是点$i, j, l$在$\left\{L\right\}$中的坐标。那么，对于点$i \in  \tilde{H}_{k+1}$，如果$(j, l, m)$是对应的平面贴片(patch),$j,l,m \in \overline{P}_k$，则点到平面的距离为</p>
<script type="math/tex; mode=display">
d_H=\frac
{\begin{vmatrix}
(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})\\
((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)}))
\end{vmatrix}
}
{\begin{vmatrix}
(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)})
\end{vmatrix} },\tag{3}</script><p>其中$\overline{X}^L_{(k,m)}$是点$m$在$\left\{L\right\}$中的坐标。</p>
<h2 id="C-运动估计"><a href="#C-运动估计" class="headerlink" title="C.运动估计"></a>C.运动估计</h2><p>激光雷达运动在扫描期间以恒定的角速度和线速度建模。这允许我们在一个扫描中对在不同时间接收到的点进行线性插值。假设$t$是当前的时间戳，$t_{k+1}$是扫描$k+1$的开始时间。设$T^L_{k+1}$为$[t_{k+1}, t]$之间的激光雷达位姿变换。$T^L_{k+1}$包含$6$自由度激光雷达的刚性运动，$T^L_{k+1} = [t_x, t_y, t_z， θ_x， θ_y， θ_z]^T$，其中$t_x$、$t_y$和$t_z$分别是$\left\{L\right\}$沿$x-$、$y-$和$z-$轴的平移，$θ_x$、$θ_y$和$θ_z$是旋转角度，遵循右手规则。给定点$i，i \in P_k$，设$t_i$为其时间戳，设为$[t_{k+1}, t_i]$之间的$T^L_{(k+1,i)}$位姿变换。$T^L_{(k+1,i)}$可以通过$T^L_{k+1}$的线性插值得到，</p>
<script type="math/tex; mode=display">
T^L_{(k+1,i)}=\frac{t_i-t_{k+1} }{t-t_{k+1} }T^L_{k+1}.\tag{4}</script><p>回想一下，$\xi_{k+1} $和 $H_{k+1}$ 是从 $P_{k+1}$ 中提取的边缘点和平面点的集合，$\tilde \xi_{k+1} $ 和$\tilde H_{k+1}$ 是重新投影到扫描开始$ t_{k+1}$的点集合 。为了解决激光雷达运动，我们需要建立$\xi_{k+1} $和$\tilde \xi_{k+1} $或$H_{k+1}$ 和$\tilde H_{k+1}$ 之间的几何关系。利用$(4)$中的变换，我们可以推导，</p>
<script type="math/tex; mode=display">
X^L_{(k+1,i)}=R\tilde X^L_{(k+1,i)}+T^L_{(k+1,i)}(1:3),\tag{5}</script><p>其中$X^L_{(k+1,i)}$是$\xi_{k+1} $或$H_{k+1}$中的点$i$的坐标，$\tilde X^L_{(k+1,i)}$是$\tilde \xi_{k+1} $或$\tilde H_{k+1}$中的点$i$的坐标，$(a:b)$是$T^L_{(k+1,i)}$的第$a$到$b$个项，$R$是由$Rodrigues$公式[25]定义的旋转矩阵。</p>
<script type="math/tex; mode=display">
R=e^{\hat{w} \theta}=I + \hat{w}sin\theta+\hat{w}^2(1-cos\theta).\tag{6}</script><p>在上式中，$θ$为旋转的大小，</p>
<script type="math/tex; mode=display">
\theta = \parallel T^L_{(k+1,i)}(4:6) \parallel,\tag{7}</script><p>$w$是表示旋转方向的单位向量，</p>
<script type="math/tex; mode=display">
w=\frac{T^L_{(k+1,i)}(4:6)}{\parallel T^L_{(k+1,i)}(4:6) \parallel},\tag{8}</script><p>$\hat{w}$为$w$的斜对称矩阵[25]。</p>
<p>回忆$(2)$和$(3)$计算属于$\tilde \xi_{k+1} $ 和$\tilde H_{k+1}$ 的点之间的距离及其对应关系。结合$(2)$和$(4)-(8)$，我们可以推导出$\xi_{k+1}$中的一个边点与相应的边线之间的几何关系，</p>
<script type="math/tex; mode=display">
f_{\xi}(X^L_{(k+1,i)},T^L_{k+1})=d_\xi,i\in \xi_{k+1}.\tag{9}</script><p>同样，结合$(3)(4)-(8)$，我们可以在$H_{k+1}$中的一个平面点与对应的平面贴片(patch)建立另一个几何关系，</p>
<script type="math/tex; mode=display">
f_H(X^L_{(k+1,i)},T^L_{k+1})=d_H,i\in H_{k+1}.\tag{10}</script><p>最后，我们用<code>Levenberg-Marquardt</code>方法[26]求解激光雷达运动。将$\xi_{k+1}$和$H_{k+1}$中每个特征点$(9)$和$(10)$叠加，得到一个非线性函数:</p>
<script type="math/tex; mode=display">
f(T^L_{k+1})=d,\tag{11}</script><p>其中每一行$f$对应一个特征点，$d$包含相应的距离。我们计算$f$关于$T^L_{k+1}$的雅可比矩阵，记作$J$，其中$J =\partial f /\partial T^L_{k+1}$。然后，$(11)$通过非线性迭代，使$d$趋近于$0$，</p>
<script type="math/tex; mode=display">
T^L_{k+1}\gets T^L_{k+1}-(J^TJ+\lambda diag(J^TJ))^{-1}J^Td.\tag{12}</script><p>$\lambda$是由<code>Levenberg-Marquardt</code>方法确定的因子。</p>
<h2 id="D-激光雷达里程计算法"><a href="#D-激光雷达里程计算法" class="headerlink" title="D.激光雷达里程计算法"></a>D.激光雷达里程计算法</h2><p><img src="/images/loam论文翻译/%E5%9B%BE%E7%89%871.png" alt="图片1"></p>
<p>激光雷达里程计算法如算法1所示。该算法以上次扫描的点云$\overline{P}_k$、当前扫描的增长点云$P_{k+1}$和上次递归的位姿变换$T^L_{k+1}$作为输入。如果启动了新的扫描，$T^L_{k+1}$将被设置为零(第$4-6$行)。然后，算法从$P_{k+1}$中提取特征点构造第$7$行$\xi_{k+1}$和$H_{k+1}$。对于每个特征点，我们可以在$\overline{P}_k$(第$9-19$行)中找到对应。运动估计适应于鲁棒拟合[27]。在第$ 15 $行，该算法为每个特征点分配一个平方权值。 与其对应的距离较大的特征点被分配较小的权重，距离大于阈值的特征点被视为异常值并分配零权重。然后，在第$ 16 $行，为一次迭代更新位姿变换。 当发现收敛或满足最大迭代次数时，非线性优化终止。 如果算法到达扫描结束，则使用扫描期间估计的运动将$P_{k+1}$重新投影到时间戳 $t_{k+2}$。 否则，仅返回变换$T^L_{k+1}$ 用于下一轮递归。</p>
<h1 id="VI-激光雷达建图"><a href="#VI-激光雷达建图" class="headerlink" title="VI.激光雷达建图"></a>VI.激光雷达建图</h1><p><img src="/images/loam论文翻译/image-20220410153350151.png" alt="image-20220410153350151" style="zoom:50%;" /></p>
<blockquote>
<p>图 8. 建图过程示意图。 蓝色曲线表示地图上的激光雷达位姿$T^W_k$ ，由建图算法在扫描 $k $处生成。 橙色曲线表示扫描 $k + 1$ 期间的激光雷达运动$T^L_{k+1}$，由里程计算法计算得出。 使用$ T^W_k$和$T^L_{k+1}$，将里程计算法发布的未失真点云投影到地图上，表示为（绿色线段）$\overline{Q}_{k+1}$，并与地图上现有的云$ Q_k$（黑色线段）进行匹配。</p>
</blockquote>
<p>建图算法运行的频率比里程计算法低，并且每次扫描只调用一次。在扫描 $k + 1$结束时，即介于$ [t_{k+1}, t_{k+2 }]$，激光雷达里程计生成一个未失真的点云$\overline{P}_{k+1}$，同时生成一个激光雷达的位姿变换$T^L_{k+1}$。建图算法在世界坐标$\left\{W\right\}$中匹配并注册$\overline{P}_{k+1}$，如图$8$所示。为了解释这个过程，让我们将$ Q_k$ 定义为累积到扫描 $k$的地图上的点云，设 $T^W_k$是扫描 $k $在$t_{k+1}$结束时，激光雷达在地图上的位姿。利用激光雷达里程计的输出，建图算法将 $T^W_k$扩展到从$t_{k+1}$到 $t_{k+2}$的一次扫描，以获得$T^W_{k+1}$，并将 $\overline{P}_{k+1}$投影到世界坐标$\left\{W\right\}$中，表示为$\overline{Q}_{k+1}$。 接下来，该算法通过优化激光雷达位姿$T^W_{k+1}$，将$\overline{Q}_{k+1}$ 与$ Q_k$ 匹配。</p>
<p>特征点的提取方法与第$V-A$节相同，但使用了$ 10 $倍的特征点。 为了找到特征点的对应关系，我们将点云存储在地图上$ Q_k$，在 $10$ 立方米区域中。立方体中与$\overline{Q}_{k+1}$相交的点被提取并存储在 $3D$  $KD-tree$ [24] 中。 我们发现$ Q_k$中的点在特征点周围的某一区域内。令$ S^\prime $为一组周围点。 对于边缘点，我们只在 $ S^\prime $中保留边缘线上的点，对于平面点，我们只保留平面上的点。然后，计算 $ S^\prime $的协方差矩阵，记为$M$, $M$的特征值和特征向量，分别记为$V$和$E$。如果$ S^\prime $分布在一条边线上，$V$包含的一个特征值明显大于其他两个特征值，$E$中与最大特征值相关联的特征向量表示边缘线的方向。另一方面，如果$ S^\prime $分布在一个平面贴片(patch)上，$V$包含两个较大的特征值，第三个特征值明显较小，$E$中最小的特征值对应的特征向量表示该平面贴片(patch)的方位。通过$ S^\prime $的几何中心确定边缘线或平面贴片(patch)的位置。</p>
<p>为了计算特征点与其对应点的距离，我们在边缘线上选择两个点，在平面贴片(patch)上选择三个点。这允许使用$(2)$和$(3)$相同的公式来计算距离。然后，为每个特征点推导出一个方程为$(9)$ 或 $(10)$，但不同之处在于$\overline{Q}_{k+1}$ 中的所有点共享相同的时间戳$t_{k+2}$。 非线性优化通过 <code>Levenberg-Marquardt</code>方法 [26] 通过鲁棒拟合 [27] 再次求解，并在$\overline{Q}_{k+1}$被注册在地图上。为了均匀分布这些点，地图云通过体素网格过滤器 [28] 缩小尺寸，体素大小为 5 厘米立方体。</p>
<p><img src="/images/loam论文翻译/image-20220410153401364.png" alt="image-20220410153401364" style="zoom:50%;" /></p>
<blockquote>
<p>图 9. 位姿变换的集成。 蓝色区域说明了建图算法 $T^W_k$ 的激光雷达位姿，每次扫描生成一次。 橙色区域是当前扫描 $T^L_{k+1} $内的激光雷达运动，由里程计算法计算得出。 激光雷达的运动估计是两种变换的组合，频率与 $T^L_{k+1} $相同。</p>
</blockquote>
<p>位姿变换的集成如图 $9 $所示。蓝色区域代表激光雷达映射 $T^W_k$ 的位姿输出，每次扫描生成一次。 橙色区域表示来自激光雷达里程计的变换输出$T^L_{k+1} $，频率约为$ 10Hz$。 相对于地图的激光雷达姿态是两种变换的组合，频率与激光雷达里程计相同。</p>
<h1 id="VII-实验"><a href="#VII-实验" class="headerlink" title="VII.实验"></a>VII.实验</h1><p>在实验期间，在$2.5GHz$四核$6Gib$内存的笔记本电脑上，在Linux下的机器人操作系统$(ROS)$[29]上对激光雷达数据进行了处理。 该方法总共消耗两个核心，里程计和建图程序在两个独立的核心上运行。 我们的软件代码和数据集是公开的$^{1,2}$。</p>
<blockquote>
<p>1wiki.ros.org/loam_back_and_forth<br>2wiki.ros.org/loam_continuous</p>
</blockquote>
<h2 id="A-室内和室外测试"><a href="#A-室内和室外测试" class="headerlink" title="A.室内和室外测试"></a>A.室内和室外测试</h2><p>该方法已在室内和室外环境中进行了测试。在室内测试中，激光雷达与电池和笔记本电脑一起放置在一个推车上。一个人推着手推车走。图$10(a)$和图$10(c)$展示了两种典型的室内环境，一个狭长走廊和一个大厅的地图。图$10(b)$和图$10(d)$为同一场景拍摄的两张照片。</p>
<p><img src="/images/loam论文翻译/image-20220410153413911.png" alt="image-20220410153413911"></p>
<blockquote>
<p>图10所示。$(a)-(b)$狭长的走廊，$(c)-(d)$大厅，$(e)-(f)$植被覆盖的道路和$(g)-(h)$两行树木之间的果园生成的地图。激光雷达在室内测试中放置在手推车上，在室外测试中安装在地面车辆上。所有测试使用$0.5m/s$的速度。</p>
</blockquote>
<p>为了评估地图的局部准确性，我们从相同的环境中收集了第二组激光雷达云。在数据选择过程中，激光雷达保持静止，并放置在每个环境中的几个不同的位置。使用点对面$ICP$方法[9]对两个点云进行匹配和比较。 匹配完成后，将一个点云与第二个点云中对应的平面块之间的距离视为匹配误差。 图 $11 $显示了误差分布的密度。室内匹配误差小于室外匹配误差。结果是合理的，因为在自然环境中特征匹配不如在人造环境中精确。</p>
<p><img src="/images/loam论文翻译/image-20220410153427498.png" alt="image-20220410153427498" style="zoom:50%;" /></p>
<blockquote>
<p>图11所示。廊道(红色)、大堂(绿色)、绿化路(蓝色)、果园(黑色)的匹配误差，对应图$10$中的四个场景。</p>
</blockquote>
<p><img src="/images/loam论文翻译/image-20220410153545569.png" alt="image-20220410153545569" style="zoom: 33%;" /></p>
<p>此外，我们还对运动估计的累积漂移进行了测试。我们选择包含闭环的走廊进行室内实验。这使得我们可以在同一个地方开始和结束。运动估计在起始位置和结束位置之间产生一个间隙，该间隙表明了漂移量。对于户外实验，我们选择果园环境。 携带激光雷达的地面车辆配备了高精度 $GPS/INS$，用于获取地面实况。 将测得的漂移与行进距离作为相对精度进行比较，并列于表$ I$。具体来说，测试$ 1 $使用与图 $10(a)$ 和图 $10(g) $相同的数据集。 一般来说，室内测试的相对准确度在$ 1\% $左右，室外测试的相对准确度在 $2.5\% $左右。</p>
<h2 id="B-融合IMU"><a href="#B-融合IMU" class="headerlink" title="B.融合IMU"></a>B.融合IMU</h2><p>我们将<code>Xsens MTi-10 IMU</code> 连接到激光雷达以应对快速的速度变化。 点云在发送到所提出的方法之前以两种方式进行预处理，$1)$ 使用来自 $IMU$ 的方向，在一次扫描中接收到的点云被旋转，使得与该扫描中激光雷达的初始方向对齐，$2)$ 使用加速度测量 ，运动失真被部分消除，就好像激光雷达在扫描过程中以恒定速度移动一样。 然后由激光雷达里程计和建图程序处理点云。</p>
<p>$IMU $定位是通过在卡尔曼滤波器 [1] 中集成来自陀螺仪的角速率和来自加速度计的读数来获得的。 图 $12(a) $显示了一个示例结果。 一个人拿着激光雷达走在楼梯上。 在计算红色曲线时，我们使用 IMU 提供的方向，我们的方法只估计平移。 在 $5 $分钟的数据收集过程中，方向漂移超过 $25°$。 假设没有可用的$ IMU$，绿色曲线仅依赖于我们方法中的优化。 蓝色曲线使用$ IMU $数据进行预处理，然后采用本文方法。 我们观察到绿色和蓝色曲线之间的微小差异。 图 $12(b) $给出了对应于蓝色曲线的图。 在图$ 12(c)$中，我们比较了图 $12(b)$中黄色矩形中地图的两个闭合视图。 上图和下图分别对应蓝色和绿色曲线。 仔细对比发现，上图的边缘更加清晰。</p>
<p><img src="/images/loam论文翻译/image-20220410153604781.png" alt="image-20220410153604781" style="zoom:50%;" /></p>
<p><img src="/images/loam论文翻译/image-20220410153615690.png" alt="image-20220410153615690" style="zoom:50%;" /></p>
<blockquote>
<p>图 $12$所示。有/无$IMU$ 辅助的结果比较。 一个人拿着激光雷达走在楼梯上。 黑点是起点。 在$(a)$中，红色曲线使用来自$ IMU $的方向和我们的方法估计的平移来计算，绿色曲线仅依赖于我们方法中的优化，蓝色曲线使用$ IMU$数据进行预处理，然后再进行该方法。 $(b)$是对应于蓝色曲线的地图。 在$(c)$中，上图和下图分别对应于蓝色和绿色曲线，使用$(b)$中黄色矩形标记的区域。 上图中的边缘更清晰，表明地图上的准确性更高。</p>
</blockquote>
<p>表 $II$ 比较了使用和不使用$ IMU $的运动估计的相对误差。 激光雷达由一个人以$0.5m/s $的速度行走并以$ 0.5m $左右的幅度上下移动激光雷达。 地面实况(ground truth)是由卷尺手动测量的。 在所有四个测试中，在$ IMU $的帮助下使用所提出的方法可以获得最高的准确度，而使用 $IMU$ 定位只会导致最低的准确度。 结果表明，$IMU$有效地消除了非线性运动，所提出的方法利用它来处理线性运动。</p>
<h2 id="C-使用-KITTI-数据集进行测试"><a href="#C-使用-KITTI-数据集进行测试" class="headerlink" title="C.使用 KITTI 数据集进行测试"></a>C.使用 KITTI 数据集进行测试</h2><p><img src="/images/loam论文翻译/image-20220410153653541.png" alt="image-20220410153653541"></p>
<blockquote>
<p>图 13. $(a) $KITTI 基准测试使用的传感器配置和车辆。该车辆安装有 Velodyne 激光雷达、立体摄像头和用于获取地面实况的高精度 GPS/INS。我们的方法仅使用来自 Velodyne 激光雷达的数据。$(b)$ 来自城市场景的示例激光雷达云（上图）和相应的视觉图像（下图）。</p>
</blockquote>
<p>我们还使用来自 KITTI 里程计基准 [30]、[31] 的数据集评估了我们的方法。数据集仔细地与安装在结构化道路上行驶的乘用车顶部的传感器相注册（图 $13(a)$）。车辆配备$ 360° $Velodyne 激光雷达、彩色/单色立体摄像头、以及用于地面实况(ground truth)的高精度 GPS/INS，激光雷达数据以 $10Hz $记录，并由我们的方法用于里程计估计。由于篇幅问题，我们无法将结果包括在内。但是，我们鼓励读者在评估(benchmark)网站上查看我们的结果$^3$。</p>
<blockquote>
<p>3www.cvlibs.net/datasets/kitti/eval_odometry.php</p>
</blockquote>
<p>数据集主要涵盖三类环境：周围有建筑物的“城市”、场景中有植被的小路上的“乡村”以及道路较宽且周围环境相对干净的“高速公路”。图 13$(b)$ 显示了一个示例激光雷达云和来自城市环境的相应视觉图像。数据集中包含的总行驶距离为$ 39.2 $公里。上传车辆轨迹后，评估(benchmark)服务器会自动计算准确性和排名。我们的方法在评估(benchmark)的所有方法中排名第一，无论传感方式如何，包括最先进的立体视觉里程计 [32]、[33]。平均位置误差是行进距离的 $0.88\%$，使用 $3D $坐标中 $100m、200m、…、800m $长度的轨迹段生成。</p>
<h1 id="VIII-结论和未来的工作"><a href="#VIII-结论和未来的工作" class="headerlink" title="VIII. 结论和未来的工作"></a>VIII. 结论和未来的工作</h1><p>使用来自旋转激光扫描仪的点云进行运动估计和建图可能很困难，因为该问题涉及激光雷达云中运动的恢复和运动失真的校正。所提出的方法通过并行运行的两种算法来划分和解决问题：激光雷达里程计进行粗略处理以估计较高频率的速度，而激光雷达建图执行精细处理以在较低频率创建地图。两种算法的合作允许实时准确的运动估计和建图。此外，该方法可以利用激光雷达扫描模式和点云分布。进行特征匹配以确保里程计算法中的快速计算，并增建图算法的准确性。该方法已在室内和室外以及 KITTI 里程计评估(benchmark)上进行了测试。</p>
<p>由于当前的方法不能识别闭环，我们未来的工作包括开发一种通过闭环来修复运动估计漂移的方法。此外，我们将我们方法的输出与卡尔曼滤波器中的 IMU 集成，以进一步减少运动估计漂移。</p>
]]></content>
      <categories>
        <category>激光SLAM</category>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>激光SLAM</tag>
        <tag>LOAM</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>ch11_实践位姿图优化</title>
    <url>/posts/40808.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>我们可以构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。通过这种方式，我们省去了大量的特征点优化的计算，只保留了关键帧的轨迹，从而构建了所谓的位姿图（Pose Graph）。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>我们将带有相机位姿和空间点的图优化称为 BA，能够有效地求解大规模的定位与建图问题。但是考虑大场景以及实时性的要求，我们不得不想办法缩减计算量，这就是引入位姿图的意义。</p>
<p><img src="/images/实践位姿图优化/image-20220407170107621.png" alt="image-20220407170107621"></p>
<h1 id="g2o-原生位姿图"><a href="#g2o-原生位姿图" class="headerlink" title="g2o 原生位姿图"></a>g2o 原生位姿图</h1><p>Pose Graph 图优化的<strong>节点</strong>表示相机位姿，以 $\xi_1,\xi_2,…,\xi_n$来表达。而<strong>边</strong>，则是两个位姿节点之间相对运动的估计，该估计可能来自于特征点法或直接法。</p>
<p><img src="/images/实践位姿图优化/image-20220408092815957.png" alt="image-20220408092815957" style="zoom:50%;" /></p>
<p><code>g2o</code>仿真产生的位姿图，由 <code>g2o</code>自带的 create sphere 程序仿真生成的。它的真实轨迹为一个球，由从下往上的多个层组成。每层为一个正圆形，很多个大小不一的圆形层组成了一个完整的球体，共包含 2500 个位姿节点，可以看成一个转圈上升的过程。然后，仿真程序生成了$ t − 1 $到 $t$ 时刻的边，称为<code>odometry</code><strong>边（里程计）</strong>。此外，又生成层与层之间的边，称为 <strong>loop closure（回环）</strong>。</p>
<p>sphere.g2o 也是一个文本文件，可以用文本编辑器打开，查看它里面的内容。文件前半部分由节点组成，后半部分则是边：</p>
<p><img src="/images/实践位姿图优化/image-20220408093444275.png" alt="image-20220408093444275"></p>
<p>可以看到，节点类型是 VERTEX_SE3，表达一个相机位姿。 g2o 默认使用四元数和平移向量表达位姿，所以后面的字段意义为：$ ID， t_x , t_y , t_z , q_x , q_y , q_z , q_w $。前三个为平移向量元素，后四个为表示旋转的单位四元数。同样，边的信息为：两个节点的 $ID， t _x , t _y , t _z , q _x , q _y , q _z , q _w$ ，信息矩阵的右上角（由于信息矩阵为对称阵，只需保存一半即可）。可以看到这里把信息矩阵设成了对角阵。</p>
<p>为了优化该位姿图，我们可以使用 g2o 默认的顶点和边，它们是由四元数表示的。由于仿真数据也是 g2o 生成的，所以用 g2o 本身优化就无需我们多做什么工作了，只需配置一下优化参数即可。</p>
<p><code>pose_graph_g2o_SE3.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/slam3d/types_slam3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/cholmod/linear_solver_cholmod.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment"> * 本程序演示如何用g2o solver进行位姿图优化</span></span><br><span class="line"><span class="comment"> * sphere.g2o是人工生成的一个Pose graph，我们来优化它。</span></span><br><span class="line"><span class="comment"> * 尽管可以直接通过load函数读取整个图，但我们还是自己来实现读取代码，以期获得更深刻的理解</span></span><br><span class="line"><span class="comment"> * 这里使用g2o/types/slam3d/中的SE3表示位姿，它实质上是四元数而非李代数.</span></span><br><span class="line"><span class="comment"> * **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 传入待优化的信息</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入文件 sphere.g2o&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择了 6×6 的块求解器</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">6</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 1.线性方程求解器（LinearSolverCholmod使用sparse cholesky分解法。继承自LinearSolverCCS）</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver。（梯度下降方法，从GN, LM, DogLeg 中选）</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4、创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexCnt = <span class="number">0</span>, edgeCnt = <span class="number">0</span>; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">    <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读文件 sphere.g2o</span></span><br><span class="line">        string name;</span><br><span class="line">        fin &gt;&gt; name;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">&quot;VERTEX_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3 顶点</span></span><br><span class="line">            g2o::VertexSE3 *v = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3</span>();</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            fin &gt;&gt; index;</span><br><span class="line">            v-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">            v-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line">            vertexCnt++;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                v-&gt;<span class="built_in">setFixed</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;EDGE_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3-SE3 边</span></span><br><span class="line">            g2o::EdgeSE3 *e = <span class="keyword">new</span> g2o::<span class="built_in">EdgeSE3</span>();</span><br><span class="line">            <span class="keyword">int</span> idx1, idx2;</span><br><span class="line">            fin &gt;&gt; idx1 &gt;&gt; idx2;</span><br><span class="line">            e-&gt;<span class="built_in">setId</span>(edgeCnt++);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, optimizer.<span class="built_in">vertices</span>()[idx1]);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, optimizer.<span class="built_in">vertices</span>()[idx2]);</span><br><span class="line">            e-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addEdge</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fin.<span class="built_in">good</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读到&quot;</span> &lt;&lt; vertexCnt &lt;&lt; <span class="string">&quot;个点，&quot;</span> &lt;&lt; edgeCnt &lt;&lt; <span class="string">&quot;个边&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;准备优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;执行优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保存优化结果......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">save</span>(<span class="string">&quot;result.g2o&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_graph )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Eigen</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># sophus </span></span><br><span class="line"><span class="keyword">find_package</span>( Sophus REQUIRED )</span><br><span class="line"><span class="comment"># Sophus链接错误</span></span><br><span class="line"><span class="keyword">set</span>(Sophus_LIBRARIES libSophus.so)</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;Sophus_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># g2o </span></span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( Cholmod REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;CHOLMOD_INCLUDE_DIR&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_graph_g2o_SE3 pose_graph_g2o_SE3.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_graph_g2o_SE3</span><br><span class="line">    g2o_core g2o_stuff g2o_types_slam3d <span class="variable">$&#123;CHOLMOD_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>优化结束执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line">./build/pose_graph_g2o_SE3 ../sphere.g2o  </span><br><span class="line"><span class="comment"># 查看优化够的位姿图</span></span><br><span class="line">g2o_viewer result.g2o </span><br></pre></td></tr></table></figure>
<p><img src="/images/实践位姿图优化/image-20220408142818313.png" alt="image-20220408142818313" style="zoom:50%;" /></p>
<h1 id="李代数上的位姿图优化"><a href="#李代数上的位姿图优化" class="headerlink" title="李代数上的位姿图优化"></a>李代数上的位姿图优化</h1><p>把 Sophus 用到 g2o 中，定义自己的顶点和边吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定误差求J_R^&#123;-1&#125;的近似</span></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matrix6d;</span><br><span class="line"><span class="function">Matrix6d <span class="title">JRInv</span><span class="params">(SE3 e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix6d J;</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>) = SO3::<span class="built_in">hat</span>(e.<span class="built_in">so3</span>().<span class="built_in">log</span>());</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = SO3::<span class="built_in">hat</span>(e.<span class="built_in">translation</span>());</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>) = Eigen::Matrix3d::<span class="built_in">Zero</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = SO3::<span class="built_in">hat</span>(e.<span class="built_in">so3</span>().<span class="built_in">log</span>());</span><br><span class="line">    J = J * <span class="number">0.5</span> + Matrix6d::<span class="built_in">Identity</span>();</span><br><span class="line">    <span class="keyword">return</span> J;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义李代数顶点"><a href="#定义李代数顶点" class="headerlink" title="定义李代数顶点"></a>定义李代数顶点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 李代数顶点</span></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Vector6d;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexSE3LieAlgebra</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">6</span>, SE3&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            is &gt;&gt; data[i];</span><br><span class="line">        <span class="built_in">setEstimate</span>(<span class="built_in">SE3</span>(Eigen::<span class="built_in">Quaterniond</span>(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>]),</span><br><span class="line">                        Eigen::<span class="built_in">Vector3d</span>(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        Eigen::Quaterniond q = _estimate.<span class="built_in">unit_quaternion</span>();</span><br><span class="line">        os &lt;&lt; _estimate.<span class="built_in">translation</span>().<span class="built_in">transpose</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        os &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate = Sophus::<span class="built_in">SE3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左乘更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Sophus::SE3 <span class="title">up</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Sophus::SO3(update[<span class="number">3</span>], update[<span class="number">4</span>], update[<span class="number">5</span>]),</span></span></span><br><span class="line"><span class="params"><span class="function">            Eigen::Vector3d(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]))</span></span>;</span><br><span class="line">        _estimate = up * _estimate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="定义李代数节点之边"><a href="#定义李代数节点之边" class="headerlink" title="定义李代数节点之边"></a>定义李代数节点之边</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个李代数节点之边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3LieAlgebra</span> :</span> <span class="keyword">public</span> g2o::BaseBinaryEdge&lt;<span class="number">6</span>, SE3, VertexSE3LieAlgebra, VertexSE3LieAlgebra&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            is &gt;&gt; data[i];</span><br><span class="line">        <span class="function">Eigen::Quaterniond <span class="title">q</span><span class="params">(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span></span>;</span><br><span class="line">        q.<span class="built_in">normalize</span>();</span><br><span class="line">        <span class="built_in">setMeasurement</span>(Sophus::<span class="built_in">SE3</span>(q, Eigen::<span class="built_in">Vector3d</span>(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">information</span>().<span class="built_in">rows</span>() &amp;&amp; is.<span class="built_in">good</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">information</span>().<span class="built_in">cols</span>() &amp;&amp; is.<span class="built_in">good</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                is &gt;&gt; <span class="built_in">information</span>()(i, j);</span><br><span class="line">                <span class="keyword">if</span> (i != j)</span><br><span class="line">                    <span class="built_in">information</span>()(j, i) = <span class="built_in">information</span>()(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VertexSE3LieAlgebra *v1 = <span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        VertexSE3LieAlgebra *v2 = <span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">        os &lt;&lt; v1-&gt;<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2-&gt;<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        SE3 m = _measurement;</span><br><span class="line">        Eigen::Quaterniond q = m.<span class="built_in">unit_quaternion</span>();</span><br><span class="line">        os &lt;&lt; m.<span class="built_in">translation</span>().<span class="built_in">transpose</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        os &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">// information matrix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">information</span>().<span class="built_in">rows</span>(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">information</span>().<span class="built_in">cols</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                os &lt;&lt; <span class="built_in">information</span>()(i, j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        os &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 误差计算与书中推导一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::SE3 v1 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">0</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        Sophus::SE3 v2 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">1</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error = (_measurement.<span class="built_in">inverse</span>() * v1.<span class="built_in">inverse</span>() * v2).<span class="built_in">log</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 雅可比计算</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::SE3 v1 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">0</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        Sophus::SE3 v2 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">1</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        Matrix6d J = <span class="built_in">JRInv</span>(SE3::<span class="built_in">exp</span>(_error));</span><br><span class="line">        <span class="comment">// 尝试把J近似为I？</span></span><br><span class="line">        _jacobianOplusXi = -J * v2.<span class="built_in">inverse</span>().<span class="built_in">Adj</span>();</span><br><span class="line">        _jacobianOplusXj = J * v2.<span class="built_in">inverse</span>().<span class="built_in">Adj</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义文件传入</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请传入文件sphere.g2o&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择了 6×6 的块求解器</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">6</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 1.线性方程求解器（LinearSolverCholmod使用sparse cholesky分解法。继承自LinearSolverCCS）</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver。（梯度下降方法，从GN, LM, DogLeg 中选）</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4、创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexCnt = <span class="number">0</span>, edgeCnt = <span class="number">0</span>; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">    vector&lt;VertexSE3LieAlgebra *&gt; vectices;</span><br><span class="line">    vector&lt;EdgeSE3LieAlgebra *&gt; edges;</span><br><span class="line">    <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读文件 sphere.g2o</span></span><br><span class="line">        string name;</span><br><span class="line">        fin &gt;&gt; name;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">&quot;VERTEX_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3 顶点</span></span><br><span class="line">            VertexSE3LieAlgebra *v = <span class="keyword">new</span> <span class="built_in">VertexSE3LieAlgebra</span>(); <span class="comment">// 使用自定义的顶点</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            fin &gt;&gt; index;</span><br><span class="line">            v-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">            v-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line">            vertexCnt++;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                v-&gt;<span class="built_in">setFixed</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;EDGE_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3-SE3 边</span></span><br><span class="line">            EdgeSE3LieAlgebra *e = <span class="keyword">new</span> <span class="built_in">EdgeSE3LieAlgebra</span>(); <span class="comment">// 使用自定义的边</span></span><br><span class="line">            <span class="keyword">int</span> idx1, idx2;</span><br><span class="line">            fin &gt;&gt; idx1 &gt;&gt; idx2;</span><br><span class="line">            e-&gt;<span class="built_in">setId</span>(edgeCnt++);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, optimizer.<span class="built_in">vertices</span>()[idx1]);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, optimizer.<span class="built_in">vertices</span>()[idx2]);</span><br><span class="line">            e-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addEdge</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fin.<span class="built_in">good</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读到&quot;</span> &lt;&lt; vertexCnt &lt;&lt; <span class="string">&quot;个点，&quot;</span> &lt;&lt; edgeCnt &lt;&lt; <span class="string">&quot;个边&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;准备优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;执行优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保存优化结果......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 因为用了自定义顶点且没有向g2o注册，这里保存自己来实现</span></span><br><span class="line">    <span class="comment">// 伪装成 SE3 顶点和边，让 g2o_viewer 可以认出</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;result_lie.g2o&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (VertexSE3LieAlgebra *v : vectices)</span><br><span class="line">    &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;VERTEX_SE3:QUAT &quot;</span>;</span><br><span class="line">        v-&gt;<span class="built_in">write</span>(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (EdgeSE3LieAlgebra *e : edges)</span><br><span class="line">    &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;EDGE_SE3:QUAT &quot;</span>;</span><br><span class="line">        e-&gt;<span class="built_in">write</span>(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>后端优化</tag>
        <tag>位姿图优化</tag>
      </tags>
  </entry>
  <entry>
    <title>g2o-viewer安装</title>
    <url>/posts/15722.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>g2o_viewer是g2o提供的位姿图优化的仿真程序，该位姿图是由 g2o 自带的 create sphere 程序仿真生成的。它的真实轨迹为一个球，由从下往上的多个层组成。每层为一个正圆形，很多个大小不一的圆形层组成了一个完整的<br>球体，共包含 2500 个位姿节点，可以看成一个转圈上升的过程。然后，仿真程序生成了 t − 1 到 t 时刻的边，称为 odometry 边（里程计）。此外，又生成层与层之间的边，称为 loop closure。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>首先，你要下载$g2o$:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.2 libcholmod-dev</span><br><span class="line"><span class="comment"># g2o_viewer依赖</span></span><br><span class="line">sudo apt-get install libsuitesparse-dev qtdeclarative5-dev qt5-qmake libqglviewer-dev-qt5</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> g2o</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>文件结构已经提过了</p>
<p><img src="/images/g2o-viewer安装/image-20220405210455088.png" alt="image-20220405210455088"></p>
<p>我们的g2o_viewer源文件就在app里面：</p>
<p><img src="/images/g2o-viewer安装/image-20220405210828391.png" alt="image-20220405210828391" style="zoom:50%;" /></p>
<p>我们编译之后检查一下g2o源代码目录下<code>g2o\bin</code>下有没有生成g2o_viewer的可执行文件</p>
<p><img src="/images/g2o-viewer安装/image-20220405211004286.png" alt="image-20220405211004286" style="zoom:50%;" /></p>
<p>因为我们编译了，所以检查一下有没有在本地</p>
<p><img src="/images/g2o-viewer安装/image-20220405211129848.png" alt="image-20220405211129848" style="zoom:50%;" /></p>
<p>如果没有说明你没有<code>sudo make install</code>成功。</p>
<p>如果此时还不可以直接在终端打开g2o:</p>
<p><img src="/images/g2o-viewer安装/image-20220405211231692.png" alt="image-20220405211231692"></p>
<p>这就是没有链接成功了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/ld.so.conf</span><br></pre></td></tr></table></figure>
<p>然后加入：<code>include /usr/local/lib</code>,当然如果你有就不加咯</p>
<p>然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>然后就可以使用了！</p>
<p><img src="/images/g2o-viewer安装/image-20220405211615903.png" alt="image-20220405211615903" style="zoom:50%;" /></p>
<p>如果还不可以，那你指定哪一步不对劲！</p>
]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>SLAM实践</tag>
        <tag>g2o</tag>
      </tags>
  </entry>
  <entry>
    <title>线性最小二乘</title>
    <url>/posts/44179.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>按偏差平方和最小的原则选取拟合曲线，并且采取二项式方程为拟合曲线的方法, 称为最小二乘法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>常见的几种曲线拟合方式：</p>
<ul>
<li>使偏差绝对值之和最小</li>
</ul>
<script type="math/tex; mode=display">
\underset{φ}{min} \sum^m_{1=1}|e_i|= \sum^m_{1=1}|φ(x_i)-y_i|</script><ul>
<li>使偏差平方和最小</li>
</ul>
<script type="math/tex; mode=display">
\underset{φ}{min} \sum^m_{1=1}e_i^2= \sum^m_{1=1}(φ(x_i)-y_i)^2</script><ul>
<li>使偏差绝对值最大的最小</li>
</ul>
<script type="math/tex; mode=display">
\underset{φ}{min} \underset{i}{max} \sum^m_{1=1}|e_i|= \sum^m_{1=1}|φ(x_i)-y_i|</script><p>按偏差平方和最小的原则选取拟合曲线，并且采取二项式方程为拟合曲线的方法, 称为最小二乘法。</p>
<h1 id="线性最小二乘"><a href="#线性最小二乘" class="headerlink" title="线性最小二乘"></a>线性最小二乘</h1><h2 id="一元线性回归求解过程"><a href="#一元线性回归求解过程" class="headerlink" title="一元线性回归求解过程"></a>一元线性回归求解过程</h2><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>举一个简单的例子，某次实验得到了四个数据点$(x,y):(1,6),(2,5),(3,7),(4,10)$，如图所示</p>
<p><img src="/images/什么是最小二乘法/image-20220404164725825.png" alt="image-20220404164725825" style="zoom:50%;" /></p>
<p>我们需要找到一条直线与这四个点的最佳匹配，设这条直线为$y=ax+b$，即找出在某种“最佳情况”下能够大致符合如下超定线性方程组的 $a,b$:</p>
<script type="math/tex; mode=display">
1a+b=6\\
2a+b=5\\
3a+b=7\\
4a+b=10\\</script><p>最小二乘法采用的方法是尽量使得等号两边的平方差最小，也就是找出这个函数的最小值：</p>
<script type="math/tex; mode=display">
\begin{align*}
S(a,b)&=[6-(1a+b)]^2+[5-(2a+b)]^2+[7-(3a+b)]^2+[10-(4a+b)]^2\\
\end{align*}</script><p>最小值可以通过对$S(a,b)$分别求$a$和$b$的偏导数，然后使他们等于零得到。</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial S}{\partial a}&=8a+20b-56=0\\
\frac{\partial S}{\partial a}&=20a+60b-154=0
\end{align*}</script><p>如此就得到了一个只有两个未知数的方程组，很容易就可以解出：</p>
<script type="math/tex; mode=display">
a=3.5\\
b=1.4</script><p>也就是说直线$y=3.5x+1.4$是最佳的！</p>
<p>所以最小二乘法就是：寻找一个最能代表拟合数据的曲线，使得每个点到达这条曲线的距离最小。</p>
<h3 id="一般式推导"><a href="#一般式推导" class="headerlink" title="一般式推导"></a>一般式推导</h3><p>一般情况下，我们称$y=\theta_0+\theta_1x$为拟合函数，称$J(\theta_0,\theta_1)$为损失函数；</p>
<script type="math/tex; mode=display">
J(\theta_0,\theta_1)=\sum^m_{i=0}(y_i-(\theta_0+\theta_1x))^2</script><p>损失函数$J(\theta_0,\theta_1)$分别对$\theta_0,\theta_1$求偏导：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial J(\theta_0,\theta_1)}{\theta_0}&=-2\sum^m_{i=0}(y_i-(\theta_0+\theta_1x_i))=0\\
\frac{\partial J(\theta_0,\theta_1)}{\theta_1}&=-2\sum^m_{i=0}(y_i-(\theta_0+\theta_1x_i))x_i=0\\\
\end{align*}</script><p>联立两式，求解可得：</p>
<script type="math/tex; mode=display">
\begin{align*}
\theta_1&=\frac{\sum \limits ^m_{i=1}(x_i-\overline{x})(y_i-\overline{y}) }
{\sum \limits ^m_{i=1}(x_i-x)^2} \\
\theta_0&=\overline{y}-\theta_1\overline{x}
\end{align*}</script><h3 id="使用矩阵求解"><a href="#使用矩阵求解" class="headerlink" title="使用矩阵求解"></a>使用矩阵求解</h3><p>当$f(x)$取线性函数的形式:</p>
<script type="math/tex; mode=display">
f(x)=Ax-b</script><p>其中A是m*n的矩阵，b是m维向量，损失函数可以表示为：</p>
<script type="math/tex; mode=display">
min\parallel Ax-b\parallel^2</script><p>定理：$x^<em>$是极小点的充分必要条件是，$x^</em>$是方程组</p>
<script type="math/tex; mode=display">
A^TAx=A^Tb</script><p>的解。</p>
<blockquote>
<p>这个定理的证明过程就是利用上文的求导方式进行的，详细查询相关资料。</p>
</blockquote>
<p>所以对于上面的案例：</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
1&1\\2&1\\3&1\\4&1\\
\end{bmatrix},
b=\begin{bmatrix}
6\\5\\7\\10\\
\end{bmatrix}</script><p>求解：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&2 &3&4\\1&1 &1&1\\
\end{bmatrix}
\begin{bmatrix}
1&1\\2&1\\3&1\\4&1\\
\end{bmatrix}
\begin{bmatrix}
\theta_0\\\theta_1\\
\end{bmatrix}=
\begin{bmatrix}
1&2 &3&4\\1&1 &1&1\\
\end{bmatrix}
\begin{bmatrix}
6\\5\\7\\10\\
\end{bmatrix}</script><p>易得：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\theta_0\\ \theta_1\\
\end{bmatrix}=
\begin{bmatrix}
1.4\\3.5\\
\end{bmatrix}</script><h2 id="多元线性回归求解过程"><a href="#多元线性回归求解过程" class="headerlink" title="多元线性回归求解过程"></a>多元线性回归求解过程</h2><p>【背景】给定$m$组点$(x_{11},…,x_{1n},y_1),(x_{21},…,x_{2n},y_2),…,(x_{m1},…,x_{mn},y_m)$，求它的拟合曲线？</p>
<p>对于多元函数的拟合，可以设拟合函数为：$ h_θ(x_1,x_2,…x_n)=θ_1+θ_2x_{j1}+…+θ_nx_{jn}$</p>
<p>为了简化，我们增加一个特征值$x_0=1$使得$ h_θ(x_0,x_1,x_2,…x_n)=θ_1+θ_2x_{j1}+…+θ_nx_{jn}$</p>
<p>则每一组数为$(1,x_1,x_2,…,x_n,yj),j=1,2,…,m$，也就是求取最合适的系数$\theta_0,\theta_1,…\theta_n$,使得多元函数对所有点的拟合达到最佳！</p>
<p>损失函数：</p>
<script type="math/tex; mode=display">
J(\theta)=\sum^m_{j=0}(y_j-(θ_1+θ_2x_{j1}+...+θ_nx_{jn})^2</script><p>分别对$\theta_1,\theta_2,…,\theta_n$，求偏导：</p>
<p>由于一共有$m$组数据，所以使用每一组数据对$\theta_1,\theta_2,…,\theta_n$分别求偏导，比如对$\theta_1$求偏导：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial J_1(\theta)}{\partial \theta_1}&= \frac{\partial[ y_1-(θ_0+θ_1x_{11} +...+θ_nx_{1n})]^2}{\partial \theta_1}\\
\frac{\partial J_2(\theta)}{\partial \theta_1}&= \frac{\partial[ y_2-(θ_0+θ_1x_{21} +...+θ_nx_{2n})]^2}{\partial \theta_1}\\
&......\\
\frac{\partial J_m(\theta)}{\partial \theta_1}&= \frac{\partial[ y_m-(θ_0+θ_1x_{m1} +...+θ_nx_{mn})]^2}{\partial \theta_1}

\end{align*}</script><p>我们可以得到一个雅可比矩阵：</p>
<script type="math/tex; mode=display">
J(\theta)=
\begin{bmatrix}
\frac{\partial J_1(\theta)}{\partial \theta_1}
&\frac{\partial J_2(\theta)}{\partial \theta_1}
&...
&\frac{\partial J_m(\theta)}{\partial \theta_1}\\
\frac{\partial J_1(\theta)}{\partial \theta_2}
&\frac{\partial J_2(\theta)}{\partial \theta_2}
&...
&\frac{\partial J_m(\theta)}{\partial \theta_2}\\
...&...&...&...\\
\frac{\partial J_1(\theta)}{\partial \theta_n}
&\frac{\partial J_2(\theta)}{\partial \theta_n}
&...
&\frac{\partial J_m(\theta)}{\partial \theta_n}\\
\end{bmatrix}</script><p>这样的问题可以用矩阵表示：</p>
<script type="math/tex; mode=display">
Ax=b</script><p>其中$X$表示$m$组点的自变量的值，$Y$代表每一组自变量对应的函数值。</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
1&x_{12}& ...&x_{1n}\\
1&x_{22}& ...&x_{2n}\\
1&...& ...&...\\
1&x_{m2}& ...&x_{mn}\\
\end{bmatrix}，
x=\begin{bmatrix}
\theta_1\\\theta_2\\ ...\\\theta_n\\
\end{bmatrix},
b=\begin{bmatrix}
y_1\\y_2\\ ...\\y_m\\
\end{bmatrix}</script><p>损失函数：</p>
<script type="math/tex; mode=display">
J(\theta)=\sum^{m}_{i=1}|y_i-\sum^n_{j=1}x_{ij}\theta_j|^2=\parallel  Ax-b \parallel^2</script><p>由上文的定理：</p>
<script type="math/tex; mode=display">
A^TAx=A^Tb</script><p>求得：</p>
<script type="math/tex; mode=display">
x=\begin{bmatrix}
\theta_1\\\theta_2\\ ...\\\theta_n\\
\end{bmatrix}=
(A^TA)^{-1}A^Tb</script>]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>最小二乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波的数学推导</title>
    <url>/posts/60703.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>卡尔曼滤波（Kalman filter）是一种高效率的<strong>递归滤波器</strong>（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h1><h2 id="先验与后验估计"><a href="#先验与后验估计" class="headerlink" title="先验与后验估计"></a>先验与后验估计</h2><p>由之前的状态空间方程：</p>
<script type="math/tex; mode=display">
\begin{align*}
{x_k }&=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\
z_{k}&=Hx_{k}+v_k
\end{align*}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$，推导如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
Q=E[ww^T]&=E
\begin{bmatrix}
\begin{bmatrix}w_1\\w_2\\.\\.\\w_k \end{bmatrix}
\begin{bmatrix}w_1&w_2&...&w_k \end{bmatrix}
\end{bmatrix}
=E
\begin{bmatrix}w_1^2&w_1w_2&...&w_1w_k\\
w_2w_1&w_2^2&...&w_2w_k\\
...&...&...&...\\
w_kw_1&w_kw_1&...&w_k^2
\end{bmatrix}\\
&=\begin{bmatrix}Ew_1^2&Ew_1w_2&...&Ew_1w_k\\
Ew_2w_1&Ew_2^2&...&Ew_2w_k\\
...&...&...&...\\
Ew_kw_1&Ew_kw_1&...&Ew_k^2
\end{bmatrix}
\end{align*}</script><p>由于$w$的期望为$0$，由方差等于平方的期望减去期望的平方以及协方差公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
Var(X)&=E(X^2)-E^2(X)\\
Cov(X,Y)&=E((X-\mu)(Y-v))
\end{align*}</script><p>所以此处平方的期望就等于方差：</p>
<script type="math/tex; mode=display">
\begin{align*}
Var(X)&=E(X^2)\\
Cov(X,Y)&=E(X·Y)
\end{align*}</script><p>即为：</p>
<script type="math/tex; mode=display">
Ew_k^2=\sigma_{w_1}^2,Ew_iw_j=\sigma_i\sigma_j</script><p>所以：</p>
<script type="math/tex; mode=display">
Q=\begin{bmatrix}Ew_1^2&Ew_1w_2&...&Ew_1w_k\\
Ew_2w_1&Ew_2^2&...&Ew_2w_k\\
...&...&...&...\\
Ew_kw_1&Ew_kw_1&...&Ew_k^2
\end{bmatrix}=
\begin{bmatrix}
\sigma_{w_{1} }^2&\sigma_{w_1}\sigma_{w_2}&...&\sigma_{w_1}\sigma_{w_k}\\
\sigma_{w_2}\sigma_{w_1}&\sigma_{w_{2} }^2&...&\sigma_{w_2}\sigma_{w_k}\\
...&...&...&...\\
\sigma_{w_k}\sigma_{w_1}&\sigma_{w_k}\sigma_{w_1}&...&\sigma_{w_{k} }^2
\end{bmatrix}</script><p>因此$Q$就是之前所提到的协方差矩阵，同样的，测量噪声也有协方差矩阵$R$，满足类似的条件。</p>
<hr>
<p>由于存在噪声的影响，所得到的$x_k$并不精确，我们暂且设它为$\hat{x}_k$，表示这是$x_k$的估计值；同样的$x_{k-1}$也是不准确的，设为$\hat{x}_{k-1}$，并且我们设通过下试得到的$x_k$成为先验估计，定义为$\hat{x}^-_k$；</p>
<p><b><span style="color:rgb(255, 0, 255);">先验估计（公式1）：</span></b></p>
<script type="math/tex; mode=display">
\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}</script><p>由于$z_k$是测出的结果，是已知的，由$z_k=Hx_k$可知：</p>
<script type="math/tex; mode=display">
\hat{x}_{kmea}=H^-z_k</script><p>对于上面的两个式子，$\hat{x}^-_k$是算出来的，$\hat{x}_{kmea}$是测出来的，因为收到噪声的影响，它们两个都是不准确的，因此这时候卡尔曼滤波的作用就显现出来了，如何利用两个不准确的值去得出一个相对准确的结果？这里就很容易想到之前提到的数据融合的思想。</p>
<script type="math/tex; mode=display">
\hat{x}_k=\hat{x}^-_k+G(H^-z_k-\hat{x}^-_k)，G\in[0,1]</script><p>分析式子很容易理解，当我们的测量数据很少时，$G\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多时，$G\approx1$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p>
<p>一般教科书上设$G=K_kH$；</p>
<p><b><span style="color:rgb(255, 0, 255);">后验估计（公式2）：</span></b></p>
<script type="math/tex; mode=display">
\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]</script><p>同样的，当我们的测量数据很少（不准确）时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多（相对准确）时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p>
<h2 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h2><p>因此，我们的目标变得十分明确了，如何选择一个合适的$K_k$值，使得$\hat{x}_k\rightarrow x_k$，其中$x_k$表示真实值。</p>
<p>此时，我们定义一个误差值$e_k$，以及一个先验误差值$e_k^-$：</p>
<script type="math/tex; mode=display">
e_k=x_k-\hat{x}_k\\
e_k^-=x_k-\hat{x}^-_k</script><p>误差也是符合高斯分布，$p(e_k)\sim(0,P)$，其中协方差矩阵$P=E[ee^T]$，与之前推导的$Q$是类似的。</p>
<p>因此，最终的目的就是选择一个合适的$K_k$值，使得$e_k$最小，也就是使得它的方差最小，因为方差越小，说明越接近期望值$0$，即$e_k\approx0$。而方差最小就是使得它的协方差矩阵的迹$tr(P)=\sigma^2_{e_{1} }+\sigma^2_{e_{2} }+…+\sigma^2_{e_{k} }$最小。</p>
<font color="#dd0000">所以，最终的目的为：寻找一个合适的$K_k$使得$tr(P)$最小！</font>

<hr>
<script type="math/tex; mode=display">
\begin{align*}
tr(P)&=E[ee^T]\\
&=E[(x_k-\hat{x}_k)(x_k-\hat{x}_k)^T]
\end{align*}</script><p>已知：</p>
<script type="math/tex; mode=display">
\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k)\\
z_k=Hx_k+v_k</script><p>带入上式：</p>
<script type="math/tex; mode=display">
\begin{align*}
x_k-\hat{x}_k&=x_k-(\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k))\\
&=x_k-\hat{x}^-_k-K_kz_k+K_kH\hat{x}^-_k\\
&=x_k-\hat{x}^-_k-K_k(Hx_k+v_k)+K_kH\hat{x}^-_k\\
&=x_k-\hat{x}^-_k-K_kHx_k-K_kv_k+K_kH\hat{x}^-_k\\
&=(x_k-\hat{x}^-_k)-K_kH(x_k-\hat{x}^-_k)-K_kv_k\\
&=(I-K_kH)(x_k-\hat{x}^-_k)-K_kv_k\\
&=(I-K_kH)e_k^--K_kv_k
\end{align*}</script><p>所以：</p>
<blockquote>
<p>可能会用到的公式：</p>
<p>$(AB)^T=B^TA^T$，$(A+B)^T=A^T+B^T$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align*}
tr(P)&=E[ee^T]\\
&=E[(x_k-\hat{x}_k)(x_k-\hat{x}_k)^T]\\
&=E[[(I-K_kH)e_k^--K_kv_k][(I-K_kH)e_k^--K_kv_k]^T]\\
&=E[[(I-K_kH)e_k^--K_kv_k][e_k^{-T}(I-K_kH)^T-v_k^TK_k^T]]\\
&=E[(I-K_kH)e_k^-e_k^{-T}(I-K_kH)^T-(I-K_kH)e_k^-v_k^TK_k^T\\
&-K_kv_ke_k^{-T}(I-K_kH)^T+K_kv_kv_k^TK_k^T]\\

\end{align*}</script><p>分别求每一项的期望：</p>
<blockquote>
<p>可能会用到的已知条件：</p>
<p>$E[e_k^-]=0,E[e_k^{-T}]=0,E[v_k^T]=0,E[v_k]=0$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align*}
&E[-(I-K_kH)e_k^-v_k^TK_k^T]\\
&=-(I-K_kH)E[e_k^-v_k^T]K_k^T\\
&=-(I-K_kH)E[e_k^-]E[v_k^T]K_k^T\\
&=0
\end{align*}</script><p>同理可得：</p>
<script type="math/tex; mode=display">
\begin{align*}
&E[-K_kv_ke_k^{-T}(I-K_kH)^T]\\
&=-K_kE[v_k]E[e_k^{-T}](I-K_kH)^T\\
&=0
\end{align*}</script><p>所以最终：</p>
<blockquote>
<p>可能会用到的定义：</p>
<p>已知协方差矩阵$P=E[ee^T]$，则定义$P_k^-=E[e_k^-e_k^{-T}]$</p>
<p>$p_{(v)}\sim(0,R)$，所以$R_k=E[v_kv^T_k]$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align*}
tr(P)&=E[ee^T]\\
&=E[(I-K_kH)e_k^-e_k^{-T}(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\
&=(I-K_kH)E[e_k^-e_k^{-T}](I-K_kH)^T+K_kE[v_kv_k^T]K_k^T\\
&=(P_k^--K_kHP_k^-)(I^T-H^TK_k^T)+K_kR_kK_k^T\\
&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kR_kK_k^T\\
\end{align*}</script><blockquote>
<p>由于，协方差矩阵的转置就是它本身，所以$P_k^{-T}=P_k^-$</p>
<p>$(P_k^-H^TK_k^T)^T=K_kHP_k^{-T}=K_kHP_k^-$，所以$tr(K_kHP_k^-)=tr(P_k^-H^TK_k^T)$</p>
</blockquote>
<p>因此：</p>
<script type="math/tex; mode=display">
\begin{align*}
tr(P)&=tr(P_k^-)-tr(K_kHP_k^-)-tr(P_k^-H^TK_k^T)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kR_kK_k^T)\\
&=tr(P_k^-)-2tr(K_kHP_k^-)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kR_kK_k^T)
\end{align*}</script><p>$tr(P)$对$K_k$求导，使得$\frac{dtr(P_k)}{dK_k}=0$：</p>
<blockquote>
<p>可能会用到的公式：</p>
<p>$\frac{dtr(AB)}{dA}=B^T$，$\frac{dtr(ABA^T)}{dA}=2AB$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align*}
\frac{dtr(P_k)}{dK_k}&=\frac{tr(P_k^-)}{dK_k}
-\frac{2tr(K_kHP_k^-)}{dK_k}
+\frac{tr(K_kHP_k^-H^TK_k^T))}{dK_k}
+\frac{tr(K_kR_kK_k^T))}{dK_k}\\
&=0-2(HP_k^-)^T+2K_kHP_k^-H^T+2K_kR_k\\
&=0
\end{align*}</script><p>所以：</p>
<script type="math/tex; mode=display">
\begin{align*}
(HP_k^-)^T&=K_k(HP_k^-H^T+R_k)
\end{align*}</script><p><b><span style="color:rgb(255, 0, 255);">卡尔曼增益（公式3）：</span></b></p>
<script type="math/tex; mode=display">
\begin{align*}
K_k&=\frac{P_k^-H^T}{HP_k^-H^T+R_k}
\end{align*}</script><p>因此，结合我们之前的结论：</p>
<blockquote>
<p>当我们的测量数据很少（不准确）时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多（相对准确）时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p>
</blockquote>
<p>此处也是相同的：</p>
<p>$R_k$表示测量噪声，当测量噪声很大时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；</p>
<p>当测量噪声很小时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p>
<hr>
<h2 id="误差协方差矩阵"><a href="#误差协方差矩阵" class="headerlink" title="误差协方差矩阵"></a>误差协方差矩阵</h2><p>总结前面推导的三个公式：</p>
<p><font color="#dd0000"><strong>先验估计（公式1）：</strong></font></p>
<script type="math/tex; mode=display">
\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}</script><p><font color="#dd0000"><strong>后验估计（公式2）：</strong></font></p>
<script type="math/tex; mode=display">
\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]</script><p><font color="#dd0000"><strong>卡尔曼增益（公式3）：</strong></font></p>
<script type="math/tex; mode=display">
\begin{align*}
K_k&=\frac{P_k^-H^T}{HP_k^-H^T+R_k}
\end{align*}</script><p>上面的公式里只有$P_k^-$是未知的，需要推导。由于已知协方差矩阵$P=E[ee^T]$，所以定义$P_k^-=E[e_k^-e_k^{-T}]$，如何求这个误差协方差矩阵是以下篇幅讨论的重点。</p>
<blockquote>
<p>可能会用到的定义与公式：</p>
<p>$e_k=x_k-\hat{x}_k$，$P_k=E[ee^T]$</p>
<p>$e_k^-=x_k-\hat{x}^-_k$ ，$P_k^-=E[e_k^-e_k^{-T}]$</p>
<p>$\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}$</p>
<p>$x_k =Ax_{k-1}+Bu_{k-1}+w_{k-1}$</p>
</blockquote>
<p>首先推导$e_k^-=x_k-\hat{x}^-_k$:</p>
<script type="math/tex; mode=display">
\begin{align*}
e_k^-&=x_k-\hat{x}^-_k\\
&=Ax_{k-1}+Bu_{k}+w_{k-1}-A\hat{x}_{k-1}-Bu_{k}\\
&=A(x_{k-1}-\hat{x}_{k-1})+w_{k-1}\\
&=Ae_{k-1}+w_{k-1}
\end{align*}</script><p>所以：</p>
<blockquote>
<p>由于$e_{k-1}=x_{k-1}-\hat{x}_{k-1}$，所以$e_{k-1}$作用的是上一时刻，而$w_k$是作用于当前时刻的，它们之间是相互独立的。$E[e_{k-1}w_{k}^T]=E[e_{k-1}]E[w_{k}^T]$，且$E[e_{k-1}]=E[w_{k}^T]=0$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align*}
P_k^-&=E[e_k^-e_k^{-T}]\\
&=E[(Ae_{k-1}+w_{k-1})(Ae_{k-1}+w_{k-1})^T]\\
&=E[(Ae_{k-1}+w_{k-1})(e_{k-1}^TA^T+w_{k-1}^T)]\\
&=E[Ae_{k-1}e_{k-1}^TA^T+Ae_{k-1}w_{k-1}^T+w_{k-1}e_{k-1}^TA^T+w_{k-1}w_{k-1}^T]\\
&=E[Ae_{k-1}e_{k-1}^TA^T]+E[Ae_{k-1}w_{k-1}^T]+E[w_{k-1}e_{k-1}^TA^T]+E[w_{k-1}w_{k-1}^T]\\
&=AE[e_{k-1}e_{k-1}^T]A^T+E[w_{k-1}w_{k-1}^T]\\
&=AP_{k-1}A^T+Q
\end{align*}</script><p><font color="#dd0000"><strong>误差协方差矩阵（公式4）：</strong></font></p>
<script type="math/tex; mode=display">
\begin{align*}
P_k^-=AP_{k-1}A^T+Q
\end{align*}</script><p>由于每一次的误差协方差矩阵$P_k^-$，都需要上一次的$P_{k-1}$，所以每一时刻我们都需要更新一下$P_k$的值，为下一时刻使用做准备。</p>
<p><font color="#dd0000"><strong>更新误差协方差：（公式5）：</strong></font></p>
<script type="math/tex; mode=display">
\begin{align*}
P_k&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kR_kK_k^T\\
&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_k(HP_k^-H^T+R_k)K_k^T\\
&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+\frac{P_k^-H^T}{HP_k^-H^T+R_k}(HP_k^-H^T+R_k)K_k^T\\
&=P_k^--K_kHP_k^-\\
&=(I-K_kH)P_k^-
\end{align*}</script><p>至此，我们可以总结一下整个卡尔曼滤波的过程：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">预测</th>
<th>校正</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">先验：$\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}$</td>
<td>卡尔曼增益：$K_k=\frac{P_k^-H^T}{HP_k^-H^T+R_k}$</td>
</tr>
<tr>
<td style="text-align:left">先验误差协方差：$P_k^-=AP_{k-1}A^T+Q$</td>
<td>后验估计：$\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]$</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>更新误差协方差：$P_k=(I-K_kH)P_k^-$</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>介绍卡尔曼滤波论文：</strong><a href="http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf">http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf</a></p>
</blockquote>
<h1 id="非线性滤波器"><a href="#非线性滤波器" class="headerlink" title="非线性滤波器"></a>非线性滤波器</h1><p>前面的卡尔曼滤波我们可以在一个线性系统得到一个最优的估计值，那么卡尔曼滤波器在非线性系统中的应用如何呢？一般来说有许多方法，但是最基本的方法就是将非线性系统进行线性化，这种滤波器我们称为扩展卡尔曼滤波器（Extended Kalman Filter，简称EKF）。</p>
<hr>
<p>对于线性系统的状态空间表达式：</p>
<script type="math/tex; mode=display">
\begin{align*}
{x_k }&=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\
z_{k}&=Hx_{k}+v_k
\end{align*}</script><p>其中$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵</p>
<hr>
<p>对于非线性系统的状态空间表达式：</p>
<script type="math/tex; mode=display">
\begin{align*}
x_k&=f(x_{k-1},u_{k-1},w_{k-1})\\
z_k&=h(x_k,v_k)
\end{align*}</script><p>其中$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵</p>
<p>虽然噪声仍然满足正态分布，但是<span style="color:red;">正态分布的随机变量通过非线性系统后就不再是正态的了。</span></p>
<p><img src="/images/卡尔曼滤波器的数学推导/image-20220402154736261.png" alt="image-20220402154736261"></p>
<p>所以需要对非线性系统进行线性化处理，这里会用到泰勒展开。</p>
<p>比如我们对$f(x)$在$x_0$处进行泰勒展开：</p>
<script type="math/tex; mode=display">
f(x)=f(x_0)+\frac{\partial f}{\partial x}(x-x_0)</script><p>对于一个非线性系统来说，最好的一个线性化的点就是它的真实点，但是由于系统存在误差，所以我们永远无法知道系统的真实点是多少，所以一般$f(x)$在$\hat{x}_{k-1}$(即上一时刻的后验估计)处进行线性化。</p>
<ul>
<li>过程方程线性化</li>
</ul>
<blockquote>
<p>假设误差$w_{k-1}=0$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align*}
x_k&=f(\hat{x}_{k-1},u_{k-1},w_{k-1})+A(x_k-\hat{x}_{k-1})+Ww_{k-1}\\
&=f(\hat{x}_{k-1},u_{k-1},0)+A(x_k-\hat{x}_{k-1})+Ww_{k-1}
\end{align*}</script><blockquote>
<p>记：$f(\hat{x}_{k-1},u_{k-1},0)=\widetilde{x}$，而$A，W$是雅可比矩阵，且$A=\frac{\partial f}{\partial x}|\hat{x}_{k-1},u_{k-1}$，$W=\frac{\partial f}{\partial w}|\hat{x}_{k-1},u_{k-1}$</p>
</blockquote>
<ul>
<li>测量方程线性化</li>
</ul>
<p>将$z_k$在$\widetilde{x}$处线性化：</p>
<blockquote>
<p>假设误差 $v_{k}=0$</p>
</blockquote>
<script type="math/tex; mode=display">
z_{k}=h(\widetilde{x}_{k},v_k)+H(x_k-\widetilde{x}_{k})+Vv_k</script><blockquote>
<p>而$H，V$是雅可比矩阵，且$H=\frac{\partial f}{\partial x}|\widetilde{x}_{k}$，$V=\frac{\partial f}{\partial v}|\widetilde{x}_{k}$</p>
</blockquote>
<p>所以非线性系统线性化后：</p>
<script type="math/tex; mode=display">
\begin{align*}
x_k&=f(\hat{x}_{k-1},u_{k-1},0)+A(x_k-\hat{x}_{k-1})+Ww_{k-1}\\
z_{k}&=h(\widetilde{x}_{k},v_k)+H(x_k-\widetilde{x}_{k})+Vv_k
\end{align*}</script><p>由于$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，那么很容易得到$p_{(Ww)}\sim N(0,wQw^T)，p_{(Vv)}\sim N(0,vRv^T)$</p>
<p>至此，我们可以总结一下整个卡尔曼滤波的过程：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">预测</th>
<th>校正</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">先验：$\hat{x}^-_k=Af(\hat{x}_{k-1},u_{k-1},0)+Bu_{k-1}$</td>
<td>卡尔曼增益：$K_k=\frac{P_k^-H^T}{HP_k^-H^T+vRv^T}$</td>
</tr>
<tr>
<td style="text-align:left">先验误差协方差：$P_k^-=AP_{k-1}A^T+wQw^T$</td>
<td>后验估计：$\hat{x}_k=\hat{x}^-_k+K_k(z_k-h(\hat{x}^-_k,0)),K_k\in[0,H^-]$</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>更新误差协方差：$P_k=(I-K_kH)P_k^-$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="EKF在SLAM中的局限性"><a href="#EKF在SLAM中的局限性" class="headerlink" title="EKF在SLAM中的局限性"></a>EKF在SLAM中的局限性</h2><p>假设了马尔可夫性，也就是$ k$ 时刻的状态只与$ k − 1$时刻相关，而与$ k − 1 $之前的状态和观测都无关（或者和前几个有限时间的状态相关）。这有点像是在视觉里程计中，只考虑相邻两帧关系一样。如果当前帧确实与很久之前的数据有关（例如回环），那么滤波器就会难以处理这种情况。</p>
<p>$EKF$ 滤波器仅在 $\hat{x}_{k−1}$ 处做了一次线性化，然后就直接根据这次线性化结果，把后验概率给算了出来。这相当于在说，我们认为该点处线性化近似，在后验概率处仍然是有效的。而实际上，当我们离开工作点较远的时候，一阶泰勒展开并不一定能够近似整个函数，这取决于运动模型和观测模型的非线性情况。</p>
<p>从程序实现上来说，EKF 需要存储状态量的均值和方差，并对它们进行维护和更新。如果把路标也放进状态的话，由于视觉 SLAM 中路标数量很大，这个存储量是相当可观的，且与状态量呈平方增长（因为要存储协方差矩阵）。因此，EKF SLAM 普遍被认为不可适用于大型场景。</p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>卡尔曼滤波器</tag>
        <tag>后端优化</tag>
        <tag>扩展卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波器的数学基础</title>
    <url>/posts/8369.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>卡尔曼滤波（Kalman filter）是一种高效率的<strong>递归滤波器</strong>（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="卡尔曼滤波器的数学基础"><a href="#卡尔曼滤波器的数学基础" class="headerlink" title="卡尔曼滤波器的数学基础"></a>卡尔曼滤波器的数学基础</h1><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>卡尔曼滤波器(Kalman Filter)，它是一种最优化的递归的数字处理算法(Optimal Recursive Data Processing Algorithm)。</p>
<p><strong>为什么使用卡尔曼滤波？</strong></p>
<p>因为显示生活中充满了不确定性，而这些不确定性主要体现在以下几个方面：</p>
<ul>
<li>不存在完美的数学模型</li>
<li>系统的扰动不可控，也很难建模</li>
<li>测量传感器存在误差</li>
</ul>
<hr>
<p>【例】测量硬币的例子</p>
<p>如图所示，不同的人去测量一个硬币的直径，一共测量$k$次，得到的测量值为$z_1,……z_k$，估计硬币的真实直径是多少？</p>
<p><img src="/images/卡尔曼滤波器/image-20220401093317316.png" alt="image-20220401093317316"></p>
<p><strong>取平均值</strong></p>
<p>设我们的平均值即对真实值的估计值(Estimate)为$\hat{x}$</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{x}_k&=\frac{1}{k}(z_1+z_2+...+z_k)\\
&=\frac{1}{k}(z_1+z_2+...+z_{k-1})+\frac{1}{k}z_k\\
&=\frac{1}{k} \frac{k-1}{k-1}(z_1+z_2+...+z_{k-1})+\frac{1}{k}z_k\\
&=\frac{k-1}{k}  \hat{x}_{k-1}+\frac{1}{k}z_k\\
&=\hat{x}_{k-1}-\frac{1}{k}\hat{x}_{k-1}  +\frac{1}{k}z_k
\end{align*}</script><p>整理得：</p>
<script type="math/tex; mode=display">
\hat{x}_k=\hat{x}_{k-1} +\frac{1}{k}(z_k-\hat{x}_{k-1} )</script><p>令$K_k=1/k$</p>
<script type="math/tex; mode=display">
\hat{x}_k=\hat{x}_{k-1} +K_k(z_k-\hat{x}_{k-1} )</script><p>即为：当前的估计值=上一时刻的估计值+$K_k$(当前测量值-上一时刻的估计值)</p>
<p><strong>分析：</strong></p>
<ul>
<li>随着$k$的增加，$K_k$趋近于0，可以得到$\hat{x}_k=\hat{x}_{k-1}$，测量的结果$z_k$不再重要</li>
<li>当$k$比较小的时候，$K_k$很大，则说明测量结果是非常重要的</li>
<li>$K_k$就是<strong>卡尔曼增益</strong>，或叫做卡尔曼因数。</li>
</ul>
<p><strong>求解卡尔曼增益$K_k$:</strong></p>
<p>设估计误差：$e_{EST}$，测量误差：$e_{MEA}$</p>
<script type="math/tex; mode=display">
K_k=\frac{ {e_{EST} }_{k-1} }{ {e_{EST} }_{k-1}+{e_{MEA} }_{k} }</script><p><strong>分析：</strong></p>
<ul>
<li>$e_{EST}&gt;&gt;e_{MEA}：$$K_k$趋近于1，则$\hat{x}_k=\hat{x}_{k-1} +z_k-\hat{x}_{k-1} =z_k$，即估计误差大相信测量值</li>
<li>$e_{EST}&lt;&lt;e_{MEA}：$$K_k$趋近于0，则$\hat{x}_k=\hat{x}_{k-1} $，测量误差大相信估计值</li>
</ul>
<hr>
<p>【例】卡尔曼滤波的应用举例：</p>
<ul>
<li><strong>一般计算卡尔曼滤波分为三步：</strong><ul>
<li>计算卡尔曼增益：$K_k=\frac{ {e_{EST} }_{k-1} }{ {e_{EST} }_{k-1}+{e_{MEA} }_{k} }$</li>
<li>计算$\hat{x}_k=\hat{x}_{k-1} +K_k(z_k-\hat{x}_{k-1} )$</li>
<li>更新${ e_{EST} }_{k}=(1-K_k){e_{EST} }_{k-1}$</li>
</ul>
</li>
</ul>
<p>已知物体的实际长度为$50mm$，测量误差$e_{MEA}=3mm$，估计误差$e_{MEA}=5mm$，$\hat{x}_0=40mm$，一共测量了13次，根据上面的三个步骤，我们可以计算并画出折线图。</p>
<p><img src="/images/卡尔曼滤波器/image-20220401102705574.png" alt="image-20220401102705574" style="zoom:50%;" /></p>
<p><img src="/images/卡尔曼滤波器/image-20220401102555645.png" alt="image-20220401102555645" style="zoom:50%;" /></p>
<p>很明显，经过测量次数的增加，最终的估计值是接近真实值的，这就是卡尔曼滤波递归的作用。</p>
<h2 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h2><p>数据融合(Data Fusion)</p>
<p>【例】现有两个称，已知它们称的结果都符合正态分布，现去称同一个物体，已知称$A$称得物体重量为$z_1=30g$，并且已知它的标准差为$\sigma_1=2g$；称$B$称得物体重量为$z_2=32g$，并且已知它的标准差为$\sigma_2=4g$；估计该物体的真实重量$\hat{z}_k=?$。</p>
<p>根据递归的思想：</p>
<script type="math/tex; mode=display">
\hat{z}_k=z_1+K_k(z_2-z_1)，K_k\in[0,1]</script><p>为了求解最接近真实值的$\hat{z}_k$，即求解最优的$K_k$值，使得方差$Var(\hat{z}_k)$最小。</p>
<script type="math/tex; mode=display">
\begin{align*}
\sigma^2_{\hat{z}_k }&=Var(z_1+K_k(z_2-z_1))\\
&=Var(z_1+K_kz_2-K_kz_1)\\
&=Var((1-K_k)z_1+K_kz_2)\\
&=Var((1-K_k)z_1)+Var(K_kz_2)\\
&=(1-K_k)^2Var(z_1)+K_k^2Var(z_2)\\
&=(1-K_k)^2\sigma_1^2+K_k^2\sigma_2^2\\
\end{align*}</script><p>对$K_k$求导：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{d\sigma^2_{\hat{z}_k } }{dK_k}=0\\
-2(1-K_k)&\sigma_1^2+2K_k\sigma_2^2=0\\
&K_k=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}
\end{align*}</script><p>已知$\sigma_1=2,\sigma_2=4$:</p>
<script type="math/tex; mode=display">
K_k=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}=\frac{4}{4+16}=0.2</script><p>带入：</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{z}_k&=z_1+K_k(z_2-z_1)\\
&=30+0.2(32-20)\\
&=30.4g
\end{align*}</script><p>对应方差：</p>
<script type="math/tex; mode=display">
\begin{align*}
\sigma^2_{\hat{z}_k }
&=(1-K_k)^2\sigma_1^2+K_k^2\sigma_2^2\\
&=(1-0.2)^2*4+0.2^2*16\\
&=3.2\\
\sigma_{\hat{z}_k }&=\sqrt{3.2} \\
&= 1.79
\end{align*}</script><p>因此，我们根据两个称的特性，根据测量值对物体的真实重量进行了预测，预测值为$30.4g$，而且它是最优解。</p>
<p>这个过程就是数据融合。</p>
<p><strong>公式：</strong></p>
<p>对于两个高斯分布的融合，如$p(A)\sim N(\mu_a,\sigma^2_a)$，$p(B)\sim N(\mu_b,\sigma^2_b)$</p>
<p>融合之后的高斯分布$p(C)\sim N(\mu_c,\sigma^2_c)$：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mu_c&=\frac{\sigma^2_b\mu_a+\sigma^2_a\mu_b}{\sigma^2_a+\sigma^2_b}\\
\sigma_c&=\frac{\sigma^2_a\sigma^2_b}{\sigma^2_b+\sigma^2_b}
\end{align*}</script><p><img src="/images/卡尔曼滤波器/WeChat%20Image_20220401141112.jpg" alt="WeChat Image_20220401141112" style="zoom: 15%;" /></p>
<hr>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>协方差矩阵(Covariance Matrix)，它可以把方差和协方差在一个矩阵中表现出来，体现了变量之间的；联动关系。</p>
<p>【例】</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">球员</th>
<th style="text-align:center">身高x</th>
<th style="text-align:center">体重y</th>
<th style="text-align:center">年龄z</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瓦尔迪</td>
<td style="text-align:center">179</td>
<td style="text-align:center">74</td>
<td style="text-align:center">33</td>
</tr>
<tr>
<td style="text-align:center">奥巴梅杨</td>
<td style="text-align:center">187</td>
<td style="text-align:center">80</td>
<td style="text-align:center">31</td>
</tr>
<tr>
<td style="text-align:center">萨拉赫</td>
<td style="text-align:center">175</td>
<td style="text-align:center">71</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center"><strong>平均值</strong></td>
<td style="text-align:center"><strong>180.3</strong></td>
<td style="text-align:center"><strong>75</strong></td>
<td style="text-align:center"><strong>30.7</strong></td>
</tr>
</tbody>
</table>
</div>
<p>分别求三者的方差以及相互之间的协方差，</p>
<script type="math/tex; mode=display">
Var(x)=\sigma_x^2=\frac{1}{n}\sum^n_{i=1}(x_i-\mu)^2=\frac{1}{n}(\sum^n_{i=1}x_i^2-n\mu^2)</script><p>方差：$\sigma_x^2=24.89, \sigma_y^2=14,\sigma_z^2=4.22$，</p>
<script type="math/tex; mode=display">
Cov(X,Y)=E((X-\mu)(Y-v))=E(X·Y)-\mu v</script><p>协方差：$\sigma_x\sigma_y=\sigma_y\sigma_x=18.7,\sigma_x\sigma_z=\sigma_z\sigma_x=4.4,\sigma_y\sigma_z=\sigma_z\sigma_y=3.3$。所以协方差矩阵为：</p>
<script type="math/tex; mode=display">
P=\begin{bmatrix}
\sigma_x^2&\sigma_x\sigma_y&\sigma_x\sigma_z\\
\sigma_y\sigma_x&\sigma_y^2&\sigma_y\sigma_z\\
\sigma_z\sigma_x&\sigma_z\sigma_y&\sigma_z^2
\end{bmatrix}=
\begin{bmatrix}
24.89&18.7&4.4\\
18.7&14&3.3\\
4.4&3.3&4.22
\end{bmatrix}</script><p>可以看出运动员的身高与体重相关性比较大，而身高体重和年龄的相关性是比较小的，这种规律，数据越多越明显。</p>
<p><strong>如何使用矩阵批量计算协方差矩阵？</strong></p>
<p>一般需要设置一个过渡矩阵：</p>
<script type="math/tex; mode=display">
a=\begin{bmatrix}
x_1&y_1&z_1\\
x_2&y_2&z_2\\
x_3&y_3&z_3
\end{bmatrix}-
\frac{1}{3}
\begin{bmatrix}
1&1&1\\\
1&1&1\\
1&1&1
\end{bmatrix}
\begin{bmatrix}
x_1&y_1&z_1\\
x_2&y_2&z_2\\
x_3&y_3&z_3
\end{bmatrix}</script><p>协方差：</p>
<script type="math/tex; mode=display">
P=\frac{1}{3}a^Ta</script><h2 id="状态空间表达式"><a href="#状态空间表达式" class="headerlink" title="状态空间表达式"></a>状态空间表达式</h2><p>【例】：有一个弹簧阻尼系统，对质量为$m$的物块施加一个力$F$，弹簧向右的位移量为$x$，已知弹簧的胡克系数为$k$，阻尼系数为$B$</p>
<p><img src="/images/卡尔曼滤波器/image-20220401152419675.png?40" alt="image-20220401152419675" style="zoom: 25%;" /></p>
<p>定义输入为$u_{(t)}=F_{(t)}$，输出为$x$</p>
<p>由胡克定律可知，弹簧拉力$f_k$以及阻力$f_B$：</p>
<script type="math/tex; mode=display">
f_k=kx\\
f_B=B\dot{x}</script><p>根据牛顿第二定律$F=ma$：</p>
<script type="math/tex; mode=display">
\begin{align*}
&m\ddot{x}=F-f_k-f_B\\
&m\ddot{x}+f_B+f_k=F\\
&m\ddot{x}+B\dot{x}+kx=F
\end{align*}</script><p>所以系统的动态方程表达式：</p>
<script type="math/tex; mode=display">
m\ddot{x}+B\dot{x}+kx=F</script><p>使用经典控制理论可以对上式进行拉普拉斯变换，进而求得系统的传递函数：</p>
<script type="math/tex; mode=display">
ms^2X_{(s)}+BsX_{(s)}+kX_{(s)}=F_{(s)}\\
G_{(s)}=\frac{X_{(s)} }{F_{(s)} }=\frac{1}{ms^2+Bs+K}</script><p>但在现代控制理论中则更多的使用状态空间方程，状态空间方程可以看成一个集合，它包含系统的输入、系统的输出以及状态变量，最终使用一个一阶微分方程的形式表达出来。</p>
<p>即：</p>
<script type="math/tex; mode=display">
m\ddot{x}+B\dot{x}+kx=u</script><p>确定两个合适的状态变量，把二阶项消除：</p>
<ul>
<li>位置：$z_1=x=x_1$</li>
<li>速度：$z_2=\dot{x}=x_2$</li>
</ul>
<p>由于$x_1=x，x_2=\dot{x}$，因此可以得到：$\dot{x_1}=x_2，\dot{x_2}=\ddot{x}$，利用上述方程化简：</p>
<script type="math/tex; mode=display">
\begin{align*}
\dot{x_1}=x_2\\
\dot{x_2}=\ddot{x}&=\frac{1}{m}\mu-\frac{B}{m}\dot{x}-\frac{k}{m}x\\
&=\frac{1}{m}\mu-\frac{B}{m}x_2-\frac{k}{m}x_1
\end{align*}</script><p>综合上面的四个方程：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\dot{x_1}\\
\dot{x_2}
\end{bmatrix}
=\begin{bmatrix}
0&1\\
-\frac{K}{m}&-\frac{B}{m}
\end{bmatrix}
\begin{bmatrix}
x_1\\x_2
\end{bmatrix}
+\begin{bmatrix}
0\\ \frac{1}{m}
\end{bmatrix}u</script><script type="math/tex; mode=display">
\begin{bmatrix}
z_1\\z_2
\end{bmatrix}=
\begin{bmatrix}
1&0\\0&1
\end{bmatrix}
\begin{bmatrix}
x_1\\x_2
\end{bmatrix}</script><p>进一步归纳：</p>
<p>连续型：</p>
<script type="math/tex; mode=display">
\dot{X}_{(t)}=AX_{(t)}+Bu_{(t)}\\
Z_{(t)}=HX_{(t)}</script><p>离散型：</p>
<script type="math/tex; mode=display">
{X_k }=AX_{k-1}+Bu_{k}\\
Z_{k}=HX_{k}</script><p>其中$k$表示采样时间单位。</p>
<p>由于现实中存在着不确定性，比如存在过程噪声(Process Noise)：$w_{k}$，测量噪声(Measurement Noise)：$v_k$</p>
<script type="math/tex; mode=display">
\begin{align*}
{X_k }&=AX_{k-1}+Bu_{k}+w_{k}\\
Z_{k}&=HX_{k}+v_k
\end{align*}</script><p>因此，我们的模型和测量都存在误差，导致计算值以及测量值都是不准确的，如何通过两个不确定的值去估计一个准确的值$\hat{x}_k=?$，根据数据融合的例子，我们可以使用这两个不准确的结果进行数据融合，从而得到一个比较准确的估计值。</p>
<h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p>
<script type="math/tex; mode=display">
f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p>
<script type="math/tex; mode=display">
f(x)=f(x_0)+f^\prime(x_0)(x-x_0)</script><p>设$f(x_0)=k_1,f^\prime(x_0)=k_2$:</p>
<script type="math/tex; mode=display">
\begin{align*}
f(x)&=k_1+k_2(x-x_0)\\
&=k_2x+(k_1-k_2x_0)\\
&=k_2x+b
\end{align*}</script><p>因此这样的一个非线性的函数$f(x)$在点$x_0$附近就被线性化为一个线性的函数。</p>
<ul>
<li><p><span style="color:red;">线性化是对某个点附近进行线性化，而不是全局进行线性化</span></p>
</li>
<li><p><span style="color:red;">线性化的前提条件，一定是$(x-x_0)\rightarrow0$ </span></p>
</li>
</ul>
<p>如果对于二维以上的，我们的一阶泰勒展开如下：</p>
<script type="math/tex; mode=display">
f(x)=f(x_0)+\frac{\partial f}{\partial x_0}(x-x_0)</script>]]></content>
      <categories>
        <category>SLAM十四讲</category>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>卡尔曼滤波器</tag>
        <tag>后端优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ch9_设计前端</title>
    <url>/posts/32548.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本次实践将前几章内容结合进来，实际书写一个视觉里程计程序，由于单目相机存在初始化问题以及尺度问题，因此本实践采用的是最简单的RGB-D相机，但是使用的也只是RGB-D数据集，而非真正的RGB-D相机。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="一、搭建VO框架"><a href="#一、搭建VO框架" class="headerlink" title="一、搭建VO框架"></a>一、搭建VO框架</h1><h2 id="1-1-确定程序基本框架"><a href="#1-1-确定程序基本框架" class="headerlink" title="1.1 确定程序基本框架"></a>1.1 确定程序基本框架</h2><h3 id="项目目录框架"><a href="#项目目录框架" class="headerlink" title="项目目录框架"></a>项目目录框架</h3><p>在编写一个小规模的库时，我们通常会建立一些文件夹，把源代码、头文件、文档、测试数据、配置文件、日志等等分类存放，这样会显得很有条理。如果一个库内容很多，我们还会把代码分解各个独立的小模块，以便测试。</p>
<p>我们的工程目录如下：</p>
<ul>
<li><p><strong>bin：</strong>用来存放可执行的二进制文件；</p>
</li>
<li><p><strong>include/myslam：</strong> 存放 slam 模块的头文件，主要是<code>.h</code>。这种做法的理由是，当你把包含目录设到 include 时，在引用自己的头文件时，需要写<code>include ”myslam/xxx.h”</code>，这样不容易和别的库混淆。</p>
</li>
<li><p><strong>src：</strong>存放源代码文件，主要是 cpp；</p>
</li>
<li><p><strong>lib：</strong> 存放编译好的库文件；</p>
</li>
<li><p><strong>build：</strong>存放执行编译操作生成的中间文件；</p>
</li>
<li><p><strong>config：</strong> 存放配置文件；</p>
</li>
<li><p><strong>cmake_modules：</strong> 第三方库的 cmake 文件，在使用 g2o 之类的库中会用到它</p>
</li>
<li><p><strong>test：</strong> 存放测试用的文件，也是 cpp</p>
</li>
<li><strong>dataset：</strong>存放我们使用的RGB-D数据集</li>
<li><strong>tools：</strong>这里是对数据集操作用的python文件</li>
</ul>
<p><img src="/images/设计前端/image-20220330203310388.png" alt="image-20220330203310388"></p>
<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p><strong>帧：</strong>一个帧是相机采集到的图像单位。它主要包含一个图像（RGB-D 情形下是一对图像）。此外，还有特征点、位姿、内参等信息。在视觉 SLAM 中我们会谈论关键帧（Key-frame），通常的做法是把某些我们认为更重要的帧保存起来，并认为相机轨迹就可以用这些关键帧来描述。关键帧如何选择是一个很大的问题，而且基于工程经验，很少有理论上的指导。</p>
<p><strong>路标：</strong>路标点即图像中的特征点。当相机运动之后，我们还能估计它们的 3D 位置。通常，会把路标点放在一个地图当中，并将新来的帧与地图中的路标点进行匹配，估计相机位姿。</p>
<h2 id="1-2-基本类的实现"><a href="#1-2-基本类的实现" class="headerlink" title="1.2 基本类的实现"></a>1.2 基本类的实现</h2><p>刚开始的阶段。我们一共写五个类：Frame 为帧，Camera 为相机模型，MapPoint 为特征点/路标点，Map<br>管理特征点，Config 提供配置参数。</p>
<p><img src="/images/设计前端/image-20220330200432411.png" alt="image-20220330200432411"></p>
<p>每个类对应一个头文件，一个源文件，由于许多类会引用很多头文件，所以我们不妨直接写一个头文件专门存放头文件，让所有的头文件都引这个头文件。当然，这个头文件里的内容是不断填充的，现在就以直接给出的形式呈现。</p>
<p><strong>WL_SLAM_VO/include/myslam/common_include.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_INCLUDE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_INCLUDE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for Eigen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Eigen::Vector2d;</span><br><span class="line"><span class="keyword">using</span> Eigen::Vector3d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for Sophus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/se3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/so3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Sophus::SE3;</span><br><span class="line"><span class="keyword">using</span> Sophus::SO3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for cv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> cv::Mat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Camera类"><a href="#Camera类" class="headerlink" title="Camera类"></a>Camera类</h3><p>Camera 类存储相机的内参和外参，并完成相机坐标系、像素坐标系、和世界坐标系之间的坐标变换。当然，在世界坐标系中你需要一个相机的（变动的）外参，我们以参数的形式传入。</p>
<p><strong>WL_SLAM_VO/include/myslam/Camera.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们用命名空间 namespace myslam </span></span><br><span class="line"><span class="comment">将类定义包裹起来命名空间可以防止我们不小心定义出别的库里同名的函数，也是一种比较安全和规范的做法。*/</span> </span><br><span class="line"><span class="keyword">namespace</span> mysalm</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 把智能指针定义成 Camera 的指针类型，因此以后在传递参数时，只需用 Camera::Ptr 类型即可</span></span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Camera&gt; Ptr;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> fx_, fy_, cx_, cy_, depth_scale_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="keyword">float</span> fx,<span class="keyword">float</span> fy,<span class="keyword">float</span> cx,<span class="keyword">float</span> cy, <span class="keyword">float</span> depth_scale) : </span><br><span class="line">        <span class="built_in">fx_</span>(fx),<span class="built_in">fy_</span>(fy),<span class="built_in">cx_</span>(cx),<span class="built_in">cy_</span>(cy),<span class="built_in">depth_scale_</span>(depth_scale)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标变换</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">world2camera</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">camera2world</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">    <span class="function">Vector2d <span class="title">camera2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c)</span></span>;</span><br><span class="line">    <span class="function">Vector2d <span class="title">pixel2camera</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">pixel2world</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">const</span> SE3 &amp;T_c_w, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">world2pixel</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>智能指针：std::shared_ptr</p>
<p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p>
<p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。</p>
</blockquote>
<p><strong>WL_SLAM_VO/src/camera.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line">    Camera::<span class="built_in">Camera</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::world2camera</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T_c_w * p_w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::camera2world</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T_c_w.<span class="built_in">inverse</span>() * p_c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2d <span class="title">Camera::camera2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2d</span>(</span><br><span class="line">            fx_ * <span class="built_in">p_c</span>(<span class="number">0</span>, <span class="number">0</span>) / <span class="built_in">p_c</span>(<span class="number">2</span>, <span class="number">0</span>) + cx_,  <span class="comment">// u = fx*X/Z+cx</span></span><br><span class="line">            fx_ * <span class="built_in">p_c</span>(<span class="number">1</span>, <span class="number">0</span>) / <span class="built_in">p_c</span>(<span class="number">2</span>, <span class="number">0</span>) + cy_); <span class="comment">// v = fy*Y/Z+cy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::pixel2camera</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector3d</span>(</span><br><span class="line">            (<span class="built_in">p_p</span>(<span class="number">0</span>, <span class="number">0</span>) - cx_) * depth / fx_, <span class="comment">// X = (u-cx)*Z/fx</span></span><br><span class="line">            (<span class="built_in">p_p</span>(<span class="number">1</span>, <span class="number">0</span>) - cy_) * depth / fy_, <span class="comment">// Y = (v-cy)*Z/fy</span></span><br><span class="line">            depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::pixel2world</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">const</span> SE3 &amp;T_c_w, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">camera2world</span>(<span class="built_in">pixel2camera</span>(p_p, depth), T_c_w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2d <span class="title">Camera::world2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">camera2pixel</span>(<span class="built_in">world2camera</span>(p_w, T_c_w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Frame类"><a href="#Frame类" class="headerlink" title="Frame类"></a>Frame类</h3><p>由于 Frame 类是基本数据单元，在许多地方会用到它，但现在初期设计阶段，我们还不清楚以后可能新加的内容。所以这里的 Frame 类只提供基本的数据存储和接口。如果之后有新增的内容，我们就继续往里添加。</p>
<p><strong>WL_SLAM_VO/include/myslam/frame.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FRAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME</span></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 提前声明MapPoint类，需要用到帧的关键点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapPoint</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Frame&gt; Ptr; <span class="comment">// 定义Frame类的智能指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> id_;                  <span class="comment">// 图像帧的id编号</span></span><br><span class="line">    <span class="keyword">double</span> time_stamp_;                 <span class="comment">// 图像帧被记录的时间戳</span></span><br><span class="line">    SE3 T_c_w_;                         <span class="comment">// 世界坐标系到相机坐标系的变换矩阵</span></span><br><span class="line">    Camera::Ptr camera_;                <span class="comment">//针孔RGB-D相机模型</span></span><br><span class="line">    Mat color_, depth_;                 <span class="comment">// 彩色图以及图像深度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frame</span>();</span><br><span class="line">    <span class="built_in">Frame</span>(<span class="keyword">long</span> id, <span class="keyword">double</span> time_stamp=<span class="number">0</span>, SE3 T_c_w=<span class="built_in">SE3</span>(), Camera::Ptr=<span class="literal">nullptr</span>,</span><br><span class="line">        Mat color = <span class="built_in">Mat</span>(),Mat depth = <span class="built_in">Mat</span>() );</span><br><span class="line">    ~<span class="built_in">Frame</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建帧</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Frame::Ptr <span class="title">creatFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 寻找给定点对应的深度 </span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findDepth</span><span class="params">(<span class="keyword">const</span> cv::KeyPoint &amp;kp)</span></span>;</span><br><span class="line">    <span class="comment">// 获取相机光心</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">getCamCenter</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 判断某个点是否在视野内</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInFrame</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;pt_world)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>WL_SLAM_VO/src/frame.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/frame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造与析构</span></span><br><span class="line">Frame::<span class="built_in">Frame</span>() : <span class="built_in">id_</span>(<span class="number">-1</span>),<span class="built_in">time_stamp_</span>(<span class="number">-1</span>),<span class="built_in">camera_</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">Frame::<span class="built_in">Frame</span> ( <span class="keyword">long</span> id, <span class="keyword">double</span> time_stamp, SE3 T_c_w, Camera::Ptr camera, Mat color, Mat depth )</span><br><span class="line">: <span class="built_in">id_</span>(id), <span class="built_in">time_stamp_</span>(time_stamp), <span class="built_in">T_c_w_</span>(T_c_w), <span class="built_in">camera_</span>(camera), <span class="built_in">color_</span>(color), <span class="built_in">depth_</span>(depth)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Frame::~<span class="built_in">Frame</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Frame</span></span><br><span class="line"><span class="function">Frame::Ptr <span class="title">Frame::creatFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> factory_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Frame::<span class="built_in">Ptr</span>( <span class="keyword">new</span> <span class="built_in">Frame</span>(factory_id++) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找给定点对应的深度</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Frame::findDepth</span><span class="params">(<span class="keyword">const</span> cv::KeyPoint &amp;kp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得像素点的坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">cvRound</span>(kp.pt.x);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">cvRound</span>(kp.pt.y);</span><br><span class="line">    <span class="comment">// 得到像素点的深度</span></span><br><span class="line">    ushort d = depth_.ptr&lt;ushort&gt;(y)[x];</span><br><span class="line">    <span class="keyword">if</span>(d != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in"><span class="keyword">double</span></span>(d)/camera_-&gt;depth_scale_;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果该像素深度为0，则选择附近的点作为参考</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            d = depth_.ptr&lt;ushort&gt;(y+dy[i])[x+dx[i]];</span><br><span class="line">            <span class="keyword">if</span>(d != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in"><span class="keyword">double</span></span>(d)/camera_-&gt;depth_scale_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取相机光心</span></span><br><span class="line"><span class="function">Vector3d <span class="title">Frame::getCamCenter</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//相机坐标系的（0,0,0）在世界坐标系下的位置</span></span><br><span class="line">    <span class="keyword">return</span> T_c_w_.<span class="built_in">inverse</span>().<span class="built_in">translation</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断某个点是否在视野内</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Frame::isInFrame</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;pt_world)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将世界坐标系下的点转换为相机坐标系</span></span><br><span class="line">    Vector3d p_cam = camera_-&gt;<span class="built_in">world2camera</span>(pt_world,T_c_w_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">p_cam</span>(<span class="number">2.0</span>)&lt;<span class="number">0</span>) <span class="comment">// Z小于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Vector2d pixel = camera_-&gt;<span class="built_in">world2pixel</span>(pt_world,T_c_w_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pixel</span>(<span class="number">0</span>,<span class="number">0</span>)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">1</span>,<span class="number">0</span>)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">0</span>,<span class="number">0</span>)&lt;color_.cols </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;color_.rows;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br></pre></td></tr></table></figure>
<h3 id="MapPoint-类"><a href="#MapPoint-类" class="headerlink" title="MapPoint 类"></a>MapPoint 类</h3><p><strong>WL_SLAM_VO/include/myslam/mappoint.h</strong></p>
<p>MapPoint 表示路标点。我们将估计它的世界坐标，并且我们会拿当前帧提取到的特征点与地图中的路标点匹配，来估计相机的运动，因此还需要存储它对应的描述子。此外，我们会记录一个点被观测到的次数和被匹配到的次数，作为评价它的好坏程度的指标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><p><strong>WL_SLAM_VO/include/myslam/map.h</strong></p>
<p>Map 类管理着所有的路标点，并负责添加新路标、删除不好的路标等工作。VO 的匹配过程只需要和 Map 打交道即可。当然 Map 也会有很多操作，但现阶段我们只定义主要的数据结构。</p>
<p><strong>WL_SLAM_VO/src/map.h</strong></p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>VO</tag>
      </tags>
  </entry>
  <entry>
    <title>ch8_RGB-D直接法实践</title>
    <url>/posts/18310.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>此次实践使用RGB-D相机主要是因为它省略掉了深度的恢复部分，如果使用单目相机，则需要进行深度的恢复，在之前的实践内容中，我们使用单目相机主要是采用基于特征点的深度恢复，后面会介绍相应的基于块匹配的深度恢复。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="一、直接法"><a href="#一、直接法" class="headerlink" title="一、直接法"></a>一、直接法</h1><p>直接法根据空间点$P$的来源不同，对应不同的直接法。</p>
<ul>
<li>稀疏直接法</li>
</ul>
<p>若$P$来自于稀疏关键点，我们称之为稀疏直接法。通常我们使用数百个至上千个关键点，并且像 $L-K $光流那样，假设它周围像素也是不变的。这种稀疏直接法不必计算描述子，并且只使用数百个像素，因此速度最快，但只能计算稀疏的重构。</p>
<ul>
<li>半稠密（Semi-Dense）的直接法</li>
</ul>
<p>如果像素梯度为零，整一项雅可比就为零，不会对计算运动增量有任何贡献。因此，可以考虑只使用带有梯度的像素点，舍弃像素梯度不明显的地方。</p>
<script type="math/tex; mode=display">
J=-\frac{\partial I_2}{\partial u}
\frac{\partial u}{\partial \delta \xi}</script><ul>
<li>稠密直接法</li>
</ul>
<p>稠密重构需要计算所有像素（一般几十万至几百万个），因此多数不能在现有的 CPU 上实时计算，需要 GPU 的加速。但是，如前面所讨论的，梯度不明显的点，在运动估计中不会有太大贡献，在重构时也会难以估计位置。</p>
<blockquote>
<p>稀疏到稠密重构，都可以用直接法来计算。它们的计算量是逐渐增长的。<strong>稀疏方法可以快速地求解相机位姿，而稠密方法可以建立完整地图。</strong>具体使用哪种方法，需要视机器人的应用环境而定。特别地，在低端的计算平台上，稀疏直接法可以做到非常快速的效果，适用于实时性较高且计算资源有限的场合</p>
</blockquote>
<h1 id="二、稀疏直接法"><a href="#二、稀疏直接法" class="headerlink" title="二、稀疏直接法"></a>二、稀疏直接法</h1><p>由于求解直接法最后等价于求解一个优化问题，因此我们可以使用$ g2o$ 或$ Ceres $这些优化库帮助我们求解。本节以 $g2o $为例设计实验，在使用 $g2o$之前，需要把直接法抽象成一个图优化问题。显然，直接法是由以下顶点和边组成的：</p>
<ul>
<li>优化变量</li>
</ul>
<p>优化变量为<strong>一个相机位姿</strong>，因此需要一个位姿顶点。由于我们在推导中使用了李代数，故程序中使用李代数表达的 $SE(3) $位姿顶点。可以使用“Ver-texSE3Expmap”作为相机位姿。</p>
<ul>
<li>误差项</li>
</ul>
<p>误差项为单个像素的<strong>光度误差</strong>。由于整个优化过程中 $I_1 (p_1 ) $保持不变，我们可以把它当成一个固定的预设值，然后调整相机位姿，使 $I_2 (p_2 )$ 接近这个值。于是，这种边只连接一个顶点，为一元边。由于 $g2o $中本身没有计算光度误差的边，我们需要自己定义一种新的边。</p>
<h2 id="2-1-构建直接法的边"><a href="#2-1-构建直接法的边" class="headerlink" title="2.1 构建直接法的边"></a>2.1 构建直接法的边</h2><p>直接法的边表示的光度误差，它是一个一元边，定义边的格式之前已经叙述，主要是对<code>virtual void computeError()</code>和<code>virtual void linearizeOplus()</code>两个函数进行重写。我们分别介绍。</p>
<h3 id="光度误差类的定义"><a href="#光度误差类的定义" class="headerlink" title="光度误差类的定义"></a>光度误差类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义直接法的边(光度误差的边),它是一个一元边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3ProjectDirect</span> :</span> <span class="keyword">public</span> BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="title">EdgeSE3ProjectDirect</span><span class="params">(Eigen::Vector3d point, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, cv::Mat *image)</span> : x_world_(point), fx_(fx), fy_(fy), cx_(cx), cy_(cy), image_(image)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolread</span><span class="params">(istream &amp;in)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 从参考图像中获取灰度值（双线性插值）</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Eigen::Vector3d x_world_;                 <span class="comment">// 世界坐标系中的3D点</span></span><br><span class="line">    <span class="keyword">float</span> cx_ = <span class="number">0</span>, cy_ = <span class="number">0</span>, fx_ = <span class="number">0</span>, fy_ = <span class="number">0</span>; <span class="comment">// 相机内参</span></span><br><span class="line">    cv::Mat *image_ = <span class="literal">nullptr</span>;                <span class="comment">//参考图像</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们的边继承自 <code>g2o::BaseUnaryEdge</code>。在继承时，需要在模板参数里填入测量值的维度、类型，以及连接此边的顶点，同时，我们把空间点 P 、相机内参和图像存储在该边的成员变量中。为了让 g2o 优化该边对应的误差，我们需要覆写两个虚函数：用 <code>computeError()</code>计算误差值，用<code>linearizeOplus()</code>计算雅可比。</p>
<h3 id="getPixelValue"><a href="#getPixelValue" class="headerlink" title="getPixelValue"></a>getPixelValue</h3><p>为了更精细地计算像素亮度，我们要对图像进行插值。我们这里采用了简单的双线性插值，也可以使用更复杂的插值方式，但计算代价可能会变高一些。</p>
<p>所以，相比之前的边的定义，这里多了一个函数<code>inline float getPixelValue(float x, float y);</code>，它的作用是从参考图像中获取灰度值，利用的是OpenCV中的双线性插值法，我们先书写它的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从参考图像中获取灰度值（双线性插值）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar *data = &amp;image_-&gt;data[<span class="built_in"><span class="keyword">int</span></span>(y) * image_-&gt;step + <span class="built_in"><span class="keyword">int</span></span>(x)];</span><br><span class="line">    <span class="keyword">float</span> xx = x - <span class="built_in">floor</span>(x);</span><br><span class="line">    <span class="keyword">float</span> yy = y - <span class="built_in">floor</span>(y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">float</span></span>(</span><br><span class="line">    (<span class="number">1</span> - xx) * (<span class="number">1</span> - yy) * data[<span class="number">0</span>] +</span><br><span class="line">    xx * (<span class="number">1</span> - yy) * data[image_-&gt;step] +</span><br><span class="line">    (<span class="number">1</span> - xx) * yy * data[image_-&gt;step + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释待理解……</p>
<h3 id="computeError"><a href="#computeError" class="headerlink" title="computeError"></a>computeError</h3><p>由前文可知，误差项为单个像素的<strong>光度误差</strong>。由于整个优化过程中 $I_1 (p_1 ) $保持不变，我们可以把它当成一个固定的预设值，然后调整相机位姿，使 $I_2 (p_2 )$ 接近这个值。<code>virtual void computeError()</code>这个函数则是使用该边连接的节点和观测值来计算误差。</p>
<p>程序中的误差计算里，使用了$ I_2 (p_2 ) − I_1 (p_1 )$ 的形式，因此前面的负号可以省去，只需把像素梯度乘以像素到李代数的梯度即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line"><span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> VertexSE3Expmap *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    Eigen::Vector3d x_local = v-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(x_world_); <span class="comment">//.map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">    <span class="comment">// 获得像素坐标</span></span><br><span class="line">    <span class="keyword">float</span> x = x_local[<span class="number">0</span>] * fx_ / x_local[<span class="number">2</span>] + cx_; <span class="comment">// x(u) = (X * fx)/Z + cx</span></span><br><span class="line">    <span class="keyword">float</span> y = x_local[<span class="number">1</span>] * fy_ / x_local[<span class="number">2</span>] + cy_; <span class="comment">// y(v) = (Y * fy)/Z + cy</span></span><br><span class="line">    <span class="comment">// 检查该像素点是否在图像内</span></span><br><span class="line">    <span class="keyword">if</span> (x - <span class="number">4</span> &lt; <span class="number">0</span> || (x + <span class="number">4</span>) &gt; image_-&gt;cols || (y - <span class="number">4</span>) &lt; <span class="number">0</span> || (y + <span class="number">4</span>) &gt; image_-&gt;rows)</span><br><span class="line">    &#123;</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setLevel</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = <span class="built_in">getPixelValue</span>(x, y) - _measurement; <span class="comment">// 光度误差，像素的亮度误差，或者是灰度值误差</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linearizeOplus"><a href="#linearizeOplus" class="headerlink" title="linearizeOplus"></a>linearizeOplus</h3><p>这个函数主要是计算雅克比矩阵，它是可选的，如果给出了则进行解析求导，不给则进行数值求导。我们直接在直接法的推导中已经介绍了该矩阵的计算，下面是推导结论，因此直接根据公式书写代码即可。</p>
<p>由直接法的推导可知：</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{\partial u}{\partial \delta \xi}&=
\frac{\partial u}{\partial q}
\frac{\partial q}{\partial \delta \xi}=
\begin{bmatrix}
\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}
&-\frac{f_xXY}{Z^{2}}&f_x+\frac{f_xX^2}{Z^{2}}&-\frac{f_xY}{Z}
\\
0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}
&-f_y-\frac{f_yY^{2}}{Z^{2}}&\frac{f_yXY}{Z}&\frac{f_yX}{Z}
\end{bmatrix}
\end{align}</script><p>最终的约旦矩阵为：</p>
<script type="math/tex; mode=display">
J=-\frac{\partial I_2}{\partial u}
\frac{\partial u}{\partial \delta \xi}</script><p>由于上面的误差使用的是$ I_2 (p_2 ) − I_1 (p_1 )$ 的形式，所以：</p>
<script type="math/tex; mode=display">
J=\frac{\partial I_2}{\partial u}
\frac{\partial u}{\partial \delta \xi}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">level</span>() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _jacobianOplusXi = Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt;::<span class="built_in">Zero</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">    VertexSE3Expmap *vtx = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 将世界坐标系下的三维点的估计转换成相机坐标系下</span></span><br><span class="line">    Eigen::Vector3d xyz_trans = vtx-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(x_world_);</span><br><span class="line">    <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];          <span class="comment">// X</span></span><br><span class="line">    <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];          <span class="comment">// Y</span></span><br><span class="line">    <span class="keyword">double</span> invz = <span class="number">1.0</span> / xyz_trans[<span class="number">2</span>]; <span class="comment">// 1/Z</span></span><br><span class="line">    <span class="keyword">double</span> invz_2 = invz * invz;      <span class="comment">// 1/Z^2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> u = x * fx_ * invz + cx_; <span class="comment">// u = (X*fx)/Z+cx</span></span><br><span class="line">    <span class="keyword">float</span> v = v * fy_ * invz + cy_; <span class="comment">// v = (Y*fy)/Z+cy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先求投影方程关于变换的导数 ∂u/∂δξ</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">6</span>&gt; jacobian_uv_ksai;</span><br><span class="line">    <span class="comment">// g2o 是旋转在前，平移在后；</span></span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">0</span>) = -x * y * fx_ * invz_2;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">1</span>) = (<span class="number">1</span> + x * x * invz_2) * fx_;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">2</span>) = -fx_ * y * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">3</span>) = fx_ * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">6</span>) = -fx_ * x * invz_2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">0</span>) = -(<span class="number">1</span> + y * y * invz_2) * fy_;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">1</span>) = fy_ * x * y * invz_2;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">2</span>) = fy_ * x * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">4</span>) = fy_ * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">5</span>) = -y * invz_2 * fy_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像素的梯度 ∂I2/∂u</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; jacobian_pixel_uv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jacobian_pixel_uv</span>(<span class="number">0</span>, <span class="number">0</span>) = (<span class="built_in">getPixelValue</span>(u + <span class="number">1</span>, v) - <span class="built_in">getPixelValue</span>(u - <span class="number">1</span>, v)) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">jacobian_pixel_uv</span>(<span class="number">0</span>, <span class="number">1</span>) = (<span class="built_in">getPixelValue</span>(u, v + <span class="number">1</span>) - <span class="built_in">getPixelValue</span>(u, v - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// J矩阵 = ∂I2/∂u * ∂u/∂δξ</span></span><br><span class="line">    _jacobianOplusXi = jacobian_pixel_uv*jacobian_uv_ksai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-直接法估计相机运动"><a href="#2-2-直接法估计相机运动" class="headerlink" title="2.2 直接法估计相机运动"></a>2.2 直接法估计相机运动</h2><p>在使用直接法估计相机运动时，我们用过g2o对相机的位姿进行优化，其中的观测值为世界坐标系下的3D点坐标以及对应的灰度值，因此我们使用一个结构体<code>Measurement</code>用来存储观测值，由于需要用到相机坐标系之间的变换，所以还需要写坐标变换相关的函数。</p>
<h3 id="Measurement结构体"><a href="#Measurement结构体" class="headerlink" title="Measurement结构体"></a>Measurement结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Measurement</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Measurement</span>(Eigen::Vector3d p, <span class="keyword">float</span> g) : <span class="built_in">pos_world</span>(p), <span class="built_in">grayscale</span>(g) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d pos_world;</span><br><span class="line">    <span class="keyword">float</span> grayscale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="project2Dto3D"><a href="#project2Dto3D" class="headerlink" title="project2Dto3D"></a>project2Dto3D</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将像素坐标系转换为世界坐标系</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector3d <span class="title">project2Dto3D</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> zz = <span class="built_in"><span class="keyword">float</span></span>(d) / scale;</span><br><span class="line">    <span class="keyword">float</span> xx = zz * (x - cx) / fx; <span class="comment">// X = Z*(u-cx)/fx</span></span><br><span class="line">    <span class="keyword">float</span> yy = zz * (y - cy) / fy; <span class="comment">// Y = Z*(u-cy)/fy</span></span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector3d</span>(xx, yy, zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="project3Dto2D"><a href="#project3Dto2D" class="headerlink" title="project3Dto2D"></a>project3Dto2D</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将世界坐标系转换为像素坐标系</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector2d <span class="title">project3Dto2D</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> u = fx * x / z + cx; <span class="comment">// u = fx*X/Z + cx</span></span><br><span class="line">    <span class="keyword">float</span> v = fy * y / z + cy; <span class="comment">// v = fy*Y/Z + cy</span></span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector2d</span>(u, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="poseEstimationDirect"><a href="#poseEstimationDirect" class="headerlink" title="poseEstimationDirect"></a>poseEstimationDirect</h3><p>这是最主要的一个函数，用直接法估计相机运动，并使用了g2o对位姿进行优化。<strong>相比于特征点法，直接法完全依靠优化来求解相机位姿。</strong></p>
<p>原理就是以第一个图像为参考帧，然后用直接法求解后续图像的位姿。在参考帧中，对第一张图像提取 FAST 关键点（不需要描述子），并使用直接法估计这些关键点在第二个图像中的位置，以及第二个图像的相机位姿。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用直接法估计相机运动(使用非线性BA优化)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">poseEstimationDirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Measurement&gt; &amp;measurements, <span class="comment">// 测量值：一个世界坐标系下三维点与一个灰度值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Mat *gray,                          <span class="comment">// 灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Eigen::Matrix3f &amp;K,                     <span class="comment">// 相机参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Eigen::Isometry3d &amp;Tcw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">1</span>&gt;&gt; DirectBlock;</span><br><span class="line">    <span class="comment">// 1.创建线性求解器 LinearSolverDense使用dense cholesky分解法</span></span><br><span class="line">    DirectBlock::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;DirectBlock::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.创建矩阵块求解器，用上面我们定义的线性求解器LinearSolver来初始化。</span></span><br><span class="line">    DirectBlock *solver_ptr = <span class="keyword">new</span> <span class="built_in">DirectBlock</span>(std::unique_ptr&lt;DirectBlock::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;DirectBlock&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4.创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.定义图的顶点和边</span></span><br><span class="line">    <span class="comment">// 顶点(待优化变量，这里是相机位姿)</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    <span class="comment">// 设置待优化位姿旋转(Rotation)(角轴或四元素表示)、平移(Translation)</span></span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(Tcw.<span class="built_in">rotation</span>(), Tcw.<span class="built_in">translation</span>()));</span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边(误差，这里是光影误差)</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Measurement m : measurements)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeSE3ProjectDirect *edge = <span class="keyword">new</span> <span class="built_in">EdgeSE3ProjectDirect</span>(</span><br><span class="line">            m.pos_world,</span><br><span class="line">            <span class="built_in">K</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">K</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">K</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="built_in">K</span>(<span class="number">1</span>, <span class="number">2</span>), gray);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, pose);                                      <span class="comment">// 定义顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(m.grayscale);                             <span class="comment">// 定义观测值</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>()); <span class="comment">// 定义协方差矩阵的逆</span></span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(id++);</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图中的边的个数：&quot;</span> &lt;&lt; optimizer.<span class="built_in">edges</span>().<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 6.开始优化</span></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>); <span class="comment">// 迭代次数</span></span><br><span class="line">    <span class="comment">// 优化后的相机位姿</span></span><br><span class="line">    Tcw = pose-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-主函数"><a href="#2-3-主函数" class="headerlink" title="2.3 主函数"></a>2.3 主函数</h2><p>整个主函数的顺序需要了解</p>
<ul>
<li>首先是一些判断或者一些初始化</li>
<li>然后我们对数据集循环操作每一张图片，但是第一张图像为参考，对后续图像和参考图像做直接法</li>
<li>对第一张图提取Fast关键点（不需要描述子）</li>
<li>使用直接法估计这些关键点在第二个图像中的位置，以及第二个图像的相机位姿</li>
<li>最后就是绘制这些特征点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;usage: useLK path_to_dataset&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    string path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    string assciate_file = path_to_dataset + <span class="string">&quot;/assciate.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(assciate_file)</span></span>;</span><br><span class="line">    string rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    cv::Mat color, depth, gray;</span><br><span class="line">    vector&lt;Measurement&gt; measurements;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">float</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">float</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">float</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">float</span> depth_scale = <span class="number">1000.0</span>;</span><br><span class="line">    Eigen::Matrix3f K;</span><br><span class="line">    K &lt;&lt; fx, <span class="number">0.f</span>, cx, <span class="number">0.f</span>, fy, cy, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Isometry3d Tcw = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line">    cv::Mat prev_color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们以第一个图像为参考，对后续图像和参考图像做直接法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*********** loop &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">        fin &gt;&gt; time_rgb &gt;&gt; rgb_file &gt;&gt; time_depth &gt;&gt; depth_file;</span><br><span class="line">        color = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + rgb_file);</span><br><span class="line">        depth = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + depth_file, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (color.data == <span class="literal">nullptr</span> || depth.data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环</span></span><br><span class="line">        <span class="comment">// 将BGR格式(color)转换成灰度图片(gray)</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(color, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;cv::KeyPoint&gt; keypoints;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">            <span class="comment">// 使用Fast特征点检测，讲检测后的特征点存入容器keypoints中</span></span><br><span class="line">            detector-&gt;<span class="built_in">detect</span>(color, keypoints);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉邻近边缘处的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (kp.pt.x &lt; <span class="number">20</span> || kp.pt.y &lt; <span class="number">20</span> || (kp.pt.x + <span class="number">20</span>) &gt; color.cols || (kp.pt.y + <span class="number">20</span>) &gt; color.rows)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环</span></span><br><span class="line">                <span class="comment">// d指定到depth矩阵的y行第x列个像素</span></span><br><span class="line">                ushort d = depth.ptr&lt;ushort&gt;(<span class="built_in">cvRound</span>(kp.pt.y))[<span class="built_in">cvRound</span>(kp.pt.x)];</span><br><span class="line">                <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 将像素坐标系转换为世界坐标系</span></span><br><span class="line">                Eigen::Vector3d p3p = <span class="built_in">project2Dto3D</span>(kp.pt.x, kp.pt.y, d, fx, fy, cx, cy, depth_scale);</span><br><span class="line">                <span class="comment">// grayscale指定到gray矩阵的y行第x列个像素</span></span><br><span class="line">                <span class="keyword">float</span> grayscale = <span class="built_in"><span class="keyword">float</span></span>(gray.<span class="built_in">ptr</span>(<span class="built_in">cvRound</span>(kp.pt.y))[<span class="built_in">cvRound</span>(kp.pt.x)]);</span><br><span class="line">                <span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line">                measurements.<span class="built_in">push_back</span>(<span class="built_in">Measurement</span>(p3p, grayscale));</span><br><span class="line">            &#125;</span><br><span class="line">            prev_color = color.<span class="built_in">clone</span>();</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;add total &quot;</span>&lt;&lt;measurements.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; measurements.&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.对后续图像使用直接法计算相机运动</span></span><br><span class="line">        <span class="built_in">poseEstimationDirect</span>(measurements, &amp;gray, K, Tcw);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tcw=&quot;</span> &lt;&lt; Tcw.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.绘制特征点</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">img_show</span><span class="params">(color.rows * <span class="number">2</span>, color.cols, CV_8UC3)</span></span>;</span><br><span class="line">        prev_color.<span class="built_in">copyTo</span>(<span class="built_in">img_show</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, color.cols, color.rows)));</span><br><span class="line">        color.<span class="built_in">copyTo</span>(<span class="built_in">img_show</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, color.rows, color.cols, color.rows)));</span><br><span class="line">        <span class="keyword">for</span> (Measurement m : measurements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rand</span>() &gt; RAND_MAX / <span class="number">5</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p = m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_prev = <span class="built_in">project3Dto2D</span>(<span class="built_in">p</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">p</span>(<span class="number">2</span>, <span class="number">0</span>), fx, fy, cx, cy);</span><br><span class="line">            Eigen::Vector3d p2 = Tcw * m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_now = <span class="built_in">project3Dto2D</span>(<span class="built_in">p2</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">p2</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">p2</span>(<span class="number">2</span>, <span class="number">0</span>), fx, fy, cx, cy);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span> || <span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>) &gt;= color.cols || <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span> || <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) &gt;= color.rows)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> b = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> g = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> r = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_prev</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_prev</span>(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">8</span>, cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">2</span>);</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) + color.rows), <span class="number">8</span>, cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">2</span>);</span><br><span class="line">            cv::<span class="built_in">line</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_prev</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_prev</span>(<span class="number">1</span>, <span class="number">0</span>)), cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) + color.rows), cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, img_show);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( directMethod )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块路径</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( G2O )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span> ) </span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( G2O_LIBS </span><br><span class="line">    g2o_core g2o_types_sba g2o_solver_csparse g2o_stuff g2o_csparse_extension </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( direct_sparse direct_sparse.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( direct_sparse <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;G2O_LIBS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( direct_semidense direct_semidense.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( direct_semidense <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;G2O_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*********** loop <span class="number">0</span> ************</span><br><span class="line">add total <span class="number">1402</span> measurements.</span><br><span class="line">*********** loop <span class="number">1</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7403254.830490</span>    <span class="selector-tag">time</span>= <span class="number">0.00082488</span>        cumTime= <span class="number">0.00082488</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">60236876.490033</span>        levenbergIter= <span class="number">5</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">7403254.830490</span>    <span class="selector-tag">time</span>= <span class="number">0.00102553</span>        cumTime= <span class="number">0.00185041</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">2119396675894340747264.000000</span>  levenbergIter= <span class="number">9</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00288273</span>  <span class="number">2.64449</span>e-<span class="number">05</span> -<span class="number">0.000928174</span></span><br><span class="line"> -<span class="number">0.00288272</span>     <span class="number">0.999996</span> -<span class="number">0.000436968</span> -<span class="number">3.76331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.77045</span>e-<span class="number">05</span>   <span class="number">0.00043689</span>            <span class="number">1</span>   <span class="number">0.00103318</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">2</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7759380.788781</span>    <span class="selector-tag">time</span>= <span class="number">0.00174707</span>        cumTime= <span class="number">0.00174707</span>     </span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">9</span>     chi2= <span class="number">7758019.671470</span>    <span class="selector-tag">time</span>= <span class="number">0.000755714</span>       cumTime= <span class="number">0.00772499</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">3783063956763384479744.000000</span>  levenbergIter= <span class="number">5</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00288243</span>  <span class="number">2.77591</span>e-<span class="number">05</span> -<span class="number">0.000928009</span></span><br><span class="line"> -<span class="number">0.00288242</span>     <span class="number">0.999996</span> -<span class="number">0.000441154</span> -<span class="number">3.82145</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.90306</span>e-<span class="number">05</span>  <span class="number">0.000441072</span>            <span class="number">1</span>   <span class="number">0.00103304</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">3</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7824244.109174</span>    <span class="selector-tag">time</span>= <span class="number">0.00174816</span>        cumTime= <span class="number">0.00174816</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">6220200914927.365234</span>   levenbergIter= <span class="number">8</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">7819308.542160</span>    <span class="selector-tag">time</span>= <span class="number">0.0010889</span>         cumTime= <span class="number">0.00689116</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">3127198551927549329408.000000</span>  levenbergIter= <span class="number">7</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00289109</span>  <span class="number">2.80266</span>e-<span class="number">05</span> -<span class="number">0.000927608</span></span><br><span class="line"> -<span class="number">0.00289108</span>     <span class="number">0.999996</span> -<span class="number">0.000451442</span> -<span class="number">3.83751</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.93317</span>e-<span class="number">05</span>  <span class="number">0.000451359</span>            <span class="number">1</span>   <span class="number">0.00103126</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">4</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8430224.068489</span>    <span class="selector-tag">time</span>= <span class="number">0.0017704</span>         cumTime= <span class="number">0.0017704</span>      edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">14477120284239.218750</span>  levenbergIter= <span class="number">8</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">10</span>    chi2= <span class="number">8429345.097617</span>    <span class="selector-tag">time</span>= <span class="number">0.000582781</span>       cumTime= <span class="number">0.00791508</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">25272065502643142656.000000</span>    levenbergIter= <span class="number">4</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">5</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8454586.253220</span>    <span class="selector-tag">time</span>= <span class="number">0.00216226</span>        cumTime= <span class="number">0.00216226</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">11915390830915310583808.000000</span>         levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">6</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8159516.143149</span>    <span class="selector-tag">time</span>= <span class="number">0.00214553</span>        cumTime= <span class="number">0.00214553</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">7207697814143619825664.000000</span>  levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">7</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8203720.110076</span>    <span class="selector-tag">time</span>= <span class="number">0.0021112</span>         cumTime= <span class="number">0.0021112</span>      edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">21225209233812976828416.000000</span>         levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">8</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8054487.520687</span>    <span class="selector-tag">time</span>= <span class="number">0.00161749</span>        cumTime= <span class="number">0.00161749</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">306330210612.899292</span>    levenbergIter= <span class="number">7</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">8047353.368341</span>    <span class="selector-tag">time</span>= <span class="number">0.00105102</span>        cumTime= <span class="number">0.00563404</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">4158192944542638931968.000000</span>  levenbergIter= <span class="number">6</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00290379</span>  <span class="number">2.91578</span>e-<span class="number">05</span> -<span class="number">0.000927602</span></span><br><span class="line"> -<span class="number">0.00290378</span>     <span class="number">0.999996</span> -<span class="number">0.000470562</span> -<span class="number">4.13493</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">3.05241</span>e-<span class="number">05</span>  <span class="number">0.000470476</span>            <span class="number">1</span>   <span class="number">0.00103238</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">9</span> ************</span><br></pre></td></tr></table></figure>
<p><img src="/images/RGB-D直接法实践/image-20220329164608300.png" alt="image-20220329164608300"></p>
<h1 id="三、半稠密直接法"><a href="#三、半稠密直接法" class="headerlink" title="三、半稠密直接法"></a>三、半稠密直接法</h1><p>我们很容易就能把程序拓展成半稠密的直接法形式。对参考帧中，先提取梯度较明显的像素，然后用直接法，以这些像素为图优化边，来估计相机运动。对先前的程序做如下的修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// select the pixels with high gradiants </span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x=<span class="number">10</span>; x&lt;gray.cols<span class="number">-10</span>; x++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> y=<span class="number">10</span>; y&lt;gray.rows<span class="number">-10</span>; y++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Eigen::Vector2d <span class="title">delta</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            gray.ptr&lt;uchar&gt;(y)[x+<span class="number">1</span>] - gray.ptr&lt;uchar&gt;(y)[x<span class="number">-1</span>], </span></span></span><br><span class="line"><span class="params"><span class="function">            gray.ptr&lt;uchar&gt;(y+<span class="number">1</span>)[x] - gray.ptr&lt;uchar&gt;(y<span class="number">-1</span>)[x]</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ( delta.<span class="built_in">norm</span>() &lt; <span class="number">50</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ushort d = depth.ptr&lt;ushort&gt; (y)[x];</span><br><span class="line">            <span class="keyword">if</span> ( d==<span class="number">0</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p3d = <span class="built_in">project2Dto3D</span> ( x, y, d, fx, fy, cx, cy, depth_scale );</span><br><span class="line">            <span class="keyword">float</span> grayscale = <span class="built_in"><span class="keyword">float</span></span> ( gray.ptr&lt;uchar&gt; (y) [x] );</span><br><span class="line">            measurements.<span class="built_in">push_back</span> ( <span class="built_in">Measurement</span> ( p3d, grayscale ) );</span><br><span class="line">        &#125;</span><br><span class="line">        prev_color = color.<span class="built_in">clone</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;add total &quot;</span>&lt;&lt;measurements.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; measurements.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*********** loop <span class="number">0</span> ************</span><br><span class="line">add total <span class="number">12556</span> measurements.</span><br><span class="line">*********** loop <span class="number">1</span> ************</span><br><span class="line">图中的边的个数：<span class="number">12556</span></span><br><span class="line">.....</span><br><span class="line">iteration= <span class="number">19</span>    chi2= <span class="number">71515789.320224</span>   <span class="selector-tag">time</span>= <span class="number">0.00527771</span>        cumTime= <span class="number">0.0867877</span>      edges= <span class="number">12556</span>    schur= <span class="number">0</span>        lambda= <span class="number">4022565853557871345664.000000</span>  levenbergIter= <span class="number">4</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999999</span> -<span class="number">1.99501</span>e-<span class="number">06</span>  -<span class="number">0.00124229</span>    <span class="number">0.0166827</span></span><br><span class="line"> <span class="number">3.02563</span>e-<span class="number">06</span>            <span class="number">1</span>  <span class="number">0.000829608</span>   -<span class="number">0.0119843</span></span><br><span class="line">  <span class="number">0.00124229</span> -<span class="number">0.000829611</span>     <span class="number">0.999999</span>   -<span class="number">0.0118238</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">....</span><br><span class="line">*********** loop <span class="number">9</span> ************</span><br></pre></td></tr></table></figure>
<p><img src="/images/RGB-D直接法实践/image-20220330165208010.png" alt="image-20220330165208010"></p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
      </tags>
  </entry>
  <entry>
    <title>ch8_直接法的推导</title>
    <url>/posts/50957.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>之前估计相机运动时使用对极几何、PnP 或 ICP 算法，而根据图像的像素灰度信息也可以计算相机运动，这种方法称为直接法。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>考虑某个空间点 $P$ 和两个时刻的相机。$P $的世界坐标为$ [X, Y, Z]$，它在两个相机上成像，记非齐次像素坐标为 $p_1 , p_2$ 。</p>
<p><img src="/images/直接法的推导/image-20220329150722092.png" alt="image-20220329150722092" style="zoom: 33%;" /></p>
<p>我们的目标是求第一个相机到第二个相机的相对位姿变换。我们以第一个相机为参照系，设第二个相机旋转和平移为$ R, t$（对应李代数为 $\xi$）。同时，两相机的内参相同，记为 $K$。为清楚起见，我们列写完整的投影方程：</p>
<script type="math/tex; mode=display">
\begin{align*}
p_1 &= 
\begin{bmatrix}
u\\v\\1
\end{bmatrix}_1=\frac{1}{Z_1}KP\\
p_2&=\begin{bmatrix}
u\\v\\1
\end{bmatrix}_2=\frac{1}{Z_2}K(RP+t)=\frac{1}{Z_2}K(exp(\xi^{\land})P)_{1:3}
\end{align*}</script><p>特征点法中，由于我们通过匹配描述子，知道了 $p_1 , p_2$ 的像素位置，所以可以计算重投影的位置。但在直接法中，由于没有特征匹配，我们无从知道哪一个 $p_1 , p_2$  对应着同一个点。</p>
<p>直接法的思路是根据当前相机的位姿估计值，来寻找 $p_2$ 的位置。但若相机位姿不够好， $p_2$ 的外观和  $p_1$ 会有明显差别。于是，为了减小这个差别，我们优化相机的位姿，来寻找与  $p_1$更相似的 $p_2$。</p>
<p>这同样可以通过解一个优化问题，但此时<strong>最小化的不是重投影误差</strong>，而是<strong>光度误差（Photometric Error）</strong>，也就是 $P $的两个像的亮度误差：</p>
<script type="math/tex; mode=display">
e = I_1 (p_1 ) − I_2 (p_2 )</script><p>这里 e 是一个标量，同样的，优化目标为该误差的二范数，暂时取不加权的形式，为：</p>
<script type="math/tex; mode=display">
\underset{\xi}{min}J(\xi)=\parallel e\parallel^2</script><p>由灰度不变假设，对于$N$个空间点$P_i$，整个相机的位姿估计问题变为：</p>
<script type="math/tex; mode=display">
\underset{\xi}{min}J(\xi)=\sum^N_{i=1}e_i^Te_i\\
e_i=I_1(p_1,i)-I_2(p_2,i)</script><p>这里的优化变量是相机位姿 $\xi$，为了求解这个优化问题，我们关心误差 $e$ 是如何随着相机位姿 $\xi$ 变化的，需要分析它们的导数关系。因此，使用李代数上的扰动模型。我们给 $exp(\xi) $左乘一个小扰动$ exp(\delta \xi)$:</p>
<script type="math/tex; mode=display">
\begin{align*}
e(\xi⊕\delta \xi)&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}K exp(\delta \xi^{\land})exp(\xi^{\land})P)\\
&\approx I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}K (1+\delta \xi^{\land})exp(\xi^{\land})P)\\
&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+\frac{1}{Z_2}K \delta \xi^{\land}exp(\xi^{\land})P)\\
\end{align*}</script><p>记：</p>
<script type="math/tex; mode=display">
\begin{align*}
q&=\delta \xi^{\land}exp(\xi^{\land})P\\
u&=\frac{1}{Z_2}Kq
\end{align*}</script><p>$q $为$ P $在扰动之后，位于第二个相机坐标系下的坐标，而 $u $为它的像素坐标</p>
<p>由一阶泰勒展开可知：</p>
<script type="math/tex; mode=display">
I(x+dx)\approx \frac{\partial I}{\partial x}dx\\
I(x+\delta \xi)\approx \frac{\partial I}{\partial \delta \xi}{\delta \xi}</script><p>所以，同样的进行一阶泰勒展开：</p>
<script type="math/tex; mode=display">
\begin{align*}
e(\xi⊕\delta \xi)&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+\frac{1}{Z_2}K \delta \xi^{\land}exp(\xi^{\land})P)\\
&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+u)\\
&\approx I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P)-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}\delta \xi\\
&=e(\xi)-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}\delta \xi
\end{align*}</script><p>一阶导数由于链式法则分成了三项，分别计算这三部分：</p>
<p>$\partial I_2 / \partial u$为$ u $处的像素梯度；</p>
<p>$∂u/∂q $为投影方程关于相机坐标系下的三维点的导数，$q $为$ P $在扰动之后，位于第二个相机坐标系下的坐标，$u $为它的像素坐标，记为$q = [X, Y, Z]^T$</p>
<script type="math/tex; mode=display">
\frac{\partial u}{\partial q}=-
\begin{bmatrix}
\frac{\partial u}{\partial X}&
\frac{\partial u}{\partial Y}&
\frac{\partial u}{\partial Z}            \\ 
\frac{\partial v}{\partial X}&
\frac{\partial v}{\partial Y}&
\frac{\partial v}{\partial Z}
\end{bmatrix}=-
\begin{bmatrix}
\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}\\
0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}
\end{bmatrix}</script><p>$∂q/∂δξ $为变换后的三维点对变换的导数，由于$q$为变换后的三维点，设变换前的三维点为$q_0$</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial q}{\partial \delta \xi}&=
\frac{\partial(Tq_0)}{\partial \delta \xi} \\ &=
\underset{\delta \xi \rightarrow0}{lim}
\frac{exp(\delta \xi ^{\land})exp(\xi ^{\land})q_0-exp(\xi ^{\land})q_0}{\delta \xi}\\&\approx
\underset{\delta \xi \rightarrow0}{lim}
\frac{(I+\delta \xi ^{\land})exp(\xi ^{\land})q_0-exp(\xi ^{\land})q_0}{\delta \xi}\\&=
\underset{\delta \xi \rightarrow0}{lim}
\frac{\delta \xi ^{\land}exp(\xi ^{\land})q_0}{\delta \xi}\\&=
\underset{\delta \xi \rightarrow0}{lim}
\frac{\begin{bmatrix}
\delta \phi^{\land}&\delta \rho \\
0^T&0
\end{bmatrix}
\begin{bmatrix}
Rq_0+t \\
1
\end{bmatrix}
}{\delta \xi}\\&=
\underset{\delta \xi \rightarrow0}{lim}
\frac{\begin{bmatrix}
\delta \phi^{\land}(Rq_0+t)+\delta \rho  \\
0
\end{bmatrix}
}
{\delta \xi}\\&=
\begin{bmatrix}
I &-(Rq_0+t)^{\land}\\
0^{T}&0^{T}
\end{bmatrix}\\&=
\begin{bmatrix}
I &-q^{\land}\\
0^{T}&0^{T}
\end{bmatrix}\\&=
(Tq)^⊙
\end{align*}</script><p>后两项只与三维点 q 有关，而与图像无关，我们经常把它合并在一起：</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{\partial u}{\partial \delta \xi}&=
\frac{\partial u}{\partial q}
\frac{\partial q}{\partial \delta \xi}=-
\begin{bmatrix}
\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}
&-\frac{f_xXY}{Z^{2}}&f_x+\frac{f_xX^2}{Z^{2}}&-\frac{f_xY}{Z}
\\
0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}
&-f_y-\frac{f_yY^{2}}{Z^{2}}&\frac{f_yXY}{Z}&\frac{f_yX}{Z}
\end{bmatrix}
\end{align}</script><p>推导了误差相对于李代数的雅可比矩阵：</p>
<script type="math/tex; mode=display">
J=-\frac{\partial I_2}{\partial u}
\frac{\partial u}{\partial \delta \xi}</script><p>对于 $N $个点的问题，我们可以用这种方法计算优化问题的雅可比，然后使用$ G-N$或$L-M$ 计算增量，迭代求解。</p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>直接法</tag>
      </tags>
  </entry>
  <entry>
    <title>ch8_使用LK光流法</title>
    <url>/posts/46698.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>光流是一种描述像素随着时间，在图像之间运动的方法。随着时间的经过，同一个像素会在图像中运动，而我们希望追踪它的运动过程。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。稀疏光流以$ Lucas-Kanade$ 光流为代表，并可以在 SLAM 中用于跟踪特征点位置。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><img src="/images/使用LK光流法/image-20220329104428515.png" alt="image-20220329104428515"></p>
<h1 id="LK光流法原理"><a href="#LK光流法原理" class="headerlink" title="LK光流法原理"></a>LK光流法原理</h1><p>在$ LK $光流中，我们认为来自相机的图像是随时间变化的。图像可以看作时间的函数：$I(t)$。那么，一个在$ t $时刻，位于$ (x, y)$ 处的像素，它的灰度可以写成</p>
<script type="math/tex; mode=display">
I(x, y, t).</script><p>灰度不变假设：</p>
<script type="math/tex; mode=display">
I(x+d_x,y+d_y,t+d_t)=I(x, y, t)</script><p>对左边进行泰勒展开，保留一阶项，得：</p>
<script type="math/tex; mode=display">
I (x + dx, y + dy, t + dt) \approx I (x, y, t)
+\frac{\partial I}{\partial x}d_x
+\frac{\partial I}{\partial y}d_y
+\frac{\partial I}{\partial t}d_t</script><p>假设了灰度不变:</p>
<script type="math/tex; mode=display">
\frac{\partial I}{\partial x}d_x
+\frac{\partial I}{\partial y}d_y
+\frac{\partial I}{\partial t}d_t=0</script><p>两边除以 $dt$:</p>
<script type="math/tex; mode=display">
\frac{\partial I}{\partial x}\frac{d_x}{d_t}
+\frac{\partial I}{\partial y}\frac{d_y}{d_t}
=-\frac{\partial I}{\partial t}</script><p>其中: $dx/dt $为像素在 $x $轴上运动速度，记为$u$， $dy/dt $为像素在 $y$轴上运动速度，记为$v$</p>
<p>$\partial I/\partial x$为图像在该点处 $x$ 方向的梯度，记为$I_x$，$\partial I/\partial y$为图像在该点处 $y$ 方向的梯度，记为$I_y$</p>
<p>图像灰度对时间的变化量记为 $I_t$</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I_x & I_y
\end{bmatrix}
\begin{bmatrix}
u \\ v
\end{bmatrix}
= - I_t</script><p>我们想计算的是像素的运动$ u, v$，但是该式是带有两个变量的一次方程，仅凭它无法计算出$ u, v$。因此，必须引入额外的约束来计算$ u, v$。在$ LK $光流中，我们假设某一个窗口内的像素具有相同的运动。</p>
<p>考虑一个大小为 $w × w$ 大小的窗口，它含有 $w^2 $数量的像素。由于该窗口内像素具有同样的运动，因此我们共有 $w^2 $个方程：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I_x & I_y
\end{bmatrix}_k
\begin{bmatrix}
u \\ v
\end{bmatrix}
= - I_{tk},k=1,....,w^2</script><p>即为：</p>
<script type="math/tex; mode=display">
A = 
\begin{bmatrix}
\begin{bmatrix}
I_x & I_y
\end{bmatrix}_1\\.\\.\\
\begin{bmatrix}
I_x & I_y
\end{bmatrix}_k
\end{bmatrix},
b=\begin{bmatrix}
I_{t1} \\.\\.\\I_{tk} 
\end{bmatrix}</script><p>于是整个方程为：</p>
<script type="math/tex; mode=display">
A\begin{bmatrix}
u\\u
\end{bmatrix}=-b</script><p>这是一个关于 u, v 的超定线性方程，传统解法是求最小二乘解。最小二乘在很多时候都用到过：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
u\\u
\end{bmatrix}^*
=-(A^TA)^{-1}A^Tb</script><p>这样就得到了像素在图像间的运动速度 $u, v$</p>
<h1 id="使用LK光流法"><a href="#使用LK光流法" class="headerlink" title="使用LK光流法"></a>使用LK光流法</h1><h2 id="光流追踪的原理"><a href="#光流追踪的原理" class="headerlink" title="光流追踪的原理"></a>光流追踪的原理</h2><ul>
<li><p>cv2.FastFeatureDetector()：Fast角点检测器确定要追踪的特征点</p>
</li>
<li><p>cv2.calcOpticalFlowPyrLK()： 追踪视频中的稀疏特征点</p>
</li>
<li><p>cv2.calcOpticalFlowFarneback()： 追踪视频中的密集特征点</p>
</li>
</ul>
<p>取第一帧，检测其中的一些 Fast角点，使用 Lucas-Kanade 光流迭代跟踪这些点。对于函数 cv2.calcOpticalFlowPyrLK() 传递前一帧、前一个点和下一帧。它返回下一个点以及一些状态编号，如果找到下一个点，则值为 1，否则为零。然后在下一步中迭代地将这些下一个点作为前一个点传递。</p>
<h2 id="光流的两种方法"><a href="#光流的两种方法" class="headerlink" title="光流的两种方法"></a>光流的两种方法</h2><p>OpenCV提供了俩种算法计算光流，分别通过：cv2.calcOpticalFlowPyrLK()、cv2.calcOpticalFlowFarneback实现；</p>
<ul>
<li>稀疏光流： 通过 Lucas-Kanade 方法计算稀疏特征集的光流（使用 角点检测算法检测到的角点）。</li>
</ul>
<p>参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::calcOpticalFlowPyrLK</span>	<span class="params">(	</span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray 	prevImg, <span class="comment">//上一帧单通道灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray 	nextImg, <span class="comment">//下一帧单通道灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray 	prevPts, <span class="comment">//像素点上一帧二维坐标pts</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputOutputArray 	nextPts,<span class="comment">//像素点下一帧二维坐标pts</span></span></span></span><br><span class="line"><span class="params"><span class="function">        OutputArray 	status,<span class="comment">// 输出状态向量,（无符号字符）;如果找到相应特征的流，则向量的每个元素设置为1，否则设置为0。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        OutputArray 	err, <span class="comment">//输出错误的矢量;如果未找到流，则未定义错误（使用status参数查找此类情况）。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        Size 	winSize = Size(<span class="number">21</span>, <span class="number">21</span>),<span class="comment">//每个金字塔等级的搜索窗口的winSize大小。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> 	maxLevel = <span class="number">3</span>,<span class="comment">// 基于0的最大金字塔等级数;如果设置为0，则不使用金字塔（单级），如果设置为1，则使用两个级别，依此类推;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        TermCriteria 	criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, <span class="number">30</span>, <span class="number">0.01</span>),<span class="comment">//参数，指定迭代搜索算法的终止条件</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> 	flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">double</span> 	minEigThreshold = <span class="number">1e-4</span> <span class="comment">//算法计算光流方程的2x2正常矩阵的最小特征值，除以窗口中的像素数;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span>	</span></span><br></pre></td></tr></table></figure>
<ul>
<li>密集光流： 通过 Gunner Farneback 来寻找密集光流。它计算帧中所有点的光流。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在使用数据之前，需要根据采集时间，对数据进行一次时间上的对齐，以便对彩色图和深度图进行配对。TUM 提供了一个 python 脚本“asso-ciate.py”帮我们完成这件事。请把此文件放到数据集目录下，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python associate.py rgb.txt depth.txt &gt; associate.txt</span><br></pre></td></tr></table></figure>
<p>主函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入数据集所在的路径！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    string associate_file = path_to_dataset + <span class="string">&quot;/associate.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(associate_file)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;associate.txt文件不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    list&lt;cv::Point2f&gt; keypoints; <span class="comment">// 因为要删除跟踪失败的点，使用list</span></span><br><span class="line">    cv::Mat color, depth, last_color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        fin &gt;&gt; time_rgb &gt;&gt; rgb_file &gt;&gt; time_depth &gt;&gt; depth_file;</span><br><span class="line">        color = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + rgb_file);       <span class="comment">// 读入彩色图</span></span><br><span class="line">        depth = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + depth_file, <span class="number">-1</span>); <span class="comment">// 读入深度图</span></span><br><span class="line">        <span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;cv::KeyPoint&gt; kps;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">            detector-&gt;<span class="built_in">detect</span>(color, kps); <span class="comment">// 提取FAST特征点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> kp : kps)           <span class="comment">// 把提取的特征点存入list</span></span><br><span class="line">                keypoints.<span class="built_in">push_back</span>(kp.pt);</span><br><span class="line">            last_color = color;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.对其他帧使用LK跟踪特征点</span></span><br><span class="line">        <span class="keyword">if</span> (color.data == <span class="literal">nullptr</span> &amp;&amp; depth.data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;cv::Point2f&gt; next_keypoints;</span><br><span class="line">        vector&lt;cv::Point2f&gt; prev_keypoints;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">            prev_keypoints.<span class="built_in">push_back</span>(kp); <span class="comment">// 讲list中的数据赋给prev_keypoints</span></span><br><span class="line">        vector&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; status;</span><br><span class="line">        vector&lt;<span class="keyword">float</span>&gt; error;</span><br><span class="line"></span><br><span class="line">        chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">calcOpticalFlowPyrLK</span>(last_color, color, prev_keypoints, next_keypoints, status, error);</span><br><span class="line"></span><br><span class="line">        chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LK Flow use time：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把跟丢的点删掉</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = keypoints.<span class="built_in">begin</span>(); iter != keypoints.<span class="built_in">end</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (status[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iter = keypoints.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *iter = next_keypoints[i];</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;跟踪到的点个数为： &quot;</span> &lt;&lt; keypoints.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (keypoints.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;all keypoints are lost.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出 keypoints</span></span><br><span class="line">        cv::Mat img_show = color.<span class="built_in">clone</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, kp, <span class="number">10</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">240</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;corners&quot;</span>, img_show);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">        last_color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为要删除跟踪失败的点，使用list,原因如下：</p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p>
<p>list的优点：</p>
<blockquote>
<p>采用动态存储分配，不会造成内存浪费和溢出<br>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</p>
</blockquote>
</blockquote>
<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LK Flow use time：0.0157339 seconds.</span><br><span class="line">跟踪到的点个数为： 1749</span><br><span class="line">LK Flow use time：0.0144717 seconds.</span><br><span class="line">跟踪到的点个数为： 1742</span><br><span class="line">LK Flow use time：0.0186928 seconds.</span><br><span class="line">跟踪到的点个数为： 1703</span><br><span class="line">LK Flow use time：0.0153624 seconds.</span><br><span class="line">跟踪到的点个数为： 1676</span><br><span class="line">LK Flow use time：0.019426 seconds.</span><br><span class="line">跟踪到的点个数为： 1664</span><br><span class="line">LK Flow use time：0.0140176 seconds.</span><br><span class="line">跟踪到的点个数为： 1656</span><br><span class="line">LK Flow use time：0.0187153 seconds.</span><br><span class="line">跟踪到的点个数为： 1641</span><br><span class="line">LK Flow use time：0.0187284 seconds.</span><br><span class="line">跟踪到的点个数为： 1634</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( useLK )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++11 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( useLK useLK.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( useLK <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/使用LK光流法/image-20220329144916230.png" alt="image-20220329144916230"></p>
<p>LK 光流跟踪能够直接得到特征点的对应关系。这个对应关系就像是描述子的匹配，但实际上我们大多数时候只会碰到特征点跟丢的情况，而不太会遇到误匹配，这应该是光流相对于描述子的一点优势。但是，匹配描述子的方法在相机运动较大时仍能成功，而光流必须要求相机运动是微小的。从这方面来说，光流的鲁棒性比描述子差一些。</p>
<p>光流法参考：</p>
<ul>
<li><a href="https://www.shouxicto.com/article/1871.html">OpenCV中的光流及视频特征点追踪</a></li>
<li><a href="https://docs.opencv.org/3.4.6/dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323"> calcOpticalFlowPyrLK()</a></li>
<li><a href="https://docs.opencv.org/3.4.6/dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af">calcOpticalFlowFarneback()</a></li>
</ul>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>LK光流法</tag>
      </tags>
  </entry>
  <entry>
    <title>g2o的结构以及BA节点与边的定义</title>
    <url>/posts/5123.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。在<code>g2o/types/sba/types_six_dof_expmap.h</code>中则提供了李代数表达的节点和边。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="g2o的结构"><a href="#g2o的结构" class="headerlink" title="g2o的结构"></a>g2o的结构</h1><blockquote>
<p>参考博客：<a href="https://www.cnblogs.com/gaoxiang12/p/5304272.html">深入理解图优化与g2o：g2o篇</a></p>
</blockquote>
<p>源码：<a href="https://github.com/RainerKuemmerle/g2o">https://github.com/RainerKuemmerle/g2o</a></p>
<p><img src="/images/g2o中关于BA的节点与边/image-20220328125016497.png" alt="image-20220328125016497"></p>
<ul>
<li><strong>cmake_modules：</strong>给cmake用来寻找库的文件。我们用g2o时也会用它里头的东西，例如FindG2O.cmake</li>
<li><strong>doc：</strong>文档。包括g2o自带的说明书（难度挺大的一个说明文档）。</li>
<li><strong>g2o：</strong>最重要的源代码都在这里！</li>
<li><strong>script：</strong>在android等其他系统编译用的脚本</li>
</ul>
<p><a href="https://github.com/RainerKuemmerle/g2o/tree/master/g2o">https://github.com/RainerKuemmerle/g2o/tree/master/g2o</a></p>
<p><img src="/images/g2o中关于BA的节点与边/image-20220328125308391.png" alt="image-20220328125308391"></p>
<ul>
<li><strong>apps：</strong>一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</li>
<li><strong>core：</strong>核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</li>
<li><strong>examples：</strong>一些例程，可以参照着这里的东西来写。不过注释不太多。</li>
<li><strong>solvers：</strong>求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</li>
<li><strong>stuff：</strong>对用户来讲可有可无的一些工具函数。</li>
<li><strong>types：</strong>各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</li>
</ul>
<p><strong>就经验而言，solvers给人的感觉是大同小异，而 types 的选取，则是 g2o 用户主要关心的内容。然后 core 下面的内容，我们要争取弄的比较熟悉，才能确保使用中出现错误可以正确地应对。</strong></p>
<p>g2o最基本的类结构：</p>
<p><img src="/images/g2o中关于BA的节点与边/606958-20160321233900042-681579456.png" alt="img"></p>
<p>　先看上半部分。SparseOptimizer 是我们最终要维护的东东。它是一个Optimizable Graph，从而也是一个Hyper Graph。一个 SparseOptimizer 含有很多个顶点 （都继承自 Base Vertex）和很多个边（继承自 BaseUnaryEdge, BaseBinaryEdge或BaseMultiEdge）。这些 Base Vertex 和 Base Edge 都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 SparseOptimizer.addVertex 和 SparseOptimizer.addEdge 向一个图中添加顶点和边，最后调用 SparseOptimizer.optimize 完成优化。</p>
<p>　　在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 SparseOptimizer 拥有一个 Optimization Algorithm，继承自Gauss-Newton, Levernberg-Marquardt, Powell’s dogleg 三者之一（我们常用的是GN或LM）。同时，这个 Optimization Algorithm 拥有一个Solver，它含有两个部分。一个是 SparseBlockMatrix ，用于计算稀疏的雅可比和海塞； 一个是用于计算迭代过程中最关键的一步</p>
<script type="math/tex; mode=display">
HΔx=−b</script><p>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p>
<p><strong>综上所述，在g2o中选择优化方法一共需要三个步骤：</strong></p>
<ol>
<li>创建一个线性求解器LinearSolver。从 PCG, CSparse, Choldmod中选，实际则来自 g2o/solvers 文件夹中定义的内容。</li>
<li>创建BlockSolver，并用上面定义的线性求解器初始化。</li>
<li>创建总求解器solver，并从GN/LM/DogLeg 中选一个作为迭代策略，再用上述块求解器BlockSolver初始化。</li>
<li>创建图优化的核心：稀疏优化器（SparseOptimizer）。</li>
<li>定义图的顶点和边，并添加到SparseOptimizer中。</li>
<li>设置优化参数，开始执行优化。</li>
</ol>
<h1 id="g2o中定义的顶点和边"><a href="#g2o中定义的顶点和边" class="headerlink" title="g2o中定义的顶点和边"></a>g2o中定义的顶点和边</h1><p>$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。<code>g2o/types/sba/types_six_dof_expmap.h</code>中则提供了李代数表达的节点和边。</p>
<p>因为在不同的应用场景（二维空间，三维空间），有不同的待优化变量（位姿，空间点），还涉及不同的优化类型（李代数位姿、李群位姿），g2o本身内部定义了一些常用的顶点类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">VertexSE2 : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, SE2&gt;  <span class="comment">//2D位姿顶点, (x,y,theta)</span></span><br><span class="line">VertexSE3 : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, Isometry3&gt;  <span class="comment">//6d vector (x,y,z,qx,qy,qz) 请注意，我们省略了四元数的 w 部分</span></span><br><span class="line">VertexPointXY : <span class="keyword">public</span> BaseVertex&lt;<span class="number">2</span>, Vector2&gt;</span><br><span class="line">VertexPointXYZ : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt;</span><br><span class="line">VertexSBAPointXYZ : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt;</span><br><span class="line"></span><br><span class="line">VertexSE3Expmap : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SE3Quat&gt;</span><br><span class="line">VertexCam : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SBACam&gt;</span><br><span class="line">VertexSim3Expmap : <span class="keyword">public</span> BaseVertex&lt;<span class="number">7</span>, Sim3&gt;</span><br></pre></td></tr></table></figure>
<h2 id="顶点Vertex"><a href="#顶点Vertex" class="headerlink" title="顶点Vertex"></a>顶点Vertex</h2><p>g2o中顶点为<strong>待优化变量</strong>，边为<strong>误差项</strong>，综合之前所提到的非线性优化的应用：</p>
<ul>
<li><p>求解$PnP$</p>
<ul>
<li>待优化的变量是：相机的位姿以及所有的特征点的空间位置$P$</li>
<li>误差项：重投影误差 $ξ^{*}=arg \underset{ξ}{min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1} {s_i}Kexp(ξ^{\land})P_i\parallel^2_2$</li>
</ul>
</li>
<li><p>求解$ICP$</p>
<ul>
<li>待优化的变量是：相机的位姿以及所有的特征点的空间位置$P$</li>
<li>误差项：重投影误差$\underset{\xi}{min}=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - exp(\xi^{\land})p^{\prime}_i) \parallel^2_2$</li>
</ul>
</li>
</ul>
<h3 id="VertexSE3Expmap"><a href="#VertexSE3Expmap" class="headerlink" title="VertexSE3Expmap"></a><code>VertexSE3Expmap</code></h3><p>VertexSE3Expmap(李代数位姿)</p>
<p>继承于<code>BaseVertex</code>这个模板类<br>需要设置的模板参数：</p>
<ul>
<li>参数<code>6</code> ：表示它内部存储的优化变量维度。可以看到这是一个 6 维的李代数。，前三维表示旋转，后三维表示平移</li>
<li>参数<code>SE3Quat</code> ：表示优化变量的类型。这里使用了 g2o 定义的相机位姿： SE3Quat。这个类内部使用了四元数加位移向量来存储位姿，但同时也支持李代数上的运算，例如对数映射（log 函数）和李代数上增量（update 函数）等操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SBA_API</span> <span class="title">VertexSE3Expmap</span> :</span> <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SE3Quat&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">        <span class="title">VertexSE3Expmap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 顶点重置函数，设定被优化变量的原始值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate = <span class="built_in">SE3Quat</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector6&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">          <span class="built_in">setEstimate</span>(SE3Quat::<span class="built_in">exp</span>(update) * <span class="built_in">estimate</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>使用时需要设置的参数，可以参考之前使用$PnP$优化第二个相机的位姿的时设置的参数内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">Eigen::Matrix3d R_mat;</span><br><span class="line">R_mat &lt;&lt; </span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 设置Id号</span></span><br><span class="line">pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>( <span class="comment">// 设置待优化位姿R,t</span></span><br><span class="line">    R_mat,</span><br><span class="line">    Eigen::<span class="built_in">Vector3d</span>(t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))、</span><br><span class="line">));</span><br><span class="line">optimizer.<span class="built_in">addVertex</span>(pose); <span class="comment">// 向一个图中添加顶点</span></span><br></pre></td></tr></table></figure>
<h3 id="VertexPointXYZ"><a href="#VertexPointXYZ" class="headerlink" title="VertexPointXYZ"></a><code>VertexPointXYZ</code></h3><p>VertexPointXYZ(空间点位置)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SLAM3D_API</span> <span class="title">VertexPointXYZ</span> :</span> <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="built_in">VertexPointXYZ</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">// 顶点重置函数，设定被优化变量的原始值。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123; _estimate.<span class="built_in">fill</span>(<span class="number">0.</span>); &#125;</span><br><span class="line">	<span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span> </span>&#123;</span><br><span class="line">        <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector3&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">        _estimate += update;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><p>使用时需要设置的参数，可以参考之前使用$PnP$优化所有特征点的空间位置P时，设置的参数内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化所有特征点的空间位置 P</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Point3f p : points_3d)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::VertexPointXYZ *point = <span class="keyword">new</span> g2o::<span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">    point-&gt;<span class="built_in">setId</span>(index++); <span class="comment">// 设置Id号</span></span><br><span class="line">    point-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z));<span class="comment">// 设置待优化空间点3D位置XYZ</span></span><br><span class="line">    point-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>); <span class="comment">// 是否边缘化（以便稀疏化求解）g2o中必须设置 marg 参见第十讲内容</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(point); <span class="comment">// 向一个图中添加顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="边Edge"><a href="#边Edge" class="headerlink" title="边Edge"></a>边Edge</h2><p>BaseUnaryEdge，BaseBinaryEdge，BaseMultiEdge 分别表示一元边，两元边，多元边。一元边可以理解为一条边只连接一个顶点，两元边理解为一条边连接两个顶点，也就是我们常见的边啦，多元边理解为一条边可以连接多个（3个以上）顶点</p>
<p><img src="/images/g2o中关于BA的节点与边/5c7df32d30e9d.png" alt=""></p>
<h3 id="EdgeProjectXYZ2UV"><a href="#EdgeProjectXYZ2UV" class="headerlink" title="EdgeProjectXYZ2UV"></a>EdgeProjectXYZ2UV</h3><p>EdgeProjectXYZ2UV(重投影误差)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SBA_API</span> <span class="title">EdgeProjectXYZ2UV</span> :</span> <span class="keyword">public</span> BaseBinaryEdge&lt;<span class="number">2</span>, Vector2, VertexPointXYZ, VertexSE3Expmap&gt; </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">//1. 默认初始化</span></span><br><span class="line">    <span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//2. 计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>; <span class="comment">// 使用当前顶点的值计算的测量值与真实的测量值之间的误差</span></span><br><span class="line">    <span class="comment">//3. 线性增量函数，也就是雅克比矩阵J的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>; <span class="comment">// 在当前顶点的值下，该误差对优化变量的偏导数，也就是我们说的Jacobian</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//相机参数</span></span><br><span class="line">  CameraParameters* _cam;  <span class="comment">// TODO make protected member?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是个二元边。第1个参数2是说观测值是2维的，也就是图像像素坐标x,y的差值，即$ z − h(ξ, P )$，对应观测值的类型是Vector2D，两个顶点也就是优化变量分别是三维点 VertexPointXYZ，和李群位姿VertexSE3Expmap</p>
<h4 id="computeError"><a href="#computeError" class="headerlink" title="computeError()"></a>computeError()</h4><p>对应的<code>computeError()</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeProjectXYZ2UV::computeError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> VertexSE3Expmap* v1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap*&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> VertexPointXYZ* v2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPointXYZ*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> CameraParameters* cam =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CameraParameters*&gt;(<span class="built_in">parameter</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 误差 = 观测 - 投影</span></span><br><span class="line">  _error = <span class="built_in">measurement</span>() - cam-&gt;<span class="built_in">cam_map</span>(v1-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(v2-&gt;<span class="built_in">estimate</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>_vertices[0]</code>对应的是 VertexPointXYZ 类型的顶点，也就是三维点，<code>_vertices[1]</code>对应的是VertexSE3Expmap 类型的顶点，也就是位姿pose。因此前面 1 对应的就应该是 pose，0对应的应该就是三维点。</p>
<p>cam_map 函数功能是把相机坐标系下三维点（输入）用内参转换为图像坐标（输出），具体代码如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector2 <span class="title">CameraParameters::cam_map</span><span class="params">(<span class="keyword">const</span> Vector3 &amp;trans_xyz)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector2 proj = <span class="built_in">project</span>(trans_xyz);</span><br><span class="line">    Vector2 res;</span><br><span class="line">    res[<span class="number">0</span>] = proj[<span class="number">0</span>] * focal_length + principle_point[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = proj[<span class="number">1</span>] * focal_length + principle_point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.map的功能是把世界坐标系下三维点变换到相机坐标系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector3 <span class="title">map</span><span class="params">(<span class="keyword">const</span> Vector3&amp; xyz)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _r * xyz + <span class="keyword">_t</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>因此下面这个代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(v2-&gt;<span class="built_in">estimate</span>())</span><br></pre></td></tr></table></figure>
<p>就是用V1估计的pose把V2代表的三维点，变换到相机坐标系下。</p>
<h4 id="linearizeOplus"><a href="#linearizeOplus" class="headerlink" title="linearizeOplus()"></a>linearizeOplus()</h4><p>对应的<code>linearizeOplus()</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeProjectXYZ2UV::linearizeOplus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VertexSE3Expmap* vj = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap*&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">  <span class="function">SE3Quat <span class="title">T</span><span class="params">(vj-&gt;estimate())</span></span>;</span><br><span class="line">  VertexPointXYZ* vi = <span class="keyword">static_cast</span>&lt;VertexPointXYZ*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">  Vector3 xyz = vi-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">  Vector3 xyz_trans = T.<span class="built_in">map</span>(xyz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">number_t</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">number_t</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">number_t</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">number_t</span> z_2 = z * z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> CameraParameters* cam =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CameraParameters*&gt;(<span class="built_in">parameter</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  Eigen::Matrix&lt;<span class="keyword">number_t</span>, <span class="number">2</span>, <span class="number">3</span>, Eigen::ColMajor&gt; tmp;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">0</span>) = cam-&gt;focal_length;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">2</span>) = -x / z * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">1</span>) = cam-&gt;focal_length;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">2</span>) = -y / z * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXi = <span class="number">-1.</span> / z * tmp * T.<span class="built_in">rotation</span>().<span class="built_in">toRotationMatrix</span>();</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">0</span>) = x * y / z_2 * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">1</span>) = -(<span class="number">1</span> + (x * x / z_2)) * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">2</span>) = y / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">3</span>) = <span class="number">-1.</span> / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">5</span>) = x / z_2 * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">0</span>) = (<span class="number">1</span> + y * y / z_2) * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">1</span>) = -x * y / z_2 * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">2</span>) = -x / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">-1.</span> / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">5</span>) = y / z_2 * cam-&gt;focal_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量<code>_jacobianOplusXi</code>是<strong>误差到空间点的导数</strong>，<code>_jacobianOplusXj</code>是误<strong>差到相机位姿的导数</strong>，以李代数的左乘扰动表达。稍有差别的是，g2o 的相机里用 $f$ 统一描述 $f_x , f_y$ ，并且李代数定义顺序不同（g2o 是旋转在前，平移在后；我们是平移在前，旋转在后），所以矩阵前三列和后三列与我们的定义是颠倒的。此外都是一致的。</p>
<p>李代数定义的$J$：（）</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial e}{\partial \delta \xi}&=
\frac{\partial e}{\partial P^′}
\frac{\partial P^′}{\partial \delta \xi}\\&=-
\begin{bmatrix}
\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}
&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}
\\
0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&-\frac{f_yX^′}{Z^{′}}
\end{bmatrix}\\&=
J
\end{align*}</script><p>而g2o中的$J$定义的方式如下：（旋转在前，平移在后）</p>
<script type="math/tex; mode=display">
-
\begin{bmatrix}
-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}
&\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}
\\
-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&-\frac{f_yX^′}{Z^{′}}
&0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
\end{bmatrix}</script><p>值得一提的是，我们亦可自己实现相机位姿节点，并使用<code>Sophus::SE3</code>来表达位姿，提供类似的求导过程。然而，既然 g2o 已经提供了这样的类，在没有额外要求的情况下，自己重新实现就没有必要了。</p>
<p>使用时需要设置的参数，以$PnP$中重投影误差为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.设置边(每个 3D 点在第二个相机中的投影)</span></span><br><span class="line">index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Point2f p : points_2d)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> g2o::<span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">    edge-&gt;<span class="built_in">setId</span>(index); <span class="comment">//定义边的编号（决定了在H矩阵中的位置）</span></span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexPointXYZ *&gt;(optimizer.<span class="built_in">vertex</span>(index)));</span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose); <span class="comment">// 定义顶点</span></span><br><span class="line">    edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y)); <span class="comment">// 定义观测值</span></span><br><span class="line">    edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>()) ; <span class="comment">// 定义协方差矩阵的逆</span></span><br><span class="line">    optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义顶点类型"><a href="#自定义顶点类型" class="headerlink" title="自定义顶点类型"></a>自定义顶点类型</h1><p>一般情况下，如果我们需要用的顶点已经提供，则直接使用即可，但是有时候我们需要的顶点类型这里面没有，就得自己定义了。重新定义顶点一般需要考虑重写如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点重置函数，设定被优化变量的原始值。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update)</span></span>;</span><br><span class="line"><span class="comment">// 读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下就可以</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>virtual void setToOriginImpl();</code>顶点重置函数，设定被优化变量的原始值。</p>
<p><code>virtual void oplusImpl(const number_t* update);</code>顶点更新函数。主要用于优化过程中增量△x的计算。我们根据增量方程计算出增量之后，就是通过这个函数对估计值进行调整的。</p>
<p>自定义顶点的格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myVertex</span>:</span> <span class="keyword">public</span> g2::BaseVertex&lt;Dim, Type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">myVertex</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    _estimate = <span class="built_in">Type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* update)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    _estimate += <span class="comment">/*update*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义边的类型"><a href="#自定义边的类型" class="headerlink" title="自定义边的类型"></a>自定义边的类型</h1><p>在使用BA求解ICP的实践中,使用的是3D-3D的边,由于g2o本身没有提供3D-3D的边,因此需自定义一个3D-3D的边:</p>
<p>自定义边格式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;n,Dim, Type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">myEdge</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以构建3D-3D的边为例:</p>
<p>主要考虑两个函数的实现</p>
<ul>
<li><p><code>virtual void computeError()</code></p>
<p> 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，这个函数则是使用该边连接的节点和观测值来计算误差</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// measurement is p, point is p&#x27;</span></span><br><span class="line">    _error = _measurement - pose-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(_point); <span class="comment">//.map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里误差的定义方式,是考虑相邻两帧图像之间的重投影误差,比如我们通过特征点匹配,确定了两个匹配好的特征点,$p_i$和$p_i^{\prime}$他们的关系为:</p>
<script type="math/tex; mode=display">
p_i = Rp_i^{\prime}+t</script><p>由于一些噪声,我们发现依据所求得的相机位姿$R,t$并没有达到理想的准确度,即$Rp_i^{\prime}+t \neq p_i$,他们的差值我们就定义为误差项:</p>
<script type="math/tex; mode=display">
e_i = p_i - (Rp_i^{\prime}+t)</script><p>因此,我们把估计的$p_i^{\prime}$的世界坐标系下三维点转换成相机坐标系,并与$p_i$做差</p>
<ul>
<li><code>virtual void linearizeOplus()</code></li>
</ul>
<p>计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导,但是就优化效率而言,前者计算速度是更快的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">        g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">g2o::SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;          <span class="comment">// 顶点的当前估计</span></span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point); <span class="comment">// .map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_jacobianOplusXi是误差关于世界坐标系下坐标点的偏导</span></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前代码待理解……</p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>g2o</tag>
      </tags>
  </entry>
  <entry>
    <title>ch7_求解ICP并使用BA优化</title>
    <url>/posts/12311.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>$ICP:$迭代最近点$（Iterative Closest Point）$求解。读者应该注意到，$3D-3D $位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组 $3D $点之间的变换时，和相机并没有关系。因此，在激光 $SLAM $中也会碰到 $ICP$，不过由于激光数据特征不够丰富，我们无从知道两个点集之间的匹配关系，只能认为距离最近的两个点为同一个，所以这个方法称为迭代最近点。而在视觉中，特征点为我们提供了较好的匹配关系，所以整个问题就变得更简单了。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>和 $PnP$ 类似，$ICP $的求解也分为两种方式：利用线性代数的求解（主要是$ SVD$），以及利用非线性优化方式的求解（类似于 $Bundle Adjustment$）。</p>
<h1 id="求解ICP"><a href="#求解ICP" class="headerlink" title="求解ICP"></a>求解ICP</h1><p>ICP的原理主要是通过两组匹配好的点云，进行运动估计，求得$R,t$的过程。我们知道对于两组匹配好的点云理想情况下应该可以达到完全重合，但是实际上则会有偏差，而重合的程度就是一个评价标椎，我们通过求解ICP，可以得到相对优的$R,t$，也就是进行最优的运动估计，这就是ICP的原理以及作用。</p>
<p><img src="/images/求解ICP并使用BA优化/image-20220428151935615.png" alt="image-20220428151935615"></p>
<p>重合程度就是一个$loss\ function$，</p>
<p><img src="/images/求解ICP并使用BA优化/image-20220428161453025.png" alt="image-20220428161453025" style="zoom:67%;" /></p>
<h2 id="SVD方法"><a href="#SVD方法" class="headerlink" title="SVD方法"></a>SVD方法</h2><h3 id="构建最小二乘"><a href="#构建最小二乘" class="headerlink" title="构建最小二乘"></a>构建最小二乘</h3><p>假设我们有一组配对好的 3D 点（比如我们对两个 RGB-D 图像进行了匹配）：</p>
<script type="math/tex; mode=display">
P = \{p_1 , . . . , p_n \} \\ P^′= \{p^′_1 , . . . , p^′_n \}</script><p>现在，想要找一个欧氏变换 $R, t，$使得：</p>
<script type="math/tex; mode=display">
∀i, p_i = Rp^′_i + t.</script><p>定义第 $i$对点的误差项：</p>
<script type="math/tex; mode=display">
e_i=p_i - (Rp^′_i + t).</script><p>构建最小二乘问题:</p>
<script type="math/tex; mode=display">
\underset{R,t}{min}J=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^′_i + t)) \parallel^2_2</script><h3 id="求解最小二乘"><a href="#求解最小二乘" class="headerlink" title="求解最小二乘"></a>求解最小二乘</h3><p>首先，定义两组点的质心(注意质心是没有下标)：</p>
<script type="math/tex; mode=display">
p=\frac{1}{n}\sum^n_{i=1}(p_i)，p^{\prime}=\frac{1}{n}\sum^n_{i=1}(p^{\prime}_i)</script><p>在误差函数中，我们作如下的处理：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^{\prime}_i + t)) \parallel^2
&=\frac{1}{2}\sum^n_{i=1}\parallel p_i - Rp^{\prime}_i - t-p+Rp^{\prime}+p-Rp^{\prime} \parallel^2
\\&= \frac{1}{2}\sum^n_{i=1}\parallel (p_i -p- R(p^{\prime}_i-p^{\prime}) )+(p- Rp^{\prime}+t) \parallel^2
\\&= \frac{1}{2}\sum^n_{i=1}(\parallel p_i -p- R(p^{\prime}_i-p^{\prime}) \parallel^2+
\parallel p- Rp^{\prime}+t\parallel^2
\\&+2(p_i -p-R(p^{\prime}_i-p^{\prime})^T(p-Rp^{\prime}-t))
\end{align*}</script><p>这里第一步加减质心的作用就是为了第二步，第二步将两组点的每一个点云分别减去各自的质心，作用将$R,t$解耦。之后就可以得到第三步的式子。</p>
<p>第三步中：</p>
<script type="math/tex; mode=display">
\begin{align*}
p_i-p-R(p^{\prime}_i-p^{\prime})&=(Rp^{\prime}_i+t)-(Rp^{\prime}+t)-R(p^{\prime}_i-p^{\prime})\\
&=Rp^{\prime}_i+t-Rp^{\prime}-t-Rp^{\prime}_i+Rp^{\prime}\\
&=0
\end{align*}</script><p>所以：</p>
<script type="math/tex; mode=display">
\begin{align*}
\underset{R,t}{min}J&=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^′_i + t)) \parallel^2\\
&=\frac{1}{2}\sum^n_{i=1}\parallel p_i -p- R(p^{\prime}_i-p^{\prime}) \parallel^2+
\parallel p- Rp^{\prime}+t\parallel^2
\end{align*}</script><p>仔细观察左右两项，我们发现左边只和旋转矩阵 R 相关，而右边既有 R 也有 t，但只和质心相，这就完成了解耦的过程。只要我们获得了 R，令第二项为零就能得到 t。于是，ICP 可以分为以下三个步骤求解：</p>
<p>1.计算两组点的质心位置 $p$, $p^{\prime}$，然后计算每个点的去质心坐标：</p>
<script type="math/tex; mode=display">
q_i = p_i − p,\\
q_i^{\prime} = p_i^{\prime} − p^{\prime}  .</script><p>2.根据以下优化问题计算旋转矩阵：</p>
<script type="math/tex; mode=display">
R^{*}=arg\underset{R}{min}\frac{1}{2}\sum^n_{i=1}\parallel q_i - Rq_i^{\prime} \parallel^2</script><p>3.根据第二步的 $R$，计算 $t$：</p>
<script type="math/tex; mode=display">
t^∗ = p − Rp^{\prime} .</script><p>计算$R$：</p>
<script type="math/tex; mode=display">
\frac{1}{2}\sum^n_{i=1}\parallel q_i - Rq_i^{\prime} \parallel^2
=\frac{1}{2}\sum^n_{i=1}q_i^{T}q_i+q_i^{\prime T}R^TRq_i^{\prime}-2q^T_iRq_i^{\prime}</script><p>第一项和$ R$ 无关，第二项由于 $R^T R = I$，亦与 $R $无关。因此，实际上优化目标函数变为：</p>
<script type="math/tex; mode=display">
\sum^n_{i=1}-q_i^{T}Rq_i^{\prime}\overset{(1)}{=}
\sum^n_{i=1}-tr(q_i^{T}Rq_i^{\prime})\overset{(2)}{=}
\sum^n_{i=1}-tr(Rq_i^{\prime}q_i^{T})=
-tr(R\sum^n_{i=1}q_i^{\prime}q_i^{T})\overset{(3)}{=}-tr(RW)</script><blockquote>
<p><strong>等式(1)：</strong>由于${q_i^{T} }_{(1\times 3)} R_{(3\times 3)} {q_i^{\prime} }_{(3\times 1)}$最终求得的是一个数，而对于一个常数来说，它的迹仍然是它本身。</p>
<p><strong>等式(2)：</strong></p>
<script type="math/tex; mode=display">
tr(AB)=\sum^m_{i=1}\sum^n_{j=1}a_{ij}b_{ji}=\sum^m_{i=1}\sum^n_{j=1}b_{ji}a_{ij}=tr(BA)</script><p><strong>等式(3)：</strong></p>
<script type="math/tex; mode=display">
W=\sum^n_{i=1}q_i^{\prime}q_i^{T}</script></blockquote>
<p>至此，我们知道优化函数就是$-tr(RW)$， <span style="color:red;">所以说我们需要求得最合适的$R$，使得$tr(RW)$达到最大值。</span></p>
<p>这里我们需要引入一个<strong>定理：</strong></p>
<p><span style="color:green;">定理：若有正定矩阵$AA^T$，则对于任意正交矩阵$B$，有$\tr(AA^T)\geq \tr(BAA^T)$</span></p>
<p>我们已知$R$是正交矩阵，$W $是一个$ 3 × 3 $的矩阵，对$ W$ 进行 $SVD$ 分解，得：</p>
<script type="math/tex; mode=display">
W = UΣV^T</script><p>$Σ $为奇异值组成的对角矩阵，对角线元素从大到小排列，而 $U $和$ V$ 为正交矩阵。当 $W$ 满秩时，令$R$ 为：</p>
<script type="math/tex; mode=display">
R = VU^T</script><p>这样：</p>
<script type="math/tex; mode=display">
RW=VU^TUΣV^T=VΣV^T=VΣ^{\frac{1}{2} }Σ^{\frac{1}{2} }V^T=VΣ^{\frac{1}{2} }(VΣ^{\frac{1}{2} })^T</script><p>此时，满足定理，使得$RW$达到了最大值。</p>
<p>解得 $R$后,按照$t^∗ = p − Rp^{\prime} .$求解 $t$ 即可。</p>
<h2 id="非线性优化方法"><a href="#非线性优化方法" class="headerlink" title="非线性优化方法"></a>非线性优化方法</h2><p>求解$ ICP$ 的另一种方式是使用非线性优化，以迭代的方式去找最优值。该方法和我们前面讲述的 $PnP $非常相似。以李代数表达位姿时，目标函数可以写成：</p>
<script type="math/tex; mode=display">
\underset{\xi}{min}=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - exp(\xi^{\land})p^{\prime}_i) \parallel^2_2</script><p>单个误差项关于位姿导数已经在前面推导过了，使用李代数扰动模型即可:</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial \delta \xi}=-(exp(\xi^{\land}p^{\prime}_i))^{⊙}</script><p>用非线性优化来计算$ ICP$不仅考虑相机的位姿，同时会优化 $3D$点的空间位置。对我们来说，RGB-D 相机每次可以观测到路标点的三维位置，从而产生一个$ 3D$ 观测数据。不过，由于$ g2o/sba$ 中没有提供 $3D$ 到 $3D$ 的边，而我们又想使用$ g2o/sba $中李代数实现的位姿节点，所以最好的方式是自定义一种这样的边，并向$ g2o$ 提供解析求导方式。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="1-特征点匹配"><a href="#1-特征点匹配" class="headerlink" title="1. 特征点匹配"></a>1. 特征点匹配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.特征点匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line"></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; match;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, match);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; max_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_dist: &quot;</span> &lt;&lt; max_dist &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_dist: &quot;</span> &lt;&lt; min_dist &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-建立3D点"><a href="#2-建立3D点" class="headerlink" title="2.建立3D点"></a>2.建立3D点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_3d_points</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;depth_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;depth_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;K,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;DMatch&gt; matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3f&gt; &amp;pts2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//提取特征点的深度值：</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取得匹配点的深度，queryIdx(表示匹配点的索引)查询描述子索引，pt关键点的坐标 (y行地址)[x列地址]</span></span><br><span class="line">        ushort d1 = depth_1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)];</span><br><span class="line">        ushort d2 = depth_2.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_2[m.trainIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_2[m.trainIdx].pt.x)];</span><br><span class="line">        <span class="keyword">if</span> (d1 == <span class="number">0</span> || d2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K);<span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">        Point2d p2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);<span class="comment">// p2:(X/Z,Y/Z,1)</span></span><br><span class="line">        <span class="keyword">float</span> dd1 = <span class="built_in"><span class="keyword">float</span></span>(d1) / <span class="number">5000.0</span>;</span><br><span class="line">        <span class="keyword">float</span> dd2 = <span class="built_in"><span class="keyword">float</span></span>(d2) / <span class="number">5000.0</span>;</span><br><span class="line">        <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">        pts1.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd1, p1.y * dd1, dd1));<span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">        pts2.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p2.x * dd2, p2.y * dd2, dd2));<span class="comment">// (X,Y,Z)第二帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3d-3d pairs: &quot;</span> &lt;&lt; pts1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-SVD求解ICP"><a href="#3-SVD求解ICP" class="headerlink" title="3.SVD求解ICP"></a>3.SVD求解ICP</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.SVD求解ICP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_3d3d</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3f p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = pts1.<span class="built_in">size</span>(); <span class="comment">// N = 72;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 += pts1[i]; <span class="comment">// p1 为pts1坐标各维之和</span></span><br><span class="line">        p2 += pts2[i]; <span class="comment">// p2 为pts2坐标各维之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">Point3f</span>(<span class="built_in">Vec3f</span>(p1) / N); <span class="comment">// 取平均得到质心p1</span></span><br><span class="line">    p2 = <span class="built_in">Point3f</span>(<span class="built_in">Vec3f</span>(p2) / N); <span class="comment">// 取平均得到质心p2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Point3f&gt; <span class="title">q1</span><span class="params">(N)</span>, <span class="title">q2</span><span class="params">(N)</span></span>; <span class="comment">// remove the center</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1[i] = pts1[i] - p1; <span class="comment">// 计算每个点的去质心坐标q1</span></span><br><span class="line">        q2[i] = pts2[i] - p2; <span class="comment">// 计算每个点的去质心坐标q2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// compute q1*q2^T</span></span><br><span class="line">    Eigen::Matrix3d W = Eigen::Matrix3d::<span class="built_in">Zero</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// w = sum(q1*q2^T)</span></span><br><span class="line">        W += Eigen::<span class="built_in">Vector3d</span>(q1[i].x, q1[i].y, q1[i].z) * Eigen::<span class="built_in">Vector3d</span>(q2[i].x, q2[i].y, q2[i].z).<span class="built_in">transpose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;W=&quot;</span> &lt;&lt; W &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 对W进行SVD分解</span></span><br><span class="line">    <span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; <span class="title">svd</span><span class="params">(W, Eigen::ComputeFullU | Eigen::ComputeFullV)</span></span>;</span><br><span class="line">    Eigen::Matrix3d U = svd.<span class="built_in">matrixU</span>(); <span class="comment">// 正交矩阵U</span></span><br><span class="line">    Eigen::Matrix3d V = svd.<span class="built_in">matrixV</span>(); <span class="comment">// 正交矩阵V</span></span><br><span class="line">    <span class="keyword">if</span> (U.<span class="built_in">determinant</span>() * V.<span class="built_in">determinant</span>() &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">U</span>(x, <span class="number">2</span>) *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U=&quot;</span> &lt;&lt; U &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V=&quot;</span> &lt;&lt; V &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3d R_ = U * (V.<span class="built_in">transpose</span>());</span><br><span class="line">    Eigen::Vector3d t_ = Eigen::<span class="built_in">Vector3d</span>(p1.x, p1.y, p1.z) - R_ * Eigen::<span class="built_in">Vector3d</span>(p2.x, p2.y, p2.z);</span><br><span class="line"></span><br><span class="line">    R = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    t = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; <span class="built_in">t_</span> ( <span class="number">0</span>,<span class="number">0</span> ), <span class="built_in">t_</span> ( <span class="number">1</span>,<span class="number">0</span> ), <span class="built_in">t_</span> ( <span class="number">2</span>,<span class="number">0</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-BA优化"><a href="#4-BA优化" class="headerlink" title="4.BA优化"></a>4.BA优化</h2><h3 id="自定义3D-3D的边"><a href="#自定义3D-3D的边" class="headerlink" title="自定义3D-3D的边"></a>自定义3D-3D的边</h3><p>由于 g2o/sba 中没有提供 3D 到 3D 的边，而我们又想使用 g2o/sba 中李代数实现的位姿节点，所以最好的方式是自定义一种这样的边，并向 g2o 提供解析求导方式。</p>
<p> $J$矩阵:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
0     &-z &y     &-1 &0     &0 \\
z     &0     &-x &0     &-1 &0 \\
-y     &x  &0     &0     &0     &-1
\end{bmatrix}</script><p>自定义 3D 到 3D 的边：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjectXYZRGBDPoseOnly</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">3</span>, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(<span class="keyword">const</span> Eigen::Vector3d &amp;point) : _point(point) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// measurement is p, point is p&#x27;</span></span><br><span class="line">        _error = _measurement - pose-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(_point); <span class="comment">// 重投影误差</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">        g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">g2o::SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;</span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point); <span class="comment">// .map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_jacobianOplusXi是误差关于世界坐标系下坐标点的偏导</span></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="BA优化"><a href="#BA优化" class="headerlink" title="BA优化"></a>BA优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.BA优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为6(即为se3李代数的维数，前三维为平移，后三维为旋转)</span></span><br><span class="line">    <span class="comment">// 误差值维度为3(每个3D点在第二个相机中的投影)</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器:使用eigen中sparse Cholesky 求解</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverEigen&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 梯度下降方法，GN(高斯牛顿)418133364</span></span><br><span class="line">    g2o::OptimizationAlgorithmGaussNewton *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用GN(高斯牛顿)方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.构建顶点</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>(); <span class="comment">// 相机位姿</span></span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(Eigen::Matrix3d::<span class="built_in">Identity</span>(), Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.构建边</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    vector&lt;EdgeProjectXYZRGBDPoseOnly*&gt; edges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeProjectXYZRGBDPoseOnly *edge = <span class="keyword">new</span> <span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(Eigen::<span class="built_in">Vector3d</span>(pts2[i].x,pts2[i].y,pts2[i].z));</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;(pose));</span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector3d</span>(pts1[i].x,pts1[i].y,pts1[i].z));</span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix3d::<span class="built_in">Identity</span>()*<span class="number">1e4</span>);</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">        index++;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 开始优化</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2-t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;优化用时: &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;优化后的T: \n: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Eigen::<span class="built_in">Isometry3d</span>(pose-&gt;<span class="built_in">estimate</span>()).<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;提供彩色图与深度图：img1 img2 depth1 depth2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.特征点匹配</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;组特征匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.建立3D点</span></span><br><span class="line">    Mat depth_1 = <span class="built_in">imread</span>(argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    Mat depth_2 = <span class="built_in">imread</span>(argv[<span class="number">4</span>], CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point3f&gt; pts1, pts2;</span><br><span class="line">    <span class="built_in">build_3d_points</span>(depth_1, depth_2, K, keypoints_1, keypoints_2, matches, pts1, pts2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.SVD求解ICP</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_3d3d</span>(pts1, pts2, R, t);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共有&quot;</span> &lt;&lt; pts1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;对3D-3D&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ICP分解结果为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R: \n&quot;</span></span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: \n&quot;</span></span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 由于前面的推导是按照pi= Rp′i+t进行的，这里的R,t, </span></span><br><span class="line">    <span class="comment">// 是第二帧到第一帧的变换，与前面PnP部分是相反的。</span></span><br><span class="line">    <span class="comment">// 所以在输出结果中，我们同时打印了逆变换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R_inv: \n &quot;</span> &lt;&lt; R.<span class="built_in">t</span>() &lt;&lt; endl; <span class="comment">// 求逆</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t_inv: \n &quot;</span> &lt;&lt; -R.<span class="built_in">t</span>() * t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.BA优化</span></span><br><span class="line">    <span class="built_in">bundleAdjustment</span>(pts1, pts2, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLsits.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_3d3d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用g2o</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( CSparse REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CSPARSE_INCLUDE_DIR&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_3d3d pose_estimation_3d3d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_3d3d </span><br><span class="line">   <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">   g2o_core g2o_stuff g2o_types_sba g2o_csparse_extension </span><br><span class="line">   <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max_dist: 94</span><br><span class="line">min_dist: 4</span><br><span class="line">一共找到79组特征匹配</span><br><span class="line">3d-3d pairs: 72</span><br><span class="line">W=  10.871 -1.01948  2.54771</span><br><span class="line">-2.16033  3.85307 -5.77742</span><br><span class="line"> 3.94738 -5.79979  9.62203</span><br><span class="line">U=  0.558087  -0.829399 -0.0252034</span><br><span class="line"> -0.428009  -0.313755   0.847565</span><br><span class="line">  0.710878   0.462228   0.530093</span><br><span class="line">V=  0.617887  -0.784771 -0.0484806</span><br><span class="line"> -0.399894  -0.366747   0.839989</span><br><span class="line">  0.676979   0.499631   0.540434</span><br><span class="line">一共有72对3D-3DICP分解结果为：</span><br><span class="line">R: </span><br><span class="line">[0.9969452349468715, 0.05983347698056557, -0.05020113095482046;</span><br><span class="line"> -0.05932607657705309, 0.9981719679735133, 0.01153858699565957;</span><br><span class="line"> 0.05079975545906246, -0.008525103184062521, 0.9986724725659557]</span><br><span class="line">t: </span><br><span class="line">[0.144159841091821;</span><br><span class="line"> -0.06667849443812729;</span><br><span class="line"> -0.03009747273569774]</span><br><span class="line">R_inv: </span><br><span class="line"> [0.9969452349468715, -0.05932607657705309, 0.05079975545906246;</span><br><span class="line"> 0.05983347698056557, 0.9981719679735133, -0.008525103184062521;</span><br><span class="line"> -0.05020113095482046, 0.01153858699565957, 0.9986724725659557]</span><br><span class="line">t_inv: </span><br><span class="line"> [-0.1461462958593589;</span><br><span class="line"> 0.05767443542067568;</span><br><span class="line"> 0.03806388018483625]</span><br><span class="line">iteration= 0     chi2= 18161.146626      time= 4.6935e-05        cumTime= 4.6935e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 1     chi2= 18155.141919      time= 9.614e-06         cumTime= 5.6549e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 2     chi2= 18155.140765      time= 9.938e-06         cumTime= 6.6487e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 3     chi2= 18155.140764      time= 9.516e-06         cumTime= 7.6003e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 4     chi2= 18155.140764      time= 8.688e-06         cumTime= 8.4691e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 5     chi2= 18155.140764      time= 8.358e-06         cumTime= 9.3049e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 6     chi2= 18155.140764      time= 1.0723e-05        cumTime= 0.000103772    edges= 72       schur= 0</span><br><span class="line">iteration= 7     chi2= 18155.140764      time= 1.1911e-05        cumTime= 0.000115683    edges= 72       schur= 0</span><br><span class="line">iteration= 8     chi2= 18155.140764      time= 1.3427e-05        cumTime= 0.00012911     edges= 72       schur= 0</span><br><span class="line">iteration= 9     chi2= 18155.140764      time= 1.207e-05         cumTime= 0.00014118     edges= 72       schur= 0</span><br><span class="line">优化用时: 0.000604832ms</span><br><span class="line">优化后的T: </span><br><span class="line">: </span><br><span class="line">  0.996945  0.0598335 -0.0502011    0.14416</span><br><span class="line">-0.0593261   0.998172  0.0115386 -0.0666785</span><br><span class="line"> 0.0507998 -0.0085251   0.998672 -0.0300979</span><br><span class="line">         0          0          0          1</span><br></pre></td></tr></table></figure>
<p>不使用解析求导</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.......</span><br><span class="line">优化用时: 0.00123263ms</span><br><span class="line">优化后的T: </span><br><span class="line">: </span><br><span class="line">   0.996945   0.0598335  -0.0502011     0.14416</span><br><span class="line"> -0.0593261    0.998172   0.0115386  -0.0666785</span><br><span class="line">  0.0507998 -0.00852509    0.998672  -0.0300979</span><br><span class="line">          0           0           0           1</span><br></pre></td></tr></table></figure>
<p><strong>不难发现,使用解析求导(即给出函数<code>virtual void linearizeOplus()</code>),比使用数值求导(即不提供该函数)要快的多.</strong></p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>ICP</tag>
        <tag>BA与图优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ch7_求解PnP并使用BA优化</title>
    <url>/posts/20908.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>$PnP（Perspective-n-Point）$是求解 $3D $到$ 2D $点对运动的方法。它描述了当我们知道$n $个$ 3D$ 空间点以及它们的投影位置时，如何估计相机所在的位姿。如果两张图像中，其中一张特征点的 $3D$ 位置已知，那么最少只需三个点对（需要至少一个额外点验证结果）就可以估计相机运动。特征点的$ 3D $位置可以由三角化，或者由 $RGB-D$ 相机的深度图确定。因此，在双目或$ RGB-D$ 的视觉里程计中，我们可以直接使用$ PnP$ 估计相机运动。而在单目视觉里程计中，必须先进行初始化，然后才能使用 $PnP$。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="PnP中的BA问题"><a href="#PnP中的BA问题" class="headerlink" title="PnP中的BA问题"></a>PnP中的BA问题</h1><p>我们可以把 $PnP $问题构建成一个定义于李代数上的非线性最小二乘问题。前面说的线性方法，往往是<strong>先求相</strong><br><strong>机位姿，再求空间点位置</strong>，而非线性优化则是把它们都看成优化变量，放在一起优化。这是一种非常通用的求解方式，我们可以用它对$ PnP $或$ ICP $给出的结果进行优化。</p>
<h2 id="1-重投影误差"><a href="#1-重投影误差" class="headerlink" title="1.重投影误差"></a>1.重投影误差</h2><p>在 $PnP $中，这个$ Bundle Adjustment $问题，是一个最小化重投影误差（Reprojection error）的问题。</p>
<p><img src="/images/求解PnP并使用BA优化/image-20220329214556296.png" alt="image-20220329214556296" style="zoom: 33%;" /></p>
<p>该问题的误差项，是将像素坐标（观测到的投影位置）与 3D 点按照当前估计的位姿进行投影得到的位置相比较得到的误差，所以称之为重投影误差。如图，我们通过特征匹配，知道了 $p_1$和 $p_2$是同一个空间点$P$ 的投影，但是我们不知道相机的位姿。在初始值中，$P $的投影$\hat{p_2}$与实际的$ p_2$之间有一定的距离。于是我们调整相机的位姿，使得这个距离变小。不过，由于这个调整需要考虑很多个点，所以最后每个点的误差通常都不会精确为零。</p>
<p>考虑 $n$ 个三维空间点 $P $和它们的投影$ p$，我们希望计算相机的位姿 $R, t，$它的李代数表示为 $ξ$。假设某空间点坐标为$ P_i = [X_i , Y_i , Z_i ]^{T} $，其投影的像素坐标为 $u_i = [u_i , v_i ]^{T} $。<br>像素位置与空间点位置的关系如下：</p>
<script type="math/tex; mode=display">
s_i
\left[
\begin{matrix}
u_i\\v_i\\1
\end{matrix}
\right]=
K\exp(ξ^{\land})
\left[
\begin{matrix}
X_i\\Y_i\\Z_i\\1
\end{matrix}
\right]</script><p>写成矩阵形式：</p>
<script type="math/tex; mode=display">
s_iu_i=K\exp(ξ^{\land})P_i</script><p>由于相机位姿未知以及观测点的噪声，该等式存在一个误差，把误差求和，构建最小二乘问题，然后寻找最好的相机位姿，使它最小化:</p>
<script type="math/tex; mode=display">
ξ^{*}=\arg \underset{ξ}{\min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1} {s_i}K\exp(ξ^{\land})P_i\parallel^2_2</script><p>求每个误差项关于优化变量的导数，也就是线性化：</p>
<script type="math/tex; mode=display">
e(x+\Delta x)\approx e(x)+J\Delta x</script><p>$e $为像素坐标误差（2 维），$x$ 为相机位姿（6 维）时，$J$ 将是一个$ 2\times 6$ 的矩阵。</p>
<h2 id="2-优化位姿"><a href="#2-优化位姿" class="headerlink" title="2.优化位姿"></a>2.优化位姿</h2><p>记变换到相机坐标系下的空间点坐标为 $P^′$:</p>
<script type="math/tex; mode=display">
s
\left[
\begin{matrix}
u\\v\\1
\end{matrix}
\right]=
\left[
\begin{matrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{matrix}
\right]
\left[
\begin{matrix}
X^{′}\\Y^{′}\\Z^{′}
\end{matrix}
\right]</script><p>利用第 3 行消去 $s$（实际上就是$ P^{′ }$的距离），得：</p>
<script type="math/tex; mode=display">
u=f_x\frac{X^′}{Z^′}+c_x\\
v=f_y\frac{Y^′}{Z^′}+c_y</script><p>这里与之前求得的相机模型是一致的，可以把$u,v$与实际的测量值比较，求差。</p>
<p>对 $ξ^{\land} $左乘扰动量$ δξ$，然后考虑 $e$ 的变化关于扰动量的导数。利用链式法则:</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial \delta \xi}=
\underset{\delta \xi \rightarrow0}{lim}
\frac{e(\delta \xi⊕\xi)}{\delta \xi}=
\frac{\partial e}{\partial P^′}
\frac{\partial P^′}{\partial \delta \xi}</script><p>其中：$\frac{\partial e}{\partial P^′}$</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial P^′}=-
\begin{bmatrix}
\frac{\partial u}{\partial X^′}&
\frac{\partial u}{\partial Y^′}&
\frac{\partial u}{\partial Z^′}            \\ 
\frac{\partial v}{\partial X^′}&
\frac{\partial v}{\partial Y^′}&
\frac{\partial v}{\partial Z^′}
\end{bmatrix}=-
\begin{bmatrix}
\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\
0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
\end{bmatrix}</script><p>$\frac{\partial P^′}{\partial \delta \xi}$为变换后的点关于李代数的导数：</p>
<p>空间点$P$经过坐标变换的到$P^{\prime}=TP$，现在求变换后的空间点对于扰动$\delta\xi$的导数，就是相当于给$T$左乘一个扰动$\Delta T=\exp(\delta\xi)$，这里设扰动项的李代数为$\delta\xi=[\delta\rho,\delta\phi]^T$</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial P^′}{\partial \delta \xi}&=
\frac{\partial(TP)}{\partial \delta \xi} \\ &=
\underset{\delta \xi \rightarrow0}{lim}
\frac{exp(\delta \xi ^{\land})exp(\xi ^{\land})p-exp(\xi ^{\land})p}{\delta \xi}\\&\approx
\underset{\delta \xi \rightarrow0}{lim}
\frac{(I+\delta \xi ^{\land})exp(\xi ^{\land})p-exp(\xi ^{\land})p}{\delta \xi}\\&=
\underset{\delta \xi \rightarrow0}{lim}
\frac{\delta \xi ^{\land}exp(\xi ^{\land})p}{\delta \xi}\\&=
\underset{\delta \xi \rightarrow0}{lim}
\frac{\begin{bmatrix}
\delta \phi^{\land}&\delta \rho \\
0^T&0
\end{bmatrix}
\begin{bmatrix}
Rp+t \\
1
\end{bmatrix}
}{\delta \xi}\\&=
\underset{\delta \xi \rightarrow0}{lim}
\frac{\begin{bmatrix}
\delta \phi^{\land}(Rp+t)+\delta \rho  \\
0
\end{bmatrix}
}
{\delta \xi}\\&=
\begin{bmatrix}
I &-(RP+t)^{\land}\\
0^{T}&0^{T}
\end{bmatrix}\\&=
\begin{bmatrix}
I &-P^{′\land}\\
0^{T}&0^{T}
\end{bmatrix}\\&=
(TP)^⊙
\end{align*}</script><p>两项相乘：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial e}{\partial \delta \xi}&=
\frac{\partial e}{\partial P^′}
\frac{\partial P^′}{\partial \delta \xi}\\&=-
\begin{bmatrix}
\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}
&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}
\\
0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}
\end{bmatrix}\\&=
J
\end{align*}</script><p>这个雅可比矩阵描述了重投影误差关于相机位姿李代数的一阶变化关系，</p>
<h2 id="3-优化空间点位置"><a href="#3-优化空间点位置" class="headerlink" title="3.优化空间点位置"></a>3.优化空间点位置</h2><p>讨论 $e$关于空间点 $P $的导数</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial P}=
\frac{\partial e}{\partial P^′}
\frac{\partial P^′}{\partial P}</script><p>由于：</p>
<script type="math/tex; mode=display">
\begin{align*}
P^′&=exp(\xi ^{\land})P=RP+t\\
\frac{\partial P^′}{\partial P}&=R
\end{align*}</script><p>所以：</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial P}=-
\begin{bmatrix}
\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\
0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}
\end{bmatrix}R</script><p><strong>我们推导了观测相机方程关于相机位姿与特征点的两个导数矩阵。它们十分重要，能够在优化过程中提供重要的梯度方向，指导优化的迭代。</strong></p>
<h1 id="求解PnP"><a href="#求解PnP" class="headerlink" title="求解PnP"></a>求解PnP</h1><p>$PnP $问题有很多种求解方法，例如用三对点估计位姿的 $P3P$，直接线性变换$(DLT)$，$EPnP(Efficient PnP)$，$UPnP$等等。此外，还能用非线性优化的方式，构建最小二乘问题并迭代求解，也就是万金油式的$ Bundle Adjustment$。</p>
<p>其中$P3P$利用了三角形相似性质，求解投影点 $a, b, c$ 在相机坐标系下的 3D 坐标，最后把问题转换成一个 3D 到 3D 的位姿估计问题($ICP$问题)。但是，$P3P$ 只利用三个点的信息。当给定的配对点多于 3 组时，难以利用更多的信息；而且，如果 3D 点或 2D 点受噪声影响，或者存在误匹配，则算法失效。</p>
<p>在 $SLAM$ 当中，通常的做法是先使用 $P3P/EPnP$ 等方法估计相机位姿，然后构建最小二乘优化问题对估计值进行调整$（Bundle Adjustment）$。</p>
<h2 id="1-特征点匹配"><a href="#1-特征点匹配" class="headerlink" title="1.特征点匹配"></a>1.特征点匹配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 特征匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; match;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, match);</span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span>(dist &lt; min_dist) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span>(dist &gt; max_dist) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_dist: &quot;</span> &lt;&lt; max_dist &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_dist: &quot;</span> &lt;&lt; min_dist &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span>*min_dist,<span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-建立3D点"><a href="#2-建立3D点" class="headerlink" title="2.建立3D点"></a>2.建立3D点</h2><p><code>queryIdx</code> 代表的特征点序列是 <code>keypoints1</code> 中的，<code>trainIdx</code>代表的特征点序列是<code>keypoints2</code>中的，此时这两张图中的特征点相互匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;queryIdx: &quot;</span> &lt;&lt; keypoints_1[m.queryIdx].pt &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;trainIdx: &quot;</span> &lt;&lt; keypoints_2[m.trainIdx].pt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两行代码返回的类型都是<code>Point2d</code>，对同一个匹配点对，总有第一帧图像的像素点坐标<code>keypoints_1[m.queryIdx].pt</code>与第二帧图像的像素点坐标<code>keypoints_2[m.trainIdx].pt</code>相对应。因此，如果匹配点对为79,则存在79对相互对应的<code>keypoints_1[m.queryIdx].pt</code>与<code>keypoints_2[m.trainIdx].pt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------第77组匹配点----------</span><br><span class="line">queryIdx: [207.825, 286.655]</span><br><span class="line">trainIdx: [186.325, 290.238]</span><br><span class="line">--------第78组匹配点----------</span><br><span class="line">queryIdx: [383.4, 326.07]</span><br><span class="line">trainIdx: [347.569, 336.819]</span><br><span class="line">--------第79组匹配点----------</span><br><span class="line">queryIdx: [351.152, 229.324]</span><br><span class="line">trainIdx: [333.236, 240.073]</span><br></pre></td></tr></table></figure>
<p>由于我们需要3D-2D，因此需要将一对匹配点的其中的一个转换成相机坐标系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像素坐标系转换成相机归一化平面的投影</span></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span><span class="params">(<span class="keyword">const</span> Point2d &amp;p, <span class="keyword">const</span> Mat &amp;K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span>(</span><br><span class="line">        (p.x - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        (p.y - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">&#123;</span><br><span class="line">    ushort d = d1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)]; <span class="comment">// 获取第一帧图像匹配的每个特征点的深度</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">float</span> dd = d / <span class="number">5000.0</span>;</span><br><span class="line">    Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">    <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">    pts_3d.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd, p1.y * dd, dd));   <span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">    pts_2d.<span class="built_in">push_back</span>(keypoints_2[m.trainIdx].pt);          <span class="comment">// 第二帧图像的像素坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一对匹配点，其中一个点是第一帧图像中的像素点，我们将它的$2D$坐标<code>keypoints_1[m.queryIdx].pt</code>转换成了相机坐标系下的$3D$点，并将转换后的$3D$坐标系存入容器<code>pts_3d</code>内；另一个点是第二帧图像中的像素点，我们直接获得它的$2D$坐标<code>keypoints_2[m.trainIdx].pt</code>，并将其存入容器<code>pts_2d</code>内；</p>
<h2 id="3-求解PnP"><a href="#3-求解PnP" class="headerlink" title="3.求解PnP"></a>3.求解PnP</h2><p>这里使用<code>EPnP</code>方法求解<code>PnP</code>，直接调用方法即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用EPnP方法求解PnP</span></span><br><span class="line">Mat r, t;</span><br><span class="line"><span class="built_in">solvePnP</span>(pts_3d, pts_2d, K, <span class="built_in">Mat</span>(), r, t, <span class="literal">false</span>, cv::SOLVEPNP_EPNP);</span><br><span class="line">Mat R;</span><br><span class="line">cv::<span class="built_in">Rodrigues</span>(r, R); <span class="comment">// r为旋转向量形式，用Rodrigues公式转换为矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;R=&quot;</span> &lt;&lt; endl</span><br><span class="line">    &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; endl</span><br><span class="line">    &lt;&lt; t &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>Parameters:</p>
<ul>
<li>objectPoints - 世界坐标系下的控制点的坐标</li>
<li>imagePoints - 在像素坐标系下对应的控制点的坐标</li>
<li>cameraMatrix - 相机的内参矩阵</li>
<li>distCoeffs - 相机的畸变系数</li>
<li>rvec - 输出的旋转向量</li>
<li>tvec - 输出的平移向量</li>
<li><p>flags - 默认使用CV_ITERATIV迭代法</p>
</li>
<li><p>SolvePnPMethod-选择方法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SolvePnPMethod</span> &#123;</span></span><br><span class="line">    SOLVEPNP_ITERATIVE   = <span class="number">0</span>,</span><br><span class="line">    SOLVEPNP_EPNP        = <span class="number">1</span>, </span><br><span class="line">    SOLVEPNP_P3P         = <span class="number">2</span>, </span><br><span class="line">    SOLVEPNP_DLS         = <span class="number">3</span>,</span><br><span class="line">    SOLVEPNP_UPNP        = <span class="number">4</span>, </span><br><span class="line">    SOLVEPNP_AP3P        = <span class="number">5</span>, </span><br><span class="line">    SOLVEPNP_IPPE        = <span class="number">6</span>, </span><br><span class="line">    SOLVEPNP_IPPE_SQUARE = <span class="number">7</span>,                           </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CV_DOXYGEN</span></span><br><span class="line">    SOLVEPNP_MAX_COUNT </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R=</span><br><span class="line">[0.9978745555297591, -0.05102729297915373, 0.04052883908410459;</span><br><span class="line"> 0.04983267620066928, 0.9983081506312504, 0.02995898472731967;</span><br><span class="line"> -0.04198899628432293, -0.02787564805402974, 0.9987291286613218]</span><br><span class="line">t=</span><br><span class="line">[-0.1273034869580363;</span><br><span class="line"> -0.01157187487421139;</span><br><span class="line"> 0.05667408337434332]</span><br></pre></td></tr></table></figure>
<h2 id="4-使用BA优化"><a href="#4-使用BA优化" class="headerlink" title="4.使用BA优化"></a>4.使用BA优化</h2><p>在使用 g2o 之前，我们要把问题建模成一个最小二乘的图优化问题，节点和边的选择：</p>
<ol>
<li><p><strong>节点：</strong>第二个相机的位姿节点 $ξ ∈ se(3)$，以及所有特征点的空间位置 $P ∈ \mathbb{R}^3 $。</p>
</li>
<li><p><strong>边：</strong>每个$ 3D$ 点在第二个相机中的投影，以观测方程来描述：</p>
<script type="math/tex; mode=display">
z_j = h(ξ, P_j ).</script></li>
</ol>
<p>由于第一个相机位姿固定为零，我们没有把它写到优化变量里，但在习题中，我希望你能够把第一个相机的位姿与观测也考虑进来。现在我们根据一组 $3D $点和第二个图像中的 $2D $投影，估计第二个相机的位姿。所以我们把第一个相机画成虚线，表明我们不希望考虑它。</p>
<p><img src="/images/求解PnP并使用BA优化/image-20220326112157782.png" alt="image-20220326112157782" style="zoom:50%;" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用BA优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;cv::Point3f&gt; &amp;points_3d,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;cv::Point2f&gt; &amp;points_2d,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;K,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;R,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为6(即为se3李代数的维数，前三维为平移，后三维为旋转)</span></span><br><span class="line">    <span class="comment">// 误差值维度为3(每个3D点在第二个相机中的投影)</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverCSparse&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 梯度下降方法，从GN(高斯牛顿), LM（列文伯格）, DogLeg 中选</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">//设置求解器（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// 打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.设置节点</span></span><br><span class="line">    <span class="comment">// 优化第二个相机的位姿</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    Eigen::Matrix3d R_mat;</span><br><span class="line">    R_mat &lt;&lt; R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(</span><br><span class="line">        R_mat,</span><br><span class="line">        Eigen::<span class="built_in">Vector3d</span>(t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))));</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line">    <span class="comment">// 优化所有特征点的空间位置 P</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Point3f p : points_3d)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexPointXYZ *point = <span class="keyword">new</span> g2o::<span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">        point-&gt;<span class="built_in">setId</span>(index++);</span><br><span class="line">        point-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z));</span><br><span class="line">        point-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>); <span class="comment">// g2o 中必须设置 marg 参见第十讲内容</span></span><br><span class="line">        optimizer.<span class="built_in">addVertex</span>(point);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备相机参数</span></span><br><span class="line">    g2o::CameraParameters *camera = <span class="keyword">new</span> g2o::<span class="built_in">CameraParameters</span>(</span><br><span class="line">        K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), Eigen::<span class="built_in">Vector2d</span>(K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>), K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)), <span class="number">0</span>);</span><br><span class="line">    camera-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addParameter</span>(camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置边(每个 3D 点在第二个相机中的投影)</span></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Point2f p : points_2d)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> g2o::<span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexPointXYZ *&gt;(optimizer.<span class="built_in">vertex</span>(index)));</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose);</span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y));</span><br><span class="line">        edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>());</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.优化</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after optimization: \n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;T= \n&quot;</span></span><br><span class="line">         &lt;&lt; Eigen::<span class="built_in">Isometry3d</span>(pose-&gt;<span class="built_in">estimate</span>()).<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入两张彩色图以及对应的深度图：img1 img2 depth1 depth2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    <span class="comment">// 1. 特征匹配</span></span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图一找到&quot;</span> &lt;&lt; keypoints_1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个关键点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图二找到&quot;</span> &lt;&lt; keypoints_2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个关键点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;筛选后一共&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;组匹配点&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立3D点</span></span><br><span class="line">    Mat d1 = <span class="built_in">imread</span>(argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED); <span class="comment">// 深度图为16位无符号数，单通道图像</span></span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point3f&gt; pts_3d;</span><br><span class="line">    vector&lt;Point2f&gt; pts_2d;</span><br><span class="line">    <span class="comment">//提取特征点的深度值：</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取得匹配点的深度，queryIdx(表示匹配点的索引)查询描述子索引，pt关键点的坐标 (y行地址)[x列地址]</span></span><br><span class="line">        ushort d = d1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)];</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">float</span> dd = d / <span class="number">5000.0</span>;</span><br><span class="line">        Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">        <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">        pts_3d.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd, p1.y * dd, dd)); <span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">        pts_2d.<span class="built_in">push_back</span>(keypoints_2[m.trainIdx].pt);        <span class="comment">// 第二帧图像的像素坐标</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3d-2d pairs: &quot;</span> &lt;&lt; pts_3d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用EPnP方法求解PnP</span></span><br><span class="line">    Mat r, t;</span><br><span class="line">    <span class="built_in">solvePnP</span>(pts_3d, pts_2d, K, <span class="built_in">Mat</span>(), r, t, <span class="literal">false</span>, cv::SOLVEPNP_EPNP);</span><br><span class="line">    Mat R;</span><br><span class="line">    cv::<span class="built_in">Rodrigues</span>(r, R); <span class="comment">// r为旋转向量形式，用Rodrigues公式转换为矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R=&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用BA优化</span></span><br><span class="line">    <span class="built_in">bundleAdjustment</span>(pts_3d, pts_2d, K, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_3d2d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用g2o</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"><span class="comment"># find_package( OpenCV REQUIRED ) # use this if in OpenCV2 </span></span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( CSparse REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CSPARSE_INCLUDE_DIR&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_3d2d pose_estimation_3d2d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_3d2d </span><br><span class="line">   <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">   <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">   g2o_core g2o_stuff g2o_types_sba g2o_csparse_extension g2o_types_slam3d <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">max_dist: <span class="number">94</span></span><br><span class="line">min_dist: <span class="number">4</span></span><br><span class="line">图一找到<span class="number">500</span>个关键点</span><br><span class="line">图二找到<span class="number">500</span>个关键点</span><br><span class="line">筛选后一共<span class="number">79</span>组匹配点</span><br><span class="line"><span class="number">3</span>d<span class="number">-2</span>d pairs: <span class="number">75</span></span><br><span class="line">R=</span><br><span class="line">[<span class="number">0.9978745555297591</span>, <span class="number">-0.05102729297915373</span>, <span class="number">0.04052883908410459</span>;</span><br><span class="line"> <span class="number">0.04983267620066928</span>, <span class="number">0.9983081506312504</span>, <span class="number">0.02995898472731967</span>;</span><br><span class="line"> <span class="number">-0.04198899628432293</span>, <span class="number">-0.02787564805402974</span>, <span class="number">0.9987291286613218</span>]</span><br><span class="line">t=</span><br><span class="line">[<span class="number">-0.1273034869580363</span>;</span><br><span class="line"> <span class="number">-0.01157187487421139</span>;</span><br><span class="line"> <span class="number">0.05667408337434332</span>]</span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">0.003377</span>  time= <span class="number">0.000995841</span>       cumTime= <span class="number">0.000995841</span>    edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">78.129155</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">5.9011e-05</span>        cumTime= <span class="number">0.00105485</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">52.086103</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">2</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">6.0375e-05</span>        cumTime= <span class="number">0.00111523</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">34.724069</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">3</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.4488e-05</span>        cumTime= <span class="number">0.00113971</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">23.149379</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">4</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3559e-05</span>        cumTime= <span class="number">0.00116327</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">15.432920</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3493e-05</span>        cumTime= <span class="number">0.00118677</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">10.288613</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">6</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3716e-05</span>        cumTime= <span class="number">0.00121048</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">6.859075</span>  levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">7</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3546e-05</span>        cumTime= <span class="number">0.00123403</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">4.572717</span>  levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">0.000333687</span>       cumTime= <span class="number">0.00156772</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">1227479343.475617</span>    levenbergIter= <span class="number">7</span></span><br><span class="line">after optimization: </span><br><span class="line">T= </span><br><span class="line">  <span class="number">0.997852</span> <span class="number">-0.0508704</span>  <span class="number">0.0412729</span>  <span class="number">-0.128668</span></span><br><span class="line"> <span class="number">0.0496577</span>   <span class="number">0.998319</span>  <span class="number">0.0298962</span> <span class="number">-0.0113707</span></span><br><span class="line"><span class="number">-0.0427243</span> <span class="number">-0.0277825</span>   <span class="number">0.998701</span>  <span class="number">0.0581576</span></span><br><span class="line">         <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>迭代 8轮后，$LM $发现优化目标函数接近不变，于是停止了优化。我们输出了最后得到位姿变换矩阵$ T$ ，对比之前直接做 $PnP $的结果，大约在小数点后第三位发生了一些变化。这主要是由于我们同时优化了特征点和相机位姿导致的。</p>
<p>$Bundle Adjustment $是一种通用的做法。它可以不限于两个图像。我们完全可以放入多个图像匹配到的位姿和空间点进行迭代优化，甚至可以把整个$ SLAM$ 过程放进来。那种做法规模较大，主要在后端使用。在前端，我们通常考虑局部相机位姿和特征点的小型 $Bundle Adjustment $问题，希望实时对它进行求解和优化。</p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>BA与图优化</tag>
        <tag>PNP</tag>
      </tags>
  </entry>
  <entry>
    <title>md公式积累</title>
    <url>/posts/58388.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Makedown常用符号。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="矩阵："><a href="#矩阵：" class="headerlink" title="矩阵："></a>矩阵：</h1><ul>
<li>matrix</li>
</ul>
<script type="math/tex; mode=display">
\begin{matrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{matrix}</script><ul>
<li>pmatrix</li>
</ul>
<script type="math/tex; mode=display">
\begin{pmatrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{pmatrix}</script><ul>
<li>bmatrix</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{bmatrix}</script><ul>
<li>Bmatrix</li>
</ul>
<script type="math/tex; mode=display">
\begin{Bmatrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{Bmatrix}</script><ul>
<li>vmatrix</li>
</ul>
<script type="math/tex; mode=display">
\begin{vmatrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{vmatrix}</script><ul>
<li>Vmatrix</li>
</ul>
<script type="math/tex; mode=display">
\begin{Vmatrix}
f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1
\end{Vmatrix}</script><h1 id="约等于，三角形"><a href="#约等于，三角形" class="headerlink" title="约等于，三角形"></a>约等于，三角形</h1><script type="math/tex; mode=display">
e(x+\Delta x)\approx e(x)+J\Delta x</script><h1 id="集合符号"><a href="#集合符号" class="headerlink" title="集合符号"></a>集合符号</h1><div class="table-container">
<table>
<thead>
<tr>
<th>\in</th>
<th>∈</th>
<th>属于</th>
</tr>
</thead>
<tbody>
<tr>
<td>\notin</td>
<td>∉</td>
<td>不属于</td>
</tr>
<tr>
<td>\subset</td>
<td>⊂</td>
<td>真子集</td>
</tr>
<tr>
<td>\not \subset</td>
<td>⊄</td>
<td>非子集</td>
</tr>
<tr>
<td>\subseteq</td>
<td>⊆</td>
<td>子集</td>
</tr>
<tr>
<td>\supset</td>
<td>⊃</td>
<td>超集</td>
</tr>
<tr>
<td>\supseteq</td>
<td>⊇</td>
<td>超集</td>
</tr>
<tr>
<td>\cup</td>
<td>∪</td>
<td>并集</td>
</tr>
<tr>
<td>\cap</td>
<td>∩</td>
<td>交集</td>
</tr>
<tr>
<td>\mathbb{R}</td>
<td>R</td>
<td>实数集</td>
</tr>
<tr>
<td>\emptyset</td>
<td>∅</td>
<td>空集</td>
</tr>
</tbody>
</table>
</div>
<h1 id="希腊符号"><a href="#希腊符号" class="headerlink" title="希腊符号"></a>希腊符号</h1><div class="table-container">
<table>
<thead>
<tr>
<th>\alpha</th>
<th>α</th>
</tr>
</thead>
<tbody>
<tr>
<td>\beta</td>
<td>β</td>
</tr>
<tr>
<td>\gamma</td>
<td>γ</td>
</tr>
<tr>
<td>\Gamma</td>
<td>Γ</td>
</tr>
<tr>
<td>\theta</td>
<td>θ</td>
</tr>
<tr>
<td>\Theta</td>
<td>Θ</td>
</tr>
<tr>
<td>\delta</td>
<td>δ</td>
</tr>
<tr>
<td>\Delta</td>
<td>Δ</td>
</tr>
<tr>
<td>\triangledown</td>
<td>▽</td>
</tr>
<tr>
<td>\epsilon</td>
<td>ϵ</td>
</tr>
<tr>
<td>\zeta</td>
<td>ζ</td>
</tr>
<tr>
<td>\eta</td>
<td>η</td>
</tr>
<tr>
<td>\kappa</td>
<td>κ</td>
</tr>
<tr>
<td>\lambda</td>
<td>λ</td>
</tr>
<tr>
<td>\mu</td>
<td>μ</td>
</tr>
<tr>
<td>\nu</td>
<td>ν</td>
</tr>
<tr>
<td>\xi</td>
<td>ξ</td>
</tr>
<tr>
<td>\pi</td>
<td>π</td>
</tr>
<tr>
<td>\sigma</td>
<td>σ</td>
</tr>
<tr>
<td>\tau</td>
<td>τ</td>
</tr>
<tr>
<td>\upsilon</td>
<td>υ</td>
</tr>
<tr>
<td>\phi</td>
<td>ϕ</td>
</tr>
<tr>
<td>\omega</td>
<td>ω</td>
</tr>
<tr>
<td>\rho</td>
<td>$\rho $</td>
</tr>
<tr>
<td>\mathbb{R}</td>
<td>$\mathbb{R}$</td>
</tr>
<tr>
<td>\parallel</td>
<td>$\parallel$</td>
</tr>
<tr>
<td>\prime</td>
<td>$\prime$</td>
</tr>
<tr>
<td>\neq</td>
<td>$ \neq$</td>
</tr>
<tr>
<td>\dot{x}</td>
<td>$\dot{x}$</td>
</tr>
<tr>
<td>\ddot{x}</td>
<td>$\ddot{x}$</td>
</tr>
<tr>
<td>\partial{x}</td>
<td>$\partial{x}$</td>
</tr>
</tbody>
</table>
</div>
<p>极限</p>
<script type="math/tex; mode=display">
\lim\limits_{x\rightarrow\infty}\frac{1}{x} <span style="color:red;">文字</span></script><p><span style="color:red;">正态分布的随机变量通过非线性系统后就不再是正态的了。</span></p>
<div class="table-container">
<table>
<thead>
<tr>
<th≯=</th>
<th><script type="math/tex">\not=</script></th>
<th>不等于</th>
</tr>
</thead>
<tbody>
<tr>
<td>\not&gt;</td>
<td>$\not&gt;$</td>
<td>不大于</td>
</tr>
<tr>
<td>\leq</td>
<td>$\leq$</td>
<td>小于等于</td>
</tr>
<tr>
<td>\geq</td>
<td>$\geq$</td>
<td>大于等于</td>
</tr>
</tbody>
</table>
</div>
<p>$\vec{a}$  向量<br>$\overline{a}$ 平均值<br>$\widehat{a}$ (线性回归，直线方程) y尖<br>$\widetilde{a}$ 颚化符号  等价无穷小<br>$\dot{a}$   一阶导数<br>$\ddot{a}$  二阶导数</p>
<p>Ⅰ、Ⅱ、Ⅲ、Ⅳ、Ⅴ、Ⅵ、Ⅶ、Ⅷ、Ⅸ、Ⅹ、Ⅺ</p>
]]></content>
      <categories>
        <category>Makedown</category>
      </categories>
      <tags>
        <tag>Makedown</tag>
      </tags>
  </entry>
  <entry>
    <title>ch7_对极约束求解相机运动</title>
    <url>/posts/28122.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>我们从两张图像中，可以得到一对配对好的特征点。如果我们有若干对这样的匹配点，就可以通过这些二维图像点的对应关系，恢复出在两帧之间摄像机的运动。整个推导结果，使用好的匹配点得到本质矩阵$E$或者基础矩阵$F$抑或单应矩阵$H$，然后通过将他们分解成$R,t$，就可以推算相机的位姿。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><img src="/images/对极约束求解相机运动/image-20220325110120640.png" alt="image-20220325110120640" style="zoom:50%;" /></p>
<p>设 $P$ 的空间位置为：</p>
<script type="math/tex; mode=display">
P=[X,Y,Z]^{T}</script><p>由于像素坐标与世界坐标的关系为：</p>
<script type="math/tex; mode=display">
Z \left(
\begin{matrix}
u\\ v\\ 1
\end{matrix}
\right)=
\left(
\begin{matrix}
f_x &0 &c_x\\
0   &f_y &c_y\\
0 &0 &1\\
\end{matrix}
\right)
\left(
\begin{matrix}
X\\ Y\\ Z
\end{matrix}
\right)=KP</script><p>两个像素点 $p_1 , p_2 $的像素位置为:</p>
<script type="math/tex; mode=display">
s_1p_1=KP，s_2p_2=K(RP+t)</script><p>使用齐次坐标：</p>
<script type="math/tex; mode=display">
p_1=KP，p_2=K(RP+t)</script><p>取：$x_1=K^{-1}p_1,x_2=K^{-1}p_2$,这里的$ x_1 , x_2 $是两个像素点的归一化平面上的坐标。</p>
<p>代入上式:</p>
<script type="math/tex; mode=display">
x_2=Rx_1+t</script><p>两边同时左乘$t^{\land}$:</p>
<script type="math/tex; mode=display">
t^{\land}x_2=t^{\land}Rx_1</script><p>两侧同时左乘$x_2^{T}$，由$t^{\land}x_2$表示$t$与$x_2$的外积，外积的定义说明$t^{\land}x_2$与$t$、$x_2$都是垂直的，故而：</p>
<script type="math/tex; mode=display">
x_2^{T}t^{\land}x_2=x_2^{T}t^{\land}Rx_1=0\\
x_2^{T}Ex_1=0</script><p>带入$p_1,p_2$:</p>
<script type="math/tex; mode=display">
p_2^{T}K^{-T}t^{\land}RK^{-1}p_1=0\\
p_2^{T}Fp_1=0</script><p>因此验证对极约束：</p>
<script type="math/tex; mode=display">
x_2^{T}t^{\land}Rx_1=0</script><h1 id="对极约束求解相机运动"><a href="#对极约束求解相机运动" class="headerlink" title="对极约束求解相机运动"></a>对极约束求解相机运动</h1><h2 id="1-特征匹配"><a href="#1-特征匹配" class="headerlink" title="1.特征匹配"></a>1.特征匹配</h2><p>这一部分的实践是在<a href="https://lukeyalvin.top/2022/03/24/特征提取/#more">特征提取与匹配</a>的基础上进行的，和之前的特征匹配没有区别，只是这里把它封装成一个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找特征匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;good_matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;                    <span class="comment">// 定义描述子</span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();       <span class="comment">//创建ORB特征检测器</span></span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>(); <span class="comment">//创建ORB特征描述子提取.</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, matches);</span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; max_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            good_matches.<span class="built_in">push_back</span>(matches[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mat img_goodmatch;</span></span><br><span class="line">    <span class="comment">// drawMatches(img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch);</span></span><br><span class="line">    <span class="comment">// imshow(&quot;优化后匹配点对&quot;, img_goodmatch);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-估计两张图像间运动"><a href="#2-估计两张图像间运动" class="headerlink" title="2.估计两张图像间运动"></a>2.估计两张图像间运动</h2><p>当我们确定两帧图像之间的特征点以及匹配，我们就可以根据良好的匹配点来估计相机的运动，这里也是封装成了一个函数。可以使用本质矩阵、基础矩阵抑或单应矩阵，它们都是封装好的函数，传参即可，不需要个人写实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相机位姿估计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_2d2d</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;good_matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 相机内参,TUM Freiburg2</span></span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 把匹配点转换为vector&lt;Point2f&gt;的形式</span></span><br><span class="line">    vector&lt;Point2f&gt; points1;</span><br><span class="line">    vector&lt;Point2f&gt; points2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)good_matches.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//`queryIdx` 代表的特征点序列是 `keypoints1` 中的，</span></span><br><span class="line">        <span class="comment">//`trainIdx `代表的特征点序列是` keypoints2 `中的，此时这两张图中的特征点相互匹配。</span></span><br><span class="line">        points1.<span class="built_in">push_back</span>(keypoints_1[good_matches[i].queryIdx].pt);</span><br><span class="line">        points2.<span class="built_in">push_back</span>(keypoints_2[good_matches[i].trainIdx].pt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 计算基础矩阵</span></span><br><span class="line">    Mat fundamental_matrix;</span><br><span class="line">    fundamental_matrix = <span class="built_in">findFundamentalMat</span>(points1, points2, CV_FM_8POINT); <span class="comment">// 八点法求基础矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基础矩阵F：\n&quot;</span></span><br><span class="line">         &lt;&lt; fundamental_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算本质矩阵</span></span><br><span class="line">    <span class="function">Point2d <span class="title">principal_point</span><span class="params">(<span class="number">325.1</span>, <span class="number">249.7</span>)</span></span>; <span class="comment">//相机光心(cx cy), TUM dataset标定值</span></span><br><span class="line">    <span class="keyword">double</span> focal_length = <span class="number">521</span>;             <span class="comment">//相机焦距(fx fy), TUM dataset标定值</span></span><br><span class="line">    Mat essential_matrix = <span class="built_in">findEssentialMat</span>(points1, points2, focal_length, principal_point);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本质矩阵E：\n&quot;</span></span><br><span class="line">         &lt;&lt; essential_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算单应矩阵</span></span><br><span class="line">    <span class="comment">// RANSAC表示基于RANSAC的鲁棒算法</span></span><br><span class="line">    <span class="comment">// ransacReprojThreshold将点对视为内点的最大允许重投影错误阈值（仅用于RANSAC和RHO方法）一般1-10</span></span><br><span class="line">    Mat homography_matrix = <span class="built_in">findHomography</span>(points1, points2, RANSAC, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单应矩阵H：\n&quot;</span></span><br><span class="line">         &lt;&lt; homography_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 从本质矩阵中恢复旋转和平移信息.</span></span><br><span class="line">    <span class="built_in">recoverPose</span>(essential_matrix, points1, points2, R, t, focal_length, principal_point);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R: \n&quot;</span></span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: \n&quot;</span></span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-验证对极约束"><a href="#3-验证对极约束" class="headerlink" title="3.验证对极约束"></a>3.验证对极约束</h2><p>上面可知：</p>
<script type="math/tex; mode=display">
x_2^{T}t^{\land}Rx_1=0</script><p>首先，要知道像素坐标转相机归一化坐标的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span><span class="params">(<span class="keyword">const</span> Point2d &amp;p, <span class="keyword">const</span> Mat &amp;K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 归一化坐标Pc(X/Z,Y/Z,1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span>(</span><br><span class="line">        (p.x - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), <span class="comment">// (u-cx)/fx = X/Z</span></span><br><span class="line">        (p.y - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment">// (v-cy)/fy = Y/Z</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可以获得两个像素点的归一化坐标$(\frac{X}{Z},\frac{Y}{Z},1)$</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point2d pt1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// keypoints_1[m.queryIdx].pt为像素坐标，K为相机内参矩阵</span></span><br><span class="line">Mat y1 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span>);       <span class="comment">// y1=(X/Z, Y/Z, 1) 相机归一化坐标</span></span><br><span class="line">Point2d pt2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);</span><br><span class="line">Mat y2 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>获得两个像素的归一化坐标之后，使用$x_2^{T}t^{\land}Rx_1=0$，进行验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat d = y2.<span class="built_in">t</span>() * t_x * R * y1; <span class="comment">//  y2.t()表示y2的转置，t_x表示t^</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;epipolar constraint = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>这仅仅是一对像素点，最终我们会发现良好的匹配点一共有79对，因此需要写一个循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************</span></span><br><span class="line"><span class="comment">* 3.验证对极约束</span></span><br><span class="line"><span class="comment">**************/</span></span><br><span class="line">Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (DMatch m : good_matches)</span><br><span class="line">&#123;</span><br><span class="line">    Point2d pt1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// keypoints_1[m.queryIdx].pt为像素坐标，K为相机内参矩阵</span></span><br><span class="line">    Mat y1 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span>);       <span class="comment">// y1=(X/Z, Y/Z, 1) 相机归一化坐标</span></span><br><span class="line">    Point2d pt2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);</span><br><span class="line">    Mat y2 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span>);</span><br><span class="line">    Mat d = y2.<span class="built_in">t</span>() * t_x * R * y1; <span class="comment">//  y2.t()表示y2的转置，t_x表示t^</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;epipolar constraint = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><p>主函数，其中调用的方法，前文已经列出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d/calib3d.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入相邻两帧的图像&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入图像</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; good_matches;</span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 1.特征匹配</span></span><br><span class="line"><span class="comment">     **************/</span></span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, good_matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到了&quot;</span> &lt;&lt; good_matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;对匹配点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 2.估计两张图像间运动</span></span><br><span class="line"><span class="comment">     **************/</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_2d2d</span>(keypoints_1, keypoints_2, good_matches, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证E=t^R*scale</span></span><br><span class="line">    Mat t_x = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, -t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2.0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">               t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), <span class="number">0</span>, -t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) - t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t^R: \n&quot;</span></span><br><span class="line">         &lt;&lt; t_x * R &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 3.验证对极约束</span></span><br><span class="line"><span class="comment">     **************/</span></span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (DMatch m : good_matches)</span><br><span class="line">    &#123;</span><br><span class="line">        Point2d pt1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// keypoints_1[m.queryIdx].pt为像素坐标，K为相机内参矩阵</span></span><br><span class="line">        Mat y1 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span>);       <span class="comment">// y1=(X/Z, Y/Z, 1) 相机归一化坐标</span></span><br><span class="line">        Point2d pt2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);</span><br><span class="line">        Mat y2 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span>);</span><br><span class="line">        Mat d = y2.<span class="built_in">t</span>() * t_x * R * y1; <span class="comment">//  y2.t()表示y2的转置，t_x表示t^</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;epipolar constraint = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_2d2d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable( pose_estimation_2d2d pose_estimation_2d2d.cpp extra.cpp ) # use this if in OpenCV2 </span></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_2d2d pose_estimation_2d2d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_2d2d <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一共找到了79对匹配点</span><br><span class="line">基础矩阵F：</span><br><span class="line">[4.544437503937326e-06, 0.0001333855576988952, -0.01798499246457619;</span><br><span class="line"> -0.0001275657012959839, 2.266794804637672e-05, -0.01416678429258694;</span><br><span class="line"> 0.01814994639952877, 0.004146055871509035, 1]</span><br><span class="line">本质矩阵E：</span><br><span class="line">[0.01097677480088526, 0.2483720528258777, 0.03167429207291153;</span><br><span class="line"> -0.2088833206039177, 0.02908423961781584, -0.6744658838357441;</span><br><span class="line"> 0.008286777636447118, 0.6614041624098427, 0.01676523772725936]</span><br><span class="line">单应矩阵H：</span><br><span class="line">[0.9261214281175537, -0.1445322024509824, 33.26921085699328;</span><br><span class="line"> 0.04535424464910424, 0.9386696693816731, 8.570979966717406;</span><br><span class="line"> -1.006197561051869e-05, -3.008140280167741e-05, 0.9999999999999999]</span><br><span class="line">R: </span><br><span class="line">[0.9969387384754708, -0.05155574188737422, 0.05878058527591362;</span><br><span class="line"> 0.05000441581290405, 0.998368531736214, 0.02756507279306545;</span><br><span class="line"> -0.06010582439453526, -0.02454140006844053, 0.9978902793175882]</span><br><span class="line">t: </span><br><span class="line">[-0.9350802885437915;</span><br><span class="line"> -0.03514646275858852;</span><br><span class="line"> 0.3526890700495534]</span><br><span class="line">t^R: </span><br><span class="line">[-0.01552350379276751, -0.3512511256212342, -0.04479421342842761;</span><br><span class="line"> 0.2932931178326273, -0.04199386952278789, 0.9889111138164588;</span><br><span class="line"> -0.992323587628662, 0.0236673579316946, 0.942925712677014]</span><br><span class="line">epipolar constraint = [0.6796225931993222]</span><br><span class="line">epipolar constraint = [1.041980822107436]</span><br><span class="line">........</span><br><span class="line">epipolar constraint = [1.014767775015567]</span><br><span class="line">epipolar constraint = [1.257231546320262]</span><br><span class="line">epipolar constraint = [1.000924219722595]</span><br><span class="line">epipolar constraint = [0.8732996303495971]</span><br></pre></td></tr></table></figure>
<h1 id="使用三角测量"><a href="#使用三角测量" class="headerlink" title="使用三角测量"></a>使用三角测量</h1><p>上文的对极约束求解相机运动存在尺度不确定性：</p>
<blockquote>
<p>由于 $E$ 本身具有尺度等价性，它分解得到的$ t, R $也有一个尺度等价性。而$ R ∈ SO(3) $自身具有约束，所以我们认为 $t $具有一个尺度。换言之，在分解过程中，对$ t $乘以任意非零常数，分解都是成立的。因此，我们通常把 $t $进行归一化，让它的长度等于 1。</p>
</blockquote>
<p>这也是由于单目相机本身的缺点，在单目 SLAM 中，仅通过单张图像无法获得像素的深度信息，我们需要通过三角测量（Triangulation）（或三角化）的方法来估计地图点的深度。</p>
<p><img src="/images/对极约束求解相机运动/image-20220325110908224.png" alt="image-20220325110908224" style="zoom:50%;" /></p>
<p>按照对极几何中的定义，设 $x_1 , x_2 $为两个特征点的归一化坐标，满足：</p>
<script type="math/tex; mode=display">
\begin{align*}
s_1p_1&=KP,\\ s_2p_2&=K(RP+t) 
\end{align*}</script><p>已知：</p>
<script type="math/tex; mode=display">
\begin{align*}
x_1 = K^{-1}p_1 \\
x_2 = K^{-1}p_2
\end{align*}</script><p>将$p_1,p_2$换成$x_1,x_2$:</p>
<script type="math/tex; mode=display">
\begin{align*}
s_1Kx_1&=KP,\\ s_2Kx_2&=K(RP+t) 
\end{align*}</script><p>因此，$x_1,x_2$的关系满足：</p>
<script type="math/tex; mode=display">
s_2x_2= s_1Rx_1+t</script><p>我们已经知道了 $R, t$，想要求解的是两个特征点的深度 $s_1 , s_2$ 。当然这两个深度是可以分开求的，比方说先来看 $s_1$ 。如果我要算 $s_1 $，那么先对上式两侧左乘一个 $x^{\land}_2$</p>
<script type="math/tex; mode=display">
s_2x^{\land}_2x_2= s_1x^{\land}_2Rx_1+x^{\land}_2t\\
s_1x^{\land}_2Rx_1+x^{\land}_2t=0 \tag{i}</script><p>这是一个关于$s_1$的方程，可以求得$s_1$的值，于是，我们就得到了两个帧下的点的深度，确定了它们的空间坐标。当然，由于噪声的存在，我们估得的 $R, t$，不一定精确使式$(i)$为零，所以更常见的做法求<strong>最小二乘解</strong>,而不是零解。</p>
<p>同样的，三角测量是在特征匹配以及估计两张图像间的运动的基础上进行的。之前我们已经获得了良好的匹配点，并通过本质矩阵求得相机的位姿$R,t$，在此基础上进行三角测量。</p>
<p>三角测量的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;DMatch&gt; &amp;matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;R, <span class="keyword">const</span> Mat &amp;t,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3d&gt; &amp;points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化单位阵(参考位姿矩阵)</span></span><br><span class="line">    Mat T1 =</span><br><span class="line">        (Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; </span><br><span class="line">         <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 对极约束求出的变换矩阵</span></span><br><span class="line">    Mat T2 =</span><br><span class="line">        (Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; </span><br><span class="line">         R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">         R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">         R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    Mat K =</span><br><span class="line">        (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">         <span class="number">520.9</span>, <span class="number">0</span>,      <span class="number">325.1</span>,</span><br><span class="line">         <span class="number">0</span>,     <span class="number">521.0</span>,  <span class="number">249.7</span>,</span><br><span class="line">         <span class="number">0</span>,     <span class="number">0</span>,      <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point2f&gt; pts_1, pts_2;</span><br><span class="line">    <span class="comment">// 遍历DMatch中匹配的特征点</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将像素坐标转换至归一化成像平面</span></span><br><span class="line">        pts_1.<span class="built_in">push_back</span>( <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt,K) );</span><br><span class="line">        pts_2.<span class="built_in">push_back</span>( <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt,K) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用三角化函数</span></span><br><span class="line">    Mat pts_4d;</span><br><span class="line">    <span class="comment">//函数接受的参数是两个相机位姿和特征点在两个相机坐标系下的归一化坐标，输出三角化后的特征点的3D坐标。</span></span><br><span class="line">    <span class="comment">//输出的3D坐标是齐次坐标，共四个维度（所以变量名为pts_4d），因此需要将前三个维度除以第四个维度以得到非齐次坐标xyz</span></span><br><span class="line">    cv::<span class="built_in">triangulatePoints</span>(T1, T2, pts_1, pts_2, pts_4d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts_4d.cols; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.<span class="built_in">col</span>(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>);<span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span><span class="params">(x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        points.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入相邻两帧的图片！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入图像</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.特征提取与匹配</span></span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到了&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个良好的匹配点&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2.估计两张图像间运动</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_2d2d</span>(keypoints_1, keypoints_2, matches, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.三角化</span></span><br><span class="line">    vector&lt;Point3d&gt; points;</span><br><span class="line">    <span class="built_in">triangulation</span>(keypoints_1,keypoints_2,matches,R,t,points);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.验证三角化点与特征点的重投影关系</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matches.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------第[&quot;</span>&lt;&lt; i+<span class="number">1</span> &lt;&lt;<span class="string">&quot;]个空间点-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 第一个图</span></span><br><span class="line">        Point2d pt1_cam = <span class="built_in">pixel2cam</span>(keypoints_1[matches[i].queryIdx].pt, K);</span><br><span class="line">        <span class="function">Point2d <span class="title">pt1_cam_3d</span><span class="params">(points[i].x / points[i].z, points[i].y / points[i].z)</span></span>; <span class="comment">// 归一化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第一帧时的像素坐标: &quot;</span> &lt;&lt; pt1_cam &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第一帧时3D投影坐标：&quot;</span> &lt;&lt; pt1_cam_3d &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;深度d:&quot;</span> &lt;&lt; points[i].z &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第二个图</span></span><br><span class="line">        Point2f pt2_cam = <span class="built_in">pixel2cam</span>(keypoints_2[matches[i].trainIdx].pt, K);</span><br><span class="line">        Mat pt2_trans = R*(Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; points[i].x, points[i].y, points[i].z) + t;</span><br><span class="line">        pt2_trans /= pt2_trans.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第二帧时的像素坐标: &quot;</span> &lt;&lt; pt2_cam &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第二帧时3D投影坐标：&quot;</span> &lt;&lt; pt2_trans.<span class="built_in">t</span>() &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Max dist : 94.000000 </span><br><span class="line">-- Min dist : 4.000000 </span><br><span class="line">一共找到了79个良好的匹配点</span><br><span class="line">基础矩阵F：</span><br><span class="line">[4.544437503937326e-06, 0.0001333855576988952, -0.01798499246457619;</span><br><span class="line"> -0.0001275657012959839, 2.266794804637672e-05, -0.01416678429258694;</span><br><span class="line"> 0.01814994639952877, 0.004146055871509035, 1]</span><br><span class="line">本质矩阵E：</span><br><span class="line">[0.01097677480088526, 0.2483720528258777, 0.03167429207291153;</span><br><span class="line"> -0.2088833206039177, 0.02908423961781584, -0.6744658838357441;</span><br><span class="line"> 0.008286777636447118, 0.6614041624098427, 0.01676523772725936]</span><br><span class="line">单应矩阵H：</span><br><span class="line">[0.9261214281175537, -0.1445322024509824, 33.26921085699328;</span><br><span class="line"> 0.04535424464910424, 0.9386696693816731, 8.570979966717406;</span><br><span class="line"> -1.006197561051869e-05, -3.008140280167741e-05, 0.9999999999999999]</span><br><span class="line">R: </span><br><span class="line">[0.9969387384754708, -0.05155574188737422, 0.05878058527591362;</span><br><span class="line"> 0.05000441581290405, 0.998368531736214, 0.02756507279306545;</span><br><span class="line"> -0.06010582439453526, -0.02454140006844053, 0.9978902793175882]</span><br><span class="line">t: </span><br><span class="line">[-0.9350802885437915;</span><br><span class="line"> -0.03514646275858852;</span><br><span class="line"> 0.3526890700495534]</span><br><span class="line">--------第[1]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.0136303, -0.302687]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.0136588, -0.302975]</span><br><span class="line">深度d:14.4036</span><br><span class="line">点在第二帧时的像素坐标: [-0.00403148, -0.270058]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.004013293769641682, -0.2697748885145957, 1]</span><br><span class="line">--------第[2]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.153772, -0.0742802]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.153809, -0.0755175]</span><br><span class="line">深度d:9.63635</span><br><span class="line">点在第二帧时的像素坐标: [-0.179497, -0.0577735]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.1795174494211173, -0.05658791842651693, 1]</span><br><span class="line">--------第[3]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.468612, 0.119578]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.46862, 0.119797]</span><br><span class="line">深度d:7.88393</span><br><span class="line">点在第二帧时的像素坐标: [-0.499328, 0.1119]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.4993080966028579, 0.1116965292982101, 1]</span><br><span class="line">--------第[4]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.226723, 0.0735125]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.226723, 0.0735073]</span><br><span class="line">深度d:8.35771</span><br><span class="line">点在第二帧时的像素坐标: [-0.268958, 0.08119]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.2689579480646592, 0.0811949362011327, 1]</span><br><span class="line">.......................(略)</span><br></pre></td></tr></table></figure>
<p>我们打印了每个空间点在两个相机坐标系下的投影坐标与像素坐标——相当于 P 的投影位置与看到的特征点位置。由于误差的存在，它们会有一些微小的差异。可以看到，误差的量级大约在小数点后第三位。可以看到，三角化特征点的距离大约为 14～15。但由于尺度不确定性，我们并不知道这里的 15 究竟是多少米。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>在ORBSLAM中这三种方法的顺序：</p>
<ul>
<li><p>使用<strong>特征点检测和特征匹配</strong>，寻找比较好的匹配点。</p>
</li>
<li><p>由两张图像的匹配点，利用<strong>对极几何</strong>计算出$H$或者$F$矩阵，并从这两个矩阵中恢复出$R，t$</p>
</li>
<li><p>有了$R,t $就可以利用相机的位姿和两帧对应的像素坐标用<strong>三角测量</strong>计算出其对应的3D点坐标。至此，相机的位姿和对应的地图点就都有了，接下来正常跟踪即可；</p>
</li>
<li><p>跟踪丢失后，就需要回到原来机器人曾经经过的位置找匹配帧，找到的匹配帧是有其3D地图点和位姿的，用这些3D点和当前帧自己的像素坐标， PnP计算出当前帧相较于匹配帧的运动$R，t$</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_25458977/article/details/113675519">https://blog.csdn.net/qq_25458977/article/details/113675519</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>对极约束</tag>
      </tags>
  </entry>
  <entry>
    <title>ch7_特征提取与匹配</title>
    <url>/posts/62703.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>目前主流的几种图像特征在 OpenCV 开源图像库中都已经集成完毕，我们可以很方便地进行调用。下面我们来实际练习一下 OpenCV 的图像特征提取、计算和匹配的过程。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>素材：</p>
<p><img src="/images/特征提取/FE.PNG" alt="FE" style="zoom:50%;" /></p>
<p>相关函数参考文档：<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/features2d/doc/features2d.html">features2d. 二维图像特征框架</a></p>
<p>特征匹配的步骤：</p>
<ul>
<li>初始化</li>
</ul>
<p>主要是定义特征点、描述子、特征检测方式(ORB、FAST、SIFT)等;</p>
<ul>
<li>提取ORB特征点</li>
</ul>
<p>主要根据创建的检测器检测角点位置，以及使用角点来计算描述子。</p>
<ul>
<li>匹配点对筛选</li>
</ul>
<p>对两幅图像中的BRIEF描述子进行匹配，可以使用$ Hamming$ 距离</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读入参数（相机相邻两帧的图片）</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请提供相邻两帧的图片！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取图像并保存为Mat数据类型</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR); <span class="comment">//存储的是三通道的彩色图片</span></span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一步：初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2; <span class="comment">// 定义特征点</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;               <span class="comment">// 定义描述子</span></span><br><span class="line">    <span class="comment">// FeatureDetetor 是虚类，通过定义FeatureDetector的对象</span></span><br><span class="line">    <span class="comment">// 可以使用多种特征检测方法。通过 create() 函数调用</span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();       <span class="comment">//创建ORB特征检测器</span></span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>(); <span class="comment">//创建ORB特征描述子提取.</span></span><br><span class="line">    <span class="comment">//对于给定参数，创建特征描述子匹配(使用默认的构造函数).</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二步：检测 Oriented FAST 角点位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三步：根据角点位置计算 BRIEF 描述子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line"></span><br><span class="line">    Mat outimg1;</span><br><span class="line">    <span class="built_in">drawKeypoints</span>(img_1, keypoints_1, outimg1, Scalar::<span class="built_in">all</span>(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;ORB特征点&quot;</span>, outimg1); <span class="comment">// 至此，已经成功提取ORB特征点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第四步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// DMatch用于匹配特征关键点的特征描述子的类：查询特征描述子索引, 特征描述子索引, 训练图像索引, 以及不同特征描述子之间的距离.</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, matches); <span class="comment">// 给定查询集合中的每个特征描述子，寻找最佳匹配.</span></span><br><span class="line"></span><br><span class="line">    Mat img_match;</span><br><span class="line">    <span class="built_in">drawMatches</span>(img_1, keypoints_1, img_2, keypoints_2, matches, img_match);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;所有匹配点对&quot;</span>, img_match);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第五步:匹配点对筛选</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; min_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    std::vector&lt;DMatch&gt; good_matches;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            good_matches.<span class="built_in">push_back</span>(matches[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat img_goodmatch;</span><br><span class="line">    <span class="built_in">drawMatches</span>(img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;优化后匹配点对&quot;</span>, img_goodmatch);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( feature_extraction )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>( feature_extraction feature_extraction.cpp  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( feature_extraction <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
<p>特征点检测</p>
<p><img src="/images/特征提取/outimg1.png" alt="outimg1" style="zoom: 50%;" /></p>
<p>所有匹配点对</p>
<p><img src="/images/特征提取/img_match.png" alt="img_match" style="zoom: 50%;" /></p>
<p>优化后匹配点对</p>
<p><img src="/images/特征提取/img_goodmatch.png" alt="img_goodmatch" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title>ch6_使用g2o拟合曲线</title>
    <url>/posts/6634.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>g2o（General Graphic Optimization，G2O）。它是一个基于图优化的库。图优化，是把优化问题表现成图（Graph）的一种方式。这里的图是图论意义上的图。一个图由若干个<strong>顶点（Vertex）</strong>，以及连接着这些节点的<strong>边（Edge）</strong>组成。进而，用<strong>顶点表示优化变量</strong>，用<strong>边表示误差项</strong>。最基本的图优化，是用图模型来表达一个非线性最小二乘的优化问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>编译与安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.2 libcholmod-dev</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> g2o</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="使用G2O的步骤："><a href="#使用G2O的步骤：" class="headerlink" title="使用G2O的步骤："></a>使用G2O的步骤：</h2><p><img src="/images/使用g2o拟合曲线/1855613-20200414153348238-1860777008.png" alt="img"></p>
<h3 id="1、创建线性求解器"><a href="#1、创建线性求解器" class="headerlink" title="1、创建线性求解器"></a>1、创建线性求解器</h3><p>这里的线性求解器<code>LinearSolver</code>创建的是<code>LinearSolverCSparse</code>：</p>
<ul>
<li><strong>LinearSolverCholmod ：</strong>使用sparse cholesky分解法。继承自LinearSolverCCS</li>
<li><strong>LinearSolverCSparse：</strong>使用CSparse法。继承自LinearSolverCCS</li>
<li><strong>LinearSolverDense ：</strong>使用dense cholesky分解法。继承自LinearSolver</li>
<li><strong>LinearSolverEigen：</strong> 依赖项只有eigen，使用eigen中sparse Cholesky 求解，因此编译好后可以方便的在其他地方使用，性能和CSparse差不多。继承自LinearSolver</li>
<li><strong>LinearSolverPCG ：</strong>使用preconditioned conjugate gradient 法，继承自LinearSolver</li>
</ul>
<h3 id="2、矩阵块求解器"><a href="#2、矩阵块求解器" class="headerlink" title="2、矩阵块求解器"></a>2、矩阵块求解器</h3><p>BlockSolver 内部包含 LinearSolver，用上面我们定义的线性求解器LinearSolver来初始化。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br></pre></td></tr></table></figure>
<h3 id="3、创建总求解器solver。"><a href="#3、创建总求解器solver。" class="headerlink" title="3、创建总求解器solver。"></a>3、创建总求解器solver。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 梯度下降方法，从GN(高斯牛顿), LM（列文伯格）, DogLeg 中选</span></span><br><span class="line">g2o::OptimizationAlgorithmGaussNewton *solver_gn = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">g2o::OptimizationAlgorithmLevenberg *solver_lm = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">g2o::OptimizationAlgorithmDogleg *solver_dog = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmDogleg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br></pre></td></tr></table></figure>
<h3 id="4、创建稀疏优化器"><a href="#4、创建稀疏优化器" class="headerlink" title="4、创建稀疏优化器"></a>4、创建稀疏优化器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g2o::SparseOptimizer optimizer;    <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">optimizer.<span class="built_in">setAlgorithm</span>(solver_lm); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line">optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);        <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br></pre></td></tr></table></figure>
<h3 id="5、定义图的顶点和边"><a href="#5、定义图的顶点和边" class="headerlink" title="5、定义图的顶点和边"></a>5、定义图的顶点和边</h3><p>定义图的顶点和边。并添加到SparseOptimizer中。</p>
<h4 id="顶点的定义"><a href="#顶点的定义" class="headerlink" title="顶点的定义"></a>顶点的定义</h4><p>节点的定义比较简单，只需要继承 G2O 的基础节点类型，并且给出几个关键虚函数的实现即可：</p>
<ul>
<li><code>setToOriginImpl()</code>：重置节点的实现，通常情况下各个参数置 0 即可</li>
<li><code>oplusImpl()</code>：更新节点方法的实现，这里由于我们使用的节点和更新量都是 <code>Eigen::Vector3d</code>，直接相加即可</li>
<li><code>read(std::istream &amp;in); &amp; write(std::ostream &amp;out);</code>：读盘和写盘，还没有深入了解，不过大部分时间不需要</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="comment">// 顶点重置函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span> <span class="comment">// 顶点更新函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="边的定义"><a href="#边的定义" class="headerlink" title="边的定义"></a>边的定义</h4><p>边的定义需要继承 G2O 中的一个基础边类型，并给出几个关键函数的实现：</p>
<ul>
<li><code>computeError()</code>： 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，这个函数则是使用该边连接的节点和观测值来计算误差。最后要更新变量 <code>_error</code></li>
<li><code>linearizeOplus()</code>：计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</li>
<li><code>read(std::istream &amp;in); &amp; write(std::ostream &amp;out);</code>：读盘和写盘</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型   (边为误差项)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, CurveFittingVertex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CurveFittingEdge</span>(<span class="keyword">double</span> x) : <span class="built_in">BaseUnaryEdge</span>(), _x(x) &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> _x; <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6、设置优化参数，开始执行优化"><a href="#6、设置优化参数，开始执行优化" class="headerlink" title="6、设置优化参数，开始执行优化"></a>6、设置优化参数，开始执行优化</h3><p>设置SparseOptimizer的初始化、迭代次数、保存结果等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 设置优化初始值</span></span><br><span class="line">optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);            <span class="comment">// 设置优化次数</span></span><br></pre></td></tr></table></figure>
<h2 id="非线性拟合案例"><a href="#非线性拟合案例" class="headerlink" title="非线性拟合案例"></a>非线性拟合案例</h2><p>假设有一条满足以下方程的曲线：</p>
<script type="math/tex; mode=display">
y=exp(ax^2+bx+c)+w</script><p>其中$ a, b, c $为曲线的参数，$w $为高斯噪声。我们故意选择了这样一个非线性模型，以使问题不至于太简单。现在，假设我们有$ N $个关于$ x, y$ 的观测数据点，想根据这些数据点求出曲线的参数。那么，可以求解下面的最小二乘问题以估计曲线参数：</p>
<script type="math/tex; mode=display">
\underset{a,b,c}{min}\frac{1}{2}\sum^{N}_{i=1}\parallel y_i-exp(ax^2_i+bx_i+c)\parallel^2</script><p>节点为优化变量，边为误差项：</p>
<p><img src="/images/使用g2o拟合曲线/image-20220326161220343.png" alt="image-20220326161220343" style="zoom: 50%;" /></p>
<p>在曲线拟合问题中，整个问题只有一个顶点：曲线模型的参数$ a, b, c$；而每个带噪声的数据点，构成了一个个误差项，也就是图优化的边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span>     <span class="comment">// 顶点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span> <span class="comment">// 边</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span> <span class="comment">// GN</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span>    <span class="comment">// LM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span>       <span class="comment">// DogLeg</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点，模板参数：优化变量维度和数据类型   (节点为优化变量)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="comment">// 顶点重置函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span> <span class="comment">// 顶点更新函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型   (边为误差项)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, CurveFittingVertex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CurveFittingEdge</span>(<span class="keyword">double</span> x) : <span class="built_in">BaseUnaryEdge</span>(), _x(x) &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> _x; <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>, c = <span class="number">1.0</span>; <span class="comment">// 真实参数值</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;                      <span class="comment">// 数据点</span></span><br><span class="line">    <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;             <span class="comment">// 噪声Sigma值</span></span><br><span class="line">    cv::RNG rng;                      <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line">    <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;        <span class="comment">// abc参数的估计值</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;生成数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(a * x * x + b * x + c) + rng.<span class="built_in">gaussian</span>(w_sigma));</span><br><span class="line">        cout &lt;&lt; x_data[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y_data[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 梯度下降方法，从GN(高斯牛顿), LM（列文伯格）, DogLeg 中选</span></span><br><span class="line">    g2o::OptimizationAlgorithmGaussNewton *solver_gn = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver_lm = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    g2o::OptimizationAlgorithmDogleg *solver_dog = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmDogleg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer;    <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver_lm); <span class="comment">//设置求解器（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);        <span class="comment">// 打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往图中增加顶点</span></span><br><span class="line">    CurveFittingVertex *v = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    v-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 设置优化初始值</span></span><br><span class="line">    v-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);                              <span class="comment">// 设置顶点ID</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(v);                   <span class="comment">// 向稀疏优化器添加顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往图中增加边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]);</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, v);           <span class="comment">// 设置连接的顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]); <span class="comment">//观测数值</span></span><br><span class="line">        <span class="comment">// 信息矩阵：协方差矩阵的逆</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge); <span class="comment">// 向稀疏优化器添加边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 开始优化：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>(); <span class="comment">// 计时工具</span></span><br><span class="line"></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 设置优化初始值</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);            <span class="comment">// 设置优化次数</span></span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;求解优化共使用了&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出优化值</span></span><br><span class="line">    Eigen::Vector3d abc_estimate = v-&gt;<span class="built_in">estimate</span>(); <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;估计模型为：&quot;</span> &lt;&lt; abc_estimate.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CMakeList.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( g2o_curve_fitting )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用ceres库</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找G2O</span></span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV</span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( curve_fitting g2o_curve_fitting.cpp )</span><br><span class="line"><span class="comment"># 与G2O和OpenCV链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( curve_fitting </span><br><span class="line">    <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">    g2o_core g2o_stuff</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">生成数据：</span><br><span class="line"><span class="symbol">0 </span><span class="number">2.71828</span></span><br><span class="line"><span class="number">0.01</span> <span class="number">2.93161</span></span><br><span class="line"><span class="number">0.02</span> <span class="number">2.12942</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0.96</span> <span class="number">47.7941</span></span><br><span class="line"><span class="number">0.97</span> <span class="number">48.5931</span></span><br><span class="line"><span class="number">0.98</span> <span class="number">51.8487</span></span><br><span class="line"><span class="number">0.99</span> <span class="number">51.0258</span></span><br><span class="line"> 开始优化：</span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">30373.727656</span>      time= <span class="number">7.3362</span>e-<span class="number">05</span>        cumTime= <span class="number">7.3362</span>e-<span class="number">05</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">699.050482</span>      levenbergIter= <span class="number">7</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">13336.948287</span>      time= <span class="number">4.4188</span>e-<span class="number">05</span>        cumTime= <span class="number">0.00011755</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">1864.134619</span>     levenbergIter= <span class="number">3</span></span><br><span class="line">iteration= <span class="number">2</span>     chi2= <span class="number">6946.262238</span>       time= <span class="number">3.8416</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000155966</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">1242.756412</span>     levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">3</span>     chi2= <span class="number">271.023143</span>        time= <span class="number">3.6174</span>e-<span class="number">05</span>        cumTime= <span class="number">0.00019214</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">414.252137</span>      levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">4</span>     chi2= <span class="number">118.903888</span>        time= <span class="number">3.7968</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000230108</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">138.084046</span>      levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">113.568661</span>        time= <span class="number">3.7864</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000267972</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">46.028015</span>       levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">6</span>     chi2= <span class="number">107.476468</span>        time= <span class="number">3.5648</span>e-<span class="number">05</span>        cumTime= <span class="number">0.00030362</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">15.342672</span>       levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">7</span>     chi2= <span class="number">103.014521</span>        time= <span class="number">4.424</span>e-<span class="number">05</span>         cumTime= <span class="number">0.00034786</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">5.114224</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">101.988349</span>        time= <span class="number">3.7035</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000384895</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">1.704741</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">9</span>     chi2= <span class="number">101.937388</span>        time= <span class="number">3.6393</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000421288</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.568247</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">10</span>    chi2= <span class="number">101.937021</span>        time= <span class="number">3.0743</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000452031</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.378831</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">11</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.2616</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000484647</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.252554</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">12</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.1629</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000516276</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.168370</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">13</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.2006</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000548282</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.112246</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">14</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.124</span>e-<span class="number">05</span>         cumTime= <span class="number">0.000579522</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.074831</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">15</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">5.3317</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000632839</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">13391510.122618</span>         levenbergIter= <span class="number">8</span></span><br><span class="line">iteration= <span class="number">16</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.736</span>e-<span class="number">05</span>         cumTime= <span class="number">0.000670199</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">857056647.847525</span>        levenbergIter= <span class="number">3</span></span><br><span class="line">求解优化共使用了<span class="number">0.00163436</span>秒</span><br><span class="line">估计模型为：<span class="number">0.890912</span>   <span class="number">2.1719</span> <span class="number">0.943629</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>g2o</tag>
      </tags>
  </entry>
  <entry>
    <title>ch6_使用Ceres拟合曲线</title>
    <url>/posts/50868.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Ceres solver 是谷歌开发的一款用于<a href="https://so.csdn.net/so/search?q=非线性&amp;spm=1001.2101.3001.7020">非线性</a>优化的库，在谷歌的开源激光雷达 slam 项目 cartographer 中被大量使用。Ceres 官网上的文档非常详细地介绍了其具体使用方法，相比于另外一个在 slam 中被广泛使用的图优化库 G2O，ceres 的文档可谓相当丰富详细。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>下载与编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ceres-solver/ceres-solver</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev libgoogle-glog-dev libgtest-dev</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> ceres-solver</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="Ceres使用步骤："><a href="#Ceres使用步骤：" class="headerlink" title="Ceres使用步骤："></a>Ceres使用步骤：</h2><ul>
<li>（1）定义$Cost Function$ 模型</li>
</ul>
<p>代价函数，也就是寻优的目标式。这个部分需要使用仿函数$（functor）$这一技巧来实现，做法是定义一个$ cost function $的结构体，在结构体内重载（）运算符。</p>
<ul>
<li><p>（2）通过代价函数构建待求解的优化问题</p>
</li>
<li><p>（3）配置求解器参数并求解问题</p>
</li>
</ul>
<h2 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例</h2><h3 id="1-构建代价函数"><a href="#1-构建代价函数" class="headerlink" title="1.构建代价函数"></a>1.构建代价函数</h3><p>本案例中待优化的函数为：$f(x)=10-x$，我们需要寻找最优的$x$值是的函数$f(x)$最小，所以误差项为$10.0-x[0]$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一部分：构建代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(<span class="number">10.0</span>) - x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-构建寻优问题"><a href="#2-构建寻优问题" class="headerlink" title="2.构建寻优问题"></a>2.构建寻优问题</h3><p>首先，定义 Problem 类型的变量，然后将构建的代价函数添加到寻优问题中。实例化对象<code>AutoDiffCostFunction</code>将创建的代价函数结构体实例作为输入，自动生成其微分并且返回一个<code>CostFunction</code> 类型的接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二部分：构建寻优问题</span></span><br><span class="line">   Problem problem;</span><br><span class="line">   CostFunction* cost_function =</span><br><span class="line">   <span class="comment">// 使用自动求导入，第一个1是输出维度，即残差的维度，第二个1是输入维度，即待寻优参数x的维度</span></span><br><span class="line">           <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor);</span><br><span class="line">   problem.<span class="built_in">AddResidualBlock</span>(cost_function, <span class="literal">NULL</span>, &amp;x); <span class="comment">//向问题中添加误差项，本问题比较简单，添加一个就行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-配置并运行求解器"><a href="#3-配置并运行求解器" class="headerlink" title="3.配置并运行求解器"></a>3.配置并运行求解器</h3><p>为求解这个优化问题，我们需要做一些配置，需要创建一个 Option，配置一下求解器的配置，创建一个 Summary。最后调用 Solve 方法，求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三部分： 配置并运行求解器</span></span><br><span class="line">    Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;<span class="comment">//输出到cout</span></span><br><span class="line">    Solver::Summary summary;<span class="comment">//优化信息</span></span><br><span class="line">    <span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);<span class="comment">//求解</span></span><br></pre></td></tr></table></figure>
<h3 id="4-输出结果"><a href="#4-输出结果" class="headerlink" title="4.输出结果"></a>4.输出结果</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//输出优化的简要信息</span></span><br><span class="line">  <span class="comment">//最终结果</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;x : &quot;</span> &lt;&lt; initial_x</span><br><span class="line">            &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>输出日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  1.250000e+01    0.00e+00    5.00e+00   0.00e+00   0.00e+00  1.00e+04        0    1.41e-05    4.20e-05</span><br><span class="line">   1  1.249750e-07    1.25e+01    5.00e-04   5.00e+00   1.00e+00  3.00e+04        1    3.10e-05    1.18e-04</span><br><span class="line">   2  1.388518e-16    1.25e-07    1.67e-08   5.00e-04   1.00e+00  9.00e+04        1    3.81e-06    1.31e-04</span><br><span class="line">Ceres Solver Report: Iterations: 3, Initial cost: 1.250000e+01, Final cost: 1.388518e-16, Termination: CONVERGENCE</span><br><span class="line">x : 5 -&gt; 10</span><br></pre></td></tr></table></figure>
<p>整体代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ceres;</span><br><span class="line"><span class="comment">//第一部分：构建代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(<span class="number">10.0</span>) - x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻优参数x的初始值，为5</span></span><br><span class="line">    <span class="keyword">double</span> initial_x = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">double</span> x = initial_x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二部分：构建寻优问题</span></span><br><span class="line">    Problem problem;</span><br><span class="line">    CostFunction* cost_function =</span><br><span class="line">            <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor); <span class="comment">//使用自动求导</span></span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, <span class="literal">NULL</span>, &amp;x); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三部分： 配置并运行求解器</span></span><br><span class="line">    Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;<span class="comment">//输出到cout</span></span><br><span class="line">    Solver::Summary summary;<span class="comment">//优化信息</span></span><br><span class="line">    <span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);<span class="comment">//求解</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//输出优化的简要信息</span></span><br><span class="line">    <span class="comment">//最终结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x : &quot;</span> &lt;&lt; initial_x</span><br><span class="line">              &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非线性优化案例"><a href="#非线性优化案例" class="headerlink" title="非线性优化案例"></a>非线性优化案例</h2><p>使用$ Ceres $拟合曲线</p>
<p>假设有一条满足以下方程的曲线：</p>
<script type="math/tex; mode=display">
y=exp(ax^2+bx+c)+w</script><p>其中$ a, b, c $为曲线的参数，$w $为高斯噪声。我们故意选择了这样一个非线性模型，以使问题不至于太简单。现在，假设我们有$ N $个关于$ x, y$ 的观测数据点，想根据这些数据点求出曲线的参数。那么，可以求解下面的最小二乘问题以估计曲线参数：</p>
<script type="math/tex; mode=display">
\underset{a,b,c}{min}\frac{1}{2}\sum^{N}_{i=1}\parallel y_i-exp(ax^2_i+bx_i+c)\parallel^2</script><p>请注意，在这个问题中，待估计的变量是 $a, b, c$，而不是$ x$。我们写一个程序，先根据模型生成 $x, y$ 的真值，然后在真值中添加高斯分布的噪声。随后，使用 $Ceres $从带噪声的数据中拟合参数模型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一部分：构建代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CURVE_FITTING_COST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构体中的自定义构造函数，同时初始化x和y(使用构造函数初始化const值，我们必须使用初始化列表)</span></span><br><span class="line">    <span class="built_in">CURVE_FITTING_COST</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 残差的计算</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="comment">// const T* const abc模型参数，有3维</span></span><br><span class="line">    <span class="comment">// T* residual      // 残差</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *<span class="keyword">const</span> abc, T *residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(_y) - ceres::<span class="built_in">exp</span>(abc[<span class="number">0</span>]* <span class="built_in">T</span>(_x)* <span class="built_in">T</span>(_x) + abc[<span class="number">1</span>] * <span class="built_in">T</span>(_x) + abc[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> _x, _y; <span class="comment">// x,y数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>, c = <span class="number">1.0</span>; <span class="comment">// 真实参数值</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;                      <span class="comment">// 数据点</span></span><br><span class="line">    <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;             <span class="comment">// 噪声Sigma值</span></span><br><span class="line">    cv::RNG rng;                      <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line">    <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;        <span class="comment">// abc参数的估计值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建存放x，y数据的容器</span></span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="comment">// 将生成100组的数据给容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;产生数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i / <span class="number">100.0</span>; <span class="comment">// x为0-1之间的100个数</span></span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(a * x * x + b * x + c) + rng.<span class="built_in">gaussian</span>(w_sigma));</span><br><span class="line">        cout &lt;&lt; x_data[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y_data[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 第二部分：构建寻优问题</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向问题中添加误差项</span></span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(</span><br><span class="line">            <span class="comment">// 使用自动求导，模板参数：误差类型，输出维度，输入维度，维数要与前面struct中一致</span></span><br><span class="line">            <span class="comment">// 第一个1是输出维度，即残差的维度，第二个3是输入维度，即待寻优参数abc的维度</span></span><br><span class="line">            <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line">                        (<span class="keyword">new</span> <span class="built_in">CURVE_FITTING_COST</span>(x_data[i], y_data[i])),</span><br><span class="line">            <span class="literal">nullptr</span>, <span class="comment">// 核函数，这里不使用，为空</span></span><br><span class="line">            abc);    <span class="comment">// 待估计参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三部分： 配置并运行求解器</span></span><br><span class="line">    ceres::Solver::Options options;               <span class="comment">// 这里有很多配置项可以填</span></span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">// 增量方程求解方法（QR）</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;  <span class="comment">// 输出到cout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化信息</span></span><br><span class="line">    ceres::Solver::Summary summary;                                                                </span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">// 计时点t1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始优化</span></span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options,&amp;problem,&amp;summary); <span class="comment">//求解!!!!</span></span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">// 计时点t2</span></span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1); <span class="comment">// 统计用时</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总计用时：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;估计的a,b,c的值为：&quot;</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : abc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( ceres_curve_fitting )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用ceres库</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找Ceres库并添加它的头文件</span></span><br><span class="line"><span class="keyword">find_package</span>( Ceres REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;CERES_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV</span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( curve_fitting ceres_curve_fitting.cpp )</span><br><span class="line"><span class="comment"># 与Ceres和OpenCV链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( curve_fitting <span class="variable">$&#123;CERES_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">产生数据：</span><br><span class="line">0 2.71828</span><br><span class="line">0.01 2.93161</span><br><span class="line">0.02 2.12942</span><br><span class="line">0.03 2.46037</span><br><span class="line">0.04 4.18814</span><br><span class="line">0.05 2.73368</span><br><span class="line">0.06 2.42751</span><br><span class="line">0.07 3.44729</span><br><span class="line">0.08 3.72543</span><br><span class="line">0.09 2.1358</span><br><span class="line">.....</span><br><span class="line">0.96 47.7941</span><br><span class="line">0.97 48.5931</span><br><span class="line">0.98 51.8487</span><br><span class="line">0.99 51.0258</span><br><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  1.824887e+04    0.00e+00    1.38e+03   0.00e+00   0.00e+00  1.00e+04        0    1.02e-04    1.95e-04</span><br><span class="line">   1  2.748700e+39   -2.75e+39    1.38e+03   7.67e+01  -1.52e+35  5.00e+03        1    1.02e-04    3.83e-04</span><br><span class="line">   2  2.429783e+39   -2.43e+39    1.38e+03   7.62e+01  -1.35e+35  1.25e+03        1    3.91e-05    4.59e-04</span><br><span class="line">   3  1.213227e+39   -1.21e+39    1.38e+03   7.30e+01  -6.73e+34  1.56e+02        1    3.29e-05    5.27e-04</span><br><span class="line">   4  1.852387e+37   -1.85e+37    1.38e+03   5.56e+01  -1.03e+33  9.77e+00        1    3.22e-05    5.87e-04</span><br><span class="line">   5  6.714689e+31   -6.71e+31    1.38e+03   2.96e+01  -3.85e+27  3.05e-01        1    3.22e-05    6.44e-04</span><br><span class="line">   6  9.500531e+12   -9.50e+12    1.38e+03   9.50e+00  -8.39e+08  4.77e-03        1    3.10e-05    7.00e-04</span><br><span class="line">   7  1.776982e+04    4.79e+02    1.83e+03   2.58e-01   1.18e+00  1.43e-02        1    1.14e-04    8.37e-04</span><br><span class="line">   8  1.599969e+04    1.77e+03    3.45e+03   5.53e-01   1.46e+00  4.29e-02        1    8.11e-05    9.54e-04</span><br><span class="line">   9  1.060557e+04    5.39e+03    7.62e+03   7.33e-01   1.68e+00  1.29e-01        1    1.30e-04    1.11e-03</span><br><span class="line">  10  3.669783e+03    6.94e+03    9.60e+03   5.25e-01   1.39e+00  3.86e-01        1    9.61e-05    1.24e-03</span><br><span class="line">  11  5.397541e+02    3.13e+03    5.00e+03   2.66e-01   1.12e+00  1.16e+00        1    8.20e-05    1.36e-03</span><br><span class="line">  12  1.484444e+02    3.91e+02    1.22e+03   8.46e-02   1.02e+00  3.48e+00        1    8.20e-05    1.48e-03</span><br><span class="line">  13  1.216815e+02    2.68e+01    3.76e+02   4.17e-02   1.01e+00  1.04e+01        1    7.39e-05    1.58e-03</span><br><span class="line">  14  9.290109e+01    2.88e+01    2.42e+02   9.10e-02   1.01e+00  3.13e+01        1    1.57e-04    1.76e-03</span><br><span class="line">  15  6.674330e+01    2.62e+01    1.09e+02   1.33e-01   1.00e+00  9.39e+01        1    1.31e-04    1.93e-03</span><br><span class="line">  16  5.936574e+01    7.38e+00    2.14e+01   1.08e-01   9.94e-01  2.82e+02        1    1.39e-04    2.10e-03</span><br><span class="line">  17  5.653118e+01    2.83e+00    1.36e+01   1.57e-01   9.98e-01  8.45e+02        1    9.11e-05    2.25e-03</span><br><span class="line">  18  5.310764e+01    3.42e+00    8.50e+00   2.81e-01   9.89e-01  2.53e+03        1    7.58e-05    2.35e-03</span><br><span class="line">  19  5.125939e+01    1.85e+00    2.84e+00   2.98e-01   9.90e-01  7.60e+03        1    7.39e-05    2.45e-03</span><br><span class="line">  20  5.097693e+01    2.82e-01    4.34e-01   1.48e-01   9.95e-01  2.28e+04        1    7.41e-05    2.54e-03</span><br><span class="line">  21  5.096854e+01    8.39e-03    3.24e-02   2.87e-02   9.96e-01  6.84e+04        1    7.30e-05    2.64e-03</span><br><span class="line">总计用时：0.00273015</span><br><span class="line">Ceres Solver Report: Iterations: 22, Initial cost: 1.824887e+04, Final cost: 5.096854e+01, Termination: CONVERGENCE</span><br><span class="line">估计的a,b,c的值为：0.891943 2.17039 0.944142 </span><br></pre></td></tr></table></figure>
<p>从 Ceres 给出的优化过程中可以看到，整体误差从 18248 左右下降到了 50.9，并且梯度也是越来越小。在迭代 22 次后算法收敛，最后的估计值为：</p>
<script type="math/tex; mode=display">
a=0.891943, b=2.17039, c=0.944142</script><p>与真实值比较接近。</p>
<p><img src="/images/使用Ceres拟合曲线/Ceres.PNG" alt="Ceres"></p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>Ceres</tag>
      </tags>
  </entry>
  <entry>
    <title>ch5_拼接点云(PCL库)</title>
    <url>/posts/44975.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>程序提供了五张 RGB-D 图像，并且知道了每个图像的内参和外参。根据 RGB-D 图像和相机内参，我们可以计算任何一个像素在相机坐标系下的位置。同时，根据相机位姿，又能计算这些像素在世界坐标系下的位置。如果把所有像素的空间坐标都求出来，相当于构建一张类似于地图的东西。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>pose.txt 文件给出了五张图像的相机位姿（以 $T_{wc} $形式）。位姿记录的形式是平移向量加旋转四元数：<br>$[x, y, z, q_x , q_y , q_z , q_w ]$,其中 $q_w $是四元数的实部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-0.228993 0.00645704 0.0287837 -0.0004327 -0.113131 -0.0326832 0.993042</span><br><span class="line">-0.50237 -0.0661803 0.322012 -0.00152174 -0.32441 -0.0783827 0.942662</span><br><span class="line">-0.970912 -0.185889 0.872353 -0.00662576 -0.278681 -0.0736078 0.957536</span><br><span class="line">-1.41952 -0.279885 1.43657 -0.00926933 -0.222761 -0.0567118 0.973178</span><br><span class="line">-1.55819 -0.301094 1.6215 -0.02707 -0.250946 -0.0412848 0.966741</span><br></pre></td></tr></table></figure>
<p>案例主要完成两件事：</p>
<p>(1). 根据内参计算一对 RGB-D 图像对应的点云；<br>(2). 根据各张图的相机位姿（也就是外参），把点云加起来，组成地图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/format.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;cv::Mat&gt; colorImgs, depthImgs; <span class="comment">// 彩色图和深度图</span></span><br><span class="line">    <span class="comment">// 定义相机位姿容器  用来存储相机位姿</span></span><br><span class="line">    vector&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses;</span><br><span class="line">    <span class="comment">// 读入五张图像的相机位姿（以 Twc 形式）</span></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;./pose.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;请在有pose.txt的目录下运行此程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入五张图片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">boost::format <span class="title">fmt</span><span class="params">(<span class="string">&quot;./%s/%d.%s&quot;</span>)</span></span>; <span class="comment">//图像文件格式</span></span><br><span class="line">        <span class="comment">// 读入彩色图放进容器中</span></span><br><span class="line">        colorImgs.<span class="built_in">push_back</span>(cv::<span class="built_in">imread</span>((fmt % <span class="string">&quot;color&quot;</span> % (i + <span class="number">1</span>) % <span class="string">&quot;png&quot;</span>).<span class="built_in">str</span>()));</span><br><span class="line">        <span class="comment">// 读入深度图放进容器中</span></span><br><span class="line">        depthImgs.<span class="built_in">push_back</span>(cv::<span class="built_in">imread</span>((fmt % <span class="string">&quot;depth&quot;</span> % (i + <span class="number">1</span>) % <span class="string">&quot;pgm&quot;</span>).<span class="built_in">str</span>(), <span class="number">-1</span>)); <span class="comment">// 使用-1读取原始图像</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读入pose中的位姿记录（位姿记录的形式是平移向量加旋转四元数）</span></span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;d : data)</span><br><span class="line">            fin &gt;&gt; d;</span><br><span class="line">        <span class="function">Eigen::Quaterniond <span class="title">q</span><span class="params">(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span></span>; <span class="comment">// qw qx qy qz</span></span><br><span class="line">        <span class="function">Eigen::Isometry3d <span class="title">T</span><span class="params">(q)</span></span>;                                   <span class="comment">// 由四元数构造变换矩阵T</span></span><br><span class="line">        <span class="comment">// 平移</span></span><br><span class="line">        T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])); <span class="comment">// x y z pretanslate 相当于左乘</span></span><br><span class="line">        <span class="comment">// 将位姿信息传入位姿容器</span></span><br><span class="line">        poses.<span class="built_in">push_back</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算点云并拼接</span></span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">double</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">double</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">double</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">double</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">double</span> depthScale = <span class="number">1000.0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正在将图像转换为点云...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义点云使用的格式：这里用的是XYZRGB</span></span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointXYZRGB PointT;</span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointCloud&lt;PointT&gt; PointCloud;</span><br><span class="line">    <span class="comment">// 新建一个点云</span></span><br><span class="line">    <span class="function">PointCloud::Ptr <span class="title">pointCloud</span><span class="params">(<span class="keyword">new</span> PointCloud)</span></span>;</span><br><span class="line">    <span class="comment">// 循环每一张图片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;张图像转换中&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cv::Mat color = colorImgs[i]; <span class="comment">// 读取彩色图</span></span><br><span class="line">        cv::Mat depth = depthImgs[i]; <span class="comment">// 读取对应的深度图</span></span><br><span class="line">        Eigen::Isometry3d T = poses[i]; <span class="comment">// 读入相机位姿</span></span><br><span class="line">        <span class="comment">// 将像素坐标转根据相机位姿换成世界坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; color.rows; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; color.cols; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> d = depth.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(v)[u]; <span class="comment">// 深度值</span></span><br><span class="line">                <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 为0表示没有测量到</span></span><br><span class="line">                Eigen::Vector3d point;</span><br><span class="line">                point[<span class="number">2</span>] = <span class="built_in"><span class="keyword">double</span></span>(d) / depthScale;   <span class="comment">// Z</span></span><br><span class="line">                point[<span class="number">0</span>] = (u - cx) * point[<span class="number">2</span>] / fx; <span class="comment">// X</span></span><br><span class="line">                point[<span class="number">1</span>] = (v - cy) * point[<span class="number">2</span>] / fy; <span class="comment">// Y</span></span><br><span class="line">                Eigen::Vector3d pointWorld = T * point; <span class="comment">// 得到世界坐标系下的点云</span></span><br><span class="line"></span><br><span class="line">                PointT p; <span class="comment">// XYZRGB类型的p</span></span><br><span class="line">                <span class="comment">// 前三位存储点云的世界坐标</span></span><br><span class="line">                p.x = pointWorld[<span class="number">0</span>];</span><br><span class="line">                p.y = pointWorld[<span class="number">1</span>];</span><br><span class="line">                p.z = pointWorld[<span class="number">2</span>]; </span><br><span class="line">                <span class="comment">// 后三位存储点云的bgr值</span></span><br><span class="line">                p.b = color.data[v * color.step + u * color.<span class="built_in">channels</span>()];</span><br><span class="line">                p.g = color.data[v * color.step + u * color.<span class="built_in">channels</span>() + <span class="number">1</span>];</span><br><span class="line">                p.r = color.data[v * color.step + u * color.<span class="built_in">channels</span>() + <span class="number">2</span>]; </span><br><span class="line">                pointCloud-&gt;points.<span class="built_in">push_back</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pointCloud-&gt;is_dense = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点云一共有&quot;</span> &lt;&lt; pointCloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个点。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileBinary</span>(<span class="string">&quot;myPCL.pcd&quot;</span>,*pointCloud);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( joinMap )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="comment"># opencv </span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># eigen </span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3/&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># pcl </span></span><br><span class="line"><span class="keyword">find_package</span>( PCL REQUIRED COMPONENT common io )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;PCL_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"><span class="keyword">add_definitions</span>( <span class="variable">$&#123;PCL_DEFINITIONS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( joinMap joinMap.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( joinMap <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure>
<p><img src="/images/拼接点云-PCL库/PCL.PNG" alt="PCL"></p>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>PCL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenCV操作图像</title>
    <url>/posts/53401.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>OpenCV 提供了大量的开源图像算法，是计算机视觉中使用极广的图像处理算法库。在ubuntu 下，你可以选择从源代码安装和只安装库文件两种方式。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>源代码安装：</p>
<p>从 <a href="http://opencv.org/downloads.html">http://opencv.org/downloads.html</a> 中下载，选择 OpenCV for Linux 版本即可</p>
<p>在编译之前，先来安装 OpenCV 的依赖项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential libgtk2.0-dev libvtk5-dev libjpeg-dev libtiff4-dev libjasper-dev libopenexr-dev libtbb-dev</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cnake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取argv[1]指定的图像</span></span><br><span class="line">    cv::Mat image;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(argv[<span class="number">1</span>]); <span class="comment">// cv::imread函数读取指定路径下的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据不存在,可能是文件不存在</span></span><br><span class="line">    <span class="keyword">if</span> (image.data == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cerr：输出到标准错误的ostream对象，常用于程序错误信息；</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;文件&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件顺利读取, 首先输出一些基本信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图像的宽为：&quot;</span> &lt;&lt; image.cols</span><br><span class="line">         &lt;&lt; <span class="string">&quot;,高为：&quot;</span> &lt;&lt; image.rows</span><br><span class="line">         &lt;&lt; <span class="string">&quot;通道数为：&quot;</span> &lt;&lt; image.<span class="built_in">channels</span>() &lt;&lt; endl;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, image); <span class="comment">// 用cv::imshow显示图像</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);             <span class="comment">// 暂停程序,等待一个按键输入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断image的类型</span></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">type</span>() != CV_8UC1 &amp;&amp; image.<span class="built_in">type</span>() != CV_8UC3) <span class="comment">// 图像既不是单通道也不是三通道</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 图像类型不符合要求</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入一张彩色图或者灰度图&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历图像, 请注意以下遍历方式亦可使用于随机像素访问</span></span><br><span class="line">    <span class="comment">// 使用 std::chrono 来给算法计时</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> y = <span class="number">0</span>; y &lt; image.rows; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用cv::Mat::ptr获得图像的行指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *row_ptr = image.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(y); <span class="comment">// row_ptr是第y行的头指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> x = <span class="number">0</span>; x &lt; image.cols; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 访问位于 x,y 处的像素</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *data_ptr = &amp;row_ptr[x * image.<span class="built_in">channels</span>()]; <span class="comment">// data_ptr 指向待访问的像素数据</span></span><br><span class="line">            <span class="comment">// 输出该像素的每个通道,如果是灰度图就只有一个通道</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != image.<span class="built_in">channels</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> data = data_ptr[i]; <span class="comment">// data为I(x,y)第c个通道的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;遍历图像用时：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; 秒。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关于 cv::Mat 的拷贝</span></span><br><span class="line">    <span class="comment">// 直接赋值并不会拷贝数据,使用clone函数来拷贝数据</span></span><br><span class="line">    cv::Mat image_clone = image.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="built_in">image_clone</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>) ).<span class="built_in">setTo</span>(<span class="number">0</span>); <span class="comment">// 将左上角100*100的块置零</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image_clone&quot;</span>,image_clone);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CMakeLsits.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( imageBasics )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加c++ 14标准支持</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找OpenCV库</span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3</span> REQUIRED )</span><br><span class="line"><span class="comment"># 添加头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( imageBasics imageBasics.cpp )</span><br><span class="line"><span class="comment"># 链接OpenCV库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( imageBasics <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Sophus库</title>
    <url>/posts/42633.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Sophus是直接在 Eigen 基础上开发的，我们不需要要安装额外的依赖库。由于历史原因，Sophus 早期版本只提供了双精度的李群/李代数类。后续版本改写成了模板类。模板类的 Sophus 中可以使用不同精度的李群/李代数，但同时增加了使用难度。这里使用的是非模板类。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="comment">// 这里使用的是绝对路径，所以在CMakeLsits.txt里并没有包含Sophus库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/alvin/workspace/slam_ws/slambook/3rdparty/Sophus/sophus/so3.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/alvin/workspace/slam_ws/slambook/3rdparty/Sophus/sophus/se3.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 沿Z轴转45s度的旋转矩阵</span></span><br><span class="line">    Eigen::Matrix3d R = Eigen::<span class="built_in">AngleAxisd</span>(M_PI / <span class="number">4</span>, Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)).<span class="built_in">matrix</span>();</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>); <span class="comment">//保留三位小数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R = &quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造李群</span></span><br><span class="line">    <span class="function">Sophus::SO3 <span class="title">SO3_R</span><span class="params">(R)</span></span>;              <span class="comment">// Sophus::SO(3)可以直接从旋转矩阵构造</span></span><br><span class="line">    <span class="function">Sophus::SO3 <span class="title">SO3_v</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, M_PI / <span class="number">4</span>)</span></span>; <span class="comment">// 亦可从旋转向量构造</span></span><br><span class="line">    <span class="function">Eigen::Quaterniond <span class="title">q</span><span class="params">(R)</span></span>;           <span class="comment">// 或者四元数</span></span><br><span class="line">    <span class="function">Sophus::SO3 <span class="title">SO3_q</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="comment">// 上述表达方式都是等价的</span></span><br><span class="line">    <span class="comment">// 输出SO(3)时，以so(3)形式输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从旋转矩阵构造SO(3): &quot;</span> &lt;&lt; SO3_R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从旋转向量构造SO(3): &quot;</span> &lt;&lt; SO3_v &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从四元数构造SO(3):&quot;</span> &lt;&lt; SO3_q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用对数映射获得它的李代数</span></span><br><span class="line">    Eigen::Vector3d so3 = SO3_R.<span class="built_in">log</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SO3的李代数so3：&quot;</span> &lt;&lt; so3.<span class="built_in">transpose</span>() &lt;&lt; endl; <span class="comment">// transpose纯粹是为了输出美观一些</span></span><br><span class="line">    <span class="comment">// hat 为向量到反对称矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;so3的反对称矩阵：\n&quot;</span></span><br><span class="line">         &lt;&lt; Sophus::SO3::<span class="built_in">hat</span>(so3) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 相对的，vee为反对称到向量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反对称矩阵到其向量：\n&quot;</span></span><br><span class="line">         &lt;&lt; Sophus::SO3::<span class="built_in">vee</span>(Sophus::SO3::<span class="built_in">hat</span>(so3)).<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">    ; <span class="comment">// transpose纯粹是为了输出美观一些</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量扰动模型的更新</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">update_so3</span><span class="params">(<span class="number">1e-4</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">//假设更新量为这么多</span></span><br><span class="line">    Sophus::SO3 SO3_update = Sophus::SO3::<span class="built_in">exp</span>(update_so3) * SO3_R;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SO3 updated = \n&quot;</span></span><br><span class="line">         &lt;&lt; SO3_update &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;************SE*************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3d R1 = Eigen::<span class="built_in">AngleAxisd</span>(M_PI / <span class="number">4</span>, Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)).<span class="built_in">matrix</span>();</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 沿X轴平移1</span></span><br><span class="line">    <span class="function">Sophus::SE3 <span class="title">SE3_Rt</span><span class="params">(R1, t)</span></span>;  <span class="comment">// 从R,t构造SE(3)</span></span><br><span class="line">    <span class="function">Sophus::SE3 <span class="title">SE3_qt</span><span class="params">(q, t)</span></span>;   <span class="comment">// 从q,t构造SE(3)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从R,t构造的SE：\n&quot;</span></span><br><span class="line">         &lt;&lt; SE3_Rt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从q,t构造的SE：\n&quot;</span></span><br><span class="line">         &lt;&lt; SE3_qt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 李代数se(3) 是一个六维向量，方便起见先typedef一下</span></span><br><span class="line">    <span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Vector6d;</span><br><span class="line">    Vector6d se3 = SE3_Rt.<span class="built_in">log</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se3:\n&quot;</span></span><br><span class="line">         &lt;&lt; se3.<span class="built_in">transpose</span>() &lt;&lt; endl; <span class="comment">// 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样的，有hat和vee两个算符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se3的反对称矩阵：\n&quot;</span> &lt;&lt; Sophus::SE3::<span class="built_in">hat</span>(se3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se3反对称矩阵到其向量：\n&quot;</span> &lt;&lt; Sophus::SE3::<span class="built_in">vee</span>( Sophus::SE3::<span class="built_in">hat</span>(se3) ).<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，演示一下更新</span></span><br><span class="line">    Vector6d update_se3;<span class="comment">//更新量</span></span><br><span class="line">    update_se3.<span class="built_in">setZero</span>();</span><br><span class="line">    <span class="built_in">update_se3</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">1e-4</span>d;</span><br><span class="line">    Sophus::SE3 SE3_updated = Sophus::SE3::<span class="built_in">exp</span>(update_se3)*SE3_Rt;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SE3 updated = \n&quot;</span> &lt;&lt; SE3_updated.<span class="built_in">matrix</span>() &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(useSophus)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(useSophus useSophus.cpp)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>Sophus</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Eigen几何模块</title>
    <url>/posts/26147.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>导入Eigen几何模块，可以使用四元数、欧拉角和旋转矩阵。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="comment">// Eigen 几何模块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"> * 本程序演示了 Eigen 几何模块的使用方法</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Eigen/Geometry 模块提供了各种旋转和平移的表示</span></span><br><span class="line">    <span class="comment">// 3D 旋转矩阵直接使用 Matrix3d 或 Matrix3f</span></span><br><span class="line">    Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::<span class="built_in">Identity</span>(); <span class="comment">// 定义一个单位阵</span></span><br><span class="line">    <span class="comment">// 旋转向量使用 AngleAxis, 它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符）</span></span><br><span class="line">    <span class="function">Eigen::AngleAxisd <span class="title">rotation_vector</span><span class="params">(M_PI / <span class="number">4</span>, Eigen::Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>; <span class="comment">//沿 Z 轴旋转 45 度</span></span><br><span class="line"></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>); <span class="comment">// 保留三位小数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rotation matrix =\n&quot;</span></span><br><span class="line">         &lt;&lt; rotation_vector.<span class="built_in">matrix</span>() &lt;&lt; endl; <span class="comment">//用matrix()转换成矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接赋值</span></span><br><span class="line">    rotation_matrix = rotation_vector.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; rotation_matrix &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 AngleAxis 可以进行坐标变换</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    Eigen::Vector3d v_rotated = rotation_vector * v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在变换后的坐标系下表示：&quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 或者用旋转矩阵</span></span><br><span class="line">    v_rotated = rotation_matrix * v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在变换后的坐标系下表示：&quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧拉角: 可以将旋转矩阵直接转换成欧拉角</span></span><br><span class="line">    Eigen::Vector3d euler_angles = rotation_matrix.<span class="built_in">eulerAngles</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// ZYX顺序，即roll pitch yaw顺序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;旋转矩阵转换成欧拉角：&quot;</span> &lt;&lt; euler_angles.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧氏变换矩阵使用 Eigen::Isometry</span></span><br><span class="line">    Eigen::Isometry3d T = Eigen::Isometry3d::<span class="built_in">Identity</span>(); <span class="comment">// 虽然称为3d，实质上是4＊4的矩阵(齐次坐标)</span></span><br><span class="line">    cout &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">rotate</span>(rotation_vector); <span class="comment">// 按照rotation_vector进行旋转</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T绕rotation_vector旋转后：&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 把平移向量设成(1,3,4)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T按照(1,3,4)平移后：&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用变换矩阵进行坐标变换</span></span><br><span class="line">    Eigen::Vector3d v_transformed = T * v; <span class="comment">// 相当于R*v+t</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在经过T变换后的坐标系下表示：&quot;</span> &lt;&lt; v_transformed.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四元数</span></span><br><span class="line">    <span class="comment">// 可以直接把AngleAxis赋值给四元数，反之亦然</span></span><br><span class="line">    Eigen::Quaterniond q = Eigen::<span class="built_in">Quaterniond</span>(rotation_vector);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;quaternion = \n&quot;</span></span><br><span class="line">         &lt;&lt; q.<span class="built_in">coeffs</span>() &lt;&lt; endl; <span class="comment">// 请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以把旋转矩阵赋给它</span></span><br><span class="line">    q = Eigen::<span class="built_in">Quaterniond</span>(rotation_matrix);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;四元数：&quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用四元数旋转一个向量，使用重载的乘法即可</span></span><br><span class="line">    v_rotated = q * v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在经过四元数变换后的坐标系下表示：&quot;</span> &lt;&lt; v_transformed.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLsits.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( geometry )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Eigen头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( eigenGeometry eigenGeometry.cpp )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Eigen基础模块</title>
    <url>/posts/6957.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Eigen是一个 C++ 开源线性代数库。它提供了快速的有关矩阵的线性代数运算，还包括解方程等功能。许多上层的软件库也使用 Eigen 进行矩阵运算，包括 g2o、Sophus 等。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>官方文档：<a href="https://eigen.tuxfamily.org/dox/">https://eigen.tuxfamily.org/dox/</a></p>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="comment">// Eigen 部分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="comment">// 稠密矩阵的代数运算（逆，特征值等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"> * 本程序演示了 Eigen 基本类型的使用</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Eigen 中所有向量和矩阵都是Eigen::Matrix，它是一个模板类。它的前三个参数为：数据类型，行，列</span></span><br><span class="line">    <span class="comment">// 声明一个2*3的float矩阵</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">3</span>&gt; matrix_23;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，Eigen 通过 typedef 提供了许多内置类型，不过底层仍是Eigen::Matrix</span></span><br><span class="line">    <span class="comment">// 例如 Vector3d 实质上是 Eigen::Matrix&lt;double, 3, 1&gt;，即三维向量</span></span><br><span class="line">    Eigen::Vector3d v_3d;</span><br><span class="line">    <span class="comment">// 这是一样的</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">1</span>&gt; vd_3d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Matrix3d 实质上是 Eigen::Matrix&lt;double, 3, 3&gt;</span></span><br><span class="line">    Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::<span class="built_in">Zero</span>(); <span class="comment">//初始化为零</span></span><br><span class="line">    <span class="comment">// 如果不确定矩阵大小，可以使用动态大小的矩阵</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, Eigen::Dynamic, Eigen::Dynamic&gt; matrix_dynamic;</span><br><span class="line">    <span class="comment">// 更简单的</span></span><br><span class="line">    Eigen::MatrixXd matrix_x;</span><br><span class="line">    <span class="comment">// 这种类型还有很多，我们不一一列举</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是对Eigen阵的操作</span></span><br><span class="line">    <span class="comment">// 输入数据（初始化）</span></span><br><span class="line">    matrix_23 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; matrix_23 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用()访问矩阵中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">matrix_23</span>(i, j) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵和向量相乘（实际上仍是矩阵和矩阵）</span></span><br><span class="line">    v_3d &lt;&lt; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line">    vd_3d &lt;&lt; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 但是在Eigen里你不能混合两种不同类型的矩阵，像这样是错的</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix&lt;double, 2, 1&gt; result_wrong_type = matrix_23 * v_3d;</span></span><br><span class="line">    <span class="comment">// 应该显式转换</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result = matrix_23.cast&lt;<span class="keyword">double</span>&gt;() * v_3d;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result2 = matrix_23 * vd_3d;</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样你不能搞错矩阵的维度</span></span><br><span class="line">    <span class="comment">// 试着取消下面的注释，看看Eigen会报什么错</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix&lt;double, 2, 3&gt; result_wrong_dimension = matrix_23.cast&lt;double&gt;() * v_3d;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些矩阵运算</span></span><br><span class="line">    <span class="comment">// 四则运算就不演示了，直接用+-*/即可。</span></span><br><span class="line">    matrix_33 = Eigen::Matrix3d::<span class="built_in">Random</span>(); <span class="comment">// 随机数矩阵</span></span><br><span class="line">    cout &lt;&lt; matrix_33 &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">transpose</span>() &lt;&lt; endl;   <span class="comment">// 转置</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">sum</span>() &lt;&lt; endl;         <span class="comment">// 各元素和</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">trace</span>() &lt;&lt; endl;       <span class="comment">// 迹</span></span><br><span class="line">    cout &lt;&lt; <span class="number">10</span> * matrix_33 &lt;&lt; endl;          <span class="comment">// 数乘</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">inverse</span>() &lt;&lt; endl;     <span class="comment">// 逆</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">determinant</span>() &lt;&lt; endl; <span class="comment">// 行列式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( useEigen )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Eigen头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>( eigenMatrix eigenMatrix.cpp )</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">./eigenMatrix</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">1       2       3</span><br><span class="line">4       5       6</span><br><span class="line">10</span><br><span class="line">28</span><br><span class="line">32</span><br><span class="line">77</span><br><span class="line"> 0.680375   0.59688 -0.329554</span><br><span class="line">-0.211234  0.823295  0.536459</span><br><span class="line"> 0.566198 -0.604897 -0.444451</span><br><span class="line"></span><br><span class="line"> 0.680375 -0.211234  0.566198</span><br><span class="line">  0.59688  0.823295 -0.604897</span><br><span class="line">-0.329554  0.536459 -0.444451</span><br><span class="line">1.61307</span><br><span class="line">1.05922</span><br><span class="line"> 6.80375   5.9688 -3.29554</span><br><span class="line">-2.11234  8.23295  5.36459</span><br><span class="line"> 5.66198 -6.04897 -4.44451</span><br><span class="line">-0.198521   2.22739    2.8357</span><br><span class="line">  1.00605 -0.555135  -1.41603</span><br><span class="line"> -1.62213   3.59308   3.28973</span><br><span class="line">0.208598</span><br><span class="line">Eigen values = </span><br><span class="line">0.0242899</span><br><span class="line"> 0.992154</span><br><span class="line">  1.80558</span><br><span class="line">Eigen vectors = </span><br><span class="line">-0.549013 -0.735943  0.396198</span><br><span class="line"> 0.253452 -0.598296 -0.760134</span><br><span class="line">-0.796459  0.316906 -0.514998</span><br><span class="line">time use <span class="keyword">in</span> normal inverse is 0.682ms</span><br><span class="line">time use <span class="keyword">in</span> Qr decomposition is 0.363ms</span><br></pre></td></tr></table></figure>
<h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><h5 id="1-LU三角分解"><a href="#1-LU三角分解" class="headerlink" title="(1)LU三角分解"></a>(1)LU三角分解</h5><p>三角分解法是仅对方阵有效，将原方阵分解成一个上三角形矩阵或是排列(permuted)的<strong>上三角形矩阵</strong>和一个<strong>下三角形矩阵</strong>，这样的分解法又称为LU分解法。它的用途主要在简化一个大矩阵的行列式值的计算过程、求反矩阵和求解联立方程组。不过要注意这种分解法所得到的上下三角形矩阵并非唯一，还可找到数个不同的一对上下三角形矩阵，此两三角形矩阵相乘也会得到原矩阵。<code>[L,U]=lu(A)</code></p>
<h5 id="2-QR分解"><a href="#2-QR分解" class="headerlink" title="(2)QR分解"></a>(2)QR分解</h5><p>QR分解法对象不一定是方阵，其将矩阵分解成一个<strong>正规正交矩</strong>阵与上<strong>三角形矩阵</strong>,所以称为QR分解法,与此正规正交矩阵的通用符号Q有关。<code>[Q,R]=qr(A)</code></p>
<h5 id="3-SVD分解"><a href="#3-SVD分解" class="headerlink" title="(3)SVD分解"></a>(3)SVD分解</h5><p>奇异值分解(singular value decomposition,SVD)是另一种正交矩阵分解法；SVD是最可靠的分解法，但是它比QR分解法要花上近十倍的计算时间。<code>[U,S,V]=svd(A)</code>，其中U和V分别代表两个正交矩阵，而S代表一对角矩阵。和QR分解法相同，原矩阵A不必为方阵。使用SVD分解法的用途是解最小平方误差法和数据压缩。</p>
<h5 id="4-LLT分解"><a href="#4-LLT分解" class="headerlink" title="(4)LLT分解"></a>(4)LLT分解</h5><p>又称Cholesky分解，其把一个对称正定的矩阵表示成一个<strong>下三角矩阵L</strong>和<strong>其转置</strong>的乘积的分解。它要求矩阵为方阵，且所有特征值必须大于零，故分解的下三角的对角元也是大于零的(LU三角分解法的变形)。$A=LL^T$</p>
<h5 id="5-LDLT分解"><a href="#5-LDLT分解" class="headerlink" title="(5)LDLT分解"></a>(5)LDLT分解</h5><p>LDLT分解法实际上是Cholesky分解法的改进，因为Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题，可用于求解线性方程组。 也需要分解对象为方阵，分解结果为$A=LDL^T$。其中L为一下三角形单位矩阵(即主对角线元素皆为1)，D为一对角矩阵(只在主对角线上有元素，其余皆为零)，$L^T$为L的转置矩阵。</p>
<h2 id="求解方程组"><a href="#求解方程组" class="headerlink" title="求解方程组"></a>求解方程组</h2><h3 id="求解特征向量与特征值"><a href="#求解特征向量与特征值" class="headerlink" title="求解特征向量与特征值"></a>求解特征向量与特征值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*******求解矩阵的特征向量和特征值*******&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 实对称矩阵可以保证对角化成功,但是也要考虑无法对角化的情况</span></span><br><span class="line">    Eigen::Matrix2f A;</span><br><span class="line">    A &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">    <span class="function">Eigen::EigenSolver&lt;Eigen::Matrix2f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() == Eigen::Success)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;特征值：&quot;</span> &lt;&lt; endl &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;特征向量：&quot;</span> &lt;&lt; endl &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;矩阵不可以对角化&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h3><p>线代中形如<code>Ax=b</code>的线性方程组是最简单的入门示例。对于常规适定的线性方程组(未知数个数=方程个数)，可以采用常规的矩阵分解法求解。在Eigen中有多种解法可供选择，以满足在精度与效率上不同的需求。有如下方程组：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
1x_1 + 2x_2+3x_3 & =  3 \\
4x_1 + 5x_2+6x_3 & =  3 \\
7x_1 + 8x_2+10x_3 & =  4
\end{aligned}
\right.</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*******求解线性方程组*******&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3f A1;</span><br><span class="line">    Eigen::Vector3f b;</span><br><span class="line">    A1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>;</span><br><span class="line">    b &lt;&lt; <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> time_stt = <span class="built_in">clock</span>();</span><br><span class="line">    Eigen::Vector3f x;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;QR分解&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A1.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(b) &lt;&lt; endl; <span class="comment">// QR分解</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总计用时：&quot;</span> &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt) / (<span class="keyword">double</span>)CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码调用了<code>.colPivHouseholderQr()</code>函数对方程进行求解。Eigen中所有不同方法调用都有固定的格式：<code>x = A.methodName().solve(b)</code>，如下是Eigen中一些常用方法的比较，根据需要选择不同方法。</p>
<p><img src="./img/2019-08-22-01.PNG" alt="img"></p>
<p>Eigen还可以解一些长的比较“奇怪”的方程组(如x、b并不是向量而是矩阵)，如下方程组：</p>
<script type="math/tex; mode=display">
\left( \begin{matrix} 
2  & -1 \\
-1 & 3
\end{matrix}\right)
\left( \begin{matrix} 
x_1 & x_2 \\
x_3 & x_4
\end{matrix}\right)
=
\left( \begin{matrix} 
1 & 2 \\
3 & 1
\end{matrix}\right)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 Eigen::Matrix2f A0, b0;</span><br><span class="line">    A0 &lt;&lt; <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>;</span><br><span class="line">    b0 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">clock_t</span> time_stt0 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LDLT分解&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A0.<span class="built_in">ldlt</span>().<span class="built_in">solve</span>(b0) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总计用时：&quot;</span> &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt0) / (<span class="keyword">double</span>)CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>SLAM实践</tag>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>了解cmake编译_hello world</title>
    <url>/posts/58756.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>理论上说，任意一个 C++ 程序都可以用 g++ 来编译。但当程序规模越来越大时，一个工程可能有许多个文件夹和里边的源文件，这时输入的编译命令将越来越长。通常一个小型 c++ 项目含有十几个类，各类间还存在着复杂的依赖关系。其中一部分要编译成可执行文件，另一部分编译成库文件。如果仅靠 g++ 命令，我们需要输入大量的编译指令，整个编译过程会变得异常繁琐。因此，对于 C++ 项目，使用一些工程管理工具会更加高效。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>库文件：用来存放函数或者类中函数的具体实现</p>
<p>在一个 C++ 工程中，并不是所有代码都会编译成可执行文件。只有带有 main 函数的文件才会生成可执行程序。而另一些代码，我们只想把它们打包成一个东西，供其他程序调用。这个东西叫做库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个库文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello SLAM&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于库的使用者，只要拿到了头文件和库文件，就可以调用这个库了。</p>
<p>头文件：存放方法或者类相关的声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="comment">// 上面的宏定义是为了防止重复引用这个头文件而引起的重定义错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>主函数：main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libHelloSLAM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 libHelloSLAM.h 中的 printHello() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们需要使用CMakeLists.txt文件帮助我们进行编译</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明要求的 cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个 cmake 工程</span></span><br><span class="line"><span class="keyword">project</span>( HelloSLAM )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译模式</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个库</span></span><br><span class="line"><span class="keyword">add_library</span>( hello libHelloSLAM.cpp )</span><br><span class="line"><span class="comment"># 共享库</span></span><br><span class="line"><span class="keyword">add_library</span>( hello_shared SHARED libHelloSLAM.cpp )</span><br><span class="line"><span class="comment"># 将库文件链接到可执行程序上</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( useHello hello_shared )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( useHello useHello.cpp )</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM十四讲</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>fatal  error ‘xxxx’ was not declared in this scope</title>
    <url>/posts/13732.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>运行slam14_ch3代码visualizeGeometry报错error: ‘xxxx’ was not declared in this scope</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><img src="/images/&quot;xxx&quot;is not std/image-20220426122937681.png" alt="image-20220426122937681"></p>
<p>亲测方案：CMakeLists.txt 添加 set(CMAKE_CXX_STANDARD 14)<br>或者：set(CMAKE_CXX_FLAGS “-std=c++14 -O2 ${SSE_FLAGS} -msse4”) </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( visualizeGeometry )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Eigen头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Pangolin依赖</span></span><br><span class="line"><span class="keyword">find_package</span>( Pangolin )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;Pangolin_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( visualizeGeometry visualizeGeometry.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( visualizeGeometry <span class="variable">$&#123;Pangolin_LIBRARIES&#125;</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>fatal error Eigen/Core No such file or directory</title>
    <url>/posts/53697.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>已添加eigen库的路径到IncludePath，include<Eigen/Dense>也没有小灯泡，可是编译出错：fatal error: Eigen/Dense: No such file or directory </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><img src="/images/eigen报错/image-20220426123112788.png" alt="image-20220426123112788"></p>
<h1 id="方案一-修改vscode配置文件"><a href="#方案一-修改vscode配置文件" class="headerlink" title="方案一:修改vscode配置文件"></a>方案一:修改vscode配置文件</h1><ol>
<li><p>添加eigen库的路径到IncludePath. （c_cpp_properties.json）</p>
<blockquote>
<p>“/usr/include/eigen3/**”,<br>“/usr/include/eigen3/“         </p>
</blockquote>
</li>
</ol>
<p><img src="/images/eigen报错/image-20220426123147968.png" alt="image-20220426123147968" style="zoom:33%;" /></p>
<p>vscode中c_cpp_properties.json的”includePath”告诉vscode插件在哪里找到头文件，便于进行源码查看和debug，并没有告诉gcc编译器这个路径。</p>
<ol>
<li>添加eigen库的路径到编译参数”args”.（tasks.json）</li>
</ol>
<p>在”args”里加入如下代码,task：”args”负责gcc等编译器的编译指令。</p>
<blockquote>
<p>“-I”,</p>
<p>“/usr/include/eigen3”</p>
</blockquote>
<p><img src="/images/eigen报错/image-20220426123215807.png" alt="image-20220426123215807" style="zoom:50%;" /></p>
<h1 id="方案二-使用命令"><a href="#方案二-使用命令" class="headerlink" title="方案二:使用命令"></a>方案二:使用命令</h1><p>命令<code>g++ eigenMatrix.cpp  -I /usr/include/eigen3 -o main</code>的意思就是编译代码,指定头文件位置,并输出可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/slam_ws/ch3/useEigen$ g++ eigenMatrix.cpp  -I /usr/include/eigen3 -o main</span><br><span class="line">alvin@ros:~/slam_ws/ch3/useEigen$ ./main </span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure>
<h1 id="方案三-使用CMake"><a href="#方案三-使用CMake" class="headerlink" title="方案三:使用CMake"></a>方案三:使用CMake</h1><p>用vscode编写这类的调用第三方，其实最好的方式是用cmake，</p>
<p>首先，配置c_cpp_properties.json中的includepath，这里配置的目的只是为了在vscode里没有红色波浪线，看起来美观。</p>
<p>这里和方案一的第一步是一样的!</p>
<p>项目结构如下：</p>
<p><img src="/images/eigen报错/image-20220426123236573.png" alt="image-20220426123236573" style="zoom: 50%;" /></p>
<p>CMakeLists.txt内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>.<span class="number">11</span>)</span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(/usr/<span class="keyword">include</span>/eigen3)</span><br><span class="line"><span class="keyword">add_executable</span> (eigenMatrix eigenMatrix.cpp)</span><br></pre></td></tr></table></figure>
<p>运行代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./eigenMatrix</span><br></pre></td></tr></table></figure>
<p><img src="/images/eigen报错/image-20220426123337819.png" alt="image-20220426123337819" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>gazebo加载world出现黑屏问题</title>
    <url>/posts/34779.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>近期发在gazebo在加载一些world环境时,总是出现下面黑屏的情况,这是因为model库加载不正确导致的</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><img src="/images/gazebo加载world出现黑屏问题/image-20220430102858532.png" alt="image-20220430102858532"></p>
<p>解决方法： 通过直接下载所有模型到用户的根目录下的.gazebo/models/下 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.gazebo/</span><br><span class="line">$ mkdir -p models</span><br><span class="line">$ <span class="built_in">cd</span> ~/.gazebo/models/</span><br><span class="line">$ wget http://file.ncnynl.com/ros/gazebo_models.txt</span><br><span class="line">$ wget -i gazebo_models.txt</span><br><span class="line">$ ls model.tar.g* | xargs -n1 tar xzvf</span><br></pre></td></tr></table></figure>
<p><img src="/images/gazebo加载world出现黑屏问题/image-20220430102920945.png" alt="image-20220430102920945" style="zoom:50%;" /></p>
<p>解决</p>
<p><img src="/images/gazebo加载world出现黑屏问题/image-20220430102953161.png" alt="image-20220430102953161"></p>
]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title>turtlebot3仿真实践</title>
    <url>/posts/62093.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>TurtleBot3 是一个小型，低成本，完全可编程，基于 ROS 的移动机器人。 它旨在用于教育，研究，产品原型和爱好应用的目的。TurtleBot3 的目标是大幅降低平台的尺寸和价格，而不会牺牲性能，功能和质量。由于提供了其他选项，如底盘，计算机和传感器，TurtleBot3 可以通过各种方式进行定制。TurtleBot3 意愿通过应用 SBC（单板计算机），深度传感器和 3D 打印的最新技术进步，成为创客运动的中心。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="下载turtlebot3仿真包"><a href="#下载turtlebot3仿真包" class="headerlink" title="下载turtlebot3仿真包"></a>下载turtlebot3仿真包</h1><ul>
<li>环境准备</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ros-noetic-turtlebot3 ros-noetic-turtlebot3-description ros-noetic-turtlebot3-gazebo ros-noetic-turtlebot3-msgs ros-noetic-turtlebot3-slam ros-noetic-turtlebot3-teleop</span><br></pre></td></tr></table></figure>
<p>以上会避免之后问题里出现的报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src/</span><br><span class="line">$ git <span class="built_in">clone</span> -b noetic-devel https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git</span><br><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure>
<ul>
<li>问题:turtlebot3_msgs报错</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws &amp;&amp; catkin_make</span><br><span class="line">Could not find a package configuration file provided by</span><br><span class="line"><span class="string">&quot;turtlebot3_msgs&quot;</span> with any of the following names:</span><br><span class="line"> </span><br><span class="line">turtlebot3_msgsConfig.cmake</span><br><span class="line">turtlebot3_msgs-config.cmake</span><br><span class="line"> </span><br><span class="line">Add the installation prefix of <span class="string">&quot;turtlebot3_msgs&quot;</span> to CMAKE_PREFIX_PATH or <span class="built_in">set</span> <span class="string">&quot;turtlebot3_msg_DIR&quot;</span> to a directory containing one of the above files.</span><br></pre></td></tr></table></figure>
<p>解决方案:这是因为缺少相关的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-turtlebot3-msgs</span><br></pre></td></tr></table></figure>
<h2 id="Empty-World"><a href="#Empty-World" class="headerlink" title="Empty World"></a>Empty World</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=burger</span><br><span class="line">$ roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch</span><br></pre></td></tr></table></figure>
<ul>
<li>问题:Resource not found: turtlebot3_description</li>
</ul>
<p><img src="/images/turtlebot3仿真实践/image-20220426124059347.png" alt="image-20220426124059347"></p>
<p>解决方案:这种情况的发生是因为turtlebot3_gazebo包没有对<code>turtlebot3_description</code>声名依赖,你应该安装一下这个依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros-noetic-turtlebot3-description</span><br></pre></td></tr></table></figure>
<p>其他版本的ros可以尝试更换<code>noetic</code>为你当前的版本</p>
<p>参考链接:<a href="https://answers.ros.org/question/348299/error-in-roslaunch-turtlebot3_gazebo-turtlebot3_worldlaunch/"><strong>Error in “roslaunch turtlebot3_gazebo turtlebot3_world.launch “</strong></a></p>
<p><img src="/images/turtlebot3仿真实践/image-20220426124124556.png" alt="image-20220426124124556"></p>
<h2 id="TurtleBot3-World"><a href="#TurtleBot3-World" class="headerlink" title="TurtleBot3 World"></a>TurtleBot3 World</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=waffle</span><br><span class="line">$ roslaunch turtlebot3_gazebo turtlebot3_world.launch</span><br></pre></td></tr></table></figure>
<p><img src="/images/turtlebot3仿真实践/image-20220426124142934.png" alt="image-20220426124142934"></p>
<h2 id="TurtleBot3-House"><a href="#TurtleBot3-House" class="headerlink" title="TurtleBot3 House"></a>TurtleBot3 House</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=waffle_pi</span><br><span class="line">$ roslaunch turtlebot3_gazebo turtlebot3_house.launch</span><br></pre></td></tr></table></figure>
<p><img src="/images/turtlebot3仿真实践/image-20220426124203261.png" alt="image-20220426124203261"></p>
<h1 id="SLAM仿真"><a href="#SLAM仿真" class="headerlink" title="SLAM仿真"></a>SLAM仿真</h1><p>在 Gazebo 模拟器中进行 SLAM 时，您可以在虚拟世界中选择或创建各种环境和机器人模型。 除了准备模拟环境而不是启动机器人之外，SLAM 仿真与实际的 TurtleBot3 的SLAM非常相似。</p>
<h2 id="加载仿真环境"><a href="#加载仿真环境" class="headerlink" title="加载仿真环境"></a>加载仿真环境</h2><p>准备了三个 Gazebo 环境，但要使用 SLAM 创建地图，建议使用 <strong>TurtleBot3 World</strong> 或 <strong>TurtleBot3 House</strong>。<br>使用以下命令之一加载 Gazebo 环境。</p>
<p>在本指令中，将使用 TurtleBot3 World。<br>请在 <code>burger</code>、<code>waffle</code>、<code>waffle_pi</code> 中为 <code>TURTLEBOT3_MODEL</code> 参数使用正确的关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=waffle_pi</span><br><span class="line">$ roslaunch turtlebot3_gazebo turtlebot3_house.launch</span><br></pre></td></tr></table></figure>
<h2 id="运行SLAM节点"><a href="#运行SLAM节点" class="headerlink" title="运行SLAM节点"></a>运行SLAM节点</h2><p>从远程 PC 使用 <code>Ctrl</code> + <code>Alt</code> + <code>T</code> 打开一个新终端并运行 SLAM 节点。 默认使用 Gmapping SLAM 方法。<br>请在 <code>burger</code>、<code>waffle</code>、<code>waffle_pi</code> 中为 <code>TURTLEBOT3_MODEL</code> 参数使用正确的关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=burger</span><br><span class="line">$ roslaunch turtlebot3_slam turtlebot3_slam.launch slam_methods:=gmapping</span><br></pre></td></tr></table></figure>
<h2 id="运行键盘控制节点"><a href="#运行键盘控制节点" class="headerlink" title="运行键盘控制节点"></a>运行键盘控制节点</h2><p>使用<code>Ctrl</code>+<code>Alt</code>+<code>T</code>从远程 PC 打开一个新终端，然后从远程 PC 运行远程操作节点。<br>请在 <code>burger</code>、<code>waffle</code>、<code>waffle_pi</code> 中为 <code>TURTLEBOT3_MODEL</code> 参数使用正确的关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=burger</span><br><span class="line">$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</span><br><span class="line"></span><br><span class="line"> Control Your TurtleBot3!</span><br><span class="line"> ---------------------------</span><br><span class="line"> Moving around:</span><br><span class="line">        w</span><br><span class="line">   a    s    d</span><br><span class="line">        x</span><br><span class="line"></span><br><span class="line"> w/x : increase/decrease linear velocity</span><br><span class="line"> a/d : increase/decrease angular velocity</span><br><span class="line"> space key, s : force stop</span><br><span class="line"></span><br><span class="line"> CTRL-C to quit</span><br></pre></td></tr></table></figure>
<p><img src="/images/turtlebot3仿真实践/image-20220426124227125.png" alt="image-20220426124227125"></p>
<h1 id="导航仿真"><a href="#导航仿真" class="headerlink" title="导航仿真"></a>导航仿真</h1><p>就像 Gazebo 模拟器中的 SLAM 一样，你可以在虚拟导航世界中选择或创建各种环境和机器人模型。 但是，在运行导航之前必须准备适当的地图。 除了准备仿真环境而不是制作机器人之外，仿真导航与实际的导航非常相似。</p>
<h2 id="加载仿真环境-1"><a href="#加载仿真环境-1" class="headerlink" title="加载仿真环境"></a>加载仿真环境</h2><p>在前面的 SLAM 部分中，TurtleBot3 World 用于创建地图。 导航将使用相同的 Gazebo 环境。请在 burger、waffle、waffle_pi 中为 TURTLEBOT3_MODEL 参数使用正确的关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=burger</span><br><span class="line">$ roslaunch turtlebot3_gazebo turtlebot3_world.launch</span><br></pre></td></tr></table></figure>
<h2 id="运行导航节点"><a href="#运行导航节点" class="headerlink" title="运行导航节点"></a>运行导航节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TURTLEBOT3_MODEL=burger</span><br><span class="line">$ roslaunch turtlebot3_navigation turtlebot3_navigation.launch map_file:=<span class="variable">$HOME</span>/map.yaml</span><br></pre></td></tr></table></figure>
<h2 id="初始姿态估计"><a href="#初始姿态估计" class="headerlink" title="初始姿态估计"></a>初始姿态估计</h2><p>必须在运行导航之前执行初始姿态估计，因为此过程会初始化对导航至关重要的 AMCL 参数。 TurtleBot3 必须正确定位在地图上，LDS 传感器数据与显示的地图整齐地重叠。</p>
<p>单击 RViz 菜单中的 2D Pose Estimate 按钮。</p>
<p>单击实际机器人所在的地图，然后将绿色大箭头拖向机器人面向的方向。</p>
<p>重复步骤 1 和 2，直到 LDS 传感器数据覆盖在保存的地图上。</p>
<p>启动键盘遥操作节点，在地图上精确定位机器人。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>gazebo</tag>
        <tag>ros</tag>
        <tag>机器人仿真</tag>
        <tag>turtlebot3</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人仿真实践_gazebo+rviz综合实践</title>
    <url>/posts/29275.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>URDF 用于创建机器人模型、Rviz 可以显示机器人感知到的环境信息，Gazebo 用于仿真，可以模拟外界环境，以及机器人的一些传感器，如何在 Gazebo 中运行这些传感器，并显示这些传感器的数据(机器人的视角)呢？</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="实践一-机器人运动控制"><a href="#实践一-机器人运动控制" class="headerlink" title="实践一:机器人运动控制"></a>实践一:机器人运动控制</h1><h2 id="1-ros-control-简介"><a href="#1-ros-control-简介" class="headerlink" title="1.ros_control 简介"></a>1.ros_control 简介</h2><p><strong>场景:</strong> 同一套 ROS 程序，如何部署在不同的机器人系统上，比如：开发阶段为了提高效率是在仿真平台上测试的，部署时又有不同的实体机器人平台，不同平台的实现是有差异的，如何保证 ROS 程序的可移植性？ROS 内置的解决方式是 ros_control。</p>
<p><strong>ros_control:</strong> 是一组软件包，它包含了控制器接口，控制器管理器，传输和硬件接口。ros_control 是一套机器人控制的中间件，是一套规范，不同的机器人平台只要按照这套规范实现，那么就可以保证 与ROS 程序兼容，通过这套规范，实现了一种可插拔的架构设计，大大提高了程序设计的效率与灵活性。</p>
<p>gazebo 已经实现了 ros_control 的相关接口，如果需要在 gazebo 中控制机器人运动，直接调用相关接口即可</p>
<h2 id="2-运动控制实现流程-Gazebo"><a href="#2-运动控制实现流程-Gazebo" class="headerlink" title="2.运动控制实现流程(Gazebo)"></a>2.运动控制实现流程(Gazebo)</h2><p>承上，运动控制基本流程:</p>
<ol>
<li>已经创建完毕的机器人模型，编写一个单独的 xacro 文件，为机器人模型添加传动装置以及控制器</li>
<li>将此文件集成进xacro文件</li>
<li>启动 Gazebo 并发布 /cmd_vel 消息控制机器人运动</li>
</ol>
<p><strong>2.1 为 joint 添加传动装置以及控制器</strong></p>
<p>两轮差速配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_move&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 传动实现:用于连接控制器与关节 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;joint_trans&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Transmission is important to link the joints and the controller --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_trans&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_motor&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 每一个驱动轮都需要配置传动装置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;left_wheel2base_link&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;right_wheel2base_link&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;differential_drive_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rosDebugLevel</span>&gt;</span>Debug<span class="tag">&lt;/<span class="name">rosDebugLevel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">publishWheelTF</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelTF</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">publishTf</span>&gt;</span>1<span class="tag">&lt;/<span class="name">publishTf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">publishWheelJointState</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelJointState</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>100.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legacyMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">legacyMode</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">leftJoint</span>&gt;</span>left_wheel2base_link<span class="tag">&lt;/<span class="name">leftJoint</span>&gt;</span> <span class="comment">&lt;!-- 左轮 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rightJoint</span>&gt;</span>right_wheel2base_link<span class="tag">&lt;/<span class="name">rightJoint</span>&gt;</span> <span class="comment">&lt;!-- 右轮 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelSeparation</span>&gt;</span>$&#123;base_link_radius * 2&#125;<span class="tag">&lt;/<span class="name">wheelSeparation</span>&gt;</span> <span class="comment">&lt;!-- 车轮间距 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelDiameter</span>&gt;</span>$&#123;wheel_radius * 2&#125;<span class="tag">&lt;/<span class="name">wheelDiameter</span>&gt;</span> <span class="comment">&lt;!-- 车轮直径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">broadcastTF</span>&gt;</span>1<span class="tag">&lt;/<span class="name">broadcastTF</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelTorque</span>&gt;</span>30<span class="tag">&lt;/<span class="name">wheelTorque</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wheelAcceleration</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">wheelAcceleration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">commandTopic</span>&gt;</span>cmd_vel<span class="tag">&lt;/<span class="name">commandTopic</span>&gt;</span> <span class="comment">&lt;!-- 运动控制话题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">odometryFrame</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryFrame</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">odometryTopic</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryTopic</span>&gt;</span> <span class="comment">&lt;!-- 里程计话题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">robotBaseFrame</span>&gt;</span>base_footprint<span class="tag">&lt;/<span class="name">robotBaseFrame</span>&gt;</span> <span class="comment">&lt;!-- 根坐标系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.2 xacro文件集成</strong></p>
<p>最后还需要将上述 xacro 文件集成进总的机器人模型文件，代码示例如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组合小车底盘与摄像头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;matrix.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;move.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.3 启动 gazebo并控制机器人运动</strong></p>
<p>launch文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find robot_simlink_gazebo)/urdf/xacro/combine.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动 launch 文件，使用 topic list 查看话题列表，会发现多了 /cmd_vel 然后发布 cmd_vel 消息控制即可</p>
<p>使用命令控制(或者可以编写单独的节点控制)<code>rosrun teleop_twist_keyboard teleop_twist_keyboard.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~$ rosrun teleop_twist_keyboard teleop_twist_keyboard.py </span><br><span class="line">the rosdep view is empty: call <span class="string">&#x27;sudo rosdep init&#x27;</span> and <span class="string">&#x27;rosdep update&#x27;</span></span><br><span class="line"></span><br><span class="line">Reading from the keyboard  and Publishing to Twist!</span><br><span class="line">---------------------------</span><br><span class="line">Moving around:</span><br><span class="line">   u    i    o</span><br><span class="line">   j    k    l</span><br><span class="line">   m    ,    .</span><br><span class="line"></span><br><span class="line">For Holonomic mode (strafing), hold down the <span class="built_in">shift</span> key:</span><br><span class="line">---------------------------</span><br><span class="line">   U    I    O</span><br><span class="line">   J    K    L</span><br><span class="line">   M    &lt;    &gt;</span><br><span class="line"></span><br><span class="line">t : up (+z)</span><br><span class="line">b : down (-z)</span><br><span class="line"></span><br><span class="line">anything <span class="keyword">else</span> : stop</span><br><span class="line"></span><br><span class="line">q/z : increase/decrease max speeds by 10%</span><br><span class="line">w/x : increase/decrease only linear speed by 10%</span><br><span class="line">e/c : increase/decrease only angular speed by 10%</span><br><span class="line"></span><br><span class="line">CTRL-C to quit</span><br><span class="line"></span><br><span class="line">currently:	speed 0.5	turn 1.0 </span><br></pre></td></tr></table></figure>
<p>在 Gazebo 的仿真环境中，机器人的里程计信息以及运动朝向等信息是无法获取的，可以通过 Rviz 显示机器人的里程计信息以及运动朝向</p>
<p><strong>里程计:</strong> 机器人相对出发点坐标系的位姿状态(X 坐标 Y 坐标 Z坐标以及朝向)。</p>
<p>修改launch文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find robot_simlink_gazebo)/urdf/xacro/combine.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 启动 rviz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 关节以及机器人状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="实践二-雷达仿真"><a href="#实践二-雷达仿真" class="headerlink" title="实践二:雷达仿真"></a>实践二:雷达仿真</h1><p>雷达传感器数据信息xacro</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 雷达 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rplidar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visualize</span>&gt;</span>true<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>5.5<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ray</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scan</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">samples</span>&gt;</span>360<span class="tag">&lt;/<span class="name">samples</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>1<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">min_angle</span>&gt;</span>-3<span class="tag">&lt;/<span class="name">min_angle</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_angle</span>&gt;</span>3<span class="tag">&lt;/<span class="name">max_angle</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">horizontal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">scan</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">range</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">min</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">min</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">max</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">max</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">range</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ray</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_rplidar&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_laser.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">topicName</span>&gt;</span>/scan<span class="tag">&lt;/<span class="name">topicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>laser<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在原来的集成的xacro添加该文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组合小车底盘与摄像头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;matrix.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;move.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser_senor.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动原来的launch文件</p>
<h1 id="实践三-摄像头仿真"><a href="#实践三-摄像头仿真" class="headerlink" title="实践三:摄像头仿真"></a>实践三:摄像头仿真</h1><h2 id="普通摄像头仿真"><a href="#普通摄像头仿真" class="headerlink" title="普通摄像头仿真"></a>普通摄像头仿真</h2><p>配置摄像头传感器信息xacro</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用的link --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 类型设置为 camara --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;camera&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera_node&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span> <span class="comment">&lt;!-- 更新频率 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 摄像头基本信息设置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">name</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>1.3962634<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">width</span>&gt;</span>1280<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">height</span>&gt;</span>720<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.02<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">far</span>&gt;</span>300<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.007<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 核心插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_camera&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_camera.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>/camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hackBaseline</span>&gt;</span>0.07<span class="tag">&lt;/<span class="name">hackBaseline</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在原来的集成的xacro添加该文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组合小车底盘与摄像头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;matrix.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;move.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser_senor.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera_senor.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动原来的launch文件</p>
<h2 id="kinect摄像头仿真"><a href="#kinect摄像头仿真" class="headerlink" title="kinect摄像头仿真"></a>kinect摄像头仿真</h2><p>配置 kinetic传感器信息xacro</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;support&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;depth&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">always_on</span>&gt;</span>true<span class="tag">&lt;/<span class="name">always_on</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">camera</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>$&#123;60.0*PI/180.0&#125;<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">width</span>&gt;</span>640<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">height</span>&gt;</span>480<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.05<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">far</span>&gt;</span>8.0<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;kinect_camera_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_openni_kinect.so&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>10<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>rgb/image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageTopicName</span>&gt;</span>depth/image_raw<span class="tag">&lt;/<span class="name">depthImageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudTopicName</span>&gt;</span>depth/points<span class="tag">&lt;/<span class="name">pointCloudTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>rgb/camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageCameraInfoTopicName</span>&gt;</span>depth/camera_info<span class="tag">&lt;/<span class="name">depthImageCameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 此处为了防止与camera混淆,采用support当作深度相机 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>support<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">baseline</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">baseline</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudCutoff</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">pointCloudCutoff</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在原来的集成的xacro添加该文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组合小车底盘与摄像头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;matrix.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;move.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser_senor.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera_senor.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;kinect_senor.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动原来的launch文件</p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>gazebo</tag>
        <tag>ros</tag>
        <tag>机器人仿真</tag>
        <tag>rviz</tag>
        <tag>xacro</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人仿真实践_gazebo中搭建</title>
    <url>/posts/46778.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:URDF 需要集成进 Rviz 或 Gazebo 才能显示可视化的机器人模型,因此我们可以结合gazebo实现一下案例:创建一个四轮圆柱状机器人模型，机器人参数如下,底盘为圆柱状，半径 10cm，高 8cm，四轮由两个驱动轮和两个万向支撑轮组成，两个驱动轮半径为 3.25cm,轮胎宽度1.5cm，两个万向轮为球状，半径 0.75cm，底盘离地间距为 1.5cm(与万向轮直径一致)</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="URDF集成gazebo的流程"><a href="#URDF集成gazebo的流程" class="headerlink" title="URDF集成gazebo的流程"></a>URDF集成gazebo的流程</h1><p><strong>URDF与Gazebo基本集成流程</strong></p>
<p>URDF 与 Gazebo 集成流程与 Rviz 实现类似，主要步骤如下:</p>
<ol>
<li>创建功能包，导入依赖项</li>
<li>编写 URDF 或 Xacro 文件</li>
<li>启动 Gazebo 并显示机器人模型</li>
</ol>
<p><strong>注意， 当 URDF 需要与 Gazebo 集成时，和 Rviz 有明显区别:</strong></p>
<p>1.必须使用 collision 标签，因为既然是仿真环境，那么必然涉及到碰撞检测，collision 提供碰撞检测的依据。</p>
<p>2.必须使用 inertial 标签，此标签标注了当前机器人某个刚体部分的惯性矩阵，用于一些力学相关的仿真计算。</p>
<p>3.颜色设置，也需要重新使用 gazebo 标签标注，因为之前的颜色设置为了方便调试包含透明度，仿真环境下没有此选项。</p>
<p><strong>1.collision</strong></p>
<p>如果机器人link是标准的几何体形状，和link的 visual 属性设置一致即可。</p>
<p><strong>2.inertial</strong></p>
<p>惯性矩阵的设置需要结合link的质量与外形参数动态生成，标准的球体、圆柱与立方体的惯性矩阵公式如下(已经封装为 xacro 实现):</p>
<p>球体惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Macro for inertia matrix --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;sphere_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>圆柱惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;cylinder_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r h&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">iyz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>立方体惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;Box_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m l w h&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(w*w + l*l)/12&#125;&quot;</span> <span class="attr">iyz</span>= <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，原则上，除了 base_footprint 外，机器人的每个刚体部分都需要设置惯性矩阵，且惯性矩阵必须经计算得出，如果随意定义刚体部分的惯性矩阵，那么可能会导致机器人在 Gazebo 中出现抖动，移动等现象。</p>
<p>3.<strong>颜色设置</strong></p>
<p>在 gazebo 中显示 link 的颜色，必须要使用指定的标签:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link节点名称&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Blue<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="gazebo仿真实践"><a href="#gazebo仿真实践" class="headerlink" title="gazebo仿真实践"></a>gazebo仿真实践</h1><h2 id="惯性矩阵xacro"><a href="#惯性矩阵xacro" class="headerlink" title="惯性矩阵xacro"></a>惯性矩阵xacro</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Macro for inertia matrix --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;sphere_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;cylinder_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r h&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">iyz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;Box_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m l w h&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(w*w + l*l)/12&#125;&quot;</span> <span class="attr">iyz</span>= <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="小车底盘xacro"><a href="#小车底盘xacro" class="headerlink" title="小车底盘xacro"></a>小车底盘xacro</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    使用 xacro 优化 URDF 版的小车底盘实现：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现思路:</span></span><br><span class="line"><span class="comment">    1.将一些常量、变量封装为 xacro:property</span></span><br><span class="line"><span class="comment">      比如:PI 值、小车底盘半径、离地间距、车轮半径、宽度 ....</span></span><br><span class="line"><span class="comment">    2.使用 宏 封装驱动轮以及支撑轮实现，调用相关宏生成驱动轮与支撑轮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根标签，必须声明 xmlns:xacro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_base&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 封装变量、常量 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- PI 值设置精度需要高一些，否则后续车轮翻转量计算时，可能会出现肉眼不能察觉的车轮倾斜，从而导致模型抖动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.1415926&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 宏:黑色设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 底盘属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_footprint 半径  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_link 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_link 长 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;earth_space&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 离地间距 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 质量  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 底盘 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_footprint_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.5 0.3 0.0 0.5&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:cylinder_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;base_link_m&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;base_link2base_footprint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_footprint&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 $&#123;earth_space + base_link_length / 2 &#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Yellow<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0325&quot;</span> /&gt;</span><span class="comment">&lt;!-- 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span><span class="comment">&lt;!-- 宽度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 质量  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮宏实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;add_wheels&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name flag&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;PI / 2&#125; 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;PI / 2&#125; 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xacro:cylinder_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;wheel_m&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 $&#123;flag * base_link_radius&#125; $&#123;-(earth_space + base_link_length / 2 - wheel_radius) &#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_wheels</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_wheels</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0075&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支撑轮半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_wheel_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.03&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 质量  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮宏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;add_support_wheel&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name flag&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xacro:sphere_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;support_wheel_m&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;flag * (base_link_radius - support_wheel_radius)&#125; 0 $&#123;-(base_link_length / 2 + earth_space / 2)&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">name</span>=<span class="string">&quot;front&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">name</span>=<span class="string">&quot;back&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>雷达xacro</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    使用 xacro 优化 URDF 版的小车底盘实现：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现思路:</span></span><br><span class="line"><span class="comment">    1.将一些常量、变量封装为 xacro:property</span></span><br><span class="line"><span class="comment">      比如:PI 值、小车底盘半径、离地间距、车轮半径、宽度 ....</span></span><br><span class="line"><span class="comment">    2.使用 宏 封装驱动轮以及支撑轮实现，调用相关宏生成驱动轮与支撑轮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根标签，必须声明 xmlns:xacro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_base&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 封装变量、常量 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- PI 值设置精度需要高一些，否则后续车轮翻转量计算时，可能会出现肉眼不能察觉的车轮倾斜，从而导致模型抖动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.1415926&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 宏:黑色设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 底盘属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_footprint 半径  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_link 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_link 长 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;earth_space&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 离地间距 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 质量  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 底盘 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_footprint_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.5 0.3 0.0 0.5&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:cylinder_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;base_link_m&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;base_link2base_footprint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_footprint&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 $&#123;earth_space + base_link_length / 2 &#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Yellow<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0325&quot;</span> /&gt;</span><span class="comment">&lt;!-- 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span><span class="comment">&lt;!-- 宽度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 质量  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮宏实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;add_wheels&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name flag&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;PI / 2&#125; 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;PI / 2&#125; 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xacro:cylinder_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;wheel_m&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 $&#123;flag * base_link_radius&#125; $&#123;-(earth_space + base_link_length / 2 - wheel_radius) &#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_wheels</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_wheels</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0075&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支撑轮半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_wheel_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.03&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 质量  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮宏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;add_support_wheel&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name flag&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xacro:sphere_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;support_wheel_m&#125;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;flag * (base_link_radius - support_wheel_radius)&#125; 0 $&#123;-(base_link_length / 2 + earth_space / 2)&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">name</span>=<span class="string">&quot;front&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">name</span>=<span class="string">&quot;back&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="相机xacro"><a href="#相机xacro" class="headerlink" title="相机xacro"></a>相机xacro</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 摄像头属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头长度(x) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.025&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头宽度(y) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_height&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.025&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头高度(z) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;base_link_length / 2 + camera_height / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的z坐标:底盘高度 / 2 + 摄像头高度 / 2  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_m&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头质量 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 摄像头关节以及link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;camera_length&#125; $&#123;camera_width&#125; $&#123;camera_height&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;camera_length&#125; $&#123;camera_width&#125; $&#123;camera_height&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xacro:Box_inertial_matrix</span> <span class="attr">m</span>=<span class="string">&quot;$&#123;camera_m&#125;&quot;</span> <span class="attr">l</span>=<span class="string">&quot;$&#123;camera_length&#125;&quot;</span> <span class="attr">w</span>=<span class="string">&quot;$&#123;camera_width&#125;&quot;</span> <span class="attr">h</span>=<span class="string">&quot;$&#123;camera_height&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;camera2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;camera&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;camera_x&#125; $&#123;camera_y&#125; $&#123;camera_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Blue<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="组合底盘-相机-雷达xacro"><a href="#组合底盘-相机-雷达xacro" class="headerlink" title="组合底盘\相机\雷达xacro"></a>组合底盘\相机\雷达xacro</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组合小车底盘与摄像头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;matrix.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;base.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a>launch文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find robot_simlink_gazebo)/urdf/xacro/combine.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>gazebo</tag>
        <tag>ros</tag>
        <tag>机器人仿真</tag>
        <tag>xacro</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人仿真实践_XACRO搭建机器人</title>
    <url>/posts/30241.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:创建一个四轮圆柱状机器人模型，机器人参数如下,底盘为圆柱状，半径 10cm，高 8cm，四轮由两个驱动轮和两个万向支撑轮组成，两个驱动轮半径为 3.25cm,轮胎宽度1.5cm，两个万向轮为球状，半径 0.75cm，底盘离地间距为 1.5cm(与万向轮直径一致)</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>在上述案例之中,使用urdf搭建机器人发现复用性差,而且参数被有很好的分离出来,很难进行管理和维护.因此引入xacro文件,在使用xacro进行优化之后思考如何引入摄像头和雷达.</p>
<h1 id="编写XACRO文件"><a href="#编写XACRO文件" class="headerlink" title="编写XACRO文件"></a>编写XACRO文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    使用 xacro 优化 URDF 版的小车底盘实现：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现思路:</span></span><br><span class="line"><span class="comment">    1.将一些常量、变量封装为 xacro:property</span></span><br><span class="line"><span class="comment">      比如:PI 值、小车底盘半径、离地间距、车轮半径、宽度 ....</span></span><br><span class="line"><span class="comment">    2.使用 宏 封装驱动轮以及支撑轮实现，调用相关宏生成驱动轮与支撑轮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根标签，必须声明 xmlns:xacro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_base&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 封装变量、常量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.141&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 宏:黑色设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 底盘属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_footprint 半径  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_link 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span> <span class="comment">&lt;!-- base_link 长 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;earth_space&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 离地间距 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 底盘 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_footprint_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;base_link_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.5 0.3 0.0 0.5&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;base_link2base_footprint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_footprint&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 $&#123;earth_space + base_link_length / 2 &#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0325&quot;</span> /&gt;</span><span class="comment">&lt;!-- 半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span><span class="comment">&lt;!-- 宽度 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动轮宏实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;add_wheels&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name flag&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;$&#123;PI / 2&#125; 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 $&#123;flag * base_link_radius&#125; $&#123;-(earth_space + base_link_length / 2 - wheel_radius) &#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_wheels</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_wheels</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0075&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支撑轮半径 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 支撑轮宏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;add_support_wheel&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name flag&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;flag * (base_link_radius - support_wheel_radius)&#125; 0 $&#123;-(base_link_length / 2 + earth_space / 2)&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">name</span>=<span class="string">&quot;front&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:add_support_wheel</span> <span class="attr">name</span>=<span class="string">&quot;back&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="在-launch-中加载-xacro文件"><a href="#在-launch-中加载-xacro文件" class="headerlink" title="在 launch 中加载 xacro文件"></a>在 launch 中加载 xacro文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find robot_simlink_rviz)/urdf/xacro/robot_xacro.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加坐标系和机器人模型,然后就可以看到搭建的小车模型.</p>
<p>我们也可以保存生成的rviz文件,以便二次打开反复添加参数,File/save config as…</p>
<p>修改launch文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载robot_description时使用command属性，属性值就是调用 xacro 功能包的 xacro 程序直接解析 xacro 文件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find robot_simlink_rviz)/urdf/xacro/robot_xacro.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_simlink_rviz)/config/robot_xacro.rviz&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事实上,还可以通过将xacro文件转换成对应的urdf文件,然后在launch文件里执行urdf文件即可</p>
<p>转换的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun xacro xacro xxx.xacro &gt; xxx.urdf</span><br></pre></td></tr></table></figure>
<h1 id="添加雷达和摄像头"><a href="#添加雷达和摄像头" class="headerlink" title="添加雷达和摄像头"></a>添加雷达和摄像头</h1><p><strong>实现流程:</strong></p>
<ol>
<li>首先编写摄像头和雷达的 xacro 文件</li>
<li>然后再编写一个组合文件，组合底盘、摄像头与雷达</li>
<li>最后，通过 launch 文件启动 Rviz 并显示模型</li>
</ol>
<h2 id="摄像头-xacro-文件"><a href="#摄像头-xacro-文件" class="headerlink" title="摄像头 xacro 文件:"></a>摄像头 xacro 文件:</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 摄像头相关的 xacro 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 摄像头属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头长度(x) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.025&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头宽度(y) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_height&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.025&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头高度(z) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;camera_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;base_link_length / 2 + camera_height / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 摄像头安装的z坐标:底盘高度 / 2 + 摄像头高度 / 2  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 摄像头关节以及link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;camera_length&#125; $&#123;camera_width&#125; $&#123;camera_height&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;camera2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;camera&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;camera_x&#125; $&#123;camera_y&#125; $&#123;camera_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="雷达-xacro-文件"><a href="#雷达-xacro-文件" class="headerlink" title="雷达 xacro 文件:"></a>雷达 xacro 文件:</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    小车底盘添加雷达</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_laser&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 雷达支架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.15&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;support_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;base_link_length / 2 + support_length / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 支架安装的z坐标:底盘高度 / 2 + 支架高度 / 2  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;support&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;support_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;support_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.8 0.2 0.0 0.8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;support2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;support&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;support_x&#125; $&#123;support_y&#125; $&#123;support_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 雷达属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.03&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达半径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_x&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达安装的x坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_y&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达安装的y坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;laser_z&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;support_length / 2 + laser_length / 2&#125;&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 雷达安装的z坐标:支架高度 / 2 + 雷达高度 / 2  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 雷达关节以及link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;laser_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;laser_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;laser2support&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;support&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;laser&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;laser_x&#125; $&#123;laser_y&#125; $&#123;laser_z&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="组合底盘摄像头与雷达的-xacro-文件"><a href="#组合底盘摄像头与雷达的-xacro-文件" class="headerlink" title="组合底盘摄像头与雷达的 xacro 文件"></a>组合底盘摄像头与雷达的 xacro 文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组合小车底盘与摄像头与雷达 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_car_camera&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;robot_xacro.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;laser.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;camera.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="launch-文件"><a href="#launch-文件" class="headerlink" title="launch 文件"></a>launch 文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find robot_simlink_rviz)/urdf/xacro/combine.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>机器人仿真</tag>
        <tag>rviz</tag>
        <tag>xacro</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人仿真实践_URDF搭建机器人</title>
    <url>/posts/32353.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:创建一个四轮圆柱状机器人模型，机器人参数如下,底盘为圆柱状，半径 10cm，高 8cm，四轮由两个驱动轮和两个万向支撑轮组成，两个驱动轮半径为 3.25cm,轮胎宽度1.5cm，两个万向轮为球状，半径 0.75cm，底盘离地间距为 1.5cm(与万向轮直径一致)</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><strong>实现流程:</strong></p>
<p>创建机器人模型可以分步骤实现</p>
<ol>
<li>新建 urdf 文件，并与 launch 文件集成</li>
<li>搭建底盘</li>
<li>在底盘上添加两个驱动轮</li>
<li>在底盘上添加两个万向轮</li>
</ol>
<h1 id="新建urdf以及launch文件"><a href="#新建urdf以及launch文件" class="headerlink" title="新建urdf以及launch文件"></a>新建urdf以及launch文件</h1><p>urdf 文件:基本实现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;mycar&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置 base_footprint  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.001&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加底盘 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加驱动轮 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加万向轮(支撑轮) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>robot</p>
<blockquote>
<p>urdf 中为了保证 xml 语法的完整性，使用了<code>robot</code>标签作为根标签，所有的 link 和 joint 以及其他标签都必须包含在 robot 标签内,在该标签内可以通过 name 属性设置机器人模型的名称\</p>
</blockquote>
<p>name: </p>
<blockquote>
<p>指定机器人模型的名称</p>
</blockquote>
<p>link</p>
<blockquote>
<p> urdf 中的 link 标签用于描述机器人某个部件(也即刚体部分)的外观和物理属性，比如: 机器人底座、轮子、激光雷达、摄像头…每一个部件都对应一个 link, 在 link 标签内，可以设计该部件的形状、尺寸、颜色、惯性矩阵、碰撞参数等一系列属性</p>
<blockquote>
<ul>
<li>name —-&gt; 为连杆命名</li>
<li><p>visual —-&gt; 描述外观(对应的数据是可视的) </p>
</li>
<li><ul>
<li><strong>geometry 设置连杆的形状</strong> </li>
</ul>
</li>
<li><ul>
<li><ul>
<li>标签1: box(盒状) </li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>属性:size=长(x) 宽(y) 高(z)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>标签2: cylinder(圆柱) </li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>属性:radius=半径 length=高度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>标签3: sphere(球体) </li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>属性:radius=半径</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>标签4: mesh(为连杆添加皮肤) </li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>属性: filename=资源路径(格式:<strong>package:////文件</strong>)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>origin 设置偏移量与倾斜弧度</strong> </li>
</ul>
</li>
<li><ul>
<li><ul>
<li>属性1: xyz=x偏移 y便宜 z偏移</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>属性2: rpy=x翻滚 y俯仰 z偏航 (单位是弧度)</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>metrial 设置材料属性(颜色)</strong> </li>
</ul>
</li>
<li><ul>
<li><ul>
<li>属性: name</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>标签: color </li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>属性: rgba=红绿蓝权重值与透明度 (每个权重值以及透明度取值[0,1])</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>collision —-&gt; 连杆的碰撞属性</p>
</li>
<li><p>Inertial —-&gt; 连杆的惯性矩阵</p>
</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<p>launch 文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 urdf 文件内容设置进参数服务器 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 将 urdf 文件内容设置进参数服务器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_simlink_rviz)/urdf/robot_urdf.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动 rivz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz_test&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启动机器人状态和关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="底盘搭建"><a href="#底盘搭建" class="headerlink" title="底盘搭建"></a>底盘搭建</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        参数</span></span><br><span class="line"><span class="comment">            形状:圆柱 </span></span><br><span class="line"><span class="comment">            半径:10     cm </span></span><br><span class="line"><span class="comment">            高度:8      cm </span></span><br><span class="line"><span class="comment">            离地:1.5    cm</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.8 0.3 0.1 0.5&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;base_link2base_footprint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_footprint&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.055&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>joint</p>
<p>urdf 中的 joint 标签用于描述机器人关节的运动学和动力学属性，还可以指定关节运动的安全极限，机器人的两个部件(分别称之为 parent link 与 child link)以”关节”的形式相连接，不同的关节有不同的运动形式: 旋转、滑动、固定、旋转速度、旋转角度限制….,比如:安装在底座上的轮子可以360度旋转，而摄像头则可能是完全固定在底座上。joint标签对应的数据在模型中是不可见的</p>
<p>属性</p>
<blockquote>
<ul>
<li><p>name —-&gt; 为关节命名</p>
</li>
<li><p>type —-&gt; 关节运动形式 </p>
</li>
<li><ul>
<li>continuous: 旋转关节，可以绕单轴无限旋转</li>
</ul>
</li>
<li><ul>
<li>revolute: 旋转关节，类似于 continues,但是有旋转角度限制</li>
</ul>
</li>
<li><ul>
<li>prismatic: 滑动关节，沿某一轴线移动的关节，有位置极限</li>
</ul>
</li>
<li><ul>
<li>planer: 平面关节，允许在平面正交方向上平移或旋转</li>
</ul>
</li>
<li><ul>
<li>floating: 浮动关节，允许进行平移、旋转运动</li>
</ul>
</li>
<li><ul>
<li>fixed: 固定关节，不允许运动的特殊关节</li>
</ul>
</li>
</ul>
</blockquote>
<p>子标签</p>
<blockquote>
<ul>
<li><p>parent(必需的)<br>parent link的名字是一个强制的属性： </p>
</li>
<li><ul>
<li>link:父级连杆的名字，是这个link在机器人结构树中的名字。</li>
</ul>
</li>
<li><p>child(必需的)<br>child link的名字是一个强制的属性： </p>
</li>
<li><ul>
<li>link:子级连杆的名字，是这个link在机器人结构树中的名字。</li>
</ul>
</li>
<li><p>origin </p>
</li>
<li><ul>
<li>属性: xyz=各轴线上的偏移量 rpy=各轴线上的偏移弧度。</li>
</ul>
</li>
<li><p>axis </p>
</li>
<li><ul>
<li>属性: xyz用于设置围绕哪个关节轴运动。</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<h1 id="添加驱动轮"><a href="#添加驱动轮" class="headerlink" title="添加驱动轮"></a>添加驱动轮</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加驱动轮 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        驱动轮是侧翻的圆柱</span></span><br><span class="line"><span class="comment">        参数</span></span><br><span class="line"><span class="comment">            半径: 3.25 cm</span></span><br><span class="line"><span class="comment">            宽度: 1.5  cm</span></span><br><span class="line"><span class="comment">            颜色: 黑色</span></span><br><span class="line"><span class="comment">        关节设置:</span></span><br><span class="line"><span class="comment">            x = 0</span></span><br><span class="line"><span class="comment">            y = 底盘的半径 + 轮胎宽度 / 2</span></span><br><span class="line"><span class="comment">            z = 离地间距 + 底盘长度 / 2 - 轮胎半径 = 1.5 + 4 - 3.25 = 2.25(cm)</span></span><br><span class="line"><span class="comment">            axis = 0 1 0</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;left_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.0325&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5705 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;left_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0.1 -0.0225&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;right_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.0325&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.015&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5705 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;right_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;right_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 -0.1 -0.0225&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="添加万向轮"><a href="#添加万向轮" class="headerlink" title="添加万向轮"></a>添加万向轮</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加万向轮(支撑轮) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        参数</span></span><br><span class="line"><span class="comment">            形状: 球体</span></span><br><span class="line"><span class="comment">            半径: 0.75 cm</span></span><br><span class="line"><span class="comment">            颜色: 黑色</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        关节设置:</span></span><br><span class="line"><span class="comment">            x = 自定义(底盘半径 - 万向轮半径) = 0.1 - 0.0075 = 0.0925(cm)</span></span><br><span class="line"><span class="comment">            y = 0</span></span><br><span class="line"><span class="comment">            z = 底盘长度 / 2 + 离地间距 / 2 = 0.08 / 2 + 0.015 / 2 = 0.0475 </span></span><br><span class="line"><span class="comment">            axis= 1 1 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;front_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.0075&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;front_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;front_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0925 0 -0.0475&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;back_wheel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.0075&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;back_wheel2base_link&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;back_wheel&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;-0.0925 0 -0.0475&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;1 1 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="执行launch文件"><a href="#执行launch文件" class="headerlink" title="执行launch文件"></a>执行launch文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ roslaunch robot_simlink_rviz robot_urdf.launch </span><br><span class="line">... logging to /home/alvin/.ros/<span class="built_in">log</span>/429ebe1e-3ba0-11ec-9e19-e56937336ffc/roslaunch-ros-113111.log</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>添加坐标系和机器人模型,然后就可以看到搭建的小车模型.</p>
<p>我们也可以保存生成的rviz文件,以便二次打开反复添加参数,File/save config as…</p>
<p>修改launch文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 urdf 文件内容设置进参数服务器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_simlink_rviz)/urdf/robot_urdf.urdf&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启动 rivz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz_test&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_simlink_rviz)/config/robot_urdf.rviz&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启动机器人状态和关节状态发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>思考:</strong></p>
<ul>
<li>为什么使用foot_print?</li>
</ul>
<blockquote>
<p>因为默认情况下: 底盘的中心点位于地图原点上，所以会导致机器人模型是半沉到地下的情况产生，可以使用的优化策略，将初始 link 设置为一个尺寸极小的 link(比如半径为 0.001m 的球体，或边长为 0.001m 的立方体)，然后再在初始 link 上添加底盘等刚体，这样实现，虽然仍然存在初始link半沉的现象，但是基本可以忽略了。这个初始 link 一般称之为 base_footprint</p>
</blockquote>
<ul>
<li>上述代码实现存在什么问题吗？比如复用性！</li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>机器人仿真</tag>
        <tag>URDF</tag>
        <tag>rviz</tag>
      </tags>
  </entry>
  <entry>
    <title>tf坐标综合实践_乌龟跟随</title>
    <url>/posts/8395.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:程序启动之初: 产生两只乌龟，中间的乌龟(A) 和 左下乌龟(B), B 会自动运行至A的位置，并且键盘控制时，只是控制 A 的运动，但是 B 可以跟随 A 运行</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><strong>案例分析:</strong> 乌龟跟随实现的核心，是乌龟A和B都要发布相对世界坐标系的坐标信息，然后，订阅到该信息需要转换获取A相对于B坐标系的信息，最后，再生成速度信息，并控制B运动。</p>
<ol>
<li>启动乌龟显示节点</li>
<li>在乌龟显示窗体中生成一只新的乌龟(需要使用服务)</li>
<li>编写两只乌龟发布坐标信息的节点</li>
<li>编写订阅节点订阅坐标信息并生成新的相对关系生成速度信息</li>
</ol>
<h1 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.安装</span></span><br><span class="line">$ sudo apt-get install ros-noetic-ros-tutorials ros-noetic-geometry-tutorials ros-noetic-rviz ros-noetic-rosbash ros-noetic-rqt-tf-tree</span><br><span class="line"><span class="comment">#2.运行</span></span><br><span class="line">$ roslaunch turtle_tf turtle_tf_demo.launch</span><br></pre></td></tr></table></figure>
<h1 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h1><h2 id="启动一只乌龟"><a href="#启动一只乌龟" class="headerlink" title="启动一只乌龟"></a>启动一只乌龟</h2><p>首先,我们知道启动乌龟及其键盘控制节点的命令有三个,我们可以使用下面的launch文件代替:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;key&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="生成第二只乌龟"><a href="#生成第二只乌龟" class="headerlink" title="生成第二只乌龟"></a>生成第二只乌龟</h2><p>其次,启动一只乌龟之后,我们可以查看一下服务:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~$ rosservice list</span><br><span class="line">/clear</span><br><span class="line">/gui/get_loggers</span><br><span class="line">/gui/set_logger_level</span><br><span class="line">/key/get_loggers</span><br><span class="line">/key/set_logger_level</span><br><span class="line">/<span class="built_in">kill</span></span><br><span class="line">/reset</span><br><span class="line">/rosout/get_loggers</span><br><span class="line">/rosout/set_logger_level</span><br><span class="line">/spawn</span><br><span class="line">/turtle1/set_pen</span><br><span class="line">/turtle1/teleport_absolute</span><br><span class="line">/turtle1/teleport_relative</span><br></pre></td></tr></table></figure>
<p>因此,生成第二只乌龟调用的是服务来创建,话题是<code>/spawn</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~$ rosservice call /spawn <span class="string">&quot;x: 0.0</span></span><br><span class="line"><span class="string">y: 0.0</span></span><br><span class="line"><span class="string">theta: 0.0</span></span><br><span class="line"><span class="string">name: &#x27;&#x27;&quot;</span> </span><br></pre></td></tr></table></figure>
<p>这是使用命令调用服务来创建一只新的乌龟:乌龟的位置为:(x,y),乌龟头的朝向为theta弧度,乌龟的名字是”name”</p>
<p>那么,如何使用代码实现呢?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;turtlesim/Spawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;spawn_client&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceClient client = nh.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">    client.<span class="built_in">waitForExistence</span>();</span><br><span class="line">    turtlesim::Spawn spawn;</span><br><span class="line">    spawn.request.x = <span class="number">2</span>;</span><br><span class="line">    spawn.request.y = <span class="number">2</span>;</span><br><span class="line">    spawn.request.theta = <span class="number">1.57</span>;</span><br><span class="line">    spawn.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    client.<span class="built_in">call</span>(spawn); </span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>client.call(spawn);</code>返回的是布尔,我们也可以接收一下,去判断是不是成功的生成了一只乌龟.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">bool</span> flag = client.<span class="built_in">call</span>(spawn); </span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;新乌龟已经生成了!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;生成失败了....&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt添加相关命令</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtlesim_follow_spawn src/turtlesim_follow_spawn.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add cmake target dependencies of the executable</span></span><br><span class="line"><span class="comment">## same as for the library above</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(turtlesim_follow_spawn <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtlesim_follow_spawn</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此时你可以在运行第一步的launch文件的基础上执行以下命令,测试是否成功生成乌龟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ rosrun tf_pratice turtlesim_follow_spawn </span><br><span class="line">[ INFO] [1635770123.695878217]: 新乌龟已经生成了!</span><br></pre></td></tr></table></figure>
<h2 id="发布两只乌龟的坐标系信息"><a href="#发布两只乌龟的坐标系信息" class="headerlink" title="发布两只乌龟的坐标系信息"></a>发布两只乌龟的坐标系信息</h2><p>可以订阅乌龟的位姿信息，然后再转换成坐标信息，两只乌龟的实现逻辑相同，只是订阅的话题名称，生成的坐标信息等稍有差异，可以将差异部分通过参数传入:</p>
<ul>
<li><p>该节点需要启动两次</p>
</li>
<li><p>每次启动时都需要传入乌龟节点名称(第一次是 turtle1 第二次是 turtle2)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/transform_broadcaster.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2/LinearMath/Quaternion.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存乌龟名称</span></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPose</span><span class="params">(<span class="keyword">const</span> turtlesim::Pose::ConstPtr &amp;pose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个广播对象</span></span><br><span class="line">    <span class="keyword">static</span> tf2_ros::TransformBroadcaster broadcaster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//坐标点解析</span></span><br><span class="line">    geometry_msgs::TransformStamped tfs;</span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;/world&quot;</span>;</span><br><span class="line">    tfs.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    tfs.child_frame_id = turtle_name.<span class="built_in">c_str</span>();</span><br><span class="line">    tfs.transform.translation.x = pose-&gt;x;</span><br><span class="line">    tfs.transform.translation.y = pose-&gt;y;</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将欧拉角转换成四元数</span></span><br><span class="line">    tf2::Quaternion qnt;</span><br><span class="line">    qnt.<span class="built_in">setRPY</span>(<span class="number">0</span>,<span class="number">0</span>,pose-&gt;theta);</span><br><span class="line">    tfs.transform.rotation.x = qnt.<span class="built_in">getX</span>();</span><br><span class="line">    tfs.transform.rotation.y = qnt.<span class="built_in">getY</span>();</span><br><span class="line">    tfs.transform.rotation.z = qnt.<span class="built_in">getZ</span>();</span><br><span class="line">    tfs.transform.rotation.w = qnt.<span class="built_in">getW</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发布坐标信息</span></span><br><span class="line">    broadcaster.<span class="built_in">sendTransform</span>(tfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_pose_pub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">//解析传入的命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;请传入正确的参数&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        turtle_name = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;乌龟 %s 坐标发送启动&quot;</span>,turtle_name.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅乌龟的位姿信息</span></span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(turtle_name + <span class="string">&quot;/pose&quot;</span>,<span class="number">1000</span>,doPose);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt添加相关命令</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtlesim_follow_pub src/turtlesim_follow_pub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add cmake target dependencies of the executable</span></span><br><span class="line"><span class="comment">## same as for the library above</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(turtlesim_follow_pub <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtlesim_follow_pub</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>综上,我们可以更改原本的launch文件,使用该launch文件完成以上三步</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动第一只乌龟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_key&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 产生第二只乌龟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle2_spaw&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_spawn&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动两个发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;caster1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_pub&quot;</span> <span class="attr">args</span>=<span class="string">&quot;turtle1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;caster2&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_pub&quot;</span> <span class="attr">args</span>=<span class="string">&quot;turtle2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们查看下一下发布的话题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~$ rostopic list </span><br><span class="line">/rosout</span><br><span class="line">/rosout_agg</span><br><span class="line">/tf</span><br><span class="line">/turtle1/cmd_vel</span><br><span class="line">/turtle1/color_sensor</span><br><span class="line">/turtle1/pose</span><br><span class="line">/turtle2/cmd_vel</span><br><span class="line">/turtle2/color_sensor</span><br><span class="line">/turtle2/pose</span><br></pre></td></tr></table></figure>
<h2 id="订阅-解析坐标信息并生成速度信息"><a href="#订阅-解析坐标信息并生成速度信息" class="headerlink" title="订阅:解析坐标信息并生成速度信息"></a>订阅:解析坐标信息并生成速度信息</h2><p>现在我们已经获得两个乌龟的坐标系,以及相对于世界的坐标关系,可以在rviz内查看,现在需要做的是怎么才能让生成的turtle2跟随turtle1运动.</p>
<p>首先,需要获取 turtle1 相对 turtle2 的坐标信息,这样turtle2就可以找到turtle1.</p>
<p>然后,turtle需要发布速度信息,根据数学计算去发布新的速度指令,进而实现乌龟跟随</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/Twist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//创建监听对象</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_pose_sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要创建发布 /turtle2/cmd_vel 的 publisher 对象</span></span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">//注意这里的发布频率必须在10以上</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先获取 turtle1 相对 turtle2 的坐标信息</span></span><br><span class="line">            geometry_msgs::TransformStamped tfs = buffer.<span class="built_in">lookupTransform</span>(<span class="string">&quot;turtle2&quot;</span>,<span class="string">&quot;turtle1&quot;</span>,ros::<span class="built_in">Time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据坐标信息生成速度信息 -- geometry_msgs/Twist.h</span></span><br><span class="line">            geometry_msgs::Twist twist;</span><br><span class="line">            twist.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(tfs.transform.translation.x,<span class="number">2</span>) </span><br><span class="line">                                        + <span class="built_in">pow</span>(tfs.transform.translation.y,<span class="number">2</span>));</span><br><span class="line">            twist.angular.z = <span class="number">4</span> * <span class="built_in">atan2</span>(tfs.transform.translation.y,tfs.transform.translation.x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发布速度信息 -- 需要提前创建 publish 对象</span></span><br><span class="line">            pub.<span class="built_in">publish</span>(twist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发生异常:%s&quot;</span>,e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt添加相关命令</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtlesim_follow_sub src/turtlesim_follow_sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add cmake target dependencies of the executable</span></span><br><span class="line"><span class="comment">## same as for the library above</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(turtlesim_follow_sub <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtlesim_follow_sub</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>综上,我们可以更改原本的launch文件,使用该launch文件完成以上四步</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动第一只乌龟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_key&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 产生第二只乌龟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle2_spaw&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_spawn&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动两个发布节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;caster1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_pub&quot;</span> <span class="attr">args</span>=<span class="string">&quot;turtle1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;caster2&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_pub&quot;</span> <span class="attr">args</span>=<span class="string">&quot;turtle2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 订阅速度信息节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf_pratice&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_follow_sub&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时就可以实现跟随了</p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>tf坐标变换</tag>
        <tag>turtlesim</tag>
      </tags>
  </entry>
  <entry>
    <title>tf坐标变换实践_多坐标变换</title>
    <url>/posts/46644.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:现有坐标系统，父级坐标系统 world,下有两子级系统 son1，son2，son1 相对于 world，以及 son2 相对于 world 的关系是已知的，求 son1原点在 son2中的坐标，又已知在 son1中一点的坐标，要求求出该点在 son2 中的坐标.已知son1和son2相对于world的偏移量分别是(0.2 0.8 0.3 0 0 0)和(0.5 0 0 0 0 0),求解点一直某一点在son1坐标系中的坐标为(1,2,3),求该点在son2中的坐标?</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><strong>案例分析:</strong></p>
<ol>
<li>首先，需要发布 son1 相对于 world，以及 son2 相对于 world 的坐标消息</li>
<li>然后，需要订阅坐标发布消息，并取出订阅的消息，借助于 tf2 实现 son1 和 son2 的转换</li>
<li>最后，还要实现坐标点的转换</li>
</ol>
<h1 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h1><h2 id="发布方"><a href="#发布方" class="headerlink" title="发布方"></a>发布方</h2><p><strong>前提:</strong> 发布两个子坐标系节点(也是静态坐标节点)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf2_ros&quot;</span> <span class="attr">name</span>=<span class="string">&quot;son1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0.2 0.8 0.3 0 0 0 /world /son1&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf2_ros&quot;</span> <span class="attr">name</span>=<span class="string">&quot;son2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0.5 0 0 0 0 0 /world /son2&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="订阅方"><a href="#订阅方" class="headerlink" title="订阅方"></a>订阅方</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/PointStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;dynamic_pub&quot;</span>);</span><br><span class="line">    <span class="comment">//创建监听对象,接受发布的静态坐标</span></span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//解析son1中的点相对于son2的坐标</span></span><br><span class="line">            geometry_msgs::TransformStamped tfs = buffer.<span class="built_in">lookupTransform</span>(<span class="string">&quot;son2&quot;</span>,<span class="string">&quot;son1&quot;</span>,ros::<span class="built_in">Time</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Son1 相对于 Son2 的坐标关系:父坐标系ID=%s,子坐标系ID=%s,坐标关系:x=%.2f,y=%.2f,z=%.2f&quot;</span>,</span><br><span class="line">                    tfs.header.frame_id.<span class="built_in">c_str</span>(),tfs.child_frame_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    tfs.transform.translation.x,</span><br><span class="line">                    tfs.transform.translation.y,</span><br><span class="line">                    tfs.transform.translation.z);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//坐标点解析</span></span><br><span class="line">            geometry_msgs::PointStamped point_son1;</span><br><span class="line">            point_son1.header.frame_id = <span class="string">&quot;son1&quot;</span>;</span><br><span class="line">            point_son1.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            point_son1.point.x = <span class="number">1</span>;</span><br><span class="line">            point_son1.point.y = <span class="number">2</span>;</span><br><span class="line">            point_son1.point.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            geometry_msgs::PointStamped point_son2;</span><br><span class="line">            <span class="comment">//PS:调用 transform 必须包含头文件&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span><br><span class="line">            point_son2 = buffer.<span class="built_in">transform</span>(point_son1,<span class="string">&quot;son2&quot;</span>);</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;在 Son2 中的坐标:x=%.2f,y=%.2f,z=%.2f&quot;</span>,</span><br><span class="line">                    point_son2.point.x,</span><br><span class="line">                    point_son2.point.y,</span><br><span class="line">                    point_son2.point.z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发生异常:%s&quot;</span>,e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line"><span class="keyword">add_executable</span>(dynamic_tf src/dynamic_tf.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add cmake target dependencies of the executable</span></span><br><span class="line"><span class="comment">## same as for the library above</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(dynamic_tf <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(dynamic_tf</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>tf坐标变换</tag>
      </tags>
  </entry>
  <entry>
    <title>tf坐标变换实践_动态坐标变换</title>
    <url>/posts/50181.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:启动 turtlesim_node,该节点中窗体有一个世界坐标系(左下角为坐标系原点)，乌龟是另一个坐标系，键盘控制乌龟运动，将两个坐标系的相对位置动态发布。通俗的说,本案例就是将相对于乌龟位姿的偏移量为(1,1,0)的坐标点动态转换成世界坐标系.</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><strong>案例分析:</strong></p>
<ol>
<li>乌龟本身不但可以看作坐标系，也是世界坐标系中的一个坐标点</li>
<li>订阅 turtle1/pose,可以获取乌龟在世界坐标系的 x坐标、y坐标、偏移量以及线速度和角速度</li>
<li>将 pose 信息转换成 坐标系相对信息并发布</li>
</ol>
<p><strong>实际案例:</strong></p>
<p>这个案例放在实际中的应用可以理解为这样,世界坐标系看成大地坐标,将乌龟看成是小车的地盘的坐标系,将将对于乌龟偏移量为(1,1,0)的点看成是小车的雷达,我们如何将不停运动的雷达的坐标转换成世界坐标系下的坐标呢?</p>
<blockquote>
<p>显然,雷达对于小车的偏移量是始终不变的,所以我们需要做的就是将雷达在小车坐标系下的坐标转换成世界坐标;</p>
</blockquote>
<h1 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h1><h2 id="发布者实现"><a href="#发布者实现" class="headerlink" title="发布者实现"></a>发布者实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/transform_broadcaster.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2/LinearMath/Quaternion.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPose</span><span class="params">(<span class="keyword">const</span> turtlesim::Pose::ConstPtr &amp;pose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建发布者对象</span></span><br><span class="line">    <span class="keyword">static</span> tf2_ros::TransformBroadcaster broadcaster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//坐标信息</span></span><br><span class="line">    geometry_msgs::TransformStamped tfs;</span><br><span class="line">    tfs.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    tfs.child_frame_id = <span class="string">&quot;turtle1&quot;</span>;</span><br><span class="line">    tfs.transform.translation.x = pose-&gt;x;</span><br><span class="line">    tfs.transform.translation.y = pose-&gt;y;</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将欧拉角转换成四元数</span></span><br><span class="line">    tf2::Quaternion qtn;</span><br><span class="line">    qtn.<span class="built_in">setRPY</span>(<span class="number">0</span>,<span class="number">0</span>,pose-&gt;theta);</span><br><span class="line">    tfs.transform.rotation.x = qtn.<span class="built_in">getX</span>();</span><br><span class="line">    tfs.transform.rotation.y = qtn.<span class="built_in">getY</span>();</span><br><span class="line">    tfs.transform.rotation.z = qtn.<span class="built_in">getZ</span>();</span><br><span class="line">    tfs.transform.rotation.w = qtn.<span class="built_in">getW</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发布坐标</span></span><br><span class="line">    broadcaster.<span class="built_in">sendTransform</span>(tfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//订阅乌龟的位姿</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_pose_sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">100</span>,doPose);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="订阅方实现"><a href="#订阅方实现" class="headerlink" title="订阅方实现"></a>订阅方实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/PointStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//创建监听者对象</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_sub&quot;</span>);</span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义任意点坐标在turtle1下的坐标</span></span><br><span class="line">        geometry_msgs::PointStamped point_turtle;</span><br><span class="line">        point_turtle.header.frame_id = <span class="string">&quot;turtle1&quot;</span>;</span><br><span class="line">        point_turtle.header.stamp = ros::<span class="built_in">Time</span>();</span><br><span class="line">        point_turtle.point.x = <span class="number">1</span>; </span><br><span class="line">        point_turtle.point.y = <span class="number">1</span>;</span><br><span class="line">        point_turtle.point.z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将turtle坐标下的点的坐标,转换成world坐标下的坐标</span></span><br><span class="line">            geometry_msgs::PointStamped point_world;</span><br><span class="line">            point_world = buffer.<span class="built_in">transform</span>(point_turtle,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;坐标点相对于 world 的坐标为:(%.2f,%.2f,%.2f)&quot;</span>,</span><br><span class="line">                     point_world.point.x,</span><br><span class="line">                     point_world.point.y,</span><br><span class="line">                     point_world.point.z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// std::cerr &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发生异常.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtlesim_tf_pub src/turtlesim_tf_pub.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(turtlesim_tf_sub src/turtlesim_tf_sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add cmake target dependencies of the executable</span></span><br><span class="line"><span class="comment">## same as for the library above</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(turtlesim_tf_pub <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(turtlesim_tf_sub <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtlesim_tf_pub</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtlesim_tf_sub</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRA</span></span><br></pre></td></tr></table></figure>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>启动rocore</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
<p>启动turtlesim gui节点,键盘控制节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key </span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ rosrun tf_pratice turtlesim_tf_pub </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ rosrun tf_pratice turtlesim_tf_sub </span><br><span class="line">[ INFO] [1635691363.394649902]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691364.394588314]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691365.394655574]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691366.394559019]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691367.394593083]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691368.394657894]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691369.394621326]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691370.394648743]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691371.394659086]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br><span class="line">[ INFO] [1635691372.394657664]: 坐标点相对于 world 的坐标为:(6.54,6.54,0.00)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>tf坐标变换</tag>
        <tag>turtlesim</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages设置自定义域名失效</title>
    <url>/posts/61723.html</url>
    <content><![CDATA[<p>在GitHub Pages设置自定义域名之后，发现每次hexo d 后都会失效，又要重新设置，太麻烦了。<br><span id="more"></span><br>只要在source 目录添加一个新文件CNAME就好<br>CNAME –不带任何后缀，这就是全称，里面写的是你的域名<br>然后就ok了。<br>怎么push都不用再去GitHub Pages设置了</p>
]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>tf坐标变换实践_静态坐标变化</title>
    <url>/posts/41052.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>案例描述:现有一机器人模型，核心构成包含主体与雷达，各对应一坐标系，坐标系的原点分别位于主体与雷达的物理中心，已知雷达原点相对于主体原点位移关系如下: x=0.2 y=0.0 z=0.5。当前雷达检测到一障碍物，在雷达坐标系中障碍物的坐标为 (2.0 3.0 5.0),请问，该障碍物相对于主体的坐标是多少？</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p><strong>实现分析:</strong></p>
<ol>
<li>坐标系相对关系，可以通过发布方发布</li>
<li>订阅方，订阅到发布的坐标系相对关系，再传入坐标点信息(可以写死)，然后借助于 tf 实现坐标变换，并将结果输出</li>
</ol>
<p><strong>实现流程:</strong></p>
<ol>
<li>新建功能包，添加依赖</li>
<li>编写发布方实现</li>
<li>编写订阅方实现</li>
<li>执行并查看结果</li>
</ol>
<h1 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h1><h2 id="发布者命令实现"><a href="#发布者命令实现" class="headerlink" title="发布者命令实现"></a>发布者命令实现</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun tf2_ros static_transform_publisher 0.2 0 0.5 0 0 0 /baselink /laser</span><br></pre></td></tr></table></figure>
<p>解释:rosrun tf2_ros static_transform_publisher x偏移量 y偏移量 z偏移量 z偏航角度 y俯仰角度 x翻滚角度 父级坐标系 子级坐标系</p>
<h2 id="查看发布信息"><a href="#查看发布信息" class="headerlink" title="查看发布信息"></a>查看发布信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ rostopic list</span><br><span class="line">/rosout</span><br><span class="line">/rosout_agg</span><br><span class="line">/tf_static</span><br><span class="line">/turtle1/cmd_vel</span><br><span class="line">/turtle1/color_sensor</span><br><span class="line">/turtle1/pose</span><br><span class="line">alvin@ros:~/catkin_ws$ rostopic <span class="built_in">echo</span> /tf_static</span><br><span class="line">transforms: </span><br><span class="line">  - </span><br><span class="line">    header: </span><br><span class="line">      seq: 1</span><br><span class="line">      stamp: </span><br><span class="line">        secs: 1635601530</span><br><span class="line">        nsecs: 483203886</span><br><span class="line">      frame_id: <span class="string">&quot;base_link&quot;</span></span><br><span class="line">    child_frame_id: <span class="string">&quot;laser&quot;</span></span><br><span class="line">    transform: </span><br><span class="line">      translation: </span><br><span class="line">        x: 0.2</span><br><span class="line">        y: 0.0</span><br><span class="line">        z: 0.5</span><br><span class="line">      rotation: </span><br><span class="line">        x: 0.0</span><br><span class="line">        y: 0.0</span><br><span class="line">        z: 0.0</span><br><span class="line">        w: 1.0</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h1><h2 id="发布者实现"><a href="#发布者实现" class="headerlink" title="发布者实现"></a>发布者实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/static_transform_broadcaster.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/TransformStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2/LinearMath/Quaternion.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;static_pub&quot;</span>);</span><br><span class="line">    <span class="comment">//创建发布者对象</span></span><br><span class="line">    tf2_ros::StaticTransformBroadcaster broadcaster;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//坐标信息</span></span><br><span class="line">    geometry_msgs::TransformStamped tfs;</span><br><span class="line">    tfs.header.seq = <span class="number">1</span>;</span><br><span class="line">    tfs.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    tfs.header.frame_id = <span class="string">&quot;base_link&quot;</span>;</span><br><span class="line">    tfs.child_frame_id = <span class="string">&quot;laser&quot;</span>;</span><br><span class="line">    tfs.transform.translation.x = <span class="number">0.2</span>;</span><br><span class="line">    tfs.transform.translation.y = <span class="number">0</span>;</span><br><span class="line">    tfs.transform.translation.z = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将欧拉角转换成四元数</span></span><br><span class="line">    tf2::Quaternion qtn;</span><br><span class="line">    qtn.<span class="built_in">setRPY</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    tfs.transform.rotation.x = qtn.<span class="built_in">getX</span>();</span><br><span class="line">    tfs.transform.rotation.y = qtn.<span class="built_in">getY</span>();</span><br><span class="line">    tfs.transform.rotation.z = qtn.<span class="built_in">getZ</span>();</span><br><span class="line">    tfs.transform.rotation.w = qtn.<span class="built_in">getW</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发布坐标</span></span><br><span class="line">    broadcaster.<span class="built_in">sendTransform</span>(tfs);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="订阅者实现"><a href="#订阅者实现" class="headerlink" title="订阅者实现"></a>订阅者实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/transform_listener.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry_msgs/PointStamped.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;static_sub&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监听者对象</span></span><br><span class="line">    tf2_ros::Buffer buffer;</span><br><span class="line">    <span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buffer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        <span class="comment">//定义某坐标点在laser坐标系下的值</span></span><br><span class="line">        geometry_msgs::PointStamped point_laser;</span><br><span class="line">        point_laser.header.frame_id = <span class="string">&quot;laser&quot;</span>;</span><br><span class="line">        point_laser.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        point_laser.point.x = <span class="number">1</span> ;</span><br><span class="line">        point_laser.point.y = <span class="number">2</span> ;</span><br><span class="line">        point_laser.point.z = <span class="number">7.3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将laser坐标系的点的坐标,转换成基坐标系下的坐标</span></span><br><span class="line">            geometry_msgs::PointStamped point_base;</span><br><span class="line">            point_base = buffer.<span class="built_in">transform</span>(point_laser,<span class="string">&quot;base_link&quot;</span>);</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;转换后的数据:(%.2f,%.2f,%.2f),参考的坐标系是:%s&quot;</span>,</span><br><span class="line">                     point_base.point.x,</span><br><span class="line">                     point_base.point.y,</span><br><span class="line">                     point_base.point.z,</span><br><span class="line">                     point_base.header.frame_id.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> std::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">ROS_INFO</span>(<span class="string">&quot;程序异常.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line"><span class="keyword">add_executable</span>(static_tf_pub src/static_tf_pub.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(static_tf_sub src/static_tf_sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add cmake target dependencies of the executable</span></span><br><span class="line"><span class="comment">## same as for the library above</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(static_tf_pub <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(static_tf_sub <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(static_tf_pub</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(static_tf_sub</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ rosrun tf_pratice static_tf_pub </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alvin@ros:~/catkin_ws$ rosrun tf_pratice static_tf_sub </span><br><span class="line">[ INFO] [1635601858.503067357]: 程序异常.....</span><br><span class="line">[ INFO] [1635601859.503191179]: 转换后的数据:(1.20,2.00,7.80),参考的坐标系是:base_link</span><br><span class="line">[ INFO] [1635601860.503162320]: 转换后的数据:(1.20,2.00,7.80),参考的坐标系是:base_link</span><br><span class="line">[ INFO] [1635601861.503066538]: 转换后的数据:(1.20,2.00,7.80),参考的坐标系是:base_link</span><br><span class="line">[ INFO] [1635601862.503088002]: 转换后的数据:(1.20,2.00,7.80),参考的坐标系是:base_link</span><br><span class="line">[ INFO] [1635601863.503098757]: 转换后的数据:(1.20,2.00,7.80),参考的坐标系是:base_link</span><br><span class="line">[ INFO] [1635601864.503162287]: 转换后的数据:(1.20,2.00,7.80),参考的坐标系是:base_link</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>tf坐标变换</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM综述简介</title>
    <url>/posts/17633.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文选&lt;权美香，朴松昊，李国． 视觉 ＳＬＡＭ 综述&gt;一文,对整个论文进行梳理,让自己对整个SLAM的框架有一定的了解.</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<h1 id="视觉SLAM综述简介"><a href="#视觉SLAM综述简介" class="headerlink" title="视觉SLAM综述简介"></a>视觉SLAM综述简介</h1><blockquote>
<p>参考文献：</p>
<p>[1]权美香，朴松昊，李国． 视觉 ＳＬＡＭ 综述［Ｊ］． 智能系统学报， ２０１６， １１（６）： ７６８－７７６．</p>
</blockquote>
<h2 id="视觉SLAM方法介绍"><a href="#视觉SLAM方法介绍" class="headerlink" title="视觉SLAM方法介绍"></a>视觉SLAM方法介绍</h2><h3 id="视觉-SLAM的概念"><a href="#视觉-SLAM的概念" class="headerlink" title="视觉 SLAM的概念"></a>视觉 SLAM的概念</h3><p>视觉 SLAM指的是相机作为唯一的外部传感器，在进行自身定位的同时创建环境地图。 SLAM创建的地图<br>的好坏对之后自主的定位、路径规划以及壁障的性能起到一个决定性的作用。</p>
<h3 id="视觉SLAM的分类"><a href="#视觉SLAM的分类" class="headerlink" title="视觉SLAM的分类"></a>视觉SLAM的分类</h3><ul>
<li>单目视觉 SLAM (仅用一个相机作为唯一外部传感器)</li>
<li>立体视觉 SLAM (使用多个相机作为传感器)</li>
<li>RGB-D SLAM (基于单目相机与红外传感器结合构成的传感器)</li>
</ul>
<h3 id="视觉SLAM的方法介绍"><a href="#视觉SLAM的方法介绍" class="headerlink" title="视觉SLAM的方法介绍"></a>视觉SLAM的方法介绍</h3><p>根据利用图像信息的不同</p>
<ul>
<li>基于特征的 SLAM 方法</li>
<li>direct SLAM 方法</li>
</ul>
<h4 id="基于特征的-SLAM-方法"><a href="#基于特征的-SLAM-方法" class="headerlink" title="基于特征的 SLAM 方法"></a>基于特征的 SLAM 方法</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>基于特征的 SLAM 方法指的是对输入的图像进行<strong>特征点检测及提取</strong>，并基于 ２⁃Ｄ 或 ３⁃Ｄ 的特征匹配<strong>计算相机位姿及对环境</strong>进行建图。如果对整幅图像进行处理，则计算复杂度太高，由于特征在保存图像重要信息的同时有效减少了计算量，从而被广泛使用。</p>
<h5 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h5><h6 id="借助于滤波器实现的单目视觉SLAM"><a href="#借助于滤波器实现的单目视觉SLAM" class="headerlink" title="借助于滤波器实现的单目视觉SLAM"></a>借助于<strong>滤波器</strong>实现的单目视觉SLAM</h6><ul>
<li><p>扩展卡尔曼滤波器（extended Kalman filter，EKF）</p>
<p><strong>原理：</strong>利用扩展卡尔曼滤波器来实现同时定位与地图创建，其主要思想是使用状态向量来存储相机位姿及地图点的三维坐标，利用概率密度函数来表示不确定性，从观测模型和递归的计算，最终获得更新的状态向量的均值和方差。</p>
<p><strong>缺点：</strong>由于EKF的引进，SLAM算法会有计算复杂度及由于线性化而带来的不确定性问题。</p>
</li>
<li><p>无迹卡尔曼滤波器（Unscented Kal-man filter，UKF）</p>
<p>该方法虽然对不确定性有所改善，但同时也增加了计算复杂度。</p>
</li>
<li><p>Rao-Blackwellized粒子滤波（Particle filter）</p>
<p>该方法避免了线性化，且对相机的快速运动有一定的弹力，但是为了保证定位精度，则需要使用较多的粒子，从而大大提高了计算复杂度</p>
</li>
</ul>
<h6 id="基于关键帧的单目视觉SLAM"><a href="#基于关键帧的单目视觉SLAM" class="headerlink" title="基于关键帧的单目视觉SLAM"></a>基于关键帧的单目视觉SLAM</h6><ul>
<li><p>Parallel Tracking and Mapping for Small AR Workspaces（PTAM）</p>
<p>该论文提出了一个简单、有效的提取关键帧的方法，且将定位和创建地图分为两个独立的任务，并在两个线程上进行。</p>
</li>
<li><p>A Versatile and Accurate Monocular SLAM System</p>
<p>在关键帧的基础上提出的一个单目视觉 SLAM 系统，将整个 SLAM 过程分为定位、创建地图、闭环 ３个线程，且对这 ３ 个任务使用相同的 ORB 特征，且引进本质图的概念来加速闭环校正过程。</p>
</li>
</ul>
<h6 id="基于RGB-D数据的SLAM"><a href="#基于RGB-D数据的SLAM" class="headerlink" title="基于RGB-D数据的SLAM"></a>基于RGB-D数据的SLAM</h6><p>微软公司推出的Kinect相机，能够同时获得图像信息及深度信息，从而简化了三维重建的过程，且由于价格便宜，基于RGB_D数据的SLAM得到了迅速的发展。</p>
<p>《RGB-D map-ping: using depth cameras for dense 3-D modeling of in-door environments》最早提出的使用<br>RGB-D相机对室内环境进行三维重建的方法，在彩色图像中提取 SHIF特征并在深度图像上查找相应的深度信息。然后使用RANSAC方法对3-D特征点进行匹配并计算出相应的刚体运动变换，再以此作为ICP (iterative closest point）的初始值来求出更精确的位姿。</p>
<p><img src="https://gitee.com/LukeyAlvin/img_mk/raw/master/img/image-20211009165001747.png" alt="image-20211009165001747"></p>
<h4 id="直接的SLAM-方法"><a href="#直接的SLAM-方法" class="headerlink" title="直接的SLAM 方法"></a>直接的SLAM 方法</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>直接的SLAM方法指的是直接对<strong>像素点的强度</strong>进行操作，避免了特征点的提取，该方法能够使用图像的所有信息。此外，提供更多的环境几何信息，有助于对地图的后续使用。且对特征较少的环境有更高的准确性和鲁棒性。</p>
<h5 id="发展-1"><a href="#发展-1" class="headerlink" title="发展"></a>发展</h5><ul>
<li>《Real-time dense geometry from a handheld camera》</li>
</ul>
<p>相机定位方法依赖图像的每个像素点，即用稠密的图像对准来进行自身定位，并构建出稠密的3-D地图。</p>
<ul>
<li>《Semi-Dense Visual Odometry for a Monocular Camera 》</li>
</ul>
<p>对当前图像构建半稠密inverse深度地图，并使用稠密图像配准（dense image alignment）法计算相机位姿。构建半稠密地图即估计图像中梯度较大的所有像素的深度值，该深度值被表示为高斯分布，且当新的图像到来时，该深度值被更新。</p>
<ul>
<li>《Dense tracking and mapping in real-time》</li>
</ul>
<p>对每个像素点进行概率的深度测量，有效降低了位姿估计的不确定性。</p>
<ul>
<li>《Fast semi-direct monocular visual odometry 》</li>
</ul>
<p>提出了一种半直接的单目视觉里程计方法，该方法相比于直接法不是对整幅图像进行直接匹配从而获得相机位姿，而是通过在整幅图像中提取的图像块来进行位姿的获取，这样能够增强算法的鲁棒性。</p>
<ul>
<li>《Large-Scale Direct Monocular SLAM》</li>
</ul>
<p>为了构建稠密的三维环境地图，Engel等提出了LSD-SLAM算法（large-scale direct SLAM），相比之前的直接的视觉里程计方法，该方法在估计高准确性的相机位姿的同时能够创建大规模的三维环境地图。</p>
<ul>
<li>《Kinect-Fusion: Real-time dense surface mapping and tracking》27</li>
</ul>
<p>提出了kinect融合的方法，该方法通过Kinect获取的深度图像对每帧图像中的每个像素进行最小化距离测量而获得相机位姿，且融合所有深度图像，从而获得全局地图信息。</p>
<ul>
<li>《A dense map building approach from spherical RGBD images》28</li>
</ul>
<p>使用图像像素点的光度信息和几何信息来构造误差函数，通过最小化误差函数而获得相机位姿，且地图问题被处理为位姿图表示。</p>
<ul>
<li>《Dense visual SLAM for RGB-D cameras》29</li>
</ul>
<p>这是较好的直接RGBD SLAM方法，该方法结合像素点的强度误差与深度误差作为误差函数，通过最小化代价函数，从而求出最优相机位姿，该过程由g20实现，并提出了基于熵的关键帧提取及闭环检方法，从而大大降低了路径的误差。</p>
<ul>
<li>《Distinctive image features from scale-invariant keypoints》30</li>
</ul>
<h3 id="视觉-SLAM主要标志性成果"><a href="#视觉-SLAM主要标志性成果" class="headerlink" title="视觉 SLAM主要标志性成果"></a>视觉 SLAM主要标志性成果</h3><h4 id="MonoSLAM"><a href="#MonoSLAM" class="headerlink" title="MonoSLAM"></a>MonoSLAM</h4><blockquote>
<p>《Mono-SLAM: real-time single camera SLAM》</p>
</blockquote>
<p>Andrew Davison提出的第1个基于EKF方法的单目SLAM，能够达到实时但是不能确定漂移多少，能够在概率框架下在线创建稀疏地图。</p>
<h4 id="DTAM"><a href="#DTAM" class="headerlink" title="DTAM"></a>DTAM</h4><blockquote>
<p>《DTAM: Dense tracking and mapping in real-time》</p>
</blockquote>
<p>2011年提出的基于直接法的单目SLAM算法，该方法通过帧率的整幅图像对准来获得相对于稠密地图的相机的6个自由度位姿，能够在GPU上达到实时的效果。</p>
<h4 id="PTAM"><a href="#PTAM" class="headerlink" title="PTAM"></a>PTAM</h4><blockquote>
<p>《Parallel Tracking and Mapping for Small AR Workspaces》</p>
</blockquote>
<p>由Georg Klein提出的第1个用多线程处理SLAM的算法，将跟踪和建图分为两个单独的任务并在两个平行的线程进行处理。</p>
<h4 id="Ki-nectFusion"><a href="#Ki-nectFusion" class="headerlink" title="Ki-nectFusion"></a>Ki-nectFusion</h4><blockquote>
<p>《Kinect-Fusion: Real-time dense surface mapping and tracking》</p>
</blockquote>
<p>第1个基于Kinect的能在GPU上实时构建稠密三维地图的算法，该方法仅使用Kinect相机获取的深度信息去计算传感器的位姿以及构建精确的环境3-D地图模型。</p>
<h4 id="LSD-SLAM"><a href="#LSD-SLAM" class="headerlink" title="LSD-SLAM"></a>LSD-SLAM</h4><blockquote>
<p>《LSD-SLAM: Large-Scale Direct Monocular SLAM》</p>
</blockquote>
<p>直接的单目SLAM方法，即直接对图像的像素点进行处理，相比于之前的基于直接法的单目视觉里程计，不仅能计算出自身的位姿，还能构建出全局的半稠密且精确的环境地图。其中的追踪方法，直接在sim3上进行操作，从而能够准确地检测尺度漂移，可在CPU上实时运行。</p>
<h4 id="ORB-SLAM"><a href="#ORB-SLAM" class="headerlink" title="ORB_SLAM"></a>ORB_SLAM</h4><blockquote>
<p>《ORB-SLAM: A Versatile and Accurate Monocular SLAM  System》</p>
</blockquote>
<p>2015年出的比较完整的基于关键帧的单目SLAM算法，将整个系统分为追踪、地图创建、闭环控制3个线程进行处理，且特征的提取与匹配、稀疏地图的创建、位置识别都是基于ORB特征，其定位精确度很高，且可以实时运行。</p>
<h3 id="SLAM的主要研究实验室"><a href="#SLAM的主要研究实验室" class="headerlink" title="SLAM的主要研究实验室"></a>SLAM的主要研究实验室</h3><p>1）<strong>苏黎世联邦理工学院的Autonomous System Lab</strong>:该实验室在tango项目上与谷歌合作，负责视觉-<br>惯导的里程计，基于视觉的定位和深度重建算法。<br>2）<strong>明尼苏达大学的Multiple Autonomous Robotic Systems Laboratory</strong>，主要研究四轴飞行器导航，合作建图，基于地图的定位，半稠密地图创建等。<br>3）<strong>慕尼黑理工大学的The Computer Vision Group</strong>，主要研究基于图像的3-D重建，机器人视觉视觉SLAM等。</p>
<h2 id="视觉-SLAM-关键性问题"><a href="#视觉-SLAM-关键性问题" class="headerlink" title="视觉 SLAM 关键性问题"></a>视觉 SLAM 关键性问题</h2><h3 id="特征检测与匹配"><a href="#特征检测与匹配" class="headerlink" title="特征检测与匹配"></a>特征检测与匹配</h3><p>目前点特征使用最多,使用最多的点特征如下</p>
<ul>
<li><strong>SIFT（scale invariant feature transform）特征</strong></li>
</ul>
<p>SIFT特征已发展10多年，且获得了巨大的成功。SIFT特征具有可辨别性，由于其描述符用高维向量（128维）表示，且具有旋转不变性、尺度不变性、放射变换不变性，对噪声和光照变化也有鲁棒性。[33-6]在视觉SLAM里使用了SIFT特征，但是由于SIFT特征的向量维数太高，导致时间复杂度高。</p>
<p>《Distinctive image features from scale-invariant keypoints》</p>
<ul>
<li><strong>SURT（speeded up robust features）[31]特征</strong></li>
</ul>
<p>SURF特征具有尺度不变性、旋转不变性，且相对于SIFT特征的算法速度提高了3到7倍。在文献[37-39]SURF被作为视觉SLAM的特征提取方法，与SIFT特征相比，时间复杂度有所降低。对两幅图像的SIFT和SURF特征进行匹配时通常是计算两个特征向量之间的欧氏距离，并以此作为特征点的相似性判断度量。</p>
<p>《spee-ded up robust features》</p>
<ul>
<li><strong>ORB（oriented fast and rotated BRIEF）[32]特征。</strong></li>
</ul>
<p>ORB特征是FAST特征检测算子与BRIEF描述符的结合，并在其基础上做了一些改进。ORB特征最大的优点是计算速度快，是SIFT特征的100倍，SURF特征的10倍，其原因是FAST特征检测速度就很快，再加上BRIEF描述符是二进制串，大大缩减了匹配速度，而且具有旋转不变性，但不具备尺度不变性。ORB特征匹配是以BRIEF二进制描述符的汉明距离为相似性度量的。</p>
<p>《An efficient alternative to SIFT or SURF》</p>
<p>在大量包含直线和曲线的环境下，使用点特征时，环境中很多信息都将被遗弃，为了弥补这个缺陷，从而也提出了<strong>基于边特征的视觉SLAM</strong>和<strong>基于区域特征的视觉SLAM</strong>方法。</p>
<blockquote>
<p>基于边特征的视觉SLAM《Edge landmarks in monocular SLAM》《Improving the agility of keyframe-based SLAM 》</p>
<p>基于区域特征的视觉SLAM《Using superpixels in monocular SLAM》</p>
</blockquote>
<h3 id="关键帧的选择"><a href="#关键帧的选择" class="headerlink" title="关键帧的选择"></a>关键帧的选择</h3><p>帧对帧的对准方法会造成大的累积漂浮，由于位姿估计过程中总会产生误差。为了减少帧对帧的对准方法带来的误差，基于关键帧的SLAM方法被提出。</p>
<p>《Parallel Tracking and Mapping for Small AR Workspaces》</p>
<p>《ORB-SLAM: A Versatile and Accurate Monocular SLAM System》</p>
<blockquote>
<p>提出满足以下全部条件时该帧作为关键帧插入到地图里：从上一个关键帧经过了n个帧；当前帧至少能看到n个地图点，位姿估计准确性较高。</p>
</blockquote>
<p>《RGB-D Mapping: Using Depth Cameras for Dense 3-D Modeling of Indoor Environments》</p>
<blockquote>
<p>当两幅图像看到的共同特征点数低于一定阈值时，创建一个新的关键帧。</p>
</blockquote>
<p>《Dense visual SLAM for RGB-D cameras 》</p>
<blockquote>
<p>提出了一种基于熵的相似性的选择关键帧的方法，由于简单的阈值不适用于不同的场景，对每一帧计算一个熵的相似性比，如果该值小于一个预先定义的阈值，则前一帧被选为新的关键帧，并插入地图里，该方法大大减少了位姿漂浮。</p>
</blockquote>
<h3 id="闭环检测（loop-closing）方法"><a href="#闭环检测（loop-closing）方法" class="headerlink" title="闭环检测（loop closing）方法"></a>闭环检测（loop closing）方法</h3><p>闭环检测及位置识别，判断当前位置是否是以前已访问过的环境区域。三维重建过程中必然会产生误差累积，实现闭环是消除的一种手段。在位置识别算法中，视觉是主要的传感器。</p>
<p>文献《A compari-son of loop closing techniques in monocular SLAM》对闭环检测方法进行了比较</p>
<p>且得出图像对图像的匹配性能<strong>优于</strong>地图对地图，图像对地图的匹配方法。</p>
<ul>
<li><p>图像对图像《Tracking and mapping recognizable features》《Accelerated appearance-only SLAM》</p>
<blockquote>
<p>图像对图像的匹配方法中，词袋（bag of words）方法由于其有效性得到了广泛的应用</p>
<p>《Scalable Recognition with a Vocabulary Tree》</p>
</blockquote>
</li>
<li><p>地图对地图《Unscented SLAM for large-scale outdoor environments 》</p>
</li>
<li><p>图像对地图《Probabilistic Lo-calization and Mapping in the Space of Appearance》</p>
</li>
</ul>
<p>《Unified loop closing and recovery for real time monocular SLAM》</p>
<blockquote>
<p>对重定位和闭环检测提出了统一的方法，它们使用基于16维的SIFT特征的词典方法不断地搜索已访问过的位置。</p>
</blockquote>
<p>《Real-time loop detec-tion with bags of binary words 》《Appearance-only SLAM at large scale with FAB-MAP》</p>
<blockquote>
<p>使用基于SURF描述符的词典方法去进行闭环检测SURF特征，SURF特征提取需要花费400 ms去进行。</p>
</blockquote>
<p>《Distinctive Image features from scale-invariant keypoints》</p>
<blockquote>
<p>使用SIFT特征执行全局定位，且用KD树来排列地图点。</p>
</blockquote>
<p>《Bags of binary words for fast place recognition in image sequences》</p>
<blockquote>
<p>提出了一种使用基于FAST特征检测与BRIEF二进制描述符词典，且添加了直接索引（direct index），直接索引的引入使得能够有效地获得图像之间的匹配点，从而加快闭环检测的几何验证。</p>
</blockquote>
<p>《Fast relocalisation andloop closing in keyframe-based SLAM》</p>
<blockquote>
<p>用基于ORB特征的词典方法进行位置识别，由于ORB特征具有旋转不变性且能处理尺度变化，该方法能识别位置从不同的视角。</p>
</blockquote>
<p>《ORB-SLAM: A Versatile and Accurate Monocular SLAM System》</p>
<blockquote>
<p>该文献的位置识别方法建于文献《Fast relocalisation andloop closing in keyframe-based SLAM》的主要思想上，即使用基于ORB特征的词典方法选出候选闭环，再通过相似性计算进行闭环的几何验证。</p>
</blockquote>
<h3 id="地图优化"><a href="#地图优化" class="headerlink" title="地图优化"></a>地图优化</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>对于一个在复杂且动态的环境下工作的机器人，3-D地图的快速生成是非常重要的，且创建的环境地图对之后的定位、路径规划及壁障的性能起到一个关键性的作用，从而精确的地图创建也是非常重要的。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>闭环检测成功后，往地图里添加闭环约束，执行闭环校正。闭环问题可以描述为<strong>大规模的光束平差法（bundle adjustment）问题</strong>，即对相机位姿及所有的地图点3-D坐标进行优化，但是该优化计算复杂度太高，从而很难实现实时。</p>
<h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><ul>
<li>通过位姿图优化（pose graph optimization）方法来对闭环进行优化</li>
</ul>
<p>顶点为相机位姿，边表示位姿之间相对变换的图称为位姿图，位姿图优化即将闭环误差沿着图进行分配，即均匀分配到图上的所有位姿上。图优化通常由图优化框架g2o（general graph optimization）《A general framework for graph optimization 》里的LM（leven-berg-marquardt）算法实现。</p>
<p>《Dense visual SLAM for RGB-D cameras》</p>
<blockquote>
<p>提出的RGB-D SLAM算法的位姿图里每个边具有一个权重，从而在优化过程中，不确定性高的边比不确定性低的边需要变化更多去补偿误差，并在最后，对图里的每个顶点进行额外的闭环检测且重新优化整个图。</p>
</blockquote>
<p>《Scale drift-aware large scale monocular SLAM》</p>
<blockquote>
<p>在闭环校正步骤使用了位姿图优化技术去实现旋转，平移及尺度漂浮的有效校正。</p>
</blockquote>
<p>《ORB-SLAM: A Versatile and Accurate Monocular SLAM System》</p>
<blockquote>
<p>在闭环检测成功后构建了本质图，并对该图进行位姿图优化。本质图包含所有的关键帧，但相比于covisibility图，减少了关键帧之间的边约束。本质图包含生成树、闭环连接及covisibility图里权重较大的边。</p>
</blockquote>
<h2 id="视觉SLAM主要发展趋势与研究热点"><a href="#视觉SLAM主要发展趋势与研究热点" class="headerlink" title="视觉SLAM主要发展趋势与研究热点"></a>视觉SLAM主要发展趋势与研究热点</h2><h3 id="多传感器融合"><a href="#多传感器融合" class="headerlink" title="多传感器融合"></a>多传感器融合</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>相机能够捕捉场景的丰富细节，而惯性测量单元（inertial measurement unit，IMU）有高的帧率且相对小的能够获得准确的短时间估计，这两个传感器能够相互互补，从而一起使用能够获得更好的结果。</p>
<h4 id="发展-2"><a href="#发展-2" class="headerlink" title="发展"></a>发展</h4><p>最初的视觉与IMU结合的位姿估计是用<strong>滤波方法</strong>解决的，用IMU的测量值作为预测值，视觉的测量值用于更新。</p>
<p>《A multi-state con-straint Kalman filter for vision-aided inertial navigation》</p>
<blockquote>
<p>提出了一种基于EKF的IMU与单目视觉的实时融合方法，提出一种测量模型能够表示一个静态特征被多个相机所观察时的几何约束，该测量模型是最优的且不需要在EKF的状态向量里包括特征的3-D坐标。</p>
</blockquote>
<p>《A dual-layer estima-tor architecture for long-term localization》</p>
<blockquote>
<p>将融合问题分为两个线程进行处理，连续图像之间的惯性测量和特征跟踪被局部地在第1个线程进行处理，提供高频率的位置估计，第2个线程包含一个间歇工作的光束法平差的迭代估计，能够减少线性误差的影响。许多结果都已证明在准确性上基于优化的视觉SLAM优于基于滤波的SLAM方法。</p>
</blockquote>
<p>《Keyframe-based visual-inertial slam using nonlinear opti-mization》</p>
<blockquote>
<p>将IMU的误差以全概率的形式融合到路标的重投影误差里，构成将被优化的联合非线性误差函数，其中通过关键帧来边缘化之前的状态去维持一个固定大小的优化窗口，保证实时操作。考虑到基于优化方法的视觉-惯导导航的计算复杂度问题，</p>
</blockquote>
<p>参考<a href="https://www">https://www</a>. google. com/a-tap/projecttango/.</p>
<blockquote>
<p>通过预积分选出的关键帧之间的惯性测量来进行解决，预积分能够精确地概括数百个惯性测量到一个单独的相对运动约束，这个预积分的IMU模型能被完美地融合到视觉-惯性的因子图的框架下。该系统的实验结果表明该系统要比Google的Tango还要精确。</p>
</blockquote>
<h3 id="SLAM与深度学习的结合"><a href="#SLAM与深度学习的结合" class="headerlink" title="SLAM与深度学习的结合"></a>SLAM与深度学习的结合</h3><p>随着深度学习在计算机视觉领域的大成功，大家对深度学习在机器人领域的应用有很大的兴趣。SLAM是一个大系统，里面有很多子模块，例如闭环检测，立体匹配等，都可通过深度学习的使用来获得更优的结果。</p>
<h4 id="发展-3"><a href="#发展-3" class="headerlink" title="发展"></a>发展</h4><p>《Stereo matching by training a convolutional neural network to compare image patches》</p>
<blockquote>
<p>提出了一种基于深度学习的立体匹配方法，用卷积神经网络来学习小图像块间的相似性，该卷积神经网络输出的结果用于线性化立体匹配代价。</p>
</blockquote>
<p>《On the per-formance of ConvNet features for place recognition》</p>
<blockquote>
<p>通过整合局部敏感散列法和新的语义搜寻空间划分的优化技术，使用卷积神经网络和大的地图达到实时的位置识别。</p>
</blockquote>
<p>《Exploring representation learning with CNNs for frame-to-frame egomotion estimation》</p>
<blockquote>
<p>使用卷积神经网络去学习视觉里程计的最佳的视觉特征和最优的估计器。</p>
</blockquote>
<p>《Modelling uncertainty in deep learning for camera relocalization》</p>
<blockquote>
<p>提出了一种重定位系统，使用贝叶斯卷积神经网络从单个彩色图像计算出六个自由度的相机位姿及其不确定性。</p>
</blockquote>
<h2 id="视觉SLAM的优缺点分析"><a href="#视觉SLAM的优缺点分析" class="headerlink" title="视觉SLAM的优缺点分析"></a>视觉SLAM的优缺点分析</h2><h3 id="单目视觉SLAM"><a href="#单目视觉SLAM" class="headerlink" title="单目视觉SLAM"></a>单目视觉SLAM</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>单目相机应用灵活、简单、价格低。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单目视觉SLAM在每个时刻只能获取一张图像，且只能依靠获得的图像数据计算环境物体的方向信息，无法直接获得可靠的深度信息，从而初始地图创建及特征点的深度恢复都比较困难。</p>
<p>此外，尺度不确定性是单目SLAM的主要特点，它是主要的误差源之一，但是正是尺度不确定性才使得单目SLAM能够在大尺度和小尺度环境之间进行自由转换。</p>
<h3 id="双目视觉SLAM"><a href="#双目视觉SLAM" class="headerlink" title="双目视觉SLAM"></a>双目视觉SLAM</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>双目视觉SLAM利用外极线几何约束的原理去匹配左右两个相机的特征，从而能够在当前帧速率的条件下直接提取完整的特征数据，因而应用比较广泛，它直接解决了系统地图特征的初始化问题。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>但是系统设计比较复杂，系统成本比较高，且它的视角范围受到一定限制，不能够获取远处的场景，从而只能在一定的尺度范围内进行可靠的测量，从而缺乏灵活性。</p>
<h3 id="RGBD-SLAM"><a href="#RGBD-SLAM" class="headerlink" title="RGBD SLAM"></a>RGBD SLAM</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>深度相机在获得彩色图像的同时获得深度图像，从而方便获得深度信息，且能够获得稠密的地图</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>成本高，体积大，有效探测距离太短，从而可应用环境很有限。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>为了弥补视觉信息的不足，视觉传感器可以与惯性传感器（IMU）、激光等传感器融合，通过传感器之间的互补获得更加理想的结果。此外，为了能在实际环境中进行应用，SLAM的鲁棒性需要很高，从而足够在各种复杂环境下进行准确的处理，SLAM的计算复杂度也不能太高，从而达到实时效果。</p>
]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT1002_写出这个数</title>
    <url>/posts/29713.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>输入格式：</p>
<blockquote>
<p> 每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p>
</blockquote>
<p>输出格式：</p>
<blockquote>
<p> 在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>
</blockquote>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567890987654321123456789</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yi san wu</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>)n[i] - <span class="number">48</span>;</span><br><span class="line">        sum = x + sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum= &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">order</span>(sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 n/10==0，则输出n</span></span><br><span class="line"><span class="comment">// 否则 先对n/10进行相同处理，之后输出n%10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    string c_num[<span class="number">10</span>]=&#123;<span class="string">&quot;ling&quot;</span>,<span class="string">&quot;yi&quot;</span>,<span class="string">&quot;er&quot;</span>,<span class="string">&quot;san&quot;</span>,<span class="string">&quot;si&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;qi&quot;</span>,<span class="string">&quot;ba&quot;</span>,<span class="string">&quot;jiu&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">order</span>(num/<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> num1 = num%<span class="number">10</span>;</span><br><span class="line">        cout &lt;&lt; c_num[num1]&lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; c_num[num] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT1001_害死人不偿命的(3n+1)猜想</title>
    <url>/posts/32148.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>卡拉兹(Callatz)猜想：对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<span id="more"></span>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？<br>输入格式：</p>
<blockquote>
<p>每个测试输入包含 1 个测试用例，即给出正整数 n 的值。</p>
</blockquote>
<p>输出格式：</p>
<blockquote>
<p>输出从 n 计算到 1 需要的步数。</p>
</blockquote>
<p>输入样例：</p>
<blockquote>
<p>3<br>  结尾无空行</p>
</blockquote>
<p>输出样例：</p>
<blockquote>
<p>5<br>  结尾无空行<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeParity</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deal</span><span class="params">(<span class="keyword">bool</span> flag,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="built_in">judgeParity</span>(n);</span><br><span class="line">        n = <span class="built_in">deal</span>(flag,n);</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeParity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deal</span><span class="params">(<span class="keyword">bool</span> flag,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        n = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        n = (<span class="number">3</span>*n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="note success"><p>初学,待进一步优化......</p></div>
</blockquote>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
</search>
