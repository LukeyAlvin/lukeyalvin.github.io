<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lukey Alvin</title>
  
  <subtitle>一份耕耘,一份收获</subtitle>
  <link href="https://lukeyalvin.top/atom.xml" rel="self"/>
  
  <link href="https://lukeyalvin.top/"/>
  <updated>2022-05-13T14:03:42.028Z</updated>
  <id>https://lukeyalvin.top/</id>
  
  <author>
    <name>爱喝烫水的阿水哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="https://lukeyalvin.top/posts/a39e0cda.html"/>
    <id>https://lukeyalvin.top/posts/a39e0cda.html</id>
    <published>2022-05-13T06:57:20.000Z</published>
    <updated>2022-05-13T14:03:42.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>在学习滑动窗口算法之前，推荐读者先阅读，<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>以及<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>，这两篇博客奠定了本文的基础，有助于对本文的理解。</p><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>我们知道，SLAM中的优化问题，就是优化一个最小二乘的问题，这里我们首先介绍一个引例。</p><p>如下图所示，存在这么一个图模型，对于图模型大家肯定不是很陌生，了解过g2o的都应该很清楚，图中圆圈表示顶点，是待优化的变量，而顶点之间的边，表示的顶点之间构建的残差。</p><p><img src="/images/滑动窗口算法/image-20220513195856537.png" alt="image-20220513195856537" style="zoom:50%;" /></p><blockquote><p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p></blockquote><p>对于这样一个系统，我们首先构建出最小二乘，如下：</p><script type="math/tex; mode=display">\xi^*=\underset{\xi}{\arg\min}\frac{1}{2}\sum_i\parallel r_i \parallel^2_{\Sigma_i}\tag{1}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p><p>根据文章<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>中提到的，SLAM优化问题，最终运动观测方程优化的部分是<strong>马氏距离</strong>，残差项即为<strong>马氏距离</strong>:</p><script type="math/tex; mode=display">\parallel r_i \parallel^2_{\Sigma_i}=r^T\Sigma^{-1}r\tag{2}</script><p>其中 $\Sigma$ 表示残差的<strong>协方差矩阵</strong>， $\Sigma^{-1}$ 表示残差的<strong>信息矩阵</strong>，因此，此处相当于一种<strong>加权的</strong>最小二乘问题。</p><p>应用高斯牛顿法，可以求解上述最小二乘问题的<strong>正规方程</strong>：</p><script type="math/tex; mode=display">J^T\Sigma^{-1}J\ \delta\xi = -J^T\Sigma^{-1}\ r\tag{3}</script><p>其中海塞矩阵 $H=J^T\Sigma^{-1}J$，矩阵 $g= -J^T\Sigma^{-1}\ r$，雅可比矩阵为：</p><script type="math/tex; mode=display">J=\frac{\partial r}{\partial \xi}=\begin{bmatrix}\frac{\partial r_{12} }{\partial \xi}\\\frac{\partial r_{13} }{\partial \xi}\\\frac{\partial r_{14} }{\partial \xi}\\\frac{\partial r_{15} }{\partial \xi}\\\frac{\partial r_{56} }{\partial \xi}\end{bmatrix}=\begin{bmatrix}J_1\\J_2\\J_3\\J_4\\J_5\\J_6 \end{bmatrix}\tag{4}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p><p>矩阵乘法公式 $(3)$ 可以写成连加：</p><script type="math/tex; mode=display">\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i J_i\ \delta\xi=-\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i\ r\tag{5}</script><p>由于每个残差只和某几个状态量有关，因此，雅克比矩阵求导时，无关项的雅克比为 0。比如</p><script type="math/tex; mode=display">J_2=\frac{\partial r_{13} }{\partial \xi}=\begin{bmatrix}\frac{\partial r_{13} }{\partial \xi_1}&0&\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\end{bmatrix}\tag{6}</script><p>对应的新的信息矩阵：</p><script type="math/tex; mode=display">Λ_2=J^T_2\Sigma^{-1}_2J_2=\begin{bmatrix}(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\end{bmatrix}\tag{7}</script><p>同理，可以计算 $Λ_1 , Λ_3 , Λ_4 , Λ_5 $，并且也是稀疏的。</p><p><strong>将五个残差的信息矩阵加起来</strong>，得到样例最终的<strong>信息矩阵</strong> $Λ$，可视化如下：</p><p><img src="/images/滑动窗口算法/image-20220513203817364.png" alt="image-20220513203817364" style="zoom: 33%;" /></p><p>关于稀疏矩阵。我们知道，可以用舒尔消元法或者称之为边缘化，来使之变得稠密，减少计算量。</p><h1 id="基于边际概率的滑动窗口算法"><a href="#基于边际概率的滑动窗口算法" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h1><h2 id="什么是滑动窗口算法？"><a href="#什么是滑动窗口算法？" class="headerlink" title="什么是滑动窗口算法？"></a>什么是滑动窗口算法？</h2><p><strong>什么是滑动窗口算法</strong></p><p>在引例的条件下，我们知道，一般情况下，SLAM问题构建的残差的信息矩阵是一个稀疏矩阵，在此基础上，我们讨论SLAM中的滑动窗口算法。</p><p>所谓的滑动窗口算法，并没有明确的定义，我做了一个动图，其展示的过程就是滑动窗口算法：</p><p>图</p><p><strong>为什么使用滑动窗口算法？</strong></p><p>那么，使用它有什么好处呢？在文章开篇的概述中已经提及，这里再做强调：</p><ul><li>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</li><li>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态<strong>增加或移除优化变量</strong>。</li></ul><p>其实它的作用也是动图中展示的，我们优化的变量就是红色框中的部分，外部的变量不断增加进来，一些历史的变量做清除。</p><p><strong>滑动窗口中的关键问题是什么？</strong></p><p>但是我们需要考虑的关键就是，如何增加或者移除？直接移除吗？比如引例中的变量 $\xi_1$如果直接把顶点连同边一起移除，那么所有的其他变量之间的边可就都没了，边就是误差项，误差都没了，如何优化？这是下面我们需要介绍的重要内容。</p><p><strong>滑动窗口算法大致流程</strong></p><p>① 增加新的变量进入最小二乘系统优化</p><p>② 如果变量数目达到了一定的维度，则移除老的变量。</p><p>③ SLAM 系统不断循环前面两步</p><h2 id="基于边际概率的滑动窗口算法-1"><a href="#基于边际概率的滑动窗口算法-1" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h2><p>关于这里，有必要回顾文章<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>中的案例，会对此有更加深刻的理解。</p><p>直接丢弃变量和对应的测量值，会损失信息。因此，我们需要选择一种“优雅的”方式丢掉历史信息，正确的做法是使用<strong>边际概率</strong>，将丢弃变量所携带的信息传递给剩余变量。意思就是，历史变量虽然被移除了，但是它的“影响力”还在。</p><p>还是用引例，我们将引例中的历史变量 $\xi_1$ 丢掉，应该如何操作呢？</p><blockquote><p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p></blockquote><p><img src="/images/滑动窗口算法/image-20220513210526896.png" alt="image-20220513210526896"></p><p>很明显，去除历史变量 $\xi_1$ 之后，其他出现了互相之间的关联，这就是说历史变量 $\xi_1$ 虽然被去除了，但是它把自己的信息传递给其他变量了，虽然自己凉了，但是完成了火炬的传递。</p><p><strong>结论：</strong><span style="color:red;"><strong>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</strong></span> 另外，marg的这一特征也给我们启示，就是在SLAM运动观测模型中，marg特征点的时候，我们要<strong>marg那些不被其他帧观测到的特征点</strong>。因为他们不会显著的使得 H 变得稠密。对于那些被其他帧观测到的特征点，要么就别设置为marg，要么就宁愿丢弃，这就是okvis和dso中用到的一些策略。</p><hr><p>那么，如果在移除变量 $\xi_1$ 的同时，加入新的变量 $\xi_7$，整个信息矩阵又如何变化呢？</p><p>如下图所示，在 $t \in [0, k]$s 时刻, 系统中状态量为 $\xi_i , i \in [1, 6]$。</p><p>在第 $k $ 时刻，最小二乘优化完以后，marg 掉变量 $\xi_1$  。被 marg 的状态量记为 $x_m$ , 剩余的变量 $ξ_i , i \in [2, 5]$ 记为 $x_r $，marg 发生以后， $x_m$ 所有的变量以及对应的测量将被丢弃。同时，这部分信息通过 marg 操作传递给了保留变量 $x_r$ 。</p><p>第 $k^′$ 时刻，加入新的观测和状态量  $\xi_7$，新的变量  $\xi_7$ 跟老的变量  $\xi_2$ 之间存在观测信息，能构建残差 $r_{27}$ 。然后开始新一轮最小二乘优化。</p><p><img src="/images/滑动窗口算法/image-20220513213728826.png" alt="image-20220513213728826"></p><p>新残差加上之前 <strong>marg 留下的信息</strong>，构建新的最小二乘系统，对应的信息矩阵的变化如下图所示：</p><p><img src="/images/滑动窗口算法/image-20220513212137697.png" alt="image-20220513212137697" style="zoom:40%;" /></p><p>注意：  $\xi_2$  自身的信息矩阵由两部分组成，一部分是原来的$Λ^{\prime}$  中的老信息，另一部分是新生成的 $Λ_6$中的新信息，这会使得系统存在<strong>潜在风险</strong>。</p><p>新老信息融合的问题在于<strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。对于零空间的介绍在后文中。</p><hr><p><span style="color:red;"><strong>marg 留下的信息到底是啥？</strong></span></p><p>记被 marg 的状态量记为 $x_m$ ，剩下的状态记为 $x_r$</p><h2 id="信息矩阵的零空间变化"><a href="#信息矩阵的零空间变化" class="headerlink" title="信息矩阵的零空间变化"></a>信息矩阵的零空间变化</h2><p><a href="https://blog.csdn.net/heyijia0327/article/details/52822104">https://blog.csdn.net/heyijia0327/article/details/52822104</a></p><p>在刘毅(稀疏毅)，王京，晓佳等人讨论下，对这张图作出了如下解释：四张能量图中，第一张是说明能量函数E E<em>E</em>由两个同样的非线性函数E 1 E_1<em>E</em>1和E 2 E_2<em>E</em>2组成，我们令函数E = 0 E=0<em>E</em>=0，这时方程的解为x y = 1 xy=1<em>x**y</em>=1，对应图中深蓝色的一条曲线。第二张能量函数图中的E 1 ′ E&#x27;_1<em>E</em>1′对应函数E 1 E_1<em>E</em>1在点(0.5,1.4)处的二阶泰勒展开，第三张能量函数图中的E 2 ′ E&#x27;_2<em>E</em>2′对应函数E 2 E_2<em>E</em>2在点(1.2,0.5)处的二阶泰勒展开。注意这两个近似的能量函数E 1 ′ E&#x27;_1<em>E</em>1′和E 2 ′ E&#x27;_2<em>E</em>2′是在不同的线性点附近对原函数展开得到的。最后一张图就是把这个近似得到的能量函数合并起来，对整个系统E E<em>E</em>的二阶近似。从第四个能量函数图中，我们发现一个大问题，能量函数为0的解由以前的一条曲线变成了一个点，不确定性的东西变得确定了，专业的术语叫不可观的状态变量变得可观了，说明我们人为的引入了错误的信息。回到marg过程，上面这个例子告诉我们，marg时，被marg的那些变量的雅克比已经不更新了，而此时留在滑动窗口里的其他变量的雅克比要用和marg时一样的线性点，就是FEJ去算，不要用新的线性点了。有了这些基础以后，大家可以再去看看王京，张腾大神们在知乎上关于FEJ更理论的表述，<a href="https://www.zhihu.com/question/52869487/noti-answers?group_id=784455517954142208">链接请戳</a>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="滑动窗口算法" scheme="https://lukeyalvin.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VSLAM中的非线性优化</title>
    <link href="https://lukeyalvin.top/posts/48933.html"/>
    <id>https://lukeyalvin.top/posts/48933.html</id>
    <published>2022-05-13T06:57:20.000Z</published>
    <updated>2022-05-13T13:48:03.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经典 SLAM 模型。它由一个状态方程和一个运动方程构成：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},u_{k})+w_{k}\\z_{k,j}&=h(y_j,x_k)+v_{k,j}\end{align*}\tag{1}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$</p><p>对应视觉$SLAM$，这里的 $x_k $乃是相机的位姿，$u_k$ 是运动传感器的读数（有时也叫输入），$y_j$代表的是相机在$x_k $处观察到的路标，并且观察到$y_j$后，产生了一个观测数据 $z_{k,j}$。整个方程里面，求解相机的位姿$x_k $就是一个定位的问题，而求解路标$y_j$就是一个建图的过程，但是由于噪声$w_{k}，v_{k,j}$的影响，我们得到的传感器数据$u_k$ 和$z_{k,j}$肯定不是完全准确的，因此需要使用这两组不太准确的数据，寻找一个相对最优的相机位姿$x_k $以及路标$y_j$。这个过程就是SLAM中的非线性优化问题。</p><h2 id="需要优化什么？"><a href="#需要优化什么？" class="headerlink" title="需要优化什么？"></a>需要优化什么？</h2><p>我们把所有带估计的数据放在一个集合：</p><script type="math/tex; mode=display">x=\left\{x_1,....,x_N,y_1,...y_M\}\right.\tag{2}</script><p>那么，我们的问题就变成求已知输入数据 $u$ 和观测数据 $z$ 的条件下，计算状态 $x$ 的条件概率分布：</p><script type="math/tex; mode=display">P(x|z,u)\tag{3}</script><hr><p>但是多数情况下，我们只有相机观察到的一帧帧的图片$z_{k,j}$，即只考虑观测方程带来的数据时，没有运动传感器$u_k$ ，这个概率分布就变成$P(x|z)$，利用贝叶斯法则：</p><script type="math/tex; mode=display">P(x|z)=\frac{P(z|x)P(x)}{P(z)}∝P (z|x) P (x) .\tag{4}</script><p>$\frac{P(z|x)P(x)}{P(z)}$称为<strong>后验估计</strong>，$P (z|x)$ 称为<strong>似然</strong>，另一部分$ P (x)$ 称为<strong>先验</strong>。</p><p>直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下，后验概率最大化（Maximize a Posterior，MAP），则是可行的：</p><script type="math/tex; mode=display">x^∗_{MAP} = \arg \max P (x|z) = \arg \max P (z|x)P (x).\tag{5}</script><p>但是当我们不知道机器人位姿大概在什么地方，此时就没有了先验,那么，可以求解$x $的最大似然估计（Maximize Likelihood Estimation, MLE）：</p><script type="math/tex; mode=display">x^∗_{MLE} = \arg \max P (z|x)\tag{6}</script><p>最大似然估计的含义就是：相机在什么样的状态下（这里指集合$x$即为相机位姿$x_{k}$以及路标$y_{j}$），最可能产生当前观测到的数据$z_{k,j}$。</p><p><strong>所以我们需要优化的内容就是：求解最优的$x_k , y_j$，使得观测方程带来的最小误差，此时就是求$x$（或者是说$x_k , y_j$）的最大似然然估计。</strong></p><h2 id="最小二乘问题"><a href="#最小二乘问题" class="headerlink" title="最小二乘问题"></a>最小二乘问题</h2><p>只考虑观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{7}</script><p>由于我们假设了噪声项 $v_k ∼ N (0, Q)$，所以观测数据的条件概率为：</p><script type="math/tex; mode=display">P (z_{j,k} |x_k , y_j ) = N (h(y_j , x_k ), Q) .\tag{8}</script><p>我们的目标就是最大化$x_k , y_j$，使得该状态下最可能产生当前观测到的数据$z_{k,j}$。</p><p>考虑一个任意的高维高斯分布 $x ∼ N (\mu, \Sigma)$，它的概率密度函数展开形式为:</p><script type="math/tex; mode=display">\begin{align*}p(x)=\frac{1}{\sqrt{(2\pi)^N det(\Sigma)} }exp(−(x−\mu)\Sigma^{-1} (x−\mu))\end{align*}\tag{9}</script><p>取负对数:</p><script type="math/tex; mode=display">\begin{align*}-ln(p(x))=\frac{1}{2}ln((2\pi)^N det(Σ))+\frac{1}{2}(x−\mu)^TΣ^{-1} (x−\mu)\end{align*}\tag{10}</script><p>对原分布求最大化相当于对负对数求最小化。在最小化上式的 $x$ 时，第一项与 $x $无关，可以略去于是，只要最小化右侧的二次型项，也称为<strong>马氏418133364418133364。带入 SLAM </strong>观测模型**：</p><script type="math/tex; mode=display">x^*=\arg\min\left((z_{k,j}-h(x_k,y_j))^TQ^{-1}_{k,j}(z_{k,j}-h(x_k,y_j))\right)\tag{11}</script><p>定义：</p><script type="math/tex; mode=display">\begin{align*}e_{v,k}&=x_k-f(x_{k-1},u_k)\\e_{u,j,k}&=z_{k,j}-h(x_k,y_j)\end{align*}\tag{12}</script><p>考虑运动与观测方程结合来看，我们求解的就是总的<strong>误差的平方和</strong>：</p><script type="math/tex; mode=display">J(x)=\sum_ke^T_{v,k}R^{-1}e_{v,k}+\sum_k\sum_je^T_{y,k,j}Q^{-1}e_{y,k,j}\tag{13}</script><p>这就得到了一个总体意义下的<strong>最小二乘问题</strong>（Least Square Problem）。我们明白它的最优解等价于状态的最大似然估计。直观来讲，由于噪声的存在，当我们把估计的轨迹与地图代入 SLAM 的运动、观测方程中时，它们并不会完美的成立。这时候怎么办呢？我们把状态的估计值进行微调，使得整体的误差下降一些。当然这个下降也有限度，它一般会到达一个极小值。这就是一个典型非线性优化的过程。</p><h2 id="非线性函数线性化"><a href="#非线性函数线性化" class="headerlink" title="非线性函数线性化"></a>非线性函数线性化</h2><p>在非线性优化的过程中，由于高斯分布经过非线性映射后不会再符合高斯分布，因此，一般我们对非线性进行线性化，这里用到泰勒级数：</p><p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}\tag{14}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f^\prime(x_0)(x-x_0)\tag{15}</script><p>如果对于二维以上的，我们的一阶泰勒展开如下：</p><script type="math/tex; mode=display">\begin{align*}f(x，y)&=f(x_0)+\frac{\partial f}{\partial x}|_{x=x_0}(x-x_0)\\&=f(x_0)+J(x)(x-x_0)\end{align*}\tag{16}</script><p>这里的雅克比矩阵代表的就是$f(x)$对于$x$的偏导数。</p><h1 id="求解非线性最小二乘"><a href="#求解非线性最小二乘" class="headerlink" title="求解非线性最小二乘"></a>求解非线性最小二乘</h1><p>对于上文，我们知道通过把最大似然估计问题转化为最小化其负对数的问题，其实就是求解一个非线性函数的最小值的问题，我们暂且考虑一个问题，我们有一个非线性的函数$f(x)$，如何求解它的最小值？</p><p>这就是一个简单的最小二乘问题：</p><script type="math/tex; mode=display">\underset{x}{min}\frac{1}{2}\parallel f(x) \parallel^2\tag{17}</script><p>这里自变量 $x\in \mathbb R^n$ ，$f $是任意一个非线性函数，我们设它有 $m $维：$f (x) \in \mathbb R^m$ 。</p><p>一般求解就是类似于二元函数求极值，对$x$求导，使得$\frac{df}{dx}=0$，即可得到$f(x)$的极值，但是也不是绝对的，我们知道这个点可能是极大值、极小值也可能是鞍点，因此需要比较所有使得$\frac{df}{dx}=0$的自变量对应的函数值$f(x)$.</p><p>但是在SLAM中，$f(x)$将是一个复杂的非线性方程，所以一般我们使用迭代的方法，从一个初始值出发，不断地更新当前的优化变量，使目标函数下降，具体步骤如下：</p><ul><li>给定某个初始值$ x_0$</li><li>对于第$k$次迭代，寻找一个增量$\Delta x_k$，使得$\parallel f(x_k+\Delta x_k)\parallel^2_2$达到极小值。</li><li>若$\Delta x_k$足够小，则停止</li><li>否则，令$x_{k+1}=x_k+\Delta x_k$，返回第二步。</li></ul><p>这让求解导函数为零的问题，变成了一个不断寻找梯度并下降的过程。直到某个时刻增量非常小，无法再使函数下降。此时算法收敛，目标达到了一个极小，我们完成了寻找极小值的过程。在这个过程中，我们只要找到迭代点的梯度方向即可，而无需寻找全局导函数为零的情况。</p><hr><p><strong>如何寻找$\Delta x_k$?</strong></p><h2 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h2><p>我们之前介绍过非线性的线性化方法，我们可以将一个非线性函数在某个点附件进行泰勒展开。</p><p>比如：对于增量方程在$x$附近进行泰勒展开：</p><script type="math/tex; mode=display">\parallel f(x+\Delta x)\parallel^2_2\approx\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{18}</script><p>这里$J$是 $\parallel f(x)\parallel^2$ 关于$ x $的导数（雅可比矩阵），而$ H $则是二阶导数（海塞（Hessian）矩阵）。保留一阶二阶分别就对应了一阶梯度法和二阶梯度法。</p><h3 id="一阶梯度法"><a href="#一阶梯度法" class="headerlink" title="一阶梯度法"></a>一阶梯度法</h3><script type="math/tex; mode=display">\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x\tag{19}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">\Delta x^*=-J^T(x)\tag{20}</script><p>当然，我们还需要该方向上取一个步长$\lambda$，求得最快的下降方式。这种方法被称为<strong>最速下降法</strong>。但是它本身也有缺点：最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。</p><h3 id="二阶梯度-牛顿法"><a href="#二阶梯度-牛顿法" class="headerlink" title="二阶梯度(牛顿法)"></a>二阶梯度(牛顿法)</h3><script type="math/tex; mode=display">\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{21}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">H\Delta x=-J^T.\tag{22}</script><p>但是牛顿法需要计算目标函数的 $H $矩阵，这在问题规模较大时非常困难，我们通常倾向于避免$ H $的计算。</p><h2 id="Gauss-Newton"><a href="#Gauss-Newton" class="headerlink" title="Gauss-Newton"></a>Gauss-Newton</h2><p>Gauss Newton 是最优化算法里面最简单的方法之一。它的思想是$f(x)$而不是$f(x)^2$在$x$处进行一阶泰勒展开：</p><script type="math/tex; mode=display">f(x+\Delta x)\approx f(x)+J(x)\Delta x\tag{23}</script><p>这里$ J (x)$ 为$ f (x) $关于$ x$ 的导数，实际上是一个$ m × n$ 的矩阵，也是一个雅可比矩阵。</p><p>当前的目标是为了寻找下降矢量 $\Delta x$，使得$ f(x+\Delta x)$达到最小。为了求 $\Delta x$，我们需要解一个线性的最小二乘问题：</p><script type="math/tex; mode=display">\Delta x^*=\arg\min\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2\tag{24}</script><p>对上式平方项进行展开：</p><script type="math/tex; mode=display">\begin{align*}\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2&=\frac{1}{2}\left(f(x)+J(x)\Delta x)^T(f(x)+J(x)\Delta x\right)\\&=\frac{1}{2}\left(\parallel f(x)\parallel^2_2+2f(x)^TJ(x)\Delta x+\Delta x^TJ(x)^TJ(x)\Delta x\right)\\\end{align*}\tag{25}</script><p>求上式关于 $\Delta x$ 的导数，并令其为零：</p><script type="math/tex; mode=display">2J(x)^Tf(x)+2J(x)^TJ(x)\Delta x=0\tag{26}</script><p>化简：</p><script type="math/tex; mode=display">J(x)^TJ(x)\Delta x=-J(x)^Tf(x)\tag{27}</script><p>要求解的变量是  $\Delta x$，因此这是一个线性方程组，我们称它为增量方程，也可以称为<strong>高斯牛顿方程 (Gauss Newton equations)</strong> 或者<strong>正规方程 (Normal equations)</strong>。我们把左边的系数定义为 $H$，右边定义为 $g$，那么上式变为：</p><script type="math/tex; mode=display">H \Delta x=g\tag{28}</script><p>对比牛顿法可见，Gauss-Newton 用$J(x)^TJ(x)$作为牛顿法中二阶 Hessian 矩阵的近似，从而省略了计算 $H $的过程。求解增量方程是整个优化问题的核心所在。</p><p>Gauss Newton 求解步骤：</p><ul><li>给定初始值$x_0$</li><li>对于第$k$次迭代，求出当前的雅可比矩阵$J(x_k)和误差$$f(x_k)$</li><li>求解增量方程：$H \Delta x=g$</li><li>若$\Delta x_k$足够小，则停止。否则，令$x_{k+1}=x_k+\Delta x_k$，返回步骤2.</li></ul><p>整个步骤中，增量方程的求解占据着主要地位。原则上，它要求我们所用的近似 $H$ 矩阵是可逆的（而且是正定的），但实际数据中计算得到的 $J(x)^TJ(x)$却只有半正定性。也就是说，在使用 Gauss Newton 方法时，可能出现$J(x)^TJ(x)$为<strong>奇异矩阵</strong>或者<strong>病态 (ill-condition)</strong> 的情况，此时增量的稳定性较差，导致算法不收敛。</p><p>更严重的是，就算我们假设$ H $非奇异也非病态，如果我们求出来的步长$ ∆x $太大，也会导致我们采用的局部近似不够准确，这样一来我们甚至都无法保证它的迭代收敛，哪怕是让目标函数变得更大都是有可能的。</p><h2 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h2><p>由于 Gauss-Newton 方法中采用的近似二阶泰勒展开<strong>只能在展开点附近有较好的近似效果</strong>，所以我们很自然地想到应该给 $\Delta x$ 添加一个信赖区域（$Trust\ Region$），不能让它太大而使得近似不准确。非线性优化种有一系列这类方法，这类方法也被称之为信赖区域方法 $ (Trust\ Region\ Method)$。<strong>在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</strong> </p><p>那么如何确定这个信赖区域的范围呢？一个比较好的方法是<strong>根据我们的近似模型跟实际函数之间的差异来确定这个范围</strong>：如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。因此，考虑使用 $(29)$ 来判断泰勒近似是否够好。</p><script type="math/tex; mode=display">\rho=\frac{f(x+\Delta x)-f(x)}{J(x)\Delta x }\tag{29}</script><p>$\rho$ 的分子是<strong>实际函数下降</strong>的值，分母是<strong>近似模型下降</strong>的值。如果 $\rho$ 接近于 1，则近似是好的。如果 $\rho$  太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。反之，如果 $\rho$  比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513154553510.png" alt="image-20220513154553510" style="zoom:50%;" /></p><p>我们用 Lagrange 乘子将$(6.24)$ 转化为一个无约束优化问题：</p><script type="math/tex; mode=display">\underset{\Delta x_K}{\min}\frac{1}{2}\parallel f(x_k)+J(x_k)\Delta x_k\parallel^2=\frac{\lambda}{2}\parallel D\Delta x \parallel^2\tag{30}</script><p>类似于 Gauss-Newton 中的做法，把它展开后，我们发现该方法最终也是计算增量的线性方程：</p><script type="math/tex; mode=display">(H+\lambda D^TD)\Delta x=g\tag{31}</script><p>可以看到，增量方程相比于 Gauss-Newton，多了一项 $\lambda D^T D$。如果考虑它的简化形 式，即 $D = I$，那么相当于求解：</p><script type="math/tex; mode=display">(H+\lambda I)\Delta x=g\tag{32}</script><p>我们看到，当参数 $λ$ 比较小时，$H $占主要地位，这说明二次近似模型在该范围内是比 较好的，L-M 方法更接近于 G-N 法。另一方面，当 $λ$ 比较大时，$λI $占据主要地位，L-M 更接近于一阶梯度下降法（即最速下降），这说明附近的二次近似不够好。L-M 的求解方 式，可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题，提供更稳定更准确 的增量 $∆x$。</p><h1 id="BA求解"><a href="#BA求解" class="headerlink" title="BA求解"></a>BA求解</h1><p>通过前文。我们知道SLAM 中的优化问题什么，而且我们知道优化的数学工具最小二乘法，那么如何进行优化，就是我们下面讨论的主要问题。</p><h2 id="投影模型"><a href="#投影模型" class="headerlink" title="投影模型"></a>投影模型</h2><p>从一个世界坐标系中的点 $p$ 出发，把相机的内外参数和畸变都考虑进来，最后投影成像素坐标，一共需要如下几个步骤：</p><ol><li>首先，把世界坐标转换到相机坐标，这里将用到相机外参数$ (R, t)$：</li></ol><script type="math/tex; mode=display">P^\prime=Rp+t=[X^\prime,Y^\prime,Z^\prime]^T\tag{33}</script><ol><li>然后，将 $P^\prime$ 投至归一化平面，得到归一化坐标：</li></ol><script type="math/tex; mode=display">P_c=[u_c,v_c,1]^T=[\frac{X^\prime}{Z^\prime},\frac{Y^\prime}{Z^\prime},1]^T\tag{34}</script><ol><li>对归一化坐标去畸变，得到去畸变后的坐标。这里暂时只考虑径向畸变：</li></ol><script type="math/tex; mode=display">\begin{align*}u_c^\prime=u_c(1+k_1r_c^2+k_2r_c^4)\\v_c^\prime=v_c(1+k_1r_c^2+k_2r_c^4)\\\end{align*}\tag{35}</script><ol><li>最后，根据内参模型，计算像素坐标：</li></ol><script type="math/tex; mode=display">\begin{align*}u_s=f_xu_c^\prime+c_x\\v_s=f_yv_c^\prime+c_y\end{align*}\tag{36}</script><p>对于观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{37}</script><p>这里的 $x$ 指代此时相机的位姿，即外参 $R, t$，它对应的李代数为 $ξ$。路标 $y$ 即这里的三维点 $p$，而观测数据则是像素坐标$z = [u_s , v_s ]^T $。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220405145736323.png" alt="image-20220405145736323"></p><p>以最小二乘的角度来考虑，那么可以列写关于此次观测的误差：</p><script type="math/tex; mode=display">e=z-h(\xi,p)\tag{38}</script><p>设 $z_{ij}$为在位姿 $\xi_i $处观察路标 $p_j $产生的数据，那么整体的损失函数（Cost Function）为：</p><script type="math/tex; mode=display">\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}\parallel^2=\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel z_{ij}-h(ξ_i,p_j) \parallel^2\tag{39}</script><p>对这个最小二乘进行求解，相当于对位姿和路标同时作了调整，也就是所谓的$BA$。</p><h2 id="BA求解-1"><a href="#BA求解-1" class="headerlink" title="BA求解"></a>BA求解</h2><p>在整体 $BA$目标函数上，我们必须把自变量定义成所有待优化的变量：</p><script type="math/tex; mode=display">x=[\xi_1,...,\xi_m,p_1,...,p_n]^T\tag{40}</script><p>相应的，增量方程中的$ ∆x $则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}+F_{ij}\Delta\xi_i+E_{ij}\Delta p_i \parallel^2\tag{41}</script><p>其中$ F_{ij} $表示整个代价函数在当前状态下对<strong>相机姿态</strong>的偏导数，而 $E_{ij}$ 表示该函数对<strong>路标点位置</strong>的偏导。</p><p><strong>观测相机方程关于相机位姿的导数矩阵：</strong></p><script type="math/tex; mode=display">\begin{align*}F&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\\end{align*}\tag{42}</script><p><strong>观测相机方程关于特征点的导数矩阵</strong></p><script type="math/tex; mode=display">E=\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}R\tag{43}</script><p>关于$E,F$雅可比矩阵的具体求导过程，可以查阅：<a href="https://lukeyalvin.top/posts/20908.html">ch7_求解PnP并使用BA优化</a></p><p>现在，把相机位姿变量放在一起：</p><script type="math/tex; mode=display">x_c=[\xi_1,\xi_2,...,\xi_m]\in\mathbb{R}^{6m}\tag{44}</script><p>并把空间点的变量也放在一起：</p><script type="math/tex; mode=display">x_p=[p_1,p_2,...,p_n]^T\in \mathbb{R}^{3n}\tag{45}</script><p>目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e+F\Delta x_c+E_\Delta x_p \parallel^2\tag{46}</script><p>需要注意的是，该式从一个由<strong>很多个小型二次项之和</strong>，变成了一个更整体的样子。这里的雅可比矩阵 $E $和$ F$ 必须是整体目标函数对整体变量的导数，它将是一个很大块的矩阵，而里头每个小分块，需要由每个误差项的导数 $F_{ij} $和 $E_{ij}$ “拼凑”起来。然后，无论我们使用 $G-N$ 还是$ L-M $方法，最后都将面对增量线性方程：</p><script type="math/tex; mode=display">H\Delta x = g\tag{47}</script><p>如果是高斯牛顿，$H$ 取$J^TJ$；列文伯格是 $J^T J + λI $的形式</p><p>由于我们把变量归类成了位姿和空间点两种，所以雅可比矩阵可以分块为：</p><script type="math/tex; mode=display">J=\begin{bmatrix}F & E\end{bmatrix}\tag{48}</script><p>其中$F$是$2 × 6$的矩阵，$E$是$2 × 3$的矩阵.</p><p>以 G-N 为例，则 H 矩阵为：</p><script type="math/tex; mode=display">H=J^TJ=\begin{bmatrix}F^TF & F^TE\\E^TF & E^TE\end{bmatrix}\tag{49}</script><p>在SLAM中我们会考虑H矩阵的稀疏性，进而加速BA的求解。</p><h2 id="稀疏性和边缘化"><a href="#稀疏性和边缘化" class="headerlink" title="稀疏性和边缘化"></a>稀疏性和边缘化</h2><p>在视觉 SLAM 中，一个图像就会提出数百个特征点，大大增加了这个线性方程的规模。如果直接对 H 求逆来计算增量方程，由于矩阵求逆是复杂度为 $O(n^3 )$ 的操作，这是非常消耗计算资源的。幸运地是，这里的 H 矩阵是有一定的特殊结构的。利用这个特殊结构，我们可以加速求解过程。</p><p>21 世纪视觉 SLAM 的一个重要进展是认识到了矩阵 H 的稀疏结构，并发现该结构可以自然、显式地用图优化来表示 。</p><p>举例：假设一个场景内有 $2$ 个相机位姿 $(C_1 , C_2 )$ 和 $6$ 个路标 $(P_1 , P_2 , P_3 , P_4 , P_5 , P_6 )$。这些相机和点云所对应的变量为 $ξ_i , i = 1, 2$ 以及 $p_j , j = 1, . . . , 6$。相机 $C_1$ 观测到路标 $P_1 , P_2 , P_3 , P_4$ ，相机 $C_2$ 观测到了路标 $P_3 , P_4 , P_5 , P_6$ 。</p><p>如图所示：相机和路标以圆形节点表示。如果 $i$ 相机能够观测到 $j$ 点云，我们就在它们对应的节点连上一条边。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513160409346.png" alt="image-20220513160409346" style="zoom: 33%;" /></p><p>可以推出该场景下的 BA 目标函数应该是：</p><script type="math/tex; mode=display">\frac{1}{2}\left(\parallel e_{11} \parallel^2+\parallel e_{12} \parallel^2+\parallel e_{13} \parallel^2+\parallel e_{14} \parallel^2+\parallel e_{23} \parallel^2+\parallel e_{24} \parallel^2+\parallel e_{25} \parallel^2+\parallel e_{26} \parallel^2\right)\tag{50}</script><p>这里的 $e_{ij}$ 使用之前定义过的代价函数，即式 $(39)$。以 $e_{11}$ 为例，它描述了在 $C_1$ 看到了 $P_1$ 这件事，与其他的相机位姿和路标无关。令 $J_{11}$  为  $e_{11}$  所对应的雅可比矩阵，不难看出  $e_{11}$  对相机变量 $\xi_2$ 和路标点 $p_2 , . . . , p_6$ 的偏导都为 0。我们把所有变量以 $x = (ξ_1 , ξ_2 , p_1 , . . . , p_6 )^T$ 的顺序摆放，则有：</p><script type="math/tex; mode=display">J_{11}=\frac{\partial e_{11} }{\partial x}=\left(\frac{\partial e_{11} }{\partial \xi_1},0,\frac{\partial e_{11} }{\partial p_1},0,0,0,0,0\right)\tag{51}</script><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161314472.png" alt="image-20220513161314472" style="zoom:50%;" /></p><p>类似地，可以推导出如下图案：</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161435601.png" alt="image-20220513161435601" style="zoom: 50%;" /></p><p>现在考虑更一般的情况，假如我们有 $m$ 个相机位姿，$n $ 个路标点。由于通常路标数量 远远会比相机多，于是有 $n ≫ m$。由上面推理可知，实际当中的 H 矩阵会像下图所示的那样。它的左上角块显得非常小，而右下角的对角块占据了大量地方。除此之外，非 对角部分则分布着散乱的观测数据。由于它的形状很像箭头，又称为<strong>箭头形（Arrow-like） 矩阵</strong>。同时它又很像一把镐子，所以也叫<strong>镐形矩阵</strong>。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161821872.png" alt="image-20220513161821872" style="zoom: 33%;" /></p><p>于是，对应的线性方程组也可以由 $H∆x = g $ 变为如下形式：</p><script type="math/tex; mode=display">\begin{bmatrix}B&E\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}v\\w\end{bmatrix}\tag{52}</script><p>其中 $B$ 是对角块矩阵，每个对角块的维度和相机参数的维度相同，对角块的个数是相机变量的个数。由于路标数量会远远大于相机变量个数，所以 $C$ 往往也远大于 $B$。三 维空间中每个路标点为三维，于是 $C$ 矩阵为对角块矩阵，每个块为 $3 \times 3$ 维矩阵。</p><p>考虑到对角块矩阵求逆的难度远小于对一般矩阵的求逆难度，我们对线性方程组进行高斯消元，目标是消去右上角的非对角部分 $E$，得：</p><script type="math/tex; mode=display">\begin{bmatrix}I&-EC^{-1}\\0&I\end{bmatrix}\begin{bmatrix}B&E\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}I&-EC^{-1}\\0&I\end{bmatrix}\begin{bmatrix}v\\w\end{bmatrix}\tag{53}</script><p>整理得：</p><script type="math/tex; mode=display">\begin{bmatrix}B-EC^{-1}E^T&0\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}v-EC^{-1}w\\w\end{bmatrix}\tag{54}</script><p>经过消元之后，第一行方程组变成和 $∆x_p$ 无关的项。单独把它拿出来，得到关于位姿部分的增量方程：</p><script type="math/tex; mode=display">[B-EC^{-1}E^T]\Delta x_c=v-EC^{-1}w\tag{55}</script><p>这个线性方程组的维度和 $B$ 矩阵一样。我们的做法是先求解这个方程，然后把解得 的 $∆x_c$ 代入到原方程，然后求解 $∆x_p$ 。</p><script type="math/tex; mode=display">\Delta x_p=C^{-1}(w-E^T\Delta x_c)\tag{56}</script><p>这个过程称为 <strong>Marginalization</strong>，或者 <strong>Schur 消元 (Schur Elimination)</strong>。</p><p>我们记 式 $(55)$ 中的 $\Delta x_c$的系数为 $S=B-EC^{-1}E^T$ ，我们看一下它的稀疏性：</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513165129947.png" alt="image-20220513165129947" style="zoom: 33%;" /></p><p>$S$ 矩阵的非对角线上的非零矩阵块，表示了该处对应的两个相机变量之间存在着共同观测的路标点，有时候称为<strong>共视（Co-visibility）</strong>。反之，如果该块为零，则表示这两个相机没有共同观测。如上图所示的稀疏矩阵，左上角前 $4 \times 4$ 个矩阵块可以表示对应的相 机变量 $C_1 , C_2 , C_3 , C_4$ 之间有共同观测。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="最小二乘法" scheme="https://lukeyalvin.top/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"/>
    
    <category term="后端优化" scheme="https://lukeyalvin.top/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    <category term="BA与图优化" scheme="https://lukeyalvin.top/tags/BA%E4%B8%8E%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SLAM中的概率基础</title>
    <link href="https://lukeyalvin.top/posts/2613d057.html"/>
    <id>https://lukeyalvin.top/posts/2613d057.html</id>
    <published>2022-05-11T12:38:35.000Z</published>
    <updated>2022-05-13T13:10:28.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="概率与概率密度"><a href="#概率与概率密度" class="headerlink" title="概率与概率密度"></a>概率与概率密度</h2><p><img src="/images/SLAM中的概率基础/image-20220511204935450.png" alt="image-20220511204935450" style="zoom:50%;" /></p><p>图中，函数 $p(x)$ 表示 $x$ 在区间 $[a,b]$ 上的<strong>概率密度</strong>，它表示的是随机变量在区间的分布情况。</p><p>$Pr$ 代表的是 $x$ 在区间 $[c,d]$ 上的<strong>概率</strong>，它是概率密度函数的积分：</p><script type="math/tex; mode=display">Pr(c\leq x \leq d)=\int^d_c p(x)dx\tag{1}</script><p>我们平时所说“高斯分布”、“非高斯分布”均是指它的概率密度。</p><h2 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h2><p><strong>联合概率</strong>表示两个事件共同发生的概率。事件 $A$ 和事件 $B$ 的联合概率表示为 $P(A\cap B),P(A,B),P(AB)$ </p><p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ 的联合概率密度函数可以表示为 $p(x,y)$，其积分表示 $x,y$ 同处在某个区间的概率，满足下式：</p><script type="math/tex; mode=display">\int^b_a\int^s_rp(x,y)dydx=1\tag{2}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p><script type="math/tex; mode=display">p(x,y)=p(x)p(y)\tag{3}</script><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>就是事件 $A$ 在事件 $B$ 发生的条件下发生的概率。即为 $P(B|A)$.</p><p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ ，当在 $y$ 已知的前提下，$x$ 的概率分布满足下式：</p><script type="math/tex; mode=display">p(x)=\int^s_r p(x|y)p(y)dy\tag{4}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p><script type="math/tex; mode=display">p(x|y)=p(x)\tag{5}</script><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>联合概率分解成条件概率和边缘概率的乘积，即</p><script type="math/tex; mode=display">p(x,y)=p(x|y)p(y)=p(y|x)p(x)\tag{6}</script><p>重新整理，即可得贝叶斯公式</p><script type="math/tex; mode=display">p(x|y)=\frac{p(y|x)p(x)}{p(y)}\tag{7}</script><h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>贝叶斯推断可以理解为贝叶斯公式的运用，它是指，如果已知<strong>先验</strong>概率密度函数 $p(x)$，以及<strong>传感器模型</strong> $p(y|x)$，那么就可以根据贝叶斯公式推断出<strong>后验</strong>概率密度。</p><script type="math/tex; mode=display">p(x|y)=\frac{p(y|x)p(x)}{\int p(y|x)p(x)dx}\tag{8}</script><p>实际中，贝叶斯推断有时也叫贝叶斯估计。</p><h2 id="高斯概率密度函数"><a href="#高斯概率密度函数" class="headerlink" title="高斯概率密度函数"></a>高斯概率密度函数</h2><p><strong>一维情况下，</strong>高斯概率密度函数表示：</p><script type="math/tex; mode=display">p(x|\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2} }\exp(-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2})\tag{9}</script><p>其中 $\mu$ 为均值， $\sigma$ 为方差。</p><p><strong>多维情况下，</strong>高斯概率密度函数表示为：</p><script type="math/tex; mode=display">p(x|\mu,\Sigma)=\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)\tag{10}</script><p>其中 $\mu$ 为均值， $\Sigma$ 为方差。</p><p>一般把高斯分布写成 $x\sim\mathcal{N}(\mu,\Sigma)$。</p><h2 id="联合高斯概率密度函数"><a href="#联合高斯概率密度函数" class="headerlink" title="联合高斯概率密度函数"></a>联合高斯概率密度函数</h2><p>若有高斯分布：</p><script type="math/tex; mode=display">\begin{align*}p(x)&=\mathcal{N}(\mu_x,\Sigma_{xx})\\p(x)&=\mathcal{N}(\mu_y,\Sigma_{yy})\end{align*}\tag{11}</script><p>则它们的联合概率密度函数可以表示为:</p><script type="math/tex; mode=display">p(x,y)=\mathcal{N}\left(\begin{bmatrix}\mu_x\\\mu_y\end{bmatrix},\begin{bmatrix}\Sigma_{xx}&\Sigma_{xy}\\\Sigma_{yx}&\Sigma_{yy}\end{bmatrix}\right)\tag{12}</script><p>由于联合概率满足下式:</p><script type="math/tex; mode=display">p(x,y)=p(x|y)p(y)\tag{13}</script><p>该式在高斯分布的前提下可以重新分解。</p><h1 id="高斯分布和协方差矩阵"><a href="#高斯分布和协方差矩阵" class="headerlink" title="高斯分布和协方差矩阵"></a>高斯分布和协方差矩阵</h1><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>由公式 $(10)$可知，零均值的多元高斯分布有如下概率形式：</p><script type="math/tex; mode=display">\begin{align*}p(x)=&\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(-\frac{1}{2}x^T\Sigma^{-1}x\right)\\=&\frac{1}{Z }\exp\left(-\frac{1}{2}x^T\Sigma^{-1}x\right)\end{align*}\tag{14}</script><p>其中 $\Sigma$ 是<strong>协方差矩阵</strong>，协方差矩阵的逆记作 $Λ = \Sigma^{-1}$ ，也称之为<strong>信息矩阵</strong>。</p><p>比如变量 $x$ 为三维的变量时，协方差矩阵为:</p><script type="math/tex; mode=display">\Sigma=\begin{bmatrix}\Sigma_{11}&\Sigma_{12}&\Sigma_{13}\\\Sigma_{21}&\Sigma_{22}&\Sigma_{23}\\\Sigma_{31}&\Sigma_{32}&\Sigma_{33}\end{bmatrix}\tag{15}</script><p>根据协方差的定义，其中 $Σ_{ij} = E(x_ix_j ) $为对应元素求期望。</p><p>关于协方差矩阵的一些案例介绍，可以查看，<a href="https://lukeyalvin.top/posts/8369.html#%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">协方差矩阵</a></p><h2 id="协方差矩阵与信息矩阵"><a href="#协方差矩阵与信息矩阵" class="headerlink" title="协方差矩阵与信息矩阵"></a>协方差矩阵与信息矩阵</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>设 $x_2$ 为室外的温度，$x_1 , x_3$ 分别为房间 $1$ 和房间 $3$ 的室内温度:</p><script type="math/tex; mode=display">\begin{align*}x_2&=v_2\\x_1&=w_1x_2+v_1\\x_3&=w_3x_2+v_3\\\end{align*}\tag{16}</script><p>其中，$w_i$ 为正的常数值，$v_i$ 相互独立，且各自服从协方差矩阵为 $\sigma_i^2$ 的高斯分布。</p><p><img src="/images/SLAM中的概率基础/image-20220512153417672.png" alt="image-20220512153417672" style="zoom:25%;" /></p><p>从上述关系，根据协方差公式的计算方式，我们可以写出 $x$ 的协方差矩阵，先从对角元素开始计算：</p><script type="math/tex; mode=display">\begin{align*}\Sigma_{11}=E(x_1x_1)&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1})({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1}))\\&={\color{red}w_1^2}E({\color{green}v_2^2})+2{\color{red}w_1}E({\color{red}v_1}{\color{green}v_2})+E({\color{red}v_1^2})\\&={\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}\end{align*}\tag{17}</script><p>同理有 $\Sigma_{22}={\color{green}\sigma_2^2},\Sigma_{33}={\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}$ ，对于协方差矩阵的非对角元素：</p><script type="math/tex; mode=display">\begin{align*}\Sigma_{12}&=E(x_1x_2)=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} ){\color{green}v_2})={\color{red}w_1}{\color{green}\sigma_2^2}\\\Sigma_{13}&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} )({\color{blue}w_3}{\color{green}v_2}+{\color{blue}v_3} ))={\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\end{align*}\tag{18}</script><p>以此类推，可以得到整个<strong>协方差矩阵</strong>：</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}\end{bmatrix}\end{align*}\tag{19}</script><p>通过计算<strong>联合高斯分布</strong>从而得到协方差矩阵的逆：</p><script type="math/tex; mode=display">\begin{align*}p(x_1,x_2,x_3)&=p(x_2)p(x_1|x_2)p(x_3|x_2)\\&={\color{green}\frac{1}{Z_2}\exp(-\frac{x^2_2}{2\sigma_2^2})}{\color{red}\frac{1}{Z_1}\exp(-\frac{(x_1-w_1x_2)^2}{2\sigma_1^2})}{\color{blue}\frac{1}{Z_3}\exp(-\frac{(x_3-w_3x_2)^2}{2\sigma_3^2})}\\&=\frac{1}{Z}\exp(-x_2^2[{\color{green}\frac{1}{2\sigma_2^2} }+{\color{red}\frac{w_1^2}{2\sigma_1^2} }-{\color{blue}\frac{w_3^2}{2\sigma_3^2} }]-x_1^2{\color{red}\frac{1}{2\sigma_1^2} }+2x_1x_2{\color{red}\frac{w_1}{2\sigma_1^2} }-x_3^2{\color{blue}\frac{1}{2\sigma_3^2} }+2x_3x_2{\color{blue}\frac{w_3}{2\sigma_3^2} })\\&=\frac{1}{Z}\exp(-\frac{1}{2}\begin{bmatrix}x_1&x_2&x_3\end{bmatrix}\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&{\color{blue}-\frac{w_3}{\sigma_3^2} }\\0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix})\end{align*}\tag{20}</script><p>由此得到协方差矩阵的逆，即<strong>信息矩阵</strong>：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&{\color{blue}-\frac{w_3}{\sigma_3^2} }\\0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }\end{bmatrix}\tag{21}</script><p><strong>总结：</strong></p><p><font color="#660066">协方差矩阵中，非对角元素 $\Sigma_{ij}&gt;0，i\ne j$ 表示两个变量之间是<strong>正相关</strong>；非对角元素 $\Sigma_{ij}=0，i\ne j$ 表示两个变量之间是<strong>相互独立</strong>；</font><br /></p><p><font color="#660066">信息矩阵中，非对角元素 $Λ_{ij}&lt;0，i\ne j$ 甚至于  $Λ_{ij}=0，i\ne j$ ，比如 $Λ_{12} &lt; 0$   表示在变量 $x_3$ 发生的条件下，元素 $x_1$ 和 $x_2$ <strong>正相关</strong>。  </font><br /></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>类似与案例一，定义 $x_1,x_2,x_3$ 关系如下：</p><script type="math/tex; mode=display">x_2=w_1x_1+w_3x_3+v_2\tag{22}</script><p>比如特征三角化，两个相机 pose 得到特征三维坐标。</p><p><img src="/images/SLAM中的概率基础/image-20220512164657043.png" alt="image-20220512164657043" style="zoom:25%;" /></p><p>同理，根据协方差矩阵的定义，可以得到协方差矩阵：</p><script type="math/tex; mode=display">\Sigma=\begin{bmatrix}{\color{red}\sigma_1^2}&{\color{red}w_1} {\color{red}\sigma_1^2}&0\\{\color{red}w_1} {\color{red}\sigma_1^2}&{\color{green}\sigma_2^2}+{\color{red}w_1} {\color{red}\sigma_1^2}+{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}w_3}  {\color{blue}\sigma_3^2}\\0&{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}\sigma_3^2}\end{bmatrix}\tag{23}</script><p><strong>协方差矩阵中非对角元素为 0 表示变量之 间没有相关性。</strong>这是否意味着信息矩阵中也会为 0 呢？</p><p>同样的方法求得协方差矩阵的逆，即<strong>信息矩阵</strong>：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }+{\color{green}\frac{w_1^2}{\sigma_2^2} }&{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{w_1w_3}{\sigma_2^2} }\\{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{1}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }\\{\color{green}\frac{w_1w_3}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }&{\color{BLUE}\frac{1}{\sigma_3^2} }+{\color{green}\frac{w_3^2}{\sigma_2^2} }\end{bmatrix}\tag{24}</script><p><strong>总结：</strong></p><p><span style="color:red;">虽然 $x_1$ 和 $x_3$ <strong>不相关</strong>，但是不说明他们的信息矩阵对应元素 $Λ_{13}$<br>为 0；恰恰信息矩阵中 $Λ_{13} &gt; 0$, 表示的是在变量 $x_2$ 发生的条件下，变 量$x_1$ 和 $x_3$ 成<strong>负相关</strong>。对应上面的例子即  $x_2$ 为常数，<strong>如果 $x_1$  大，则 $x_3$ 小</strong>。</span></p><p><strong>样例的意义: 非常有助于我们了解 SLAM 的信息矩阵 H 的组成。</strong></p><h3 id="去除案例1中变量"><a href="#去除案例1中变量" class="headerlink" title="去除案例1中变量"></a>去除案例1中变量</h3><p>如果我们移除变量，信息矩阵或协方差矩阵如何变化呢?</p><p>比如对于案例一来说，去除变量$x_3$，那么它的信息矩阵或协方差矩阵如何变化呢?</p><p><img src="/images/SLAM中的概率基础/image-20220512170647991.png" alt="image-20220512170647991" style="zoom:25%;" /></p><p>利用协方差的计算公式可知，$x_1 , x_2$ 计算协方差时跟 $x_3$ ，并无关系，所以:</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }\\\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }&\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }&\xcancel{ {\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2} }\end{bmatrix}\end{align*}\tag{25}</script><p>就能得到去除 $x_3$  后的协方差矩阵：</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}\\\end{bmatrix}\end{align*}\tag{26}</script><p>同样，我们只418133364需要把信息矩阵公式 $(16)$ 中 $x_3$  对应的部分 (蓝色) 去掉 就可以:</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&\xcancel{0}\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2}+\xcancel{ {\color{blue}\frac{w_3^2}{\sigma_3^2} } } }&\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }\\\xcancel{0}&\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }&\xcancel{ {\color{blue}-\frac{1}{\sigma_3^2} } }\end{bmatrix}\tag{27}</script><p>从而得到：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\\end{bmatrix}\tag{28}</script><p>是不是非常简单？但是问题在于：<strong>实际操作过程中并不会有这种颜色标记。</strong></p><p>这时，需要引入 marginalization <strong>(边缘化)</strong> 和 Schur’s complement <strong>(舒尔补)</strong>来解决这个问题。</p><h1 id="舒尔补及其应用"><a href="#舒尔补及其应用" class="headerlink" title="舒尔补及其应用"></a>舒尔补及其应用</h1><h2 id="舒尔补的概念"><a href="#舒尔补的概念" class="headerlink" title="舒尔补的概念"></a>舒尔补的概念</h2><p>给定任意矩阵块 $M$，如下所示：</p><script type="math/tex; mode=display">M=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{29}</script><p>如果，矩阵块 $D$ 是可逆的，则 $A − BD^{−1} C$称之为 $D$ 关于 $M$ 的舒尔补。</p><p>如果，矩阵块 $A$ 是可逆的，则 $D − CA^{−1} B$ 称之为 $A$ 关于 $M$ 的舒尔补。</p><h2 id="舒尔补的来由"><a href="#舒尔补的来由" class="headerlink" title="舒尔补的来由"></a>舒尔补的来由</h2><p>将 $M$ 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&B\\C&D\end{bmatrix}=\begin{bmatrix}A&B\\0&\Delta_A\end{bmatrix}\\\begin{bmatrix}A&B\\C&D\end{bmatrix}\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&0\\C&\Delta_A\end{bmatrix}\end{align*}\tag{30}</script><p>其中：$∆_A = D − CA^{−1} B$。联合起来，将 $M$ 变形成对角形：</p><script type="math/tex; mode=display">\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&B\\C&D\end{bmatrix}\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\tag{31}</script><p>反过来，我们又能从对角形恢复成矩阵 $M$：</p><script type="math/tex; mode=display">\begin{bmatrix}I&0\\CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\begin{bmatrix}I&A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{32}</script><h2 id="舒尔补分解的好处"><a href="#舒尔补分解的好处" class="headerlink" title="舒尔补分解的好处"></a>舒尔补分解的好处</h2><p><strong>快速求解矩阵 M 的逆</strong>。由于矩阵 $M$ 可以写成：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}=\begin{bmatrix}I&0\\CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\begin{bmatrix}I&A^{-1}B\\0&I\end{bmatrix}\tag{33}</script><p>由此可得到矩阵 $M$ 的逆：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\tag{34}</script><p>我们发现，原本复杂的求逆矩阵的过程变得更加容易了。</p><h2 id="舒尔补应用于多元高斯分布"><a href="#舒尔补应用于多元高斯分布" class="headerlink" title="舒尔补应用于多元高斯分布"></a>舒尔补应用于多元高斯分布</h2><p>假设多元变量 $x$ 服从高斯分布，且由两部分组成：$x=\begin{bmatrix}a\\b\end{bmatrix}$，变量之间的协方差矩阵为：</p><script type="math/tex; mode=display">K=\begin{bmatrix}Cov(a,a)&Cov(a,b)\\Cov(b,a)&Cov(b,b)\end{bmatrix}=\begin{bmatrix}A&C^T\\C&D\end{bmatrix}\tag{35}</script><p>依据公式 $(6)$ ，变量 $x$ 的概率分布为：</p><script type="math/tex; mode=display">P(a,b)=p(b|a)p(a)∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\tag{36}</script><p>利用舒尔补进行分解指数部分：</p><script type="math/tex; mode=display">\begin{align*}&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}I&-A^{-1}C^T\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a^T&(b-CA^{-1}a)^T\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}a\\b-CA^{-1}a\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)+(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)\right)\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\&∝p(a)p(b|a)\end{align*}\tag{37}</script><p>类似与公式 $(6)$ 的贝叶斯公式，我们将联合概率分解成条件概率和边缘概率的乘积。对于高斯分布而言，我们可以从多元高斯分布 $P(a,b)$ 中分解得到边际概率 $p(a)$ 和 条件概率 $p(b|a)$。</p><h3 id="P-a-P-b-a-的协方差矩阵"><a href="#P-a-P-b-a-的协方差矩阵" class="headerlink" title="$P(a), P(b|a)$ 的协方差矩阵"></a>$P(a), P(b|a)$ 的协方差矩阵</h3><p>$P(a)$ 的启示:</p><script type="math/tex; mode=display">P(a)∝\exp\left(-\frac{1}{2}a^TA^{-1}a\right)\sim\mathcal{N}(0,A)\tag{38}</script><p><span style="color:red;"><strong>启示：边际概率的协方差就是从联合分布中取对应的矩阵块就行了。</strong></span></p><p>$P(b|a)$ 的启示:</p><script type="math/tex; mode=display">P(b|a)∝\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T\Delta_A^{-1}(b-CA^{-1}a)\tag{39}\right)</script><p><span style="color:red;"><strong>启示：$P(b|a)\sim \mathcal{N} (CA^{−1} a,\Delta_A )$。条件概率的协方差变为 $a$ 对应的舒尔补，均值也变了。</strong></span></p><h3 id="P-a-P-b-a-的信息矩阵"><a href="#P-a-P-b-a-的信息矩阵" class="headerlink" title="$P(a), P(b|a)$ 的信息矩阵"></a>$P(a), P(b|a)$ 的信息矩阵</h3><p><strong>为什么要讨论 $P (a), P (b|a)$ 的信息矩阵？</strong><br>因为基于优化的 SLAM 问题中，我们往往直接操作的是<strong>信息矩阵</strong>，而不是协方差矩阵。所以，有必要知道边际概率，条件概率的信息矩阵是何形式。</p><p>假设已知<strong>联合分布的信息矩阵</strong>：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\tag{40}</script><p>另外，由公式 $(34)$ 可知，协方差矩阵各块和信息矩阵之间有：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}A^{-1}+A^{-1}C^T\Delta_A^{-1}CA^{-1}&-A^{-1}C^T\Delta_A^{-1}\\-\Delta_A^{-1}CA^{-1}&\Delta_A^{-1}\end{bmatrix}\triangleq\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\tag{41}</script><p>其中：$∆_A^{-1} = [D − CA^{−1} B]^{-1}$。</p><p>由条件概率 $P (b|a)$ 的<strong>协方差矩阵</strong>为 $∆_A$ 以及公式 $(41)$，易得其<strong>信息矩阵</strong>为：</p><script type="math/tex; mode=display">∆_A^{-1}=Λ_{bb}\tag{42}</script><p>由边际概率 $P (a)$ 的<strong>协方差矩阵</strong>为 $A$ 以及公式$(41)$，易得其<strong>信息矩阵</strong>为：</p><script type="math/tex; mode=display">A^{-1}=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\tag{43}</script><p>由此我们就知道如何从<strong>联合分布的信息矩阵</strong>中求解 $P ( a )$和 $P(b|a)$ 的<strong>信息矩阵</strong>了。</p><h2 id="回顾样例"><a href="#回顾样例" class="headerlink" title="回顾样例"></a>回顾样例</h2><p>回顾 “<strong>去除案例1中变量</strong>” 中去除变量 $x_3$ 的操作</p><p><img src="/images/SLAM中的概率基础/image-20220512213456958.png" alt="image-20220512213456958" style="zoom: 33%;" /></p><p>从联合分布 $P (x_1 , x_2 , x_3 )$中 marg 掉变量 $x_3$ ，即 $P (x_1 , x_2 )$ 对应的信息矩阵可以用公式 $(43)$ 得到。</p><script type="math/tex; mode=display">\begin{align*}\Sigma^{-1}_2&=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\\&=Λ_{aa}-\begin{bmatrix}0\\-\frac{w_3}{\sigma^2_3}\end{bmatrix}\sigma^2_3\begin{bmatrix}0&-\frac{w_3}{\sigma^2_3}\end{bmatrix}\\&=Λ_{aa}-\begin{bmatrix}0&0\\0&\frac{w_3}{\sigma^2_3}\end{bmatrix}\\&=\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\\end{bmatrix}\end{align*}\tag{44}</script><p>这么操作，就使得在已知<strong>联合分布的信息矩阵</strong>的前提下，我们通过舒尔补的操作，即 $(44)$ 中的 $Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}$，65                   </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。 条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。</strong> 表格总结如下:</p><script type="math/tex; mode=display">P(a,b)=\mathcal{N}\left(\begin{bmatrix}\mu_a\\\mu_b\end{bmatrix},\begin{bmatrix}\Sigma_{aa}&\Sigma_{ab}\\\Sigma_{ba}&\Sigma_{bb}\end{bmatrix}\right)=\mathcal{N}^{-1}\left(\begin{bmatrix}\eta_a\\\eta_b\end{bmatrix},\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\right)\tag{45}</script><p><img src="/images/SLAM中的概率基础/image-20220512215118251.png" alt="image-20220512215118251" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学基础" scheme="https://lukeyalvin.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="概率基础" scheme="https://lukeyalvin.top/tags/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>六、VIO视觉残差的构建以及雅可比的求取</title>
    <link href="https://lukeyalvin.top/posts/c041a7d0.html"/>
    <id>https://lukeyalvin.top/posts/c041a7d0.html</id>
    <published>2022-05-10T11:40:18.000Z</published>
    <updated>2022-05-11T08:03:05.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p><h1 id="VIO残差构建"><a href="#VIO残差构建" class="headerlink" title="VIO残差构建"></a>VIO残差构建</h1><p>VIO重投影误差：</p><p>具体详解见：<a href="https://lukeyalvin.top/posts/ddbf64.html#VIO%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE"><a href="https://lukeyalvin.top/posts/ddbf64.html#VIO重投影误差">VIO重投影误差</a></a></p><p><img src="/images/5-VIO视觉残差的构建以及雅可比的求取/image-20220505205125811-16522560257751.png" alt="image-20220505205125811" style="zoom: 33%;" /></p><p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p><script type="math/tex; mode=display">\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{1}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u_{cj}\\\frac{Y_{cj} }{Z_{cj} }-v_{cj}\end{bmatrix}\tag{2}</script><h1 id="VIO残差的雅可比推导"><a href="#VIO残差的雅可比推导" class="headerlink" title="VIO残差的雅可比推导"></a>VIO残差的雅可比推导</h1><p>按照变换矩阵和旋转矩阵之间的关系：</p><script type="math/tex; mode=display">\begin{align*}T_{bc}^{-1}&=\begin{bmatrix}R^T_{bc}&-R^T_{bc}p_{bc}\\0^T&1\end{bmatrix},\ T_{wb_j}^{-1}=\begin{bmatrix}R^T_{wb_j}&-R^T_{wb_j}p_{wb_j}\\0^T&1\end{bmatrix}\\T_{wb_j}&=\begin{bmatrix}R^T_{wb_j}&p_{wb_j}\\0^T&1\end{bmatrix},\ \ \ \ \  \ \  \ T_{bc}=\begin{bmatrix}R^T_{bc}&p_{bc}\\0^T&1\end{bmatrix}\end{align*}\tag{3}</script><p>根据公式$(3)$将公式$(1)$中拆分成三维坐标形式：</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}=\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\end{bmatrix}&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}\frac{1}{\lambda}\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\&+R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\end{align*}\tag{4}</script><p>为了推导的方便定义如下公式：</p><script type="math/tex; mode=display">\begin{align*}f_{c_i}&=\frac{1}{\lambda}\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\f_{b_i}&=R_{bc}f_{c_i}+p_{bc}\\f_w&=R_{wb_i}f_{b_i}+p_{wb_i}\\f_{b_j}&=R^T_{wb_j}(f_{w}-p_{bc})\\\end{align*}\tag{5}</script><p>雅可比矩阵 为视觉误差对两个时刻的状态量，外参以及逆深度求导：</p><script type="math/tex; mode=display">J=\begin{bmatrix}\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_ib_i^\prime}\\ \delta\theta_{b_ib_i^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_jb_j^\prime}\\ \delta\theta_{b_jb_j^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{cc^\prime}\\ \delta\theta_{cc^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\delta\lambda } \end{bmatrix}\tag{6}</script><p>根据链式法则， Jacobian 的计算可以分两步走:</p><ul><li>第一步误差对 $f_{c_j}$ 求导：  </li></ul><script type="math/tex; mode=display">\frac{\partial r_c}{\partial f_{c_j} }=\begin{bmatrix}\frac{1}{Z_{c_j} }&0&\frac{X_{c_j}}{Z_{c_j}^2 }\\0&\frac{1}{Z_{c_j} }&\frac{Y_{c_j}}{Z_{c_j}^2 }\end{bmatrix}\tag{7}</script><ul><li>第二步对 $f_{c_j}$ 对各状态量求导：</li></ul><ol><li><strong>对 $i$ 时刻的状态量求导</strong></li></ol><p>① 对 $i$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_ib_i^\prime} }=R^{T}_{bc}R^{T}_{wb_j}\tag{8}</script><p>② 对 $i$ 时刻的<strong>角度</strong>增量求导</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}\left(R^{T}_{wb_j}\left( ({\color{red}R_{wb_i} }p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\end{align*}\tag{9}</script><p>上面公式和 $i$ 时刻角度相关的量并不多，下面为了简化，直接丢弃了不相关的部分 :</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }p_{bc}+(···)\\&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(R_{bc}f_{c_i}+p_{bc})+(···)\\&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}+(···)\end{align*}\tag{9}</script><p> 雅可比矩阵为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(I+[\delta\theta_{b_ib^\prime_i}]^{\land})f_{b_i}-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[\delta\theta_{b_ib^\prime_i}]^{\land}f_{b_i} }{\partial\delta\theta_{b_ib^\prime_i} }\\&=-\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} [\delta\theta_{b_ib^\prime_i}]}{\partial\delta\theta_{b_ib^\prime_i} }\\&=-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} \end{align*}\tag{10}</script><ol><li><strong>对 $j$ 时刻的状态量求导</strong></li></ol><p>① 对 $j$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_jb_j^\prime} }=-R^{T}_{bc}R^{T}_{wb_j}\tag{11}</script><p>② 对 $j$ 时刻的<strong>角度</strong>增量求导</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }R_{wb_i}R_{bc}f_{c_i}+R^{T}_{bc}\left({\color{green}R^{T}_{wb_j} }\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\\&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }\left(R_{wb_i}(R_{bc}f_{c_i}+p_{bc})+p_{wb_j}-p_{wb_j}\right)+(···)\\&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }(f_w-p_{wb_j})+(···)\\\end{align*}\tag{12}</script><p> 雅可比矩阵为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}(I-[\delta\theta_{b_ib^\prime_j}]^{\land}){\color{green}R^T_{wb_j} }(f_w-p_{wb_j})-R^{T}_{bc}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}f_{b_j} }{\partial\delta\theta_{b_ib^\prime_i} }\\&-=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[f_{b_j}]^{\land}[\delta\theta_{b_ib^\prime_j}] }{\partial\delta\theta_{b_ib^\prime_i} }\\&=-R^{T}_{bc}[f_{b_j}]^{\land}\end{align*}\tag{13}</script><ol><li><strong>对 imu 和相机之间的外参求导</strong>  </li></ol><p>① 对<strong>位移</strong>求导</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{cc^\prime} }=R^{T}_{bc}(R^{T}_{wb_j}R_{wb_i}-I_{3\times 3})\tag{14}</script><p>② 对<strong>角度</strong>增量求导，由于 $f_{c_j}$ 都和 $R_{bc}$ 有关，并且比较复杂，所以这次分两部分求导  </p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&={\color{green}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i} }+{\color{blue}R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)}\\&={\color{green}f^1_{c_j} }+{\color{blue}f^2_{c_j} }\end{align*}\tag{15}</script><p>第一部分 ${\color{green}f^1_{c_j} }$ 雅可比为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j}^1 }{\partial\delta\theta_{cc^\prime} }=&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\and}) R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(I+[\delta\theta_{cc^\prime}]^{\and}) f_{c_i}-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc} }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[\delta\theta_{cc^\prime}]^{\and}f_{c_i}-[\delta\theta_{cc^\prime}]^{\and} R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}+o^2(\theta_{cc^\prime}) }{\partial\delta\theta_{cc^\prime} }\\&\approx \underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial -R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\and}[\delta\theta_{cc^\prime}]+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\and}[\delta\theta_{cc^\prime}] ) }{\partial\delta\theta_{cc^\prime} }\\&=-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\and}+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\and}\end{align*}\tag{16}</script><p>第一部分 ${\color{blue}f^2_{c_j} }$ 雅可比为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j}^2 }{\partial\delta\theta_{cc^\prime} }&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\and}) R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)-R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right) }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial-[\delta\theta_{cc^\prime}]^{\and} R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right) }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial-[R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)]^{\and}[\delta\theta_{cc^\prime}]  }{\partial\delta\theta_{cc^\prime} }\\&=[R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)]^{\and}\end{align*}\tag{17}</script><p>两个 Jacobian 相加就是视觉误差对外参中的角度增量的最终结果。  </p><ol><li><strong>视觉误差对特征逆深度的求导</strong>  </li></ol><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial \delta\lambda}&=\frac{\partial f_{c_j} }{\partial f_{c_i} }\frac{\partial f_{c_i} }{\partial \delta\lambda}\\&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(-\frac{1}{\lambda^2}\begin{bmatrix}u_{c_i}\\v_{c_i}\\1 \end{bmatrix})\\&=-\frac{1}{\lambda}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}\end{align*}\tag{18}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>五、预积分残差的雅克比求取</title>
    <link href="https://lukeyalvin.top/posts/b68d674.html"/>
    <id>https://lukeyalvin.top/posts/b68d674.html</id>
    <published>2022-05-10T11:38:28.000Z</published>
    <updated>2022-05-11T07:54:42.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>对于右乘雅可比，我们做如下的公式简化：</p><script type="math/tex; mode=display">\frac{\partial x_a}{\partial \delta\theta}=\underset{\delta\theta\rightarrow0}{lim}\frac{R_{ab}\exp([\delta\theta]^{\land})x_b-R_{ab}x_b}{\delta\theta}</script><p>后续简写为：</p><script type="math/tex; mode=display">\frac{\partial x_a}{\partial \delta\theta}=\frac{R_{ab}\exp([\delta\theta]^{\land})x_b}{\delta\theta}</script><h1 id="预积分残差的雅克比求取"><a href="#预积分残差的雅克比求取" class="headerlink" title="预积分残差的雅克比求取"></a>预积分残差的雅克比求取</h1><p>定义：一段时间内 IMU 构建的预积分量作为<strong>测量值</strong>，对两时刻之间的状态量进行约束，  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{e}_{B}(x_i,x_j)=\begin{bmatrix}r_p\\r_q\\r_v\\r_{ba}\\r_{bg}\end{bmatrix}_{15\times1}=\begin{bmatrix}q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-{\color{blue}\alpha_{b_ib_j} }\\2[{\color{blue}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{blue}\beta_{b_ib_j} }\\b^a_j-b^a_i\\b^g_j-b^g_i\end{bmatrix}\end{align*}\tag{1}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t\end{align*}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第二项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p><p>在求解非线性方程时，需要知道误差 $\mathbf{e}_{B}$ 对两个关键帧 $i, j$ 的状态量 $p, q, v, ba, bg$ 的雅可比。对 $i, j$ 时刻的状态量 $p, q, v$ 求导还是比较直观的，直接对误差公式进行计算就行。但是对 $i$ 时刻的 $b^a_i , b^g_i$ 求导就显得十分复杂，下面我们详细讨论。  </p><p>因为 $i$ 时刻的 bias 相关的预积分计算是通过迭代一步一步累计递推的，可以算但是太复杂。所以对于预积分量直接在 $i$ 时刻的 bias 附近用<strong>一阶泰勒展开</strong>来近似，而不用真的去迭代计算。  </p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\alpha_{b_ib_j}+J^{\alpha}_{b^a_i}\delta b^a_i+J^{\alpha}_{b^g_i}\delta b^g_i\\\beta_{b_ib_j}&=\beta_{b_ib_j}+J^{\beta}_{b^a_i}\delta b^a_i+J^{\beta}_{b^g_i}\delta b^g_i\\q_{b_ib_j}&=q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^{q}_{b^g_i}\delta b^g_i \end{bmatrix}\end{align*}\tag{2}</script><p>其中 $J^{\alpha}_{b^a_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^a_i},J^{\alpha}_{b^g_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^g_i},J^{\beta}_{b^a_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^a_i},J^{\beta}_{b^g_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^g_i},J^{q}_{b^g_i}=\frac{\partial q_{b_ib_j} }{\partial\delta b^g_i}$，表示预积分量对 $i$ 时刻的 bias 求导。</p><p>这些雅克比根据前面讨论的<strong>协方差传递公式</strong>，能一步步递推得到：  </p><script type="math/tex; mode=display">J_{k+1}=\mathbf{F}J_k\tag{3}</script><h2 id="r-v-对各状态量的雅可比"><a href="#r-v-对各状态量的雅可比" class="headerlink" title="$r_v$ 对各状态量的雅可比"></a>$r_v$ 对各状态量的雅可比</h2><p>下面我们来讨论 IMU 误差相对于两帧的 PVQ 的 雅克比:由于 $r_p$ 和 $r_v$ 的误差形式很相近，对各状态量求导的 雅克比形式也很相似，所以这里只对 $r_v$ 的推导进行详细介绍  </p><p>① 对 $i$ 时刻<strong>位移</strong>的雅可比</p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta p_{b_ib^\prime_i} }=0\tag{4}</script><p>② 对 $i$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_v}{\partial\delta \theta_{b_ib^\prime_i} }&=\frac{\partial (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2} \delta \theta_{b_ib^\prime_i}\end{bmatrix})^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial (R_{wb_i}\exp([\delta \theta_{b_ib^\prime_i}]^{\land}))^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial\exp([-\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial(I-[\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial -[\delta \theta_{b_ib^\prime_i}]^{\land}[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial -[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}[\delta \theta_{b_ib^\prime_i}]}{\partial\delta \theta_{b_ib^\prime_i} }\\&=[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}\end{align*}\tag{5}</script><p>③ 对 $i$ 时刻<strong>速度</strong>的雅可比</p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta v_i^w}=-R_{b_iw}\tag{6}</script><p>④ 对 $i$ 时刻<strong>加速度 bais</strong>的雅可比 ,注意 bias 量只和预积分 $\beta$ 有关：  </p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta b_i^a}=-\frac{\partial \beta_{b_ib_j} }{\partial\delta b_i^a}=-J^{\beta}_{b^a_i}\tag{7}</script><h2 id="r-q-对各状态量的雅可比"><a href="#r-q-对各状态量的雅可比" class="headerlink" title="$r_q$ 对各状态量的雅可比"></a>$r_q$ 对各状态量的雅可比</h2><p>① 对 $i$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial2[q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*\otimes q_{wb_j}]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial-2[(q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*\otimes q_{wb_j})^*]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial-2[q_{wb_j}^* \otimes (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})\otimes q_{b_ib_j} ]_{xyz}}{\partial \delta\theta_{b_ib^\prime_i} }\\&=-2[0\ \ I]\frac{\partial[q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=-2[0\ \ I][q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R\begin{bmatrix}0\\\frac{1}{2}I\end{bmatrix}\end{align*}\tag{8}</script><p>其中 $[·]_L$ 和 $[·]_R$ 为四元数转为左/右旋转矩阵的算子。  </p><p>② 对 $j$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=\frac{\partial2[q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}\otimes \begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}\end{bmatrix} ]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=\frac{\partial2[[q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_L\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}\end{bmatrix} ]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=2[0\ \ I][q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_L\begin{bmatrix}0\\\frac{1}{2}I\end{bmatrix}\end{align*}\tag{9}</script><p>② 对 $i$ 时刻<strong>陀螺仪偏置 $b^g_i$</strong> 的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_v}{\partial\delta b_i^g}&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial2[(q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial-2[((q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*\otimes q_{wb_i}^*\otimes q_{wb_j})^*]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial-2[q_{wb_j}^*\otimes q_{wb_i}\otimes(q_{b_ib_j} \otimes \begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})]_{xyz} }{\partial\delta b_i^g}\\&=-2[0\ \ I][q_{wb_j}^*\otimes q_{wb_i}\otimes q_{b_ib_j}]_L\begin{bmatrix}0\\\frac{1}{2}J^q_{b^g_i}\end{bmatrix}\end{align*}\tag{10}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>四、IMU误差状态传递方程的推导</title>
    <link href="https://lukeyalvin.top/posts/aaff1b40.html"/>
    <id>https://lukeyalvin.top/posts/aaff1b40.html</id>
    <published>2022-05-10T07:28:11.000Z</published>
    <updated>2022-05-11T08:06:50.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="IMU误差状态传递方程的推导"><a href="#IMU误差状态传递方程的推导" class="headerlink" title="IMU误差状态传递方程的推导"></a>IMU误差状态传递方程的推导</h1><h2 id="协方差的传播"><a href="#协方差的传播" class="headerlink" title="协方差的传播"></a>协方差的传播</h2><p>例如，已知一个变量$y=Ax,x\in \mathcal{N}(0,\Sigma_{x})$，则有$\Sigma_y=A\Sigma_xA^T$</p><script type="math/tex; mode=display">\begin{align*}\Sigma_y&=E((Ax)(Ax)^T)\\&=E(Axx^TA^T)\\&=A\Sigma_xA^T\end{align*}\tag{1}</script><p>我们知道，一个IMU数据作为测量值的噪声方差我们可以标定 （类似公式$(1)$中的已知量$x$），那么一段时间的多个IMU数据形成的IMU数据积分形式的预积分量的方差（类似公式$(1)$中的已知量$y$），就可以通过以上形式求解，关键是找出IMU  噪声与预积分量之间的<strong>线性递推关系</strong>（类似公式$(1)$中的已知量$y=Ax$）。</p><p>假设已知了<strong>相邻时刻误差的线性传递方程：</strong></p><script type="math/tex; mode=display">\eta_{ik}=\mathbf{F}_{k-1}\eta_{ik-1}+\mathbf{G}_{k-1}\mathbf{n}_{k-1}\tag{2}</script><p>比如：状态量误差为 $\eta_{ik}=[\delta\theta_{ik},\delta\mathbf{v}_{ik},\delta\mathbf{p}_{ik}]$，$\eta_{ik}$为当前时刻的误差，$\eta_{ik-1}$为上一时刻的误差；<strong>测量噪声</strong>为 $\mathbf{n}_{k}=[\mathbf{n}_{k}^a,\mathbf{n}_{k}^g]$，因此，误差的传递由两部分组成，即<strong>当前时刻的误差传递给下一时刻，当前时刻的测量噪声传递给下一时刻</strong>。</p><p>如果已知上面的误差状态传递方程，那么一段时间内IMU积分的协方差矩阵就可以轻松递推算出：</p><script type="math/tex; mode=display">\Sigma_{ik}=\mathbf{F}_{k-1}\Sigma_{ik-1}\mathbf{F}_{k-1}^T+\mathbf{G}_{k-1}\Sigma_\mathbf{n}\mathbf{G}_{k-1}^T\tag{3}</script><p>其中，$\Sigma_n$是<strong>测量噪声的协方差矩阵</strong>，方差从 $i$ 时刻开始进行递推，$\Sigma_{ii}=0$</p><h2 id="状态误差线性递推方程的推导"><a href="#状态误差线性递推方程的推导" class="headerlink" title="状态误差线性递推方程的推导"></a>状态误差线性递推方程的推导</h2><p>通常情况下，对于状态量之间的递推关系是非线性的方程，如 $x_k=f(x_{k-1},\mathbf{u}_{k-1})$，其中状态量 $x,\mathbf{u}$ 为系统的输入量。</p><p>我们可以用两种方法来推导误差传递的线性递推关系：</p><ul><li>一种是<strong>基于一阶泰勒展开</strong>的误差传递方程，主要应用于 EKF 的协方差预测。</li><li>一种是<strong>基于误差随时间变化</strong>的递推方程。</li></ul><h3 id="基于一阶泰勒展开"><a href="#基于一阶泰勒展开" class="headerlink" title="基于一阶泰勒展开"></a>基于一阶泰勒展开</h3><p>令状态量为 $x=\hat{x}+\delta x$，其中，真值为$\hat{x}$，误差为 $\delta x$，另外输入量 $\mathbf{u}$ 的噪声为 $\mathbf{n}$。</p><p>对于非线性系统  $x_k=f(x_{k-1},\mathbf{u}_{k-1})$ 进行一阶泰勒展开有：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},\mathbf{u}_{k-1})\\\hat{x}_k+\delta x_k&=f(\hat{x}_{k-1}+\delta x_{k-1},\hat{\mathbf{u} }_{k-1}+\mathbf{n}_{k-1})\\{\color{blue}\hat{x}_k}+\delta x_k&={\color{blue}f(\hat{x}_{k-1},\hat{\mathbf{u} }_{k-1})}+\mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\end{align*}\tag{4}</script><p>可以看出蓝色字体部分表示真值，他们相互抵消掉了，剩下的就是误差的线性递推关系：</p><script type="math/tex; mode=display">\delta x_k = \mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\tag{5}</script><p>其中，$\mathbf{F}$ 是状态量 $x_k$ 对状态量 $x_{k-1}$ 的雅可比矩阵， $\mathbf{G}$ 是状态量 $x_k$ 对输入量 $\mathbf{u}_{k-1}$ 的雅可比矩阵。</p><h3 id="基于误差随时间变化"><a href="#基于误差随时间变化" class="headerlink" title="基于误差随时间变化"></a>基于误差随时间变化</h3><p>如果我们能够推导状态误差随着时间变换的倒数关系，比如：</p><script type="math/tex; mode=display">\dot{\delta x}=\mathbf{A}\delta x+\mathbf{B}\mathbf{n}\tag{6}</script><p>则误差状态的递推方程为：</p><script type="math/tex; mode=display">\begin{align*}&\delta x_k = \delta x_{k-1} + \dot{\delta x_{k-1} }\Delta t\\\rightarrow&\delta x_k=(\mathbf{I}+\mathbf{A}\Delta t)\delta x_{k-1}+\mathbf{B}\Delta t \mathbf{n}_{k-1} \end{align*}\tag{7}</script><p>综合两种方法可以发现：</p><script type="math/tex; mode=display">\mathbf{F}=\mathbf{I}+\mathbf{A}\Delta t,\ \ \ \ \mathbf{G}=\mathbf{B}\Delta t\tag{8}</script><p>由于在 VIO 系统中我们已经知道了状态的导数与状态之间的旋转矩阵，如公式 $(26)$:</p><script type="math/tex; mode=display">\dot{\mathbf{v} }=Ra^b+g\tag{9}</script><p>那么我们就可以推导<strong>速度误差</strong>和<strong>状态误差</strong>之间的关系，再每一项上都加上各自的误差，既有：</p><script type="math/tex; mode=display">\begin{align*}\dot{\mathbf{v} }+\dot{\delta\mathbf{v} }&=R(\mathbf{I}+[\delta\theta]^{\land})(a^b+\delta a^b)+g+\delta g\\\dot{\delta\mathbf{v} }&=R\delta a^b+R[\delta\theta]^{\land}(a^b+\delta a^b)+\delta g\\\dot{\delta\mathbf{v} }&=R\delta a^b-R[a^b]^{\land}\delta\theta+\delta g\end{align*}\tag{10}</script><p>由此就可以以此类推，很轻易的写出整个 $\mathbf{A}$ 和 $\mathbf{B}$ ，这也是此方法的优点。 </p><h1 id="基于一阶泰勒展开的推导"><a href="#基于一阶泰勒展开的推导" class="headerlink" title="基于一阶泰勒展开的推导"></a>基于一阶泰勒展开的推导</h1><p>由上一节的公式$(17)$：IMU 预积分误差的离散形式 ，此时将噪声模型也考虑进去：</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}{\color{red}+\mathbf{n}^a_{k} }-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }{\color{red}+\mathbf{n}^a_{k+1} }-b^a_k)]\\w&=\frac{1}{2}[(w^{b_k}{\color{red}+\mathbf{n}^g_{k} }-b^g_k)+(w^{b_{k+1} }{\color{red}+\mathbf{n}^g_{k+1} }-b^g_k)]\\{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t\end{align*}\tag{11}</script><p>用前面一阶泰勒展开的推导方式，我们希望能推导出如下的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}\delta\alpha_{b_{k+1}b^{\prime}_{k+1} }\\\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\\delta\beta_{b_{k+1}b^{\prime}_{k+1} }\\\delta\mathbf{b}^a_{k+1}\\\delta\mathbf{b}^g_{k+1}\\\end{bmatrix}=\mathbf{F}\begin{bmatrix}\delta\alpha_{b_{k}b^{\prime}_{k} }\\\delta\theta_{b_{k}b^{\prime}_{k} }\\\delta\beta_{b_{k}b^{\prime}_{k} }\\\delta\mathbf{b}^a_{k}\\\delta\mathbf{b}^g_{k}\\\end{bmatrix}+\mathbf{G}\begin{bmatrix}\mathbf{n}^a_{k}\\\mathbf{n}^g_{k}\\\mathbf{n}^a_{k+1}\\\mathbf{n}^g_{k+1}\\\mathbf{n}_{\mathbf{b}^a_k}\\\mathbf{n}_{\mathbf{b}^g_k}\\\end{bmatrix}\tag{12}</script><p>$\mathbf{F},\mathbf{G}$为两个时刻间的协方差传递矩阵。</p><p>这里我们直接给出 $\mathbf{F},\mathbf{G}$ 的最终形式，后面会对部分项进行详细推导：  </p><script type="math/tex; mode=display">\mathbf{F}=\begin{bmatrix}\mathbf{I}&f_{12}&\mathbf{I}\delta t&-\frac{1}{4}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t^2&f_{15}\\0&\mathbf{I}-[\omega]^{\land}&0&0&-\mathbf{I}\delta t\\0&f_{32}&\mathbf{I}&-\frac{1}{2}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t&f_{35}\\0&0&0&\mathbf{I}&0\\0&0&0&0&\mathbf{I}\end{bmatrix}\tag{13}</script><script type="math/tex; mode=display">\mathbf{G}=\begin{bmatrix}\frac{1}{4}q_{b_ib_k}\delta t^2&g_{12}&\frac{1}{4}q_{b_ib_{k+1} }\delta t^2&g_{14}&0&0\\0&\frac{1}{2}\mathbf{I}\delta t&0&\frac{1}{2}\mathbf{I}\delta t&0&0\\\frac{1}{2}q_{b_ib_k}\delta t&g_{32}&\frac{1}{2}q_{b_ib_{k+1} }\delta t&g_{34}&0&0\\0&0&0&0&\mathbf{I}\delta t&0\\0&0&0&0&0&\mathbf{I}\delta t\end{bmatrix}\tag{14}</script><p>其中的系数如下：</p><p><img src="/images/3-2-IMU误差状态传递的推导/image-20220509150144881-16521033725157.png" alt="image-20220509150144881"></p><h2 id="雅克比矩阵-mathbf-F-的推导"><a href="#雅克比矩阵-mathbf-F-的推导" class="headerlink" title="雅克比矩阵 $\mathbf{F}$ 的推导"></a>雅克比矩阵 $\mathbf{F}$ 的推导</h2><h3 id="速度预积分量的雅可比"><a href="#速度预积分量的雅可比" class="headerlink" title="速度预积分量的雅可比"></a>速度预积分量的雅可比</h3><p>$\beta$ 对于各个状态量的雅可比矩阵推导，即 $\mathbf{F}$ 矩阵第三行。速度预积分量 $\beta$ 的递推计算形式:  </p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{15}</script><p>$f_{33}$: 对上一时刻<strong>速度预积分量</strong>的 雅可比：</p><script type="math/tex; mode=display">f_{33}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\beta_{b_{k}b^{\prime}_{k} } }=\mathbf{I}_{3\times 3}\tag{16}</script><p>$f_{32}$: 对上一时刻<strong>角度预积分量</strong>的 雅可比：</p><p>首先将公式 $(32)$写成如下形式：</p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{17}</script><p>那么，<strong>速度的预积分量对角度预积分量</strong>的 雅可比：  </p><script type="math/tex; mode=display">f_{32}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }=\frac{\partial a\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\tag{18}</script><p>其中分子可以写成：</p><script type="math/tex; mode=display">\begin{align*}a\delta t &=\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}(a^{b_k}-b^a_k)\delta t\\&+\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)\delta t\\&=\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t\\&+\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t\end{align*}\tag{19}</script><p>分别对分子的两项进行求导：</p><p>①第一项</p><script type="math/tex; mode=display">\begin{align*}&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }(I + [\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t-R_{b_ib_{k} }(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[(a^{b_{k} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}[\delta\theta_{b_kb^{\prime}_{k} }]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}\end{align*}\tag{20}</script><p>②第二项</p><script type="math/tex; mode=display">\begin{align*}&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }(I+[\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }\left[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\ [\delta\theta_{b_kb^{\prime}_{k} }\right]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }\exp([\omega\delta t]^{\land})\left[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})[\delta\theta_{b_kb^{\prime}_{k} }\right]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\&=-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\&\approx-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}(I-[\omega\delta t]^{\land})\end{align*}\tag{21}</script><p>将上面两部分综合起来就能得到  :</p><script type="math/tex; mode=display">\begin{align*}f_{32}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\frac{1}{2}\left([a^{b_{k} }-b^a_k]^{\land}\delta t+R_{b_ib_{k+1} }[a^{b_{k+1} }-b^a_k]^{\land}(I-[\omega]^{\land}\delta t)\delta t \right)\end{align*}\tag{22}</script><p>$f_{35}$: <strong>速度预积分量</strong>对 $k$ 时刻<strong>角速度 bias</strong> 的 雅可比：</p><p>递推公式如下:</p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes \begin{bmatrix}1\\{\color{red}\frac{1}{2}w\delta t}\end{bmatrix}(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{23}</script><p>只有红色公式部分和角速度 bias 有关系，因此雅克比的推导只考虑红色公式部分。  </p><script type="math/tex; mode=display">\begin{align}f_{35}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{\partial \frac{1}{2}q_{b_ib_{k} }\otimes \begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes \begin{bmatrix}1\\-\frac{1}{2}\mathbf{b}^g_k\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)\delta t-\partial \frac{1}{2}q_{b_ib_{k} }\otimes \begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes (a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }\exp([-\delta\mathbf{b}^g_k\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }(I+[-\delta\mathbf{b}^g_k\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }[-\delta\mathbf{b}^g_k\delta t]^{\land}[(a^{b_{k+1} }-b^a_k)\delta t]}{\partial\delta\mathbf{b}^g_k}\\&=-\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}[-\delta\mathbf{b}^g_k\delta t]}{\partial\delta\mathbf{b}^g_k}\\&=-\frac{1}{2}(R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)]^{\land}\delta t)(-\delta t)\end{align}\tag{24}</script><h3 id="旋转预积分量的雅可比"><a href="#旋转预积分量的雅可比" class="headerlink" title="旋转预积分量的雅可比"></a>旋转预积分量的雅可比</h3><p>旋转预积分的递推公式为：  </p><script type="math/tex; mode=display">\begin{align*}q_{b_ib_{k+1} }&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}(\frac{1}{2}(\omega^{b_k}+\omega^{b_{k+1} })-\mathbf{b}^g_k)\delta t\end{bmatrix}\end{align*}\tag{25}</script><p>$f_{22}$: 前一时刻的旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 如何影响当前的旋转误差  $\delta\theta_{b_{k+1}b^{\prime}_{k+1} }$ ？</p><p>假设两个时刻的真值为 $q_{b_ib_{k+1} },\ q_{b_ib_{k} }$，两个时间的增量真值为 $q_{b_kb_{k+1} }$。推导过程只考虑一个变量，即旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 的影响，而不考虑测量值 角速度 bias 误差影响，可以假设 $q_{b_kb_{k+1} }\approx\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}$。</p><p>另外，三元组四元数相乘有如下性质：</p><script type="math/tex; mode=display">\mathbf{q}\otimes\mathbf{p}\otimes\mathbf{q}^*=[\mathbf{q}]_L[\mathbf{q}]_R^T\mathbf{p}=\begin{bmatrix}p_w\\R\mathbf{p}_v\end{bmatrix}\tag{26}</script><p>其中 $R$是 $\mathbf{q}$ 对应的旋转矩阵，$\mathbf{q}^*$ 是 $\mathbf{q}$ 的共轭， $p_w$ 为 $\mathbf{p}$ 的实部，  $\mathbf{p}_v$ 为  $\mathbf{p}$ 的虚部。</p><p>下面开始详细推导：  </p><script type="math/tex; mode=display">\begin{align*}q_{b_ib_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}&=q_{b_ib_{k+1} }^*\otimes q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=q_{b_{k+1}b_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&\approx \begin{bmatrix}1\\-\frac{1}{2}\omega\delta t\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=\begin{bmatrix}1\\\frac{1}{2}R\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\end{align*}\tag{27}</script><p>注意：上面推导过程，也可以用李代数的右扰动   $R\exp([\delta\theta_{k+1}]^{\land})$</p><p>只考虑公式 $(27)$ 中的虚部：</p><script type="math/tex; mode=display">\begin{align*}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }&=R\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\&=\exp([-w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\\&\approx (I-[w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\end{align*}\tag{28}</script><p>那么，第 $k+1$ 时刻的旋转预积分的误差相对于第 $k$ 时刻的 雅可比为：</p><script type="math/tex; mode=display">f_{22}=\frac{\partial \delta\theta_{b_{k+1}b^{\prime}_{k+1} } }{\partial \delta\theta_{b_{k}b^{\prime}_{k} } }=I-[w\delta t]^{\land}\tag{29}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>三、预积分模型以及残差的构建</title>
    <link href="https://lukeyalvin.top/posts/285413d6.html"/>
    <id>https://lukeyalvin.top/posts/285413d6.html</id>
    <published>2022-05-09T13:22:59.000Z</published>
    <updated>2022-05-11T07:53:08.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="IMU的误差模型"><a href="#IMU的误差模型" class="headerlink" title="IMU的误差模型"></a>IMU的误差模型</h1><ul><li><strong>加速度计的误差模型</strong></li></ul><p>设导航系$G$为东北天，$g^G=(0,0,-9.81)^T$。</p><p>理论测量值：</p><script type="math/tex; mode=display">a_m^B=R_{BG}(a^G-g^G)\tag{1}</script><p>如果考虑高斯白噪声，bias，以及尺度因子(通常假设尺度因子为单位矩阵。)，则为：</p><script type="math/tex; mode=display">a_m^B=S_aR_{BG}(a^G-g^G)+n_a+b_a\tag{2}</script><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423171217806.png" alt="image-20220423171217806" style="zoom:50%;" /></p><ul><li><strong>陀螺仪的误差模型</strong></li></ul><p>考虑尺度因子，高斯白噪声，以及 bias, 陀螺仪的误差模型如下：</p><script type="math/tex; mode=display">w^b_m=S_gw^b+n_g+b_g\tag{3}</script><p>低端传感器，考虑加速度对陀螺仪的影响，即 g-灵敏度：</p><script type="math/tex; mode=display">w^b_m=S_gw^b+S_{ga}a^b+n_g+b_g\tag{4}</script><p>陀螺仪受四种噪声的影响分别如下图所示：</p><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423190440715.png" alt="image-20220423190440715" style="zoom: 50%;" /></p><h1 id="IMU模型与运动积分"><a href="#IMU模型与运动积分" class="headerlink" title="IMU模型与运动积分"></a>IMU模型与运动积分</h1><p>忽略 scale 的影响，根据imu的误差模型我们可以假设：角速度读数会在真实值的基础上受到<strong>bias和白噪声</strong>的影响，加速度除了受到<strong>bias和白噪声</strong>的影响，还会受到<strong>重力</strong>的影响。因此我们可以从IMU中得到角速度和加速度的读数，如公式$(5)(6)$的等式左边，它们都是基于IMU坐标系的。</p><script type="math/tex; mode=display">\begin{align*}\tilde{w}^b&=w^b+b_g+n_g\tag{5}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\tilde{a}^b&=q_{bw}(a^w-g^w)+b_a+n_a\tag{6}\end{align*}</script><p>上标$ g$ 表示 gyro，a 表示 acc，$^w $表示在世界坐标系 world，$^b$表示imu 机体坐标系 body。IMU 的真实值为$w, a$, 测量值为$\tilde w, \tilde a$，测量值即为IMU的读数。 </p><p>我们知道<strong>角速度$w$</strong>积分得到<strong>姿态$q$</strong>，<strong>加速度$a$</strong>积分得到<strong>速度$v$</strong>，<strong>速度$v$</strong>积分得到<strong>位移$p$</strong>。而现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型， <strong>P(ose)（位置），V(elocity)（速度），Q(uaternion) （旋转）</strong>对时间的导数可写成：</p><script type="math/tex; mode=display">\begin{align*}\dot p_{wb}&=v^w_t\\\dot v^w_t &=a^w_t\\\dot q_{wb_t} &=q_{wb_t} \otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\end{align*}\tag{7}</script><p>它描述了 IMU坐标系 的姿势和速度的演变。</p><p>第三项，四元数求导参考 <a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0">一、VIO概述以及三维刚体运动知识点回顾</a></p><p> $t + \Delta t $时刻的状态是通过积分方程$(7)$获得的：</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+\int^{t+\Delta t}_t v^w(\tau)d\tau+\iint^{t+\Delta t}_t a^w d\tau^2\\v^w(t+\Delta t)&=v^w(t)+\int^{t+\Delta t}_t a^w d\tau\\q_{wb}(t+\Delta t)&=\int^{t+\Delta t}_t q_{wb}(\tau)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(\tau)\end{bmatrix}d\tau\end{align*}\tag{8}</script><p>根据积分的性质，这里的 $\tau$ 是把 $[t,t+\Delta t]$分割的无限小部分。</p><p>假设 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2} a^w \Delta t^2\\v^w(t+\Delta t)&=v^w(t)+ a^w \Delta t\\q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(t)\Delta t\end{bmatrix}\end{align*}\tag{9}</script><p>根据公式$(5)(6)$可以将 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 写成 IMU 测量的函数，因此 $(9)$ 变为:</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t^2\\v^w(t+\Delta t)&=v^w(t)+g^w\Delta t+ q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t\\q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}(\tilde{w}^b(t)-b_g(t)-n_g(t))\Delta t\end{bmatrix}\end{align*}\tag{10}</script><p>方程 $(10)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。<strong>这样就可以得到旋转，速度，平移与 IMU 读数之间的关系，进而可以根据IMU 的读数来估计位姿。</strong></p><h1 id="IMU预积分模型"><a href="#IMU预积分模型" class="headerlink" title="IMU预积分模型"></a>IMU预积分模型</h1><h2 id="IMU-预积分"><a href="#IMU-预积分" class="headerlink" title="IMU 预积分"></a>IMU 预积分</h2><p>如图所示，相机的采样频率是明显低于 IMU 的采样频率的，相机或激光一般在几十 HZ，而 IMU 可以达到几百 HZ，而在 SLAM 中我们通常是求解每一帧图像/激光的位姿，因此需要对两帧图像/激光之间的所有IMU观测进行累加，可以得到 $i$ 帧和 $j$ 帧两个关键帧之间的单个复合的测量值，我们称之为<strong>预积分</strong>。</p><p><img src="/images/3-预积分模型以及误差递推方程的推导/image-20220507202527649-16521033725156.png" alt="image-20220507202527649"></p><p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 $(10)$，我们发现：</p><script type="math/tex; mode=display">\begin{align*}{p_{wb} }_j&={p_{wb} }_i+\sum^{j-1}_{k=i}\left[v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb_k}\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t^2\right]\\v^w_j&=v^w_i+g^w\Delta t_{ij}+ \prod^{j-1}_{k=i} q_{wb_k}(t)\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t\\q_{wb_j}&= q_{wb_i}\otimes \begin{bmatrix}0\\ \frac{1}{2}\prod^{j-1}_{k=i}(\tilde{w}^b_k-b_{gk}-n_{gk})\Delta t\end{bmatrix}\end{align*}\tag{11}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。 $(11)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(11)$ 中的积分（直观地说，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_k}、k = i,…,j-1$ 的变化，因此有必要重新评估 $(11)$ 中的求和和乘积。</p><blockquote><p>这里没有找到离散形势下使用四元数的预积分推导相关资料，而在高博等人的《从零开始手写VIO》课程中，用的是如下连续形式进行推导的，事实上，我认为 $(12)$ 中的连续形式中在递推 $p_{wb_j}$的时候，对速度没有积分是不对的，此处暂且留疑点。</p></blockquote><p>同样的，连续形式下，可以得到:</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t+\iint_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t^2\\v^w_j&=v^w_i+\int_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t\\q_{wb_j}&=\int_{t\in[i,j]}q_{wb_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{12}</script><p>其中，不难发现，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_t}、t \in [i,j]$ 的变化，导致对 $(12)$中的积分进行重复计算。</p><p>一个很简单的公式转换，就可以将积分模型转为预积分模型：  </p><script type="math/tex; mode=display">q_{wb_t}=q_{wb_i}\otimes q_{b_ib_t}\tag{13}</script><p>其中 $\otimes$ 表示四元数的乘法，具体可以可以参考，<a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0"><strong>四元数的乘法运算</strong></a></p><p>那么， PVQ 积分公式中的积分项则变成相对于第 $i$ 时刻的姿态，而不是相对于世界坐标系的姿态，则公式$(12)$变换为：</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+q_{wb_i}\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\v^w_j&=v^w_i-g^w\Delta t+q_{wb_i}\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{wb_j}&=q_{wb_i}\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{14}</script><p>这样的话，积分里的把相对于世界坐标系的状态量 $q_{wb_i}$ 移出去了，积分里面都是相对于第 $i$ 时刻的状态量 $q_{b_ib_t}$。</p><p>定义预积分量如下，预积分量仅仅跟 IMU 测量值有关，它将一段时间内的 IMU 数据直接积分起来就得到了<strong>预积分量</strong>：  </p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t\end{align*}\tag{15}</script><p>由公式$(14)$与$(15)$重新整理PVQ的积分公式，有：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}p_{wb_j}\\v^w_{j}\\q_{wb_j}\\b^a_j\\b^g_j\end{bmatrix}=\begin{bmatrix}p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+q_{wb_i}\alpha_{b_ib_j}\\v^w_i-g^w\Delta t+q_{wb_i}\beta_{b_ib_j}\\q_{wb_i}q_{b_ib_j}\\b^a_i\\b^g_i\end{bmatrix}\end{align*}\tag{16}</script><h2 id="IMU-预积分残差"><a href="#IMU-预积分残差" class="headerlink" title="IMU 预积分残差"></a>IMU 预积分残差</h2><p>定义：一段时间内 <strong>IMU 构建的预积分量作为测量值</strong>，对两时刻之间的状态量进行约束，  </p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}r_p\\r_v\\r_q\\r_{ba}\\r_{bg}\end{bmatrix}_{15\times1}=\begin{bmatrix}q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-{\color{red}\alpha_{b_ib_j} }\\q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{red}\beta_{b_ib_j} }\\2[{\color{red}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\b^a_j-b^a_i\\b^g_j-b^g_i\end{bmatrix}\end{align*}\tag{16}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第三项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p><h2 id="IMU-预积分残差的离散形式"><a href="#IMU-预积分残差的离散形式" class="headerlink" title="IMU 预积分残差的离散形式"></a>IMU 预积分残差的离散形式</h2><p>使用 mid-point 方法，即两个相邻时刻$ k$到$ k+1$ 的位姿是用两个时刻的测量值$ a,w $的平均值来计算。参考公式$(11)(12)$:</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\\w&=\frac{1}{2}[(w^{b_k}-b^g_k)+(w^{b_{k+1} }-b^g_k)]\\{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t\end{align*}\tag{17}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【文献阅读】On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</title>
    <link href="https://lukeyalvin.top/posts/e6b6704d.html"/>
    <id>https://lukeyalvin.top/posts/e6b6704d.html</id>
    <published>2022-05-08T13:16:58.000Z</published>
    <updated>2022-05-08T13:17:50.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry"><a href="#On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry" class="headerlink" title="On-Manifold Preintegration for Real-Time Visual-Inertial Odometry"></a>On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</h1><p>摘要：当前的视觉惯性里程计（VIO）方法能够通过非线性优化获得高度准确的状态估计。然而，随着轨迹随着时间的推移，实时优化很快变得不可行。尤其是惯性测量以高速率出现的时候，这个问题变得更加突出，因此导致优化中变量数量的快速增长。在本文中，我们<strong>通过预积分关键帧之间的惯性测量以得到单个相对运动约束</strong>。</p><p>我们的第一个贡献是一个预积分理论，它正确地解决了<strong>旋转群的流形结构</strong>。我们正式讨论生成测量模型以及旋转噪声的性质，并推导出最大后验状态估计器的表达式。我们的理论发展能够计算所有必要的雅可比矩阵，以分析形式的优化和后验偏差校正。</p><p>第二个贡献是表明预积分的 IMU 模型可以在因子图的统一框架下被整合到视觉-惯性流程中。这使得<strong>增量平滑算法</strong>的应用和<strong>视觉测量的无结构模型</strong>的使用成为可能，避免了对 3D 点的优化，进一步加速了计算。</p><p>我们在真实和模拟数据集上对我们的单目 VIO 流程进行了广泛的评估。结果证实，我们的建模工作可以实时进行准确的状态估计，优于最先进的方法。</p><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>使用相机和惯性传感器进行三维结构和运动估计已经受到机器人界的极大关注。两种传感器类型都便宜、无处不在且互补。<strong>移动相机</strong>是一种外感知传感器，它允许我们测量三维场景的外观和几何形状，直至未知的度量尺度；<strong>惯性测量单元 (IMU)</strong> 是一种本体感受传感器，可呈现单目视觉和重力可视化的度量尺度 [1]，并提供稳健且准确的帧间运动估计。<strong>视觉惯性里程计（VIO）</strong>的应用范围从无GPS环境的自动驾驶到3D重建和增强现实。</p><p>现有的关于 VIO 的文献在准确性和计算效率之间进行了权衡（第 II 节给出了详细的回顾）。一方面，<strong>滤波方法</strong>可以实现快速推断，但其准确性会因线性化误差的累积而下降。另一方面，<strong>基于非线性优化的完全平滑方法</strong>是准确的，但计算量很大。固定滞后平滑（$Fixed-lag\ Smoothing$）在精度和效率之间提供折中；但是，尚不清楚如何设置估计窗口的长度以保证给定的性能水平。</p><p>在这项工作中，我们表明可以克服这种权衡。我们设计了一个 VIO 系统，可以实现快速增量平滑并实时计算最优的最大后验 (MAP) 估计。第IV给出了我们方法的概述。</p><p>实现这一目标的第一步是发展一个新的预积分理论。在 [2] 中首次提出使用预积分 IMU 测量，其组合两个关键帧间的许多惯性测量为单个相对运动约束。我们在这项工作的基础上提出了一个预积分理论，该理论正确地<strong>解决了旋转群 $SO(3)$ 的流形结构</strong>。我们的预积分理论在第 V-VI 节中介绍。与[2]相比，我们的理论对旋转噪声提供了更正式的处理，并避免了旋转表示中的奇异性。此外，我们能够以解析形式推导出所有必要的雅可比矩阵：具体来说，我们在本文的附录中报告了残差、噪声传播和后验偏差校正的解析雅可比矩阵。</p><p>我们的第二个贡献是<strong>将 IMU 预积分理论框架化为因子图模型</strong>。这使得增量平滑算法的应用成为可能，如 iSAM2 [3]，它避免了线性化误差的累积，并提供了一种优雅的方式来权衡精度和效率。受 [4, 5] 的启发，我们还<strong>采用无结构模型进行视觉测量</strong>，允许在增量平滑期间消除大量变量（即所有 3D 点），从而进一步加速计算（第 VII 节）。与 [5] 相比，我们在增量平滑框架中使用无结构模型。这有两个主要优点：我们不需要延迟视觉测量的处理，我们可以多次重新线性化视觉测量。</p><p>为了证明我们模型的有效性，我们将提议的 IMU 预积分集成到最先进的 VIO 流程中，并在真实和模拟数据集 2（第 VIII 节）上对其进行了测试。我们的理论发展带来了切实的实际优势：本文提出的方法的实现以 100 Hz 的速率执行完全平滑，并相对于具有竞争力的最先进的过滤和优化方法实现了卓越的精度。</p><p>除了技术贡献，论文还为实践者提供了教程贡献。在第III部分和整篇论文中，我们对流形上的不确定性表示以及不确定性传播和雅可比计算的示例推导进行了简短而简洁的总结。所有方程和雅可比矩阵的完整推导——实现我们的模型所必需的——在附录中给出。</p><p>本文是我们之前工作 [6] 的扩展，包括额外的实验、对相关工作的深入讨论和全面的技术推导。新实验的结果突出了偏差估计的准确性，证明了我们方法的一致性，并提供了与全批次估计的比较。我们在 GTSAM 4.0 优化工具箱中发布了预集成 IMU 和无结构视觉因素的实现。</p><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>视觉惯性里程计的相关工作可以沿着三个主要维度进行划分。<strong>第一个维度是 在估计中涉及的相机位姿的数量。</strong>虽然完全平滑器（$full\ smoothers$）（或批量非线性最小二乘算法（$batch\ nonlinear\ least-squares\ algorithms$）估计姿势的完整历史，但固定滞后平滑器（$fixed-lag\ smoothers$）（或滑动窗口估计器（$fixed-lag\ smoothers$）考虑最新姿势的窗口，而过滤方法仅估计最新状态。固定滞后平滑器和滤波器都会<strong>边缘化</strong>旧状态并<strong>吸收</strong>高斯先验中的相应信息。</p><p><strong>第二个维度是 关于测量不确定性和高斯先验的表示</strong>：扩展卡尔曼滤波器 (EKF) 使用协方差矩阵表示不确定性；相反，信息滤波器和平滑器求助于信息矩阵（协方差的倒数）或信息矩阵的平方根 [3, 8]</p><p>最后，<strong>第三个维度 通过查看测量模型线性化的次数来区分现有方法。</strong>虽然标准 EKF（与迭代 EKF 相比）只处理一次测量，但平滑方法允许多次线性化。</p><p>虽然术语很多，但底层算法是紧密相关的。例如，可以证明<strong>迭代扩展卡尔曼滤波器方程等价于高斯牛顿算法</strong>，通常用于平滑 [9]</p><h2 id="A-滤波"><a href="#A-滤波" class="headerlink" title="A. 滤波"></a>A. 滤波</h2><p>滤波算法通过将推理过程限制在系统的最新状态来实现有效的估计。 EKF 的复杂性在估计的地标数量上呈二次增长，因此，通常会跟踪少量地标（大约 20 个）以允许实时操作 [10-12]。另一种方法是采用<strong>“无结构”方法</strong>，其中地标位置被<strong>边缘化</strong>出状态向量。这种策略的一个很好的例子是<strong>多状态约束卡尔曼滤波器</strong>（$Multi-State\ Constraint\ Kalman\ filter\ ，MSC-KF$）[5]。无结构方法需要通过<strong>随机克隆</strong>（$stochastic\ cloning$） [13] 将先前的姿势保留在状态向量中。</p><p>使用无结构方法进行过滤的一个缺点是，<strong>地标测量的处理</strong>需要延迟，直到获得地标的所有测量值 [5]。这会妨碍准确性，因为滤波器不能使用所有当前的视觉信息。<strong>边缘化</strong>也是错误的来源，因为它锁定了<strong>线性化误差</strong>和<strong>错误的异常值测量</strong>。因此，滤除虚假测量值尤为重要，因为单个异常值会不可逆转地破坏滤波器 [14]。此外，<strong>线性化误差</strong>会在估计中引入漂移并导致滤波器不一致。不一致的一个影响是<strong>估计器</strong>变得过于自信，导致非最优信息融合。通常，VIO 问题有四个不可观察的方向：<strong>全局位置</strong>和围绕重力方向（<strong>偏航</strong>，yaw）的方向 [15, 16]。在 [16] 中表明，<strong>错误估计的线性化</strong>仅导致三个不可观察的方向（全局位置）；因此，错误的线性化将偏航方向的虚假信息添加到高斯先验中，从而导致滤波器不一致。这个问题已通过<strong>首次估计雅可比方法</strong> （$first-estimates\ jacobian$）[17] 得到解决，<strong>该方法确保状态不会使用不同的线性化点进行更新</strong>——这是不一致的来源。在可观察性约束（$observability-constrained$）的 EKF (OC-EKF) 中，维持对不可观察方向的估计，这允许仅在可观察的方向上更新滤波器 [16, 18]。在 [1, 15, 19] 中给出了对 VIO 可观察性属性的全面分析。</p><h2 id="B-固定滞后平滑"><a href="#B-固定滞后平滑" class="headerlink" title="B.固定滞后平滑"></a>B.固定滞后平滑</h2><p>固定滞后平滑器（$fixed-lag\ smoothers$）估计落在给定时间窗口内的状态，同时边缘化较旧的状态[20-24]。在最大似然估计设置中，固定滞后平滑器会<strong>导致一组最近状态的优化问题</strong>。对于非线性问题，<strong>平滑方法</strong>通常比滤波更准确，因为它们会<strong>重新线性化过去的测量</strong> [25]。此外，这些方法<strong>对异常值更具弹性</strong>，可以在后验（即优化之后）丢弃，或者可以通过使用鲁棒代价函数来缓解。不利的一面是，<strong>估计窗口外的状态边缘化会导致密集的高斯先验，从而阻碍有效的推理。</strong>出于这个原因，有人提出为了<strong>稀疏性</strong>而放弃某些测量值[24]。此外，由于边缘化，固定滞后平滑器具有过滤的部分问题（一致性、线性化误差的累积）[18、22、26]。</p><h2 id="C-完全平滑"><a href="#C-完全平滑" class="headerlink" title="C. 完全平滑"></a>C. 完全平滑</h2><p>完全平滑（$Full\ Smoothing$）方法<strong>通过解决大型非线性优化问题来估计状态的整个历史</strong>（相机轨迹和 3D 地标）[27-31]。全平滑保证了最高精度；然而，随着轨迹和地图随着时间的推移而增长，实时操作很快变得不可行。因此，已经提出丢弃除选定<strong>关键帧</strong>之外的帧 [24, 32-34] 或使用<strong>跟踪和建图双重架构</strong> [20, 35] 在并行线程中运行优化。一项突破是<strong>增量平滑技术</strong>（$incremental\ smoothing\ techniques$）（iSAM [36]、iSAM2 [3]）的发展，该技术<strong>利用因子图的表达性来保持稀疏性，并仅识别和更新受新测量影响的通常较小的变量子集。</strong></p><p>尽管如此，高频率的惯性测量（通常为 $100 Hz$ 至 $1 kHz$）仍然对平滑方法构成挑战。一个简单的实现需要在每次 IMU 测量时添加一个新状态，这很快就会变得非常慢 [37]。因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。<strong>对于两帧之间的标准 IMU 集成，初始条件由第一帧的状态估计给出。</strong>因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。对于两帧之间的标准 IMU 积分，初始条件由第一帧的状态估计给出。然而，<strong>在优化的每次迭代中，状态估计都会发生变化，这需要在所有帧之间重复 IMU 积分</strong>[24]。 Lupton 和 Sukkarieh [2] 表明，<strong>通过重新参数化相对运动约束可以避免这种重复积分。这种重新参数化称为 IMU 预积分。</strong></p><p>在目前的工作中，我们以开创性工作 [2] 为基础，通过适当<strong>解决旋转群 SO(3) 的流形结构</strong>，使 IMU 预积分理论走向成熟。工作[2]采用欧拉角作为旋转的全局参数。在刚性变换的作用下，使用欧拉角并应用欧几里得空间的通常平均和平滑技术进行状态传播和协方差估计并不具有不变性[41, 42]。此外，欧拉角具有奇异性。我们的研究，另一方面，提供了一个正式的旋转测量的表示（和对应噪声），并提供了完整的最大后验估计量的推导。我们还推导出雅可比矩阵的解析表达式（优化所需），据我们所知，这些表达式以前没有在文献中报道过。在实验部分，我们表明旋转流形的正确表示会导致更高的准确性和鲁棒性，从而比原始提议 [2] 带来切实的优势。</p><h1 id="三、预备知识"><a href="#三、预备知识" class="headerlink" title="三、预备知识"></a>三、预备知识</h1><p>在本文中，我们根据 MAP 估计来制定 VIO。在我们的模型中，MAP 估计会导致非线性优化问题，该问题涉及存在于<strong>平滑流形</strong>上的量（例如，旋转、姿势）。因此，在深入研究细节之前，我们方便地回顾一些有用的几何概念。专家读者可以跳过本节。</p><p>我们将本节结构如下：第 III-A 节提供了与两个主要<strong>黎曼流形</strong>相关的有用概念：<strong>特殊正交群</strong> $SO(3)$ 和<strong>特殊欧几里得群</strong>$ SE(3)$。我们的介绍基于 [43, 44]。第 III-B 节描述了一个合适的模型来描述$ SO(3) $中的不确定旋转。第 III-C 节根据标准参考文献 [45] 回顾了流形上的优化。</p><h2 id="A-黎曼几何的概念"><a href="#A-黎曼几何的概念" class="headerlink" title="A. 黎曼几何的概念"></a>A. 黎曼几何的概念</h2><p>a) 特殊正交群：SO(3) 描述了一组 3D 旋转矩阵，正式定义为$SO(3)\doteq \{R\in\mathbb{R}^{3\times3}:R^TR=I,\det(R)=1\}.$群运算就是通常的矩阵乘法，逆运算就是矩阵转置。群 $ SO(3) $也形成一个<strong>光滑的流形</strong>。流形（恒等式）的<strong>切线空间表示</strong>为 $\mathfrak{so}(3)$，也称为<strong>李代数</strong>，与 $3\times3$ 斜对称矩阵的空间重合。我们可以使用$hat$算子在 R3 中用一个向量识别每个倾斜对称矩阵：</p><script type="math/tex; mode=display">w^{\land}=\begin{bmatrix}w_1\\w_2\\w_3\end{bmatrix}^{\land}=\begin{bmatrix}0&-w_3&w_2\\w_3&0&-w_1\\-w_2&w_1&0\end{bmatrix}\in\mathfrak{so}(3).\tag{1}</script><p>类似地，我们可以使用 $vee $算子$(\cdot)^{\lor}$ 将斜对称矩阵映射到$\mathbb{R}^3 $中的向量：对于<strong>斜对称矩阵</strong> $S= ω^{\land}$，$vee $ 算子使得 $S^{\lor}= ω$。稍后将有用的斜对称矩阵的属性是：</p><script type="math/tex; mode=display">a^{\land}b=-b^{\land}a,\forall a,b\in\mathbb{R}^3.\tag{2}</script><p><strong>指数映射</strong>（恒等式）$ \exp : \mathfrak{so}(3)\rightarrow SO(3)$将李代数的一个元素与旋转相关联，并与标准矩阵指数（罗德里格斯公式）一致：</p><script type="math/tex; mode=display">\exp(\phi)^{\land}=I+\frac{\sin(\parallel\phi\parallel)}{\parallel\phi\parallel}\phi^{\land}+\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel}(\phi^{\land})^2.\tag{3}</script><p>我们稍后将使用的指数映射的一阶近似是：</p><script type="math/tex; mode=display">\exp(\phi)^{\land}\approx I+\phi^{\land}.\tag{4}</script><p><strong>对数映射</strong>（恒等式）将 $SO(3)$ 中的矩阵 $R\ne I $与斜对称矩阵相关联：</p><script type="math/tex; mode=display">\log(R)=\frac{\varphi\cdot(R-R^T)}{2\sin(\varphi)},\varphi=\cos^{-1}(\frac{\tr(R)-1}{2}).\tag{5}</script><p>注意$ \log(R)^{\lor}= a\varphi$，其中 $a $和 $\varphi $分别是 $R$ 的旋转轴和旋转角度。如果 $R = I$，则 $\varphi= 0 $，并且 $a$ 是不确定的，因此可以任意选择。</p><p>如果限制在一个开放的球内$\parallel\phi\parallel&lt;\pi$，<strong>指数映射</strong>是<strong>双射</strong>，对应的逆是<strong>对数映射</strong>。然而，如果我们不限制定义域，指数映射就会变成<strong>满射</strong>的，因为每个向量$ \phi= (\varphi + 2k\pi)a, k \in \mathbb{Z}$ 将是 $R$ 的一个可容许对数。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507100016617.png" alt="image-20220507100016617"></p><p>为了符号方便，我们采用指数和对数图的“矢量化”版本：</p><script type="math/tex; mode=display">\begin{align*}Exp&:\ \mathbb{R}^3\rightarrow SO(3)\ ;\ \phi\mapsto \exp(\phi^{\land})\\Log&:\ SO(3)\rightarrow \mathbb{R}^3\ ;\ R\mapsto \log(R)^{\lor}\end{align*}\tag{6}</script><p>它直接对向量进行操作，而不是对$ \mathfrak{so}(3) $中的斜对称矩阵进行操作。</p><p>稍后，我们将使用以下一阶近似：</p><script type="math/tex; mode=display">Exp(\phi+\delta\phi)\approx Exp(\phi)\ Exp(J_r(\phi)\delta\phi).\tag{7}</script><p>$J_r(\phi)$是$SO(3)$ [43, p.40] 的右雅可比行列式，并将切线空间中的加法增量与右侧应用的乘法增量相关联（图 1）：</p><script type="math/tex; mode=display">J_r(\phi)=I-\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel^2}\phi^{\land}+\frac{\parallel\phi\parallel-\sin(\parallel\phi\parallel)}{\parallel\phi^3\parallel}(\phi^{\land})^2.\tag{8}</script><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507102404953.png" alt="image-20220507102404953" style="zoom: 50%;" /></p><blockquote><p>图 1：右雅可比$ J_r $将切线空间中的加性微扰 $\delta\phi$ 与流形$ SO(3)$ 上的乘性微扰联系起来，如方程。 (7)。</p></blockquote><p>类似的一阶近似适用于对数：</p><script type="math/tex; mode=display">Log(Exp(\phi)\ Exp(\delta\phi))\approx\phi+J_r^{-1}(\phi)\delta\phi.\tag{9}</script><p>右雅可比行列式的倒数是:</p><script type="math/tex; mode=display">\begin{align*}J_r^{-1}=I+\frac{1}{2}\phi^{\land}+\left(\frac{1}{\parallel\phi\parallel^2}+\frac{1+\cos(\parallel\phi\parallel)}{2\parallel\phi\parallel\sin(\parallel\phi\parallel)}\right)(\phi^{\land})^2,\end{align*}</script><p>当$\parallel\phi\parallel= 0$ 时，右雅可比 $J_r(\phi)$ 及其逆$J_r^{-1}(\phi)$简化为单位矩阵。</p><p>指数映射的另一个有用属性是：</p><script type="math/tex; mode=display">\begin{align*}&R \ Exp(\phi)R^T=\exp(R\phi^{\land}R^T)=Exp(R\phi)\tag{10} \\ &\Leftrightarrow Exp(\phi)R=RExp(R^T\phi)\tag{11}\end{align*}</script><p>b) 特殊欧几里得群：$SE(3)$ 描述了 $3D$ 中刚体运动的群，是 $SO(3)$ 和 $\mathbb{R}^3 $的半直积，定义为 $SE(3) \doteq \{(R, p ) : R \in SO(3), p \in\mathbb{R}^3\}$。给定 $T_1, T_2 ∈ SE(3)$，组运算为$ T_1 \cdot T_2 = (R_1R_2 , p_1 + R_1p_2)$，逆运算为$ T_1^{-1} = (R^T_1 , −R^T_1 p_1)$。 $SE(3)$的指数映射和对数映射在 [44] 中定义。但是，本文不需要这些，原因将在第 III-C 节中明确说明。</p><h2 id="B-SO-3-中的不确定性描述"><a href="#B-SO-3-中的不确定性描述" class="headerlink" title="B. SO(3) 中的不确定性描述"></a>B. SO(3) 中的不确定性描述</h2><p>$SO(3)$中不确定性的自然定义是定义切线空间中的分布，然后通过指数映射$(6)$[44, 46, 47] 将其映射到$ SO(3)$：</p><script type="math/tex; mode=display">\tilde{R}=R\ Exp(\epsilon),\epsilon \sim\mathcal{N}(0,\Sigma),\tag{12}</script><p>其中 $R$是给定的无噪声旋转（平均值）并且$\epsilon$是一个小的正态分布扰动，均值为零，协方差为$\Sigma$。</p><p>为了获得 $R$分布的显式表达式，我们从$\mathbb{R}^3$中高斯分布的积分开始：</p><script type="math/tex; mode=display">\int_{\mathbb{R}^3}p(\epsilon)d\epsilon=\int_{\mathbb{R}^3}\alpha e^{-\frac{1}{2}\parallel\epsilon\parallel^2_{\Sigma} }d\epsilon=1,\tag{13}</script><p>其中$ \alpha= 1/\sqrt{(2\pi)^3 \det(\Sigma)} $， $\parallel\epsilon\parallel^2_{\Sigma}\doteq\epsilon^T\Sigma^{-1}\epsilon$是具有协方差 $\Sigma$ 的平方<strong>马氏距离</strong>。然后，应用坐标的变化$\epsilon = Log(R^{−1}\tilde{R})$ （当$ \parallel\epsilon\parallel&lt;\pi$ 时，这是 $(12)$ 的倒数），积分 $(13)$ 变为：</p><script type="math/tex; mode=display">\int_{SO(3)}\beta(\tilde{R})e^{-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma}}d\tilde{R}=1,\tag{14}</script><p>其中 $\beta(\tilde{R})$是归一化因子。归一化因子的形式为 $\beta(\tilde{R})= α/|\det\left(\mathcal{J} (\tilde{R})\right)|$，其中$ \mathcal{J} (\tilde{R}) \doteq J_r( Log(R^{-1}\tilde{R})) $，并且$ J_r(·)$ 是右雅可比行列式 $(8)$；$\mathcal{J} (\tilde{R})$ 是变量变化的副产品，推导参见 [46]。</p><p>根据$ (14) $的论点，我们可以直接读取 $SO(3)$ 中的“高斯”分布：</p><script type="math/tex; mode=display">p(\tilde{R})=\beta(\tilde{R})e^{-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma} }.\tag{15}</script><p>对于小的协方差，我们可以逼近$ β\simeqα$，因为当接$\tilde{R}$近 $R$ 时，$J_r( Log(R^{-1}\tilde{R}))$ 可以很好地由单位矩阵逼近。请注意，$(14)$ 已经假设协方差 $\Sigma$相对较小，因为它“剪裁”了半径为 $\pi$的开放球之外的概率尾部（这是由于重新参数化$\epsilon = Log(R^{−1}\tilde{R})$，将 $\epsilon $限制为 $\parallel\epsilon\parallel &lt; \pi$）。将$ β$ 近似为一个常数，给定一个如$(15)$中分布的测量值$\tilde{R}$，旋转 $R$ 的负对数似然是：</p><script type="math/tex; mode=display">\mathcal{L}(R)=\frac{1}{2}\parallel Log(R^{−1}\tilde{R}) \parallel^2_{\Sigma}+const=\frac{1}{2}\parallel Log(\tilde{R}^{−1}R) \parallel^2_{\Sigma}+const.\tag{16}</script><p>几何上可以解释为由逆不确定性$Σ^{-1}$加权的$\tilde{R}$和$R$之间的平方角（$SO(3)$中的测地线距离）。</p><h2 id="C-流形上的高斯-牛顿法"><a href="#C-流形上的高斯-牛顿法" class="headerlink" title="C. 流形上的高斯-牛顿法"></a>C. 流形上的高斯-牛顿法</h2><p>欧几里得空间中的标准高斯-牛顿方法通过反复优化（通常为非凸的）目标函数的二次近似来工作。求解二次近似简化为求解一组线性方程（正规方程），并且这个局部近似的解用于更新当前估计。在这里，我们回顾一下如何将这种方法扩展到（无约束的）优化问题，其变量属于某个流形 $\mathcal{M}$。让我们考虑以下优化问题：</p><p>让我们考虑以下优化问题：</p><script type="math/tex; mode=display">\underset{x\in\mathcal{M} }{\min}f(x),\tag{17}</script><p>其中变量 $x$ 属于流形$\mathcal{M}$；为简单起见，我们在 $(17)$ 中考虑单个变量，而描述很容易推广到多个变量。</p><p>与欧几里得情况相反，不能直接将 $(17) $近似为 $x$ 的二次函数。这是由于两个主要原因。首先，直接在 $x$上工作会导致问题的过度参数化（例如，我们对具有 $9$ 个元素的旋转矩阵进行参数化，而 $3D$ 旋转完全由 $\mathbb{R}^3$中的向量定义），这会使正规方程不确定，其次，所得近似的解一般不属于 $\mathcal{M}$。</p><p>流形优化的标准方法 [45, 48] 包括定义<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$，它是切线空间（在$ x$ 处）的元素 $\delta x$ 和 $x \in\mathcal{M} $的邻域之间的<strong>双射映射</strong>。使用回缩（$retraction$），我们可以将我们的问题重新参数化如下：</p><script type="math/tex; mode=display">\underset{x\in\mathcal{M} }{\min}f(x)  \Longrightarrow \underset{\delta x\in\mathbb{R}^n }{\min}f(\mathcal{R}_x(\delta x)).\tag{18}</script><p>重新参数化通常称为<strong>提升</strong>（$lifting$） [45]。粗略地说，我们在当前估计定义的切空间中工作，该空间在局部表现为欧几里得空间。使用<strong>回缩</strong>（$retraction$）允许在合适维度的欧几里德空间上构建优化问题（例如，当我们在 $SO(3) $中工作时，$\delta x ∈ \mathbb{R}^3$）。</p><p>我们现在可以将标准优化技术应用于 $(18) $右侧的问题。在 Gauss-Newton 框架中，我们将当前估计的成本平方。然后我们求解二次逼近得到一个向量$\delta x^{\star}$在切线空间。最后，流形上的当前猜测被更新为:</p><script type="math/tex; mode=display">\hat{x}\leftarrow \mathcal{R}_{\hat{x} }(\delta x^{\star}).\tag{19}</script><p>这种“lift-solve-retract”方案可以推广到任何信任区域方法[45]。此外，它提供了错误状态模型的基础和统一概括，该模型通常用于航空航天文献中的过滤[49]，最近在机器人技术中用于优化[23, 34]。</p><p>我们通过讨论<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$的选择来结束本节。一个可能的<strong>回缩</strong>（$retraction$）是指数映射。众所周知，在计算上，这可能不是最方便的选择，参见 [50]。</p><p>这项工作中，我们对 $SO(3)$ 使用以下<strong>回缩</strong>（$retraction$），</p><script type="math/tex; mode=display">\mathcal{R}_R(\phi)=R\ Exp(\delta\phi),\ \ \delta\phi\in\mathbb{R}^3,\tag{20}</script><p>对于$SE(3)$，我们使用$ T \doteq(R, p) $处的<strong>回缩</strong>（$retraction$）：</p><script type="math/tex; mode=display">\mathcal{R}_T(\delta\phi,\delta p)=(R\ Exp(\delta\phi),p+R\delta p),\ \ [\delta\phi\ \delta p]\in\mathbb{R}^6,\tag{21}</script><p>这就解释了为什么在第 III-A 节中我们只定义了 $SO(3)$ 的指数映射：通过这种<strong>回缩</strong>（$retraction$）选择，我们永远不需要计算 SE(3) 的指数映射。</p><h1 id="四、最大后验视觉惯性状态估计"><a href="#四、最大后验视觉惯性状态估计" class="headerlink" title="四、最大后验视觉惯性状态估计"></a>四、最大后验视觉惯性状态估计</h1><p>我们考虑一个VIO问题，其中我们想跟踪一个<strong>感知系统</strong>（$sensing\ system$）（例如，一个自主机器人，一个UAV，或者一个手持设备）的状态，其装备一个IMU和一个单目相机。我们假设IMU坐标系“B”和我们想要跟踪的身体坐标系重合，相机和IMU之间的变换是固定的，并且通过之前的标定已经知道（见图2）。此外，我们假设一个前端提供在未知位置的3D路标的图片测量。前端还选择一组图片，称为<strong>关键帧</strong>[32]，我们想计算它的位姿估计。第7节-B1讨论了应用，包括我们实验的前端选择。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507153228526.png" alt="image-20220507153228526" style="zoom:50%;" /></p><blockquote><p>图 2：$T_{WB}\doteq  (R_{WB}, _\mathrm{W}\mathbf{p})$ 是Body坐标系相对于世界坐标系 $W$的位姿。我们假设Body坐标与 IMU 坐标系重合。 $T_{BC}$ 是相机在Body坐标中的位姿，由先验标定已知。</p></blockquote><h2 id="A-状态"><a href="#A-状态" class="headerlink" title="A. 状态"></a>A. 状态</h2><p>系统在时间 $i $的状态由 IMU 方向、位置、速度和偏差描述：</p><script type="math/tex; mode=display">\mathrm{x}_i\doteq    [R_i,\mathbf{p}_i,\mathbf{v}_i,\mathbf{b}_i].\tag{22}</script><p>姿态 $(R_i,\mathbf{p}_i)$属于$ SE(3)$，而速度存在于向量空间中，即 $\mathbf{v}_i \in \mathbb{R}^3$。 IMU 偏差可以写为 $\mathbf{b}_i = [\mathbf{b}_i^g\ \ \mathbf{b}_i^a] \in \mathbb{R}^6$，其中 $\mathbf{b}_i^g\ , \mathbf{b}_i^a\in \mathbb{R}^3 $分别是陀螺仪和加速度计偏差。</p><p>令 $\mathcal{K}_k$ 表示直到时间 $k$ 的所有关键帧的集合。在我们的方法中，我们估计所有关键帧的状态：</p><script type="math/tex; mode=display">\mathcal{X}_k\doteq    \{\mathrm{x}_i\}_{i\in\mathcal{K_k} }.\tag{23}</script><p>在我们的实现中，我们采用了<strong>无结构</strong>的方法（参见第 VII 节），因此 3D 地标不是要估计的变量。但是，提出的方法可以推广到一般方法来估计路标和相机内参以及外参。</p><h2 id="B-测量"><a href="#B-测量" class="headerlink" title="B. 测量"></a>B. 测量</h2><p>我们估计问题的<strong>输入是来自相机和 IMU 的测量值</strong>。我们用 $\mathcal{C}_i$表示关键帧$i$处的图像测量值。在时间 $i$，相机可以观察到多个地标 $l$，因此 $\mathcal{C}_i$包含多个图像测量值 $\mathrm{z}_{il}$。我们稍微滥用符号，我们记 $ l \in \mathcal{C}_i$ 为在 $i$ 时刻看到地标 $l$ 。</p><p>我们用 $\mathcal{I}_{ij}$ 表示在两个连续关键帧 $i$ 和 $j$ 之间获得的<strong>一组 IMU 测量值</strong>。根据 IMU 测量速率和所选关键帧的频率，每个集合 $\mathcal{I}_{ij}$ 可以包含从少量到数百个 IMU 测量值。到时间 $k$ 收集的测量值集是:</p><script type="math/tex; mode=display">\mathcal{Z}_k\doteq\{\mathcal{C}_i,\mathcal{I}_{ij}\}_{(i,j)\in\mathcal{K}_k}.\tag{24}</script><h2 id="C-因子图和-MAP-估计"><a href="#C-因子图和-MAP-估计" class="headerlink" title="C. 因子图和 MAP 估计"></a>C. 因子图和 MAP 估计</h2><p>给定可用的视觉和惯性测量 $\mathcal{Z}_k$ 和先验 $p(\mathcal{X}_0)$，变量 $\mathcal{X}_k$ 的后验概率为：</p><script type="math/tex; mode=display">\begin{align*}p(\mathcal{X}_k|\mathcal{Z}_k)&\propto p(\mathcal{X}_0)\ p(\mathcal{X}_k|\mathcal{Z}_k)\overset{(a)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{C}_i,\mathcal{I}_{ij}|\mathcal{X}_k)\\&\overset{(b)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{I}_{ij}|\mathrm{x}_i,\mathrm{x}_j)\prod_{i\in\mathcal{K}_k}\prod_{l\in\mathcal{C}_i}p(\mathrm{z}_{il}|\mathrm{x}_i)\end{align*}\tag{25}</script><p>分解 $(a)$ 和 $(b)$ 遵循测量之间的标准独立假设。此外，马尔可夫属性应用于$(b)$（例如，时间 $i$ 的图像测量仅取决于时间 $i$ 的状态）。</p><p>由于测量值 $\mathcal{Z}_k$ 是已知的，我们可以自由地将它们作为变量消除，并将它们视为<strong>实际未知数的联合概率因子</strong>的参数。这自然会导致众所周知的因子图表示，这是一类可用于表示这种因子密度的<strong>二分图模型</strong> [51, 52]。图 3 给出了 VIO 问题背后的因子图的连通性示意图（无结构视觉因子的连通性将在第 VII 节中阐明）。<strong>因子图</strong>由<strong>未知数节点</strong>和定义在其上的<strong>概率因子节点</strong>组成，<strong>图结构表示每个因子涉及哪些未知数</strong>。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507162306950.png" alt="image-20220507162306950"></p><blockquote><p>图 3：左：VIO 中的视觉和惯性测量。右图：因子图，其中几个 IMU 测量值汇总在单个预积分 IMU 因子中，无结构视觉因子约束关键帧观察相同的地标。</p></blockquote><p>MAP 估计 $\mathcal{X}_k^{\star}$ 对应于 $(25)$ 的最大值，或者等效地，负对数后验的最小值。在零均值高斯噪声的假设下，<strong>负对数后验</strong>可以写为<strong>残差平方和</strong>：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}_k^{\star}&\doteq\arg\underset{\mathcal{X}_k}{\min}-\log_ep(\mathcal{X}_k|\mathcal{Z}_k)\\&=\arg\underset{\mathcal{X}_k}{\min}\parallel r_0 \parallel^2_{\Sigma_0}+\sum_{(i,j)\in\mathcal{K}_k}\parallel r_{\mathcal{I}_{ij} } \parallel^2_{\Sigma_{ij} }+\sum_{i\in\mathcal{K}_k}\sum_{j\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\end{align*}\tag{26}</script><p>其中 $r_0,r_{\mathcal{I}_{ij} },r_{\mathcal{C}_{il} }$ 是与测量相关的<strong>残差</strong>，而 $\Sigma_0,\Sigma_{ij} $和 $\Sigma_{\mathcal{C} }$ 是相应的<strong>协方差矩阵</strong>。粗略地说，残差是 $\mathcal{X}_k$ 的函数，其在给定状态 $\mathcal{X}_k$ 和先验的前提下，量化测量值和预测值的差。以下部分的目标是提供残差和协方差的表达式。</p><h1 id="五、IMU模型与运动积分"><a href="#五、IMU模型与运动积分" class="headerlink" title="五、IMU模型与运动积分"></a>五、IMU模型与运动积分</h1><p>IMU 通常包括一个 3 轴加速度计和一个 3 轴陀螺仪，，并允许我们来测量传感器相对一个惯性坐标系的旋转速度和加速度。测量值，即 $_B\tilde{a}(t)$ 和 $_B\tilde{w}_{WB}(t)$，受加性白噪声 $\eta$ 和缓慢变化的传感器偏差 $\mathbf{b}$ 的影响：</p><script type="math/tex; mode=display">\begin{align*}_\mathrm{B}\tilde{\omega}_{\mathrm{WB} }(t)&= \ _\mathrm{B}\omega_{\mathrm{WB} }(t)+\mathbf{b}^g(t)+\mathbf{\eta}^g(t)\tag{27}\\_\mathrm{B}\tilde{a}(t)&=R^T_{\mathrm{WB} }(t)(\ _\mathrm{W}\mathbf{a}(t)-\ _\mathrm{W}\mathbf{g})+\mathbf{b}^a(t)+\mathbf{\eta}^a(t)\tag{28}\end{align*}</script><p>在我们的符号中，前缀 $\mathrm{B}$ 表示相应的量在坐标系中 $\mathrm{B}$ 表示（参见图 2）。 IMU 的位姿由变换 $\{R_\mathrm{WB},\ _\mathrm{W}p\}$ 描述，该变换将传感器坐标系 $\mathrm{B}$ 中的一个点映射到 $\mathrm{W}$ 。向量 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)\in \mathbb{R}^3$ 是坐标系 $\mathrm{B}$ 中表示的 $\mathrm{B}$ 相对于 $\mathrm{W}$ 的<strong>瞬时角速度</strong>，而$\ _\mathrm{W}\mathbf{a}(t)\in \mathbb{R}^3$是传感器的<strong>加速度</strong>； $\ _\mathrm{W}\mathbf{g}$ 是世界坐标中的<strong>重力加速度</strong>。我们忽略了地球自转的影响，这相当于假设 $\mathrm{W}$ 是一个惯性系。</p><p>现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型 [49, 53]：</p><script type="math/tex; mode=display">\begin{align*}\dot{R}_\mathrm{WB}&={R}_\mathrm{WB}\ _B{\omega}^{\land}_\mathrm{WB}\\_\mathrm{W}\dot{\mathbf{v} }&=\ _\mathrm{W}\mathbf{a}\\_\mathrm{W}\dot{\mathbf{p} }&=\ _\mathrm{W}\mathbf{v}\end{align*}\tag{29}</script><p>它描述了 $\mathrm{B}$ 的姿势和速度的演变。</p><p> $t + \Delta t $时刻的状态是通过积分方程$(29)$获得的：</p><script type="math/tex; mode=display">\begin{align*}{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\int^{t + \Delta t }_t\ _B{\omega}_\mathrm{WB}(\tau)d\tau\right) \\_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+ \int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau\\_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{v}(\tau)d\tau+\iint^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau^2\end{align*}</script><p>假设 $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p><script type="math/tex; mode=display">\begin{align*}{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\ _B{\omega}_\mathrm{WB}(t)\Delta t\right) \\_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+\ _\mathrm{W}\mathbf{a}(t)\Delta t\\_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\  _\mathrm{W}\mathbf{v}(t)\Delta t+\frac{1}{2}\  _\mathrm{W}\mathbf{a}(t)\Delta t^2\end{align*}\tag{30}</script><p>使用方程式。 (27)–(28)，我们可以将  $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$  写为 IMU 测量的函数，因此 (30) 变为:</p><script type="math/tex; mode=display">\begin{align*}{R}(t + \Delta t )&={R}(t)Exp\left(\ (\tilde{\omega}(t)-\mathbf{b}^g(t)-\mathbf{\eta}^{gd}(t))\Delta t\right) \\\mathbf{v}(t + \Delta t)&=\ \mathbf{v}(t)+\mathbf{g}\Delta t+\ R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t\\\mathbf{p}(t + \Delta t)&=\ \mathbf{p}(t)+\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t^2\end{align*}\tag{31}</script><p>为了便于阅读，我们删除了坐标系下标（从现在开始，符号应该是明确的）。速度和位置的这种数值积分假定两个测量之间 $R(t)$是常数，对于具有非零旋转速率的测量，这不是微分方程 $(29)$ 的精确解。在实践中，使用高速IMU 可以减轻这种近似的影响。我们采用 $(31)$ 的积分方案，<strong>因为它简单，且对于建模和不确定性传播是经得起检验的。</strong>虽然我们表明这种积分方案在实践中表现非常好，但我们注意到对于较慢的 IMU 测量速率，可以考虑使用高阶数值积分方法 [54-57]。</p><p>离散时间噪声 $\eta^{gd}$ 的协方差是采样率的函数，并且通过 $Cov(\eta^{gd}(t)) = \frac{1}{\Delta t}Cov(\eta^{g}(t))$ 与连续时间频谱噪声 $\eta^{g}$ 相关。同样的关系也适用于 $\eta^{ad}$（参见 [58, 附录]）。</p><h1 id="六、-流形上的IMU预积分"><a href="#六、-流形上的IMU预积分" class="headerlink" title="六、 流形上的IMU预积分"></a>六、 流形上的IMU预积分</h1><p>虽然等式 $(31)$  可以很容易地被视为因子图中的概率约束，它需要在因子图中以高速率包含状态。直观地说，方程。 $(31)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。因此，我们必须在每次新的 IMU 测量时在估计中添加新状态 [37]。</p><p>在这里，我们展示了在时间 $k = i$ 和 $k = j$（见图 4）的两个关键帧之间的所有测量值可以总结为单个复合测量值，称为预积分 IMU 测量值，它限制了连续关键帧之间的运动。这个概念最初是在 [2] 中使用欧拉角提出的，我们通过开发一种适用于流形 $SO(3)$ 上的预积分的理论来扩展它。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507202527649.png" alt="image-20220507202527649"></p><blockquote><p>图 4：IMU 和相机的不同速率。</p></blockquote><p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 (31)，我们发现：</p><script type="math/tex; mode=display">\begin{align*}{R}_j&={R}_i\prod^{j-1}_{k=i} Exp\left( (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)\Delta t\right) \\\mathbf{v}_j&=\ \mathbf{v}_i+\mathbf{g}\Delta t_{ij}+\ \prod^{j-1}_{k=i}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\\mathbf{p}_j&=\mathbf{p}_i+\sum^{j-1}_{k=i}\left[\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] \end{align*}\tag{32}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。虽然等式。 $(32)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(32)$ 中的积分 [24]（直观地说，旋转 $R_i$ 的变化，意味着所有未来旋转 $R_k、k = i,…,j-1$ 的变化，因此有必要重新评估 $(32)$ 中的求和和乘积。</p><p>我们希望避免在时间 $t_i$ 的线性化点发生变化时重新计算上述积分。因此，我们遵循 [2] 并定义以下相对运动增量，这些增量与 $t_i$ 处的位姿和速度无关:</p><script type="math/tex; mode=display">\begin{align*}\Delta{R}_{ij}&\doteq{R}^T_iR_j\prod^{j-1}_{k=i} Exp\left( (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)\Delta t\right) \\\Delta\mathbf{v}_{ij}&\doteq{R}^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})\ = \sum^{j-1}_{k=i}\Delta R_{ij}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\\Delta\mathbf{p}_{ij}&\doteq{R}^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\sum^{j-1}_{k=i}\mathbf{g}\Delta t^2)\\&=\sum^{j-1}_{k=i}\left[\  \mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta R_{ik}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] \end{align*}\tag{33}</script><p>其中 $\Delta{R}_{ik}\doteq R^T_i R_k $ 和 $\Delta\mathbf{v}_{ik} \doteq R^T_i (\mathbf{v}_{k}−\mathbf{v}_{i}−\mathbf{g}\Delta t_{ik})$。我们强调，与“delta”旋转 $\Delta{R}_{ij}$ 相比， $\Delta\mathbf{v}_{ij}$  和 $\Delta\mathbf{p}_{ij}$都不对应于速度和位置的真实物理变化，而是以一种方式定义的，使得 $(33)$ 的右侧独立于时间 $i$ 的状态以及引力效应。事实上，我们将能够直接从两个关键帧之间的惯性测量中计算 $(33)$ 的右侧。</p><p>不幸的是，$(33)$ 中的求和和乘积仍然是偏差估计的函数。我们分两步解决这个问题。在第 VI-A 节中，我们假设$\mathbf{b}_{i}$ 是已知的；然后，在第 VI-C 节中，我们展示了如何在偏差估计发生变化时避免重复积分。</p><p>在本文的其余部分，我们假设两个关键帧之间的偏差保持不变：</p><script type="math/tex; mode=display">\mathbf{b}^g_{i}=\mathbf{b}^g_{i+1}=···=\mathbf{b}^g_{j-1},\ \ \ \ \mathbf{b}^a_{i}=\mathbf{b}^a_{i+1}=···=\mathbf{b}^a_{j-1}.\tag{34}</script><h2 id="A-预积分-IMU-测量"><a href="#A-预积分-IMU-测量" class="headerlink" title="A. 预积分 IMU 测量"></a>A. 预积分 IMU 测量</h2><p>等式 $(33)$ 将关键帧 $i$ 和 $j$ 的状态（左侧）与测量值（右侧）相关联。从这个意义上说，它已经可以理解为一种测量模型。不幸的是，它对测量噪声有相当复杂的依赖性，这使得 MAP 估计的直接应用变得复杂。直观地说，MAP 估计器需要清楚地定义测量的密度（及其对数似然）。在本节中，我们修改 $(33)$  以便更容易推导测量对数似然。在实践中，我们在 $(33)$ 中隔离了单个惯性测量的噪声项。如上所述，在本节中，假设时间 $t_i$ 的偏差是已知的。</p><p>让我们从 $(33)$ 中的旋转增量 $\Delta{R}_{ij}$ 开始。我们使用一阶近似 $(7)$（旋转噪声“小”）并重新排列术语，通过使用关系$(11)$将噪声“移动”到末尾：</p><script type="math/tex; mode=display">\begin{align*}\Delta{R}_{ij} &\overset{eq.(7)}{\simeq}\prod^{j-1}_{k=i}\left[Exp((\tilde{\omega}_k-\mathbf{b}^g_i)\Delta t)Exp(-J^k_r\eta^{gd}_k\Delta t)\right]\\&\overset{eq.(11)}{\simeq}\Delta{\tilde R}_{ij}\prod^{j-1}_{k=i}Exp(-\Delta \tilde R^T_{k+1 j} J^k_r \eta^{gd}_k \Delta t)\\&\doteq    \Delta{\tilde R}_{ij}Exp(-\delta \phi_{ij})    \end{align*}\tag{35}</script><p>其中，$J^k_r \doteq J^k_r(( \tilde\omega_k − b^g_i )Δt)$。在 $(35)$ 的最后一行，我们定义了预积分旋转测量 $\Delta{\tilde R}_{ij} \doteq \prod^{j−1}_{k=i} Exp (( \tilde\omega_k − b^g_i) Δt)$，及其噪声 $\delta\phi_{ij}$，将在下一节中分析。</p><p>将 $(35)$ 代回 $(33)$ 中 $\Delta\mathbf{v}_{ij}$ 的表达式，使用 $Exp(-\delta \phi_{ij})    $ 的一阶近似 $(4)$，并去掉高阶噪声项，我们得到：</p><script type="math/tex; mode=display">\begin{align*}\Delta\mathbf{v}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t -\Delta{\tilde R}_{ik}\eta^{gd}_k\Delta t\\&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{v} }_{ij}+\sum^{j-1}_{k=i}\left[\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t - \Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t\right]\\&\doteq    \Delta\tilde{\mathbf{v} }_{ij}-\delta\mathbf{v}_{ij}\end{align*}\tag{36}</script><p>其中，我们定义了预积分速度测量 $\Delta\tilde{\mathbf{v} }_{ij}\doteq\sum^{j-1}_{k=i}<br>\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\Delta t $及其噪声 $\delta\mathbf{v}_{ij}$。</p><p>类似地，将$(35)$ 和$(36)$ 代入$(33)$ 中的 $\Delta\mathbf{p}_{ij}$ 表达式，并使用一阶近似 $(4)$，我们得到：</p><script type="math/tex; mode=display">\begin{align*}\Delta\mathbf{p}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\left[(\Delta\tilde{\mathbf{v} }_{ik}-\delta\mathbf{v}_{ik})\Delta t+\frac{1}{2}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t^2 -\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\\&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{p} }_{ij}+\sum^{j-1}_{k=i}\left[-\delta\mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t^2 - \frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2\right]\\&\doteq    \Delta\tilde{\mathbf{p} }_{ij}-\delta\mathbf{p}_{ij}\end{align*}\tag{37}</script><p>其中我们定义了预集成的位置测量 $\Delta\tilde{\mathbf{p} }_{ij}$ 及其噪声 $\delta\mathbf{p}_{ij}$。</p><p>将表达式 $(35), (36), (37)$ 代入$ (33)$ 中 $\Delta{R}_{ij}, \Delta\mathbf{v}_{ij}, \Delta\mathbf{p}_{ij}$ 的原始定义，我们最终得到了我们的<strong>预积分测量模型</strong>（记住 $Exp(-\delta\phi_{ij})^T = Exp(\delta\phi_{ij})$):</p><script type="math/tex; mode=display">\begin{align*}\Delta{\tilde R}_{ij}&=R^T_iR_j\mathrm{Exp}(\delta\phi_{ij})\\R^T_i\Delta\tilde{\mathbf{v} }_{ij}&=R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})+\delta\mathbf{v}_{ij}\\\Delta\tilde{\mathbf{p} }_{ij}&=R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)+\delta\mathbf{p}_{ij}\end{align*}\tag{38}</script><p>其中我们的复合测量被写为（待估计）状态“加上”随机噪声的函数，由随机向量 $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 描述。</p><p>为了总结本节的内容，我们将 $(33)$ 的测量模型重新写为 $(38)$。$(38)$ 的优势在于，对于一个合适的噪声分布，它直接定义了对数似然。例如，具有零均值加性高斯噪声（ $(38)$的最后两行）测量的（负）对数是一个二次函数。类似地，如果 $\delta\phi_{ij}$  是零均值高斯噪声，我们计算与 $\Delta\tilde R_{ij}$ 相关的（负）对数似然。噪声项的性质将在下一节中讨论。</p><h2 id="B-噪声传播"><a href="#B-噪声传播" class="headerlink" title="B. 噪声传播"></a>B. 噪声传播</h2><p>在本节中，我们推导出噪声向量  $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 的统计量。虽然我们已经观察到将噪声向量近似为零均值正态分布是很方便的，但准确地建模噪声协方差是至关重要的。实际上，噪声协方差对 MAP 估计器有很大的影响（逆噪声协方差用于对优化中的项进行加权 $(26)$）。因此，在本节中，我们提供了预积分测量的协方差 $\Sigma_{ij}$ 的推导：</p><script type="math/tex; mode=display">\eta^{\Delta}_{ij}\doteq[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T\sim\mathcal{N}(0_{9\times1},\Sigma_{ij})\tag{39}</script><p>我们首先考虑预积分的旋转噪声 $\delta\phi_{ij}$。回想一下 $(35)$</p><script type="math/tex; mode=display">\mathrm{Exp}(-\delta\phi_{ij})\doteq\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\tag{40}</script><p>取两边的对数并改变符号，我们得到：</p><script type="math/tex; mode=display">\delta\phi_{ij}=-\mathrm{Log}\left(\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\right)\tag{41}</script><p>一阶近似 $(9)$ 的重复应用（回想一下，$\eta^{gd}_k$ 和 $\delta\phi_{ij}$ 都是小的旋转噪声，因此右雅可比矩阵接近恒等式）产生：</p><script type="math/tex; mode=display">\delta\phi_{ij}\simeq\sum^{j-1}_{k=1}\Delta\tilde R^T_{K+1j}J^k_r\eta^{gd}_k\Delta t\tag{42}</script><p>保留到一阶，噪声  $\delta\phi_{ij}$ 是零均值和高斯的，因为它是零均值噪声项 $\eta^{gd}_k$ 的线性组合。这是可取的，因为它使旋转测量模型 $(38)$ 完全符合形式 $(12)$。</p><script type="math/tex; mode=display">\begin{align*}\delta \mathbf{v}_{ij}&\simeq \sum^{j-1}_{k=i}\left[-\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t +\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t\right]\\\delta\mathbf{p}_{ij} &\simeq\sum^{j-1}_{k=i}\left[\delta\mathbf{v}_{ik}\Delta t-\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t ^2 +\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\end{align*}\tag{43}</script><p>其中关系到一阶都是正确的。</p><p>方程。 $(42)-(43)$ 将预积分噪声 $\eta^{\Delta}_{ij}$ 表示为 IMU 测量噪声 $\eta^d_k \doteq [\eta^{gd}_k , \eta^{ad}_k ], k = 1, . . .,j − 1$, 的线性函数。因此，根据 $\eta^{d}_{k}$  的协方差知识（在 IMU 规范中给出），我们可以通过简单的线性传播计算 $\eta^{\Delta}_{ij}$ 的协方差，即 $\Sigma_{ij}$。</p><p>在附录 IX-A 中，我们提供了一种更巧妙的方法来计算$\Sigma_{ij}$。特别是，我们展示了 $\Sigma_{ij}$ 可以方便地以迭代形式计算：当一个新的 IMU 测量到达时，我们只更新 $\Sigma_{ij}$，而不是从头开始重新计算。迭代计算导致更简单的表达式并且更适合在线推理。</p><h2 id="C-组合偏差更新"><a href="#C-组合偏差更新" class="headerlink" title="C. 组合偏差更新"></a>C. 组合偏差更新</h2><p>在上一节中，我们假设在 $k = i$ 和 $k = j$ 之间的预积分期间使用的偏差 $\{\overline{b}^a_i , \overline{b}^g_i\}$ 是正确的并且不会改变。然而，更有可能的是，偏差估计在优化过程中会发生少量 $\delta\mathbf{b}$ 的变化。一种解决方案是在偏差发生变化时重新计算 delta 测量值；但是，这在计算上是昂贵的。相反，给定偏差更新 $\mathbf{b}\gets \mathbf{b} + \delta\mathbf{b}$，我们可以使用一阶展开更新 delta 测量：</p><script type="math/tex; mode=display">\begin{align*}\Delta\tilde{R}_{ij}(\mathbf{b}^g_i)&\simeq\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)\\\Delta\tilde{\mathbf{v} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\\\Delta\tilde{\mathbf{p} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\end{align*}\tag{44}</script><p>这类似于 [2] 中的偏差校正，但直接在 $SO(3)$ 上运行。雅可比矩阵 $\{ \frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g} , \frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g} , . . .\}$（在  $\overline{\mathbf{b} }_i$ 计算，积分时的偏差估计）描述了测量值如何由于偏差估计的变化而变化。雅可比矩阵保持不变，并且可以在预积分期间预先计算。雅可比矩阵的推导与我们在第 VI-A 节中用于将测量值表示为大值加上小扰动的推导非常相似，并在附录 IX-B 中给出。</p><h2 id="D-预积分IMU因子"><a href="#D-预积分IMU因子" class="headerlink" title="D. 预积分IMU因子"></a>D. 预积分IMU因子</h2><p>给定 $(38)$ 中的预积分测量模型，并且由于测量噪声是零均值和高斯（协方差 $\Sigma_{ij}$）直到一阶 $(39)$，现在很容易写出残差 $r_{\mathcal{I}_{ij} }\doteq [r^T_{\Delta R_{ij} }, r^T_{\Delta \mathbf{v}_{ij} },r^T_{\Delta \mathbf{p}_{ij} }]^T \in \mathbb{R}^9$, 其中:</p><script type="math/tex; mode=display">\begin{align*}r_{\Delta R_{ij} }&\doteq \mathrm{Log}\left(\left(\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)\right)^TR^T_iR_j\right)\\r_{\Delta \mathbf{v}_{ij} }&\doteq R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})-\left[\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a\right]\\r_{\Delta \mathbf{p}_{ij} }&\doteq R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)-\left[\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a\right]\\\end{align*}\tag{45}</script><p>其中我们还包括了方程的偏差更新 $(44)$。</p><p>根据“lift-solve-retract”方法（第 III-C 节），在每次 Gauss-Newton 迭代中，我们需要使用<strong>回缩($retraction$)</strong> $(21)$重新参数化 $(45)$。然后，“解决”步骤需要围绕当前估计线性化结果成本。出于线性化的目的，计算残差的雅可比行列式分析表达式很方便，我们在附录 IX-C 中推导出了该表达式。</p><h2 id="E-偏置模型"><a href="#E-偏置模型" class="headerlink" title="E. 偏置模型"></a>E. 偏置模型</h2><p>在介绍 IMU 模型 $(27)$ 时，我们说偏差是缓慢随时间变化的量。因此，我们用“布朗运动”对它们进行建模，即综合白噪声：</p><script type="math/tex; mode=display">\dot{b}^g(t)=\eta^{bg}, \ \ \ \ \dot{b}^a(t)=\eta^{ba}\tag{46}</script><p>在两个连续关键帧 $i$ 和 $j$ 之间的时间间隔 $[t_i, t_j]$ 上对 $(46)$ 进行积分，我们得到：</p><script type="math/tex; mode=display">\mathbf{b}^g_j(t)=\mathbf{b}^g_i+\eta^{bgd}, \ \ \ \ \ \mathbf{b}^a_j(t)=\mathbf{b}^a_i+\eta^{bad}\tag{47}</script><p>其中，如前所述，我们使用简写 $\mathbf{b}^g_j\doteq \mathbf{b}^g(t_i)$，我们定义离散噪声 $\eta^{bgd}$ 和 $\eta^{bad}$，它们的均值和协方差为零 $\Sigma^{bgd}\doteq \Delta t_{ij} Cov(\eta^{bg})$ 和 $\Sigma^{bad}\doteq \Delta t_{ij} Cov(\eta^{ba})$，分别（参见[58，附录]）。</p><p>模型 $(47)$ 可以很容易地包含在我们的因子图中，作为 $(26)$ 中所有连续关键帧的进一步附加项：</p><script type="math/tex; mode=display">\parallel r_{b_{ij} } \parallel^2 \doteq\parallel \mathbf{b}^g_j- \mathbf{b}^g_i \parallel^2_{\Sigma_{bgd} }+\parallel \mathbf{b}^a_j- \mathbf{b}^a_i \parallel^2_{\Sigma_{bad} }\tag{48}</script><h1 id="七、无结构视觉因子"><a href="#七、无结构视觉因子" class="headerlink" title="七、无结构视觉因子"></a>七、无结构视觉因子</h1><p>在本节中，我们将介绍我们用于视觉测量的无结构模型。我们方法的关键特征是地标的线性消除。请注意，在每次 Gauss-Newton 迭代中都会重复消除，因此我们仍然可以保证获得最佳 MAP 估计。</p><p>视觉测量通过如下求和贡献到代价函数 $(26)$ 中:</p><script type="math/tex; mode=display">\sum_{i\in\mathcal{K}_k}\sum_{l\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2=\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\tag{49}</script><p>其中，在右侧，我们将其重写为每个地标 $l = 1 ,. . , L$, 的贡献的总和。在 (49) 中，$\mathcal{X}(l)$ 表示看到 $l$ 的关键帧的子集。</p><p>单个图像测量 $\mathbf{z}_{il}$ 的残差的一个相当标准的模型是重投影误差：</p><script type="math/tex; mode=display">r_{\mathcal{c}_{il} }=\mathbf{z}_{il}-\pi(R_i,\mathbf{p}_{i},ρ_l)\tag{50}</script><p>其中 $ρ_l \in \mathbb{R}^3$ 表示第 $l$ 个地标的位置，$π(·)$ 是标准透视投影，它也编码了（已知的）IMU 相机变换 $T_{BC}$。</p><p>直接使用 $(50)$ 将需要包括地标位置 $ρ_l, l = 1, 。 . . , L$ 在优化中，这对计算产生负面影响。因此，在下文中，我们采用了一种无结构的方法，避免对地标进行优化，从而确保检索 MAP 估计</p><p>正如在第 III-C 节中回顾的那样，在每次 GN 迭代中，我们使用<strong>回缩($retraction$)</strong> $(21)$来提升成本函数。对于视觉因素，这意味着原始残差 $(49)$ 变为：</p><script type="math/tex; mode=display">\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel \mathbf{z}_{il}-\check{\pi}(\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l)\parallel^2_{\Sigma_{\mathcal{C} } }\tag{51}</script><p>其中 $\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l$ 是欧几里得修正，$\check{\pi}(·)$ 是提升的成本函数。 GN 方法中的“求解”步骤基于残差的线性化：</p><script type="math/tex; mode=display">\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel \mathbf{F}_{il}\delta\mathbf{T}_{i}+\mathbf{E}_{il}\delta ρ_l-\mathbf{b}_{il}\parallel^2\tag{52}</script><p>其中 $\delta \mathbf{T}_i \doteq [\delta\phi_i,\delta\mathbf{p}_i]^T$; 雅可比矩阵 $\mathbf{F}_{il},\mathbf{E}_{il}$ 和向量 $\mathbf{b}_{il}$（均由 $\Sigma^{1/2}_{\mathcal{C}}$ 归一化）来自线性化。向量$\mathbf{b}_{il}$是线性化点处的残差。将 $(52)$ 中的第二个和写成矩阵形式，我们得到：</p><script type="math/tex; mode=display">\sum^L_{l=1}\parallel \mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}\parallel^2\tag{53}</script><p>其中，对于所有 $i \in \mathcal{X}(l)，\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 分别通过堆叠 $\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 获得。</p><p>由于地标 $l$ 出现在总和 $(53)$ 的单个项中，因此对于任何给定的姿态扰动 $\delta\mathbf{T}_{\mathcal{X}(l)}$ 选择，最小化代价函数 $\parallel<br>\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}<br>\parallel^2$ 的地标扰动 $\deltaρ_l$ 是：</p><script type="math/tex; mode=display">\deltaρ_l=-(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\tag{54}</script><p>将 $(54)$ 代回 $(53)$ 我们可以从优化问题中消除变量 $\deltaρ_l$ ：</p><script type="math/tex; mode=display">\sum^L_{l=1}\parallel (\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T)(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\parallel^2\tag{55}</script><p>其中 $\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T$ 是 $\mathbf{E}_{l}$的正交投影。在附录 IX-D 中，我们展示了可以进一步操纵成本 $(55)$，从而实现更有效的实施。</p><p>这种方法在BA文献中被称为 Schur 补码技巧($Schur\ complement\ trick$)，其中一种标准做法是通过反向替换来更新 $ρ_l$ 的线性化点 [61]。相反，我们使用快速线性三角测量从姿势的线性化点获得更新的地标位置。使用这种方法，我们将涉及姿势和地标的大量因子 $(51)$ 减少为仅涉及姿势的较小 $L$ 因子集 $(55)$。特别是，与界标 $l$ 对应的因子仅涉及观察 $l$ 的状态 $\mathcal{X}(l)$，创建图 3 的连接模式。MSCKF [5] 中也使用相同的方法来避免在状态向量中包含界标.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>外积、内积、张量积、Kronecker积</title>
    <link href="https://lukeyalvin.top/posts/bdcf3114.html"/>
    <id>https://lukeyalvin.top/posts/bdcf3114.html</id>
    <published>2022-05-08T13:08:37.000Z</published>
    <updated>2022-05-08T13:26:11.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h1><p>内积又称为点积，有两种定义方式，一种是代数方式，一种是集合方式。</p><ul><li><strong>代数定义</strong></li></ul><p>两个向量$\vec{a}=[a_1,a_2,···,a_n]$和$\vec{b}=[b_1,b_2,···,b_n]$的点积定义为：</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b}=\sum^{n}_{i=1}a_ib_i=a_1b_1+a_2b_2+···+a_nb_n\tag{1}</script><p>点积也可以写成$\vec{a}\vec{b}^T$</p><ul><li><strong>几何定义</strong></li></ul><p>在欧几里得空间中，点积可以直观地定义为:</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\cos\theta\tag{2}</script><p>其中，$|\vec{x}|$表示$\vec{x}$的模长，$\theta$表示两个向量之间的夹角。</p><h1 id="叉积（Cross-product）"><a href="#叉积（Cross-product）" class="headerlink" title="叉积（Cross product）"></a>叉积（Cross product）</h1><ul><li><strong>定义</strong></li></ul><p>叉积又称为向量积（有时候也说是外积，这里为了区分，就不这么说，因为你会发现好多外积），是对三维空间中的两个向量的二元运算，使用符号$\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量$a$和$b$，它们的外积写作 $a\times b$，是 $ a $和$b$所在平面的法线向量，与$ a $和$b$都垂直。</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506153837169.png" alt="image-20220506153837169" style="zoom: 25%;" /></p><p>两个向量$a$和$b$的叉积仅在三维空间有定义，写作 $a\times b$，叉积也可以定义为：</p><script type="math/tex; mode=display">a\times b=\parallel a \parallel \parallel b\parallel \sin(\theta)n\tag{3}</script><p>其中$\theta$表示$a$和$b$在它们所定义的平面上的夹角，$\parallel a \parallel$和$\parallel b \parallel$表示向量$a$和$b$的模长，而$n$则是一个与$a$和$b$所构成的平面的垂直的单位向量，方向由右手定则决定。</p><ul><li><strong>矩阵表示</strong></li></ul><p>叉积也可以定义为：</p><script type="math/tex; mode=display">a\times b=\left|\begin{matrix}i&j&k\\a_1&a_2&a_3\\b_1&b_2&b_3\end{matrix}\right|=\begin{bmatrix}a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1\end{bmatrix}=\begin{bmatrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\end{bmatrix}b\triangleq a^{\land}b\tag{4}</script><p>这里引入符号$^{\land}$，成为反对称符号，这样就可以把外积$a\times b$写成了矩阵与向量的乘法$a^{\land}b$，把它变成可线性运算。在《视觉SLAM十四讲》中也有提及。</p><h1 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h1><p>在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的:最一般的双线性运算。在某些上下文中也叫做外积。</p><script type="math/tex; mode=display">b\otimes a \rightarrow \begin{bmatrix}b_1\\b_2\\b_3\\b_4\end{bmatrix}_{4\times 1}\begin{bmatrix}a_1&a_2&a_3\end{bmatrix}_{1\times 3}=\begin{bmatrix}a_1b_1&a_2b_1&a_3b_1\\a_1b_2&a_2b_2&a_3b_2\\a_1b_3&a_2b_3&a_3b_3\\a_1b_4&a_2b_4&a_3b_4\\\end{bmatrix}_{4\times 3}\tag{5}</script><p>对于张量积之后的秩：</p><script type="math/tex; mode=display">rank(V\otimes U)=rank(V)+rank(U)\tag{6}</script><h1 id="Kronecker积"><a href="#Kronecker积" class="headerlink" title="Kronecker积"></a>Kronecker积</h1><p>数学上，克罗内克积（英语：Kronecker product）是两个任意大小的矩阵间的运算，表示为⊗。克罗内克积是外积从向量到矩阵的推广，也是张量积在标准基下的矩阵表示。</p><p>如果$A$是一个$m\times n$的矩阵，$B$是一个$p\times q$的矩阵，克罗内克积为$A\otimes B$则是一个$mp\times nq$的矩阵：</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162341626.png" alt="image-20220506162341626" style="zoom: 20%;" /></p><p>更具体的表示为：</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162438902.png" alt="image-20220506162438902" style="zoom:40%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学基础" scheme="https://lukeyalvin.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="内积与外积" scheme="https://lukeyalvin.top/tags/%E5%86%85%E7%A7%AF%E4%B8%8E%E5%A4%96%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>相机模型简要分析</title>
    <link href="https://lukeyalvin.top/posts/ddbf64.html"/>
    <id>https://lukeyalvin.top/posts/ddbf64.html</id>
    <published>2022-05-08T13:06:11.000Z</published>
    <updated>2022-05-08T13:08:07.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="相机成像模型"><a href="#相机成像模型" class="headerlink" title="相机成像模型"></a>相机成像模型</h1><p>相机模型基于小孔成像：</p><p><img src="/images/相机模型简要分析/image-20220505170737171.png" alt="image-20220505170737171" style="zoom: 67%;" /></p><p>这里出现了几个坐标系：</p><ul><li>世界坐标系$\{W\}$，在世界坐标系下，特征点$P$在世界坐标系下的坐标为$P_w=(X_w,Y_w,Z_w)$</li><li><p>相机坐标系$\{C\}$，对相机来说，也有一个相机坐标系，也可以称之为机器人本体坐标系，因为相机属于机器人，特征点$P$在相机坐标系下的坐标为$P_c=(X_c,Y_c,Z_c)$</p></li><li><p>像素平面坐标系$\{P^{\prime}\}$，这个是通过相机内部得到的投影平面坐标系，它是一个二维的平面，特征点$P$在像素平面坐标系下的坐标为$P^{\prime}=(X^{\prime},Y^{\prime})$，</p></li><li><p>像素坐标系$\{P_{uv}\}$，像素坐标系是素平面坐标系$\{P^{\prime}\}$经过缩放和平移得到的，后面介绍。</p></li></ul><p>那么我们需要明白这几个坐标系之间的关系：</p><p><img src="/images/相机模型简要分析/image-20220505171918452.png" alt="image-20220505171918452"></p><h2 id="世界坐标系——相机坐标系"><a href="#世界坐标系——相机坐标系" class="headerlink" title="世界坐标系——相机坐标系"></a>世界坐标系——相机坐标系</h2><p>这个很简单，两者就相差一个刚体变换，这变换矩阵为$T_{cw}$，则对于特征点$P$来说，就有：</p><script type="math/tex; mode=display">P_{c}=(T_{cw}P_{w})_{(1:3)}=(T_{cw}\begin{bmatrix}X_{w}\\Y_{w}\\Z_{w}\end{bmatrix})_{(1:3)}\tag{1}</script><p>这里$(T_{cw})_{(1:3)}$指的是纯旋转的情况下，考虑他的前三项。</p><h2 id="相机坐标系——像平面坐标系"><a href="#相机坐标系——像平面坐标系" class="headerlink" title="相机坐标系——像平面坐标系"></a>相机坐标系——像平面坐标系</h2><p><img src="/images/相机模型简要分析/image-20220505172602891.png" alt="image-20220505172602891"></p><p>如图所示，展示相机内部投影的过程，</p><script type="math/tex; mode=display">\begin{align*}X^{\prime}=f\frac{X_c}{Z_c}\\Y^{\prime}=f\frac{Y_c}{Z_c}\end{align*}\tag{2}</script><h2 id="像平面坐标系——像素坐标系"><a href="#像平面坐标系——像素坐标系" class="headerlink" title="像平面坐标系——像素坐标系"></a>像平面坐标系——像素坐标系</h2><p>像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。我们设像素坐标在$u$ 轴上缩放了 $\alpha$倍，在 $v$上缩放了 $\beta$ 倍。同时，原点平移了$ [c_x,c_y]^T$。那么， $P^′$ 的坐标与像素坐标 $[u,v]^T $的关系为：  </p><script type="math/tex; mode=display">\left\{\begin{array}{L}u=\alpha X^{\prime}+c_x\\v=\alpha Y^{\prime}+c_y\end{array}\right.\\tag{3}</script><p>将$(2)$带入$(3)$:</p><script type="math/tex; mode=display">\left\{\begin{array}{L}u=f_x \frac{X_c}{Z_c}+c_x\\v=f_y \frac{Y_c}{Z_c}+c_y\end{array}\right.\\tag{3}</script><p>其中$f_x= \alpha f$，$f_y= \beta f$，$f$ 的单位为米， $\alpha,\beta$ 的单位为像素每米，所以 $f_x,f_y $的单位为像素 。</p><h2 id="相机坐标系——像素坐标系"><a href="#相机坐标系——像素坐标系" class="headerlink" title="相机坐标系——像素坐标系"></a>相机坐标系——像素坐标系</h2><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}\triangleq \lambda KP_c\tag{4}</script><p>其中，$\lambda$称为逆深度，$K$表示相机的内参。</p><ul><li>采用逆深度的方式，表达一个点的坐标$(x,y,z)$变成成了$1/λ * [u,v,1]^T$，将$3$个优化变量，变成了一个优化变量（$u,v$为归一化相机坐标系下的三维点的坐标，通过观测数据是可知的），所以优化变量少。</li><li>同时，对于深度很大的点，在数值上很大，采用逆深度的方式，倒一下，数值上变小了，有利于优化过程中数值的稳定性，不会因为很远的点（深度值很大）导致一次优化过程中出现较大的误差函数的变换，因此再远的点（如天空中的点）也能表达了，所以能表达非常远的点。</li><li>将深度值倒数一下，变成小数，跟接近高斯分布的函数表达形式，方便优化。</li></ul><p><strong>归一化坐标</strong></p><p>另外我们引入归一化坐标的概念，它位于相机前方 $z = 1$ 处的平面上。该平面称为<strong>归一化平面</strong>。  比如对$P_c$进行归一化处理得到$\overline{P}$</p><script type="math/tex; mode=display">\overline{P}=\frac{1}{Z_c}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\tag{5}</script><p>因此，可以得到像素坐标与归一化坐标之间的关系为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}\triangleq  K\overline{P}\tag{6}</script><p>可以发现相机归一化坐标$\overline{P}$经过相机内参就可以得到像素坐标，所以我们可以把像素坐标$[u,v]^T$ ，看成对归一化平面上的点进行量化测量的结果。  </p><h2 id="相机坐标系——世界坐标系"><a href="#相机坐标系——世界坐标系" class="headerlink" title="相机坐标系——世界坐标系"></a>相机坐标系——世界坐标系</h2><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}(R_{cw}P_w+t)\triangleq \lambda KT_{cw}P_w\tag{7}</script><h1 id="VO重投影误差"><a href="#VO重投影误差" class="headerlink" title="VO重投影误差"></a>VO重投影误差</h1><p>重投影误差如图示，我们通过特征匹配可知，观测值$p_1$和$p_2$是同一个空间点$P$的投影，而实际上我们利用帧间的位姿估计，可以通过观测值$p_1$求得对应的匹配$\hat{p}_2$，理论上，我们的计算值$\hat{p}_2$与观测值$p_1$应该是重合的，但是，由于我们估计的帧间位姿并不是准确的，因此就会出现误差$e$，我们称之为重投影误差。</p><p><img src="/images/相机模型简要分析/image-20220505202300998.png" alt="image-20220505202300998" style="zoom:50%;" /></p><p>按照之前的基础知识，可以推导：</p><script type="math/tex; mode=display">s_iu_i=K\exp(\xi^{\land})P_i\tag{8}</script><p>其中，$u_i=[u_i,v_i]^T$表示特征点$P$的投影坐标，$s_i$表示深度，$K$表示相机内参，$\exp(\xi^{\land})$则是变换$T_{cw}$的李代数形式，这里的$P_i$是特征点的世界坐标。这里类似于公式$(7)$。</p><p>通过重投影误差的定义可知，我们的目的在于不断优化变量$\xi$，从而得到一个最优的$\xi$使得$e$的值达到最小，因此构建最小二乘：</p><script type="math/tex; mode=display">\xi^*=\arg\underset{\xi}{\min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1}{s_i}K\exp(\xi^{\land})P_i\parallel^2_2\tag{9}</script><p>然后就是对其优化的内容了，这里可以参考：<a href="https://lukeyalvin.top/posts/20908.html#1-%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE">PnP_重投影误差</a></p><h1 id="VIO重投影误差"><a href="#VIO重投影误差" class="headerlink" title="VIO重投影误差"></a>VIO重投影误差</h1><p>由构建于VIO重投影误差省略了相机内参$K$，那么，我们在公式$(6)$的基础上把$K$去掉，就发现<strong>特征点在相机归一化平面的坐标就是像素坐标</strong>$[u,v]^T$，其中$[u,v]^T$是观测值，由于$T_{cw}$是估计出来的，所以等式右边是估计值，理想情况下有：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=T_{cw}\begin{bmatrix}\frac{X_w}{Z_w}\\\frac{Y_w}{Z_w}\\1\end{bmatrix}=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\triangleq  \overline{P}</script><p>而此时的重投影误差就变成了：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_c}{Z_c}-u\\\frac{Y_c}{Z_c}-v\end{bmatrix}</script><p>熟悉这个之后，我们再来学习一下VIO重投影误差。</p><p><img src="/images/相机模型简要分析/image-20220505205125811.png" alt="image-20220505205125811" style="zoom: 33%;" /></p><p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p><script type="math/tex; mode=display">\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{10}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u\\\frac{Y_{cj} }{Z_{cj} }-v\end{bmatrix}\tag{11}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="相机模型" scheme="https://lukeyalvin.top/tags/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="VO" scheme="https://lukeyalvin.top/tags/VO/"/>
    
  </entry>
  
  <entry>
    <title>状态估计模型与贝叶斯滤波</title>
    <link href="https://lukeyalvin.top/posts/b04da399.html"/>
    <id>https://lukeyalvin.top/posts/b04da399.html</id>
    <published>2022-05-04T11:29:54.032Z</published>
    <updated>2022-05-08T13:27:20.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><strong>滤波器的本质：</strong>结合预测和观测，得到“最精确”的后验值。这个精确值是相对的，因为实际中，预测和观测均是从传感器而来的，因此滤波器的作用就是结合各个传感器得到一个最好的融合结果。这就是一个数据融合的过程，关于数据融合的介绍可以参考：<a href="https://lukeyalvin.top/posts/8369.html#%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88">数据融合</a></p><p><img src="/images/滤波器基本原理/image-20220504151009319.png" alt="image-20220504151009319" style="zoom:50%;" /></p><p>1) 实际中预测往往从IMU、编码器等传感器递推而来；<br>2) 观测往往从GPS、雷达、相机等传感器而来；<br>3) 后验为融合后的结果，即定位模块的输出。</p><h1 id="状态估计模型"><a href="#状态估计模型" class="headerlink" title="状态估计模型"></a>状态估计模型</h1><p>实际状态估计任务中，待估计的后验概率密度可以表示为：</p><script type="math/tex; mode=display">p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})\tag{1}</script><p>其中：$\tilde{x}_0$表示的是状态初始值；$v_{1:k}$表示从第1时刻到第$k$时刻的输入；$y_{0:k}$表示从第0时刻到第$k$时刻的观测。</p><p>因此，滤波问题可以直观表示为，根据所有历史数据（输入、观测、初始状态），得出的最终的融合结果。历史数据之间的关系，可以用下面的图模型表示，</p><p><img src="/images/滤波器基本原理/image-20220504205031587.png" alt="image-20220504205031587" style="zoom: 33%;" /></p><p>图模型中体现了<strong>马尔可夫性</strong>，即当前状态只跟前一时刻状态相关，和其他历史时刻状态无关。数学表达该性质，</p><script type="math/tex; mode=display">\left\{\begin{aligned}运动方程：x_k&=f(x_{k-1},v_k,w_k)\\观测方程：y_k&=g(x_k,n_k)\end{aligned}\right.\tag{2}</script><h1 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h1><p>根据贝叶斯公式，$k$时刻后验概率密度可以表示为</p><script type="math/tex; mode=display">\begin{align*}p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})&=\frac{p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}{p(y_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}\\&=\eta p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\end{align*}\tag{3}</script><p>根据观测方程，$y_k$只与$x_k$相关，因此上式可以简写为：</p><script type="math/tex; mode=display">p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})=\eta p(y_k|x_k)p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\tag{4}</script><p>应用系统的马尔可夫性进一步化简公式，</p><script type="math/tex; mode=display">\begin{align*}&p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\\&=\int p(x_k,x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\&=\int p(x_k|x_{k-1}，\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\&=\int p(x_k|x_{k-1},v_{k})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\end{align*}\tag{3}</script><p>经过以上化简，最终后验概率可以写为</p><p><img src="/images/滤波器基本原理/image-20220504211503741.png" alt="image-20220504211503741" style="zoom: 50%;" /></p><p>根据以上结果，可以画出贝叶斯滤波的信息流图如下</p><p><img src="/images/滤波器基本原理/image-20220504210156815.png" alt="image-20220504210156815"></p><p>贝叶斯滤波分为很多种实现形式：</p><p><img src="/images/滤波器基本原理/image-20220504211643228.png" alt="image-20220504211643228" style="zoom: 50%;" /></p><p>实际中，粒子滤波（PF）多用于(早期的)2D激光SLAM方案中。在高斯假设前提下，用贝叶斯滤波的原始形式比较复杂，可以利用高斯的特征得到简化形式，即广义高斯滤波，后面KF、EKF、IEKF、UKF的推导均采用这种形式，只有PF例外，因为它是针对非高斯的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="滤波器" scheme="https://lukeyalvin.top/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    
    <category term="概率基础" scheme="https://lukeyalvin.top/tags/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    
    <category term="贝叶斯滤波" scheme="https://lukeyalvin.top/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>点云地图的建立、畸变补偿和定位</title>
    <link href="https://lukeyalvin.top/posts/f737dac5.html"/>
    <id>https://lukeyalvin.top/posts/f737dac5.html</id>
    <published>2022-05-03T10:44:59.183Z</published>
    <updated>2022-05-04T01:30:50.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>点云地图的建立</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="建图流程"><a href="#建图流程" class="headerlink" title="建图流程"></a>建图流程</h1><p>建图流程设计的核心原则是准确、高效地把<strong>里程计相对位姿</strong>、<strong>回环相对位姿</strong>、<strong>惯导先验位姿</strong>进行融合。</p><p><img src="/images/点云地图的建立/image-20220503190523343.png" alt="image-20220503190523343" style="zoom: 33%;" /></p><ul><li>轨迹对齐</li></ul><p>里程计的初始位姿是从激光雷达收到第一帧点云开始的，它的初始位姿就是单位阵，平移和旋转均为0；而对于惯导而言，它的旋转是以东北天坐标系为准的，因此它的初始位姿并不一定为0；因此里程计第一帧之间的位姿和惯导第一帧的位姿出现了相对旋转，这会导致里程计和先验之间出现很大的误差，所以我们求第一帧时里程计和惯导位姿之间的相对变换即可，这样就可以把里程计的轨迹拉到与惯导轨迹（一般和小车行进方向一致）一致的方向。这个过程就是<strong>轨迹对齐</strong>。</p><ul><li>回环检测</li></ul><p>这里涉及一个简单的回环检测的策略，比如如下的回环，我们检测回环不可能每一帧都进行检测，而是在一定的范围内，并且两帧之间的时间差必须大于一定的阈值，另外当某一帧被检测为闭环了，那么它相邻的一些帧则不做重复的检测，把相邻帧做“吸收化”之后，在后续段进行闭环检测。</p><p><img src="/images/点云地图的建立/image-20220503191428273.png" alt="image-20220503191428273" style="zoom: 50%;" /></p><ul><li>优化周期</li></ul><p>固定优化周期，可以在一定周期内进行优化，可以在误差累积相对较小的情况下进行优化，因为累积误差小，优化时间短，这样前端里程计构建过程中可以同步实现后端的优化，可以提高效率。</p><h1 id="畸变补偿"><a href="#畸变补偿" class="headerlink" title="畸变补偿"></a>畸变补偿</h1><ul><li><strong>产生原因：</strong></li></ul><p>由于一帧点云中的激光点是不同时刻采集的，激光点的坐标原点是采集时刻的雷达位姿，雷达在不同时刻的位姿有变化的时候，各个激光点原点不一致，拼接成一帧时，点云的形状便和实际物体形状不一致。</p><p><img src="/images/点云地图的建立/image-20220503193403250.png" alt="image-20220503193403250" style="zoom:50%;" /></p><p><img src="/images/loam论文深度解析/image-20220411193701848.png" alt="image-20220411193701848" style="zoom:33%;" /></p><ul><li><strong>补偿方法：</strong></li></ul><p>对于每一个激光点坐标做补偿，补偿量为激光点云与原点（即当时激光雷达坐标）相对于该帧起始时刻的变换。</p><h2 id="计算相对坐标"><a href="#计算相对坐标" class="headerlink" title="计算相对坐标"></a>计算相对坐标</h2><p>在匀速模型假设前提下，坐标 = 运动×时间。</p><p>假设第一帧点云的起始位姿为：</p><script type="math/tex; mode=display">T_0=\begin{bmatrix}R_0&t_0\\0&1\end{bmatrix}\tag{1}</script><p>第$i$个激光点采集时，雷达的位姿为：</p><script type="math/tex; mode=display">T_i=\begin{bmatrix}R_i&t_i\\0&1\end{bmatrix}\tag{2}</script><p>第$i$个激光点的坐标为：</p><script type="math/tex; mode=display">P_i=[p_{ix} \ p_{iy} \ p_{iz}]^T\tag{3}</script><p>则第$i$个激光点补偿畸变后的坐标应该为：</p><script type="math/tex; mode=display">\overline{P}_i=T_0^{-1}T_iP_i\tag{4}</script><p>上式可以理解为，只需要计算$0$到$i$时刻，激光雷达的相对旋转和相对平移变换即可。</p><p>实际上，雷达点云是局部坐标系下的表示，当以0时刻雷达的位姿为基准坐标系的时候，此时$T_0$为单位阵，$T_i$即为$0$到$i$时刻的相对旋转和平移。</p><p>此时有：</p><script type="math/tex; mode=display">\begin{align*}R_i&=\omega\nabla t\\t_i&=V\nabla t\end{align*}\tag{5}</script><p>即，只需要知道$0$到$i$时刻的平均角速度和平均速度即可。</p><p><strong>那么时间差如何进行求取呢？</strong></p><p>由于是顺序扫描，我们可以通过$\arctan\frac{y}{x}$来计算出该激光点相对于第一个激光点旋转过的角度$\beta$，已知雷达内部旋转$360°$用了$100ms$，那么旋转$\beta$角度所用的时间就可以计算出来了。</p><p>但是由于$\arctan\frac{y}{x}\in[-90°,90°]$的范围。而雷达的周期是$360°$，因此计算出来的$\arctan\frac{y}{x}$还需要进行角度补偿。</p><p>下面摘自：<a href="https://zhuanlan.zhihu.com/p/109379384">从零开始做自动驾驶定位(八): 点云畸变补偿</a></p><h2 id="点云数据排列方式"><a href="#点云数据排列方式" class="headerlink" title="点云数据排列方式"></a>点云数据排列方式</h2><p>做激光定位的多数都看过loam的程序，会发现在计算激光点采集时刻这一步上我们和它是有区别的，这就是这个点云排列方式导致的。</p><p>从激光雷达原理上讲，每次采集一列，边扫描边采集，所以数据应该是一列一列地存储，这样保证第一个点一定是最早时刻被采集的，最后一个点是最晚时刻被采集的，这样做有一个好处，那就是可以计算雷达真正扫描了多少度，因为它就是第一个点和最后一个点的角度差。</p><p>而在这个bag文件里，是按行存储的，也就是先索引第一根线上的点，再第二根，依次类推，直到最后一根，这样的缺点是，我们无法通过这个来计算雷达实际扫描角度了，因为第一个点不一定是时间最早的点，如果第一根线前半部分被遮挡，那么你就会得到错误的计算角度，所以这时候，像我们这样直接强制把扫描角度设置成360度是更稳妥的，缺点就是它不够精确。</p><p>这个问题的原因应该是数据的二次加工导致的，kitti先把数据存成bin文件，kitti2bag再转成bag文件，改变了原来的排列方式。一般雷达驱动中输出的数据都是按列排列的。</p><p>所以如果各位以后使用的数据是列排列的，那么时间计算上可以使用loam里的方法，会更准确。</p><h1 id="定位流程"><a href="#定位流程" class="headerlink" title="定位流程"></a>定位流程</h1><p>在地图匹配的过程中，鲁棒性和运行速度特别重要，因此实际中，基于NDT的匹配使用更为广泛。由于NDT匹配需要较准确的初始位姿，因此在定位之前需要初始化环节，给出载体的初始位姿。<br>按照难度由低到高，常见的初始化需求有这样几种：</p><p>1）已知位姿的初始化<br>2）位置已知而姿态未知的初始化<br>3）位置和姿态均未知的初始化</p><p><img src="/images/点云地图的建立/image-20220504092212456.png" alt="image-20220504092212456" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;点云地图的建立&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="建图" scheme="https://lukeyalvin.top/tags/%E5%BB%BA%E5%9B%BE/"/>
    
    <category term="畸变补偿" scheme="https://lukeyalvin.top/tags/%E7%95%B8%E5%8F%98%E8%A1%A5%E5%81%BF/"/>
    
  </entry>
  
  <entry>
    <title>后端位姿图优化</title>
    <link href="https://lukeyalvin.top/posts/aed03174.html"/>
    <id>https://lukeyalvin.top/posts/aed03174.html</id>
    <published>2022-05-02T13:26:34.855Z</published>
    <updated>2022-05-03T10:35:42.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="后端优化的基本原理"><a href="#后端优化的基本原理" class="headerlink" title="后端优化的基本原理"></a>后端优化的基本原理</h1><ul><li><strong>后端优化的目的：</strong></li></ul><p>利用回环检测结果和惯导先验位姿修正里程计误差，而回环在此提供的是两帧之间的相对位姿。</p><ul><li><strong>后端优化的方法：</strong></li></ul><p>假设马尔可夫性，简单的一阶马氏性认为，$k $时刻状态只与$ k − 1 $时刻状态有关，而与再之前的无关。如果做出这样的假设，我们就会得到以扩展卡尔曼滤波（EKF）为代表的滤波器方法。在滤波方法中，我们会从某时刻的状态估计，推导到下一个时刻。</p><p>另外一种方法是依然考虑 $k$ 时刻状态与之前所有状态的关系，此时将得到非线性优化为主体的优化框架。在视觉SLAM中非线性优化如BA与图优化、位姿图优化等。</p><ul><li><strong>总结而言，后端优化的观测主要从这三个方面：</strong></li></ul><p>①连续两帧之间的相对位姿观测（里程计）</p><p>②闭环匹配得到的相对位姿观测（闭环检测）</p><p>③组合导航提供的先验位姿估计（IMU）</p><p>①②的观测构成了<strong>基于回环的位姿修正</strong>，①③的观测构成了<strong>基于先验观测的位姿修正，</strong>当然三者也可以结合使用。三者的关系是，②③在①的基础上对位姿进行修正，这里对里程计的平滑性有一定的要求。</p><h1 id="基于回环的位姿修正"><a href="#基于回环的位姿修正" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h1><h2 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h2><p><img src="/images/后端位姿图优化/fc51f93b-322d-475b-bfa5-cae57a6750f9.jpeg" alt="回环检测是什么"></p><p>首先我们需要了解什么是回环检测，如是上图所示，对于里程计而言，它用来估计帧与帧之间的位姿估计，而这个位姿估计会因为噪声而产生漂移，（即使每一帧之间我们都进行了BA优化，但微小的漂移仍是无法避免的），由于里程计帧之间的位姿估计有很多，因此积少成多，漂移最终累积特别大，就会导致机器人在达到初始位置是，观测显示已经回到初始位置，而位姿估计却显示与初始位置相差一段距离，如上图所示。</p><p>我们通过构建位姿估计的位置和初始位置的残差项，对整个回环进行优化和修正，进而得到如下的地图。（理论而言，没有漂移的情况下，位姿估计的位置和初始位置是重合的。）</p><p><img src="/images/后端位姿图优化/32fa19ca-c057-4ccb-8075-802d0a456991.jpeg" alt="什么是回环检测"></p><p>因此，回环检测的目的就是消除累积误差。</p><h2 id="位姿图优化"><a href="#位姿图优化" class="headerlink" title="位姿图优化"></a>位姿图优化</h2><p>与之前的BA优化不同，比如我们之前学习的重投影模型，它考虑的是相邻帧之间的位姿估计，需要优化每个相机的位姿和特征点的位置，即使我们使用关键帧，对于大场景而言，特征点的观测是非常巨大的，这种计算量也是巨大的。</p><p>而位姿图优化，构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。</p><p><img src="/images/后端位姿图优化/image-20220503095925699.png" alt="image-20220503095925699" style="zoom:50%;" /></p><h2 id="基于回环的位姿修正-1"><a href="#基于回环的位姿修正-1" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h2><h3 id="构建残差"><a href="#构建残差" class="headerlink" title="构建残差"></a>构建残差</h3><p>在上文，我们找到如何构建残差项，下一步就是对残差项进行修正，那么我们就需要求得残差项对相应状态量的雅可比矩阵，从而才能知道从哪个方向修正状态量能够达到优化的目的。</p><p>位姿图优化关心的是两帧之间的观测，这两帧并不一定是相邻的两帧，比如回环检测中的两帧。设第$i$和第$j$帧之间的观测，在李群SE3上可以表示为：</p><script type="math/tex; mode=display">\Delta T_{ij}=T_i^{-1}T_j.\tag{1}</script><p>很容易理解，如果说第$i$和第$j$帧构成回环，那么$T_i^{-1}T_j=I$，也就不存在误差。</p><p>也可以用李代数表示：</p><script type="math/tex; mode=display">\Delta \xi_{ij}=\xi^{-1}_i◦\xi_j=\ln(T_i^{-1}T_j)^{\lor}.\tag{2}</script><p>构建残差：</p><script type="math/tex; mode=display">\begin{align*}e_{ij}&=\ln(\Delta T_{ij}^{-1}T_i^{-1}T_j)^{\lor}\\&=\ln(\exp((-\xi_{ij})^{\land})\exp((-\xi_i)^{\land})\exp(\xi^{\land}_j))^{\lor}\end{align*}.\tag{3}</script><p>位姿图优化的思想是通过调整状态量（即位姿），使残差项的值最小化，这就是需要用残差项求雅可比矩阵，才能使用梯度下降方法进行迭代优化。</p><h3 id="求雅可比矩阵"><a href="#求雅可比矩阵" class="headerlink" title="求雅可比矩阵"></a>求雅可比矩阵</h3><p>我们对位姿$T_i$和$T_j$分别左乘一个扰动$\Delta T=\exp(\delta\xi^{\land})$</p><script type="math/tex; mode=display">\begin{align*}\hat{e}_{ij}&=\ln \left(T_{ij}^{-1}T_i^{-1}\exp((-\delta\xi_i)^{\land})\exp(\delta\xi_j^{\land})T_j\right)^{\lor}\\&=\ln \left( T_{ij}^{-1}T_i^{-1}T_j\exp\left(  (-Ad(T_j^{-1})\delta\xi_i)^{\land}  \right)\exp\left(    (Ad(T_j^{-1})\delta\xi_j)^{\land} \right)\right)^{\lor}\\&\approx\ln \left( \exp(e_{ij})\exp\left((-Ad(T_j^{-1})\delta\xi_i)^{\land}+(Ad(T_j^{-1})\delta\xi_j)^{\land}\right)\right)^{\lor}\\&\approx e_{ij}-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\delta\xi_i+\mathcal{J}_r^{-1}Ad(T_j^{-1})\delta\xi_j\end{align*}\tag{4}</script><hr><p>这里推导过程的第一步到第二步利用了李群的伴随性质：</p><ul><li><strong>SO(3)上的伴随性质</strong></li></ul><script type="math/tex; mode=display">R\exp(p^{\land})R^T=\exp((Rp)^{\land})\\</script><ul><li><strong>SE(3)上的伴随性质</strong></li></ul><script type="math/tex; mode=display">T\exp(\xi^{\land})T^{-1}=\exp((Ad(T)\xi)^{\land})\\</script><p>其中伴随矩阵的定义如下：</p><script type="math/tex; mode=display">Ad(T)=\begin{bmatrix}R&t^{\land}R\\ 0&R\end{bmatrix}</script><p>第二步第三步使用的是BCH公式：</p><ul><li><strong>SO(3)上的BCH公式</strong></li></ul><script type="math/tex; mode=display">\ln(\exp(\phi_1^{\land})\exp(\phi_2^{\land}))\approx\left\{\begin{aligned}J_l(\phi_2)^{-1}\phi_1+\phi_2\ ,\ 当\phi_1为小量 \\J_r(\phi_1)^{-1}\phi_2+\phi_1\ ,\ 当\phi_2为小量\end{aligned}\right.</script><p>其中左乘雅可比为：</p><script type="math/tex; mode=display">J_l=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})aa^T+\frac{1-\cos\theta}{\theta}a^{\land}</script><p>所以：</p><script type="math/tex; mode=display">J_l^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})aa^T-\frac{\theta}{2}a^{\land}</script><p>右乘雅可比仅需要在左乘雅可比的基础上对自变量取负号，即：</p><script type="math/tex; mode=display">J_r(\phi)=J_l(-\phi)</script><ul><li><strong>SE(3)上的BCH公式</strong></li></ul><script type="math/tex; mode=display">\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\left\{\begin{aligned}J_l(\xi_2)^{-1}\xi_1+\xi_2\ ,\ 当\xi_1为小量 \\J_r(\xi_1)^{-1}\xi_2+\xi_1\ ,\ 当\xi_2为小量\end{aligned}\right.</script><p>其中右乘雅可比为：</p><script type="math/tex; mode=display">\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi^{\land}&\rho^{\land}\\0&\phi^{\land}\end{bmatrix}</script><p>一般情况下，若$\xi$非常小，该雅克比矩阵可以直接使用单位阵，此时：</p><script type="math/tex; mode=display">\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\ln(\exp(\xi_1^{\land}+\xi_2^{\land}))^{\lor}</script><p>这里第二步到第三步的推导用的就是这个式子。</p><hr><p>所以，残差关于$T_i$的雅可比为：</p><script type="math/tex; mode=display">A_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_i}=-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{5}</script><p>残差关于$T_j$的雅可比为：</p><script type="math/tex; mode=display">B_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_j}=\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{6}</script><p>其中：</p><script type="math/tex; mode=display">\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi_e^{\land}&\rho_e^{\land}\\0&\phi_e^{\land}\end{bmatrix}\tag{7}</script><p>为了找到梯度方向，需要对残差进行一阶泰勒展开：</p><script type="math/tex; mode=display">\begin{align*}&e_{ij}(x_i+\Delta x_i,x_j+\Delta x_j)\\=&e_{ij}(x+\Delta x)\\\approx&e_{ij}+J_{ij}\Delta x\end{align*}\tag{8}</script><p>其中$J_{ij}$即为前面推导的残差关于位姿的雅可比组成的矩阵：</p><script type="math/tex; mode=display">J_{ij}=(0···0\ A_{ij}\ 0···0 \ B_{ij} \ 0···0)</script><p>至此，我们就把非线性优化变成了一个线性化问题。</p><h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><p>位姿图优化就是把所有的观测和状态放在一起优化，在实际使用中，各个残差会被分配一个权重，也就是信息矩阵，它相当于对残差进行加权，考虑信息矩阵后，总的残差可以表示为:</p><script type="math/tex; mode=display">F(x)=\sum_{i,j\in \mathcal{C} }F_{ij}=\sum_{i,j\in \mathcal{C}} e_{ij}^T\Omega_{ij}e_{ij}\tag{9}</script><blockquote><p>权重矩阵又称为信息矩阵，它是协方差矩阵的逆，即为：$\Omega_{ij}=\Sigma_{ij}^{-1}$，因为每个残差都看作高斯分布，而每个高斯分布都可以归一化为标准的高斯分布$N(0,1)$，这种归一化操作是减去均值求平方然后除以方差。残差预期均值为0，所以不用减只需要除以方差，扩展到多维的话就变成了信息矩阵加权形式。</p></blockquote><p>所以此时的优化问题就是：</p><script type="math/tex; mode=display">x^*=\arg\underset{x}{\min}\ F(x)\tag{10}</script><p>对于每一个残差块，都有：</p><script type="math/tex; mode=display">\begin{align*}&F_{ij}(x+\Delta x)\\&=e_{ij}(x+\Delta x)^T\Omega_{ij}e_{ij}(x+\Delta x)\\&\approx e_{ij}^T\Omega_{ij}e_{ij}+2e_{ij}^T\Omega_{ij}J_{ij}\Delta x+\Delta x^TJ_{ij}^T\Omega_{ij}J_{ij}\Delta x\\&=c_{ij}+2b^T_{ij}\Delta x+\Delta x^TH_{ij}\Delta x\end{align*}\tag{11}</script><p>其中：</p><script type="math/tex; mode=display">c_{ij}=e_{ij}^T\Omega_{ij}e_{ij}</script><script type="math/tex; mode=display">H^T_{ij}=J_{ij}^T\Omega_{ij}J_{ij}=\begin{bmatrix}··· & ··· & ··· & ··· \\··· &A^T_{ij}\Omega_{ij}A_{ij}&···&A^T_{ij}\Omega_{ij}B_{ij}\\··· & ··· & ··· & ··· \\··· &B^T_{ij}\Omega_{ij}A_{ij}&···&B^T_{ij}\Omega_{ij}B_{ij}\\··· & ··· & ··· & ··· \\\end{bmatrix}</script><script type="math/tex; mode=display">b_{ij}=e_{ij}^T\Omega_{ij}J_{ij}=\begin{bmatrix} ···\\A^T_{ij}\Omega_{ij}e_{ij}\\···\\B^T_{ij}\Omega_{ij}e_{ij}\\···\end{bmatrix}</script><p>所以，要使得误差最小，只需要使得：</p><script type="math/tex; mode=display">H\Delta x = -b\tag{11}</script><p>根据修正量，修正$x$的值，即完成依次迭代：</p><script type="math/tex; mode=display">x^*=x+\Delta x\tag{12}</script><p>多次迭代，直至残差满足收敛条件时，则终止循环，完成优化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="后端优化" scheme="https://lukeyalvin.top/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    <category term="位姿图优化" scheme="https://lukeyalvin.top/tags/%E4%BD%8D%E5%A7%BF%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ScanContext解析与实践</title>
    <link href="https://lukeyalvin.top/posts/3df51dc4.html"/>
    <id>https://lukeyalvin.top/posts/3df51dc4.html</id>
    <published>2022-04-30T02:00:58.104Z</published>
    <updated>2022-05-02T11:19:41.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p><strong>Scan Context</strong> 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在<strong>IROS</strong>(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/images/ScanContext解析与实践/1-16512834289741.gif" alt="1"></p><p>对于SLAM来说，回环检测是重要的一步，我们知道，当机器人做一个回环时，可能会出现已经达到达起始点，但是由于漂移，位姿估计值却显示当前位置和初始位置还有相差一段距离，这时候，我们就依赖回环检测，把当前位置拉回初始位置，这样就消除了漂移，这个过程就是回环检测的目的。</p><p>所以回环检测的关键是，对于某一帧点云来说，它经过一个历史状态之后，我们如何去索引当前帧是否在历史帧中出现过，即检测有没有发生回环。当然，最容易想到的也是最朴素的做法就是，将这一帧的3D点云与历史所有帧做匹配，找到最接近的那一个。但是对于3D点云来这么做计算量无疑是巨大的，而且三维匹配还存在一个初值的问题。</p><p>因此，作者提出了ScanContext，上面的动画可以看出ScanContext的工作过程就是把3D点云通过俯视图的方式转换为2D，然后用过2D匹配找到回环，达到回环检测的目的，这样将三维降为两维进行匹配大大减小了计算量，并且它对初值相对不敏感。</p><p>ScanContext的主要流程如下：</p><p><img src="/images/ScanContext解析与实践/image-20220430131549451.png" alt="image-20220430131549451" style="zoom: 50%;" /></p><h1 id="点云切割"><a href="#点云切割" class="headerlink" title="点云切割"></a>点云切割</h1><p>首先是进行点云分割，如下图所示:</p><p>首先使用来自 3D 扫描的点云的俯视图，以扫描的中心充当全局关键点。对点云的俯视图进行圆环分割和扇区分割，可以看出以扫描中心为关键点，向外扩散形成$N_r$个同心圆，我们称之为$N_r$个环。然后以中心为关键点对圆环的$[0,2\pi]$进行均匀分割，得到$N_s$ 个扇区。论文中取 $N_s= 60$ 和 $N_r = 20$。</p><p><img src="/images/ScanContext解析与实践/image-20220430133756320.png" alt="image-20220430133756320" style="zoom: 33%;" /></p><p><img src="/images/ScanContext解析与实践/image-20220430132509355.png" alt="image-20220430132509355"></p><p>可以发现，沿着半径增大的方向（绿色箭头的方向），把点云分割成了$N_r$个圆环，每个圆环的宽度为：</p><script type="math/tex; mode=display">d_r=\frac{L_{max} }{N_r}\tag{1}</script><p>其中$L_{max}$表示激光雷达测得点云的最远距离。</p><p>通过图不难发现，我们一共得到$N_r$个环和$N_s$ 个扇区，每个环都与扇区有重叠区域，这个重叠区域称之为bin，而且远离传感器的 bin 的物理面积比近的 bin 更宽。设$\mathcal{P}_{ij}$是属于第$ i $个环和第 $j$ 个扇区重叠的 bin 的点集。设激光点经过分割后的集合为$\mathcal{P}$，则：</p><script type="math/tex; mode=display">\mathcal{P}=\underset{i\in[N_r],j\in[N_s]}{\cup}\mathcal{P}_{ij}\tag{2}</script><p>其中，符号 $[N_s] =\{1, 2, …, N_{s-1}, N_s\},[N_r] =\{1, 2, …, N_{r-1}, N_r\}$。</p><h1 id="生成ScanContext"><a href="#生成ScanContext" class="headerlink" title="生成ScanContext"></a>生成ScanContext</h1><p>经过分割后，我们发现分割后的点云的集合就是bin的集合，而bin是$N_r$个环和$N_s$ 个扇区的重叠区域，每个bin区域可能会有点云也可能没有点云（图（b）中的蓝色像素），而我们将bin的集合表示为矩阵形式，就可以得到一个$N_r\times N_s$的矩阵，其中矩阵的每一行代表一个圆环，则一共有$N_r$行，所以下图纵坐标范围为$[0,L_{max}]$；矩阵的每一列代表一个扇区，则一共有$N_s$列，所以下图横坐标范围为$[0,2\pi]$。</p><p><img src="/images/ScanContext解析与实践/image-20220430135402491.png" alt="image-20220430135402491" style="zoom: 67%;" /></p><p>那么bin的值如何确定呢？我们知道，没有点云的bin，我们对其赋值为0，图中用蓝色像素表示；那么有点云的bin如何表示呢？作者在这里使用的是<strong>最大高度</strong>。</p><p>设某个点云为$p$， $z(\cdot ) $是返回点 $p$ 的$ z $坐标值的函数，则任一个点云集合bin的值为：</p><script type="math/tex; mode=display">\phi(\mathcal{P}_{ij})=\underset{p\in\mathcal{P}_{ij}}{\max}z(p)\tag{3}</script><p>这么做有什么好处？我们知道，在开始我们把三维点云降为二维，损失了高度信息，而这里对高度信息相当于一次补偿作用，保留了信息的完整性。</p><h1 id="基于ScanContext的匹配"><a href="#基于ScanContext的匹配" class="headerlink" title="基于ScanContext的匹配"></a>基于ScanContext的匹配</h1><p>在得到ScanContext数据之后，我们如何利用ScanContext进行匹配，进而完成回环检测，这是ScanContext最终的目的。</p><p>设</p><ul><li><p>$I^q$为当前帧的ScanContext， $c^q_j $为$I^q$中的第$j$列；</p></li><li><p>$ I^c $为历史帧的ScanContext，$c^c_j $为$I^c$中的第$j$列；</p></li></ul><p>两帧之间的距离函数定义为：</p><script type="math/tex; mode=display">d(I^q,I^c)=\frac{1}{N_s}\sum^{N_s}_{j=1}(1-\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}).\tag{4}</script><p>通过这个距离函数可以发现，它反应了两帧之间的差异性，对于相似的两帧，它们的相同列向量的内积的模应该为1，即$\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}=1$，则距离接近为0，当然这仅仅是理想情况下，实际上，我们通过设置阈值的方式，当距离函数小于某一个阈值时，认为该历史帧为回环检测的回环帧。</p><p><strong>但是这里存在一个问题，就是历史帧有旋转的时候：</strong></p><p>这里我们定义的是当前帧与历史帧的相同列进行比较，这个条件是十分强的，假设激光雷达在经过一个地方的时候方向与之前的方向恰恰相反，或者该地方为一个十字路口，激光雷达从不同的方向经过一个地方，则雷达相对于全局坐标的坐标会发生变化，导致得到的ScanContext中的列向量顺序可能发生变化，进而使得两帧的距离函数比较大，导致经过相同地方的两帧点云的距离函数非常大，最终回环检测匹配失败。</p><p>如下图所示，这是经过相同地方的两帧点云，它们由于激光雷达的朝向发生了改变，导致两者的ScanContext中的列向量顺序发生变化，距离函数值随之变得非常大。</p><p><img src="/images/ScanContext解析与实践/image-20220430143355265.png" alt="image-20220430143355265" style="zoom:50%;" /></p><p>不难发现，将图(b)后半部分切割放到前面，如下图所示，就可以得到与(a)十分相似的ScanContext.</p><p><img src="/images/ScanContext解析与实践/image-20220430143946603.png" alt="image-20220430143946603" style="zoom:50%;" /></p><p>对于人而言，上述规律是非常容易发现的。但是实际程序中怎么切割，怎么移动才能达到上述效果？</p><p>最简单也是最朴素的做法就是，将历史帧$I^c$按列平移，得到$[N_s]$个ScanContext，依次与当前帧的ScanContext计算距离，选择距离最小的，即为闭环匹配的帧。</p><p>但是这种方法的计算量也是相对较大的，作者在代码中对此方法进行了优化，优化方法就是将当前帧与历史帧对应列分别求列和，然后根据列和我们找到可能的最佳切割点，但是由于我们降维之后会损失一部分信息，因此我们寻找的切割点并不是足够准确的，所以我们将在切割点附近对对应的二维$m$列依次进行切割平移，得到远远小于$n(n&lt;&lt;[N_s])$个的ScanContext，依次与当前帧的ScanContext计算距离，选择距离最小的，即为闭环匹配的帧。</p><p><img src="/images/ScanContext解析与实践/image-20220430153440012.png" alt="image-20220430153440012" style="zoom: 67%;" /></p><h1 id="计算相对位姿"><a href="#计算相对位姿" class="headerlink" title="计算相对位姿"></a>计算相对位姿</h1><p>设$I^c_n$ 是一个$\mathrm{Scan Context}$，它的第$n$列是从原始的$\mathrm{Scan Context}$偏移过来的。由于列向量代表的是分辨率为$\frac{2\pi}{N_s}$的扇区，所以每个列对应的角度为$\frac{2\pi}{N_s}$。整个过程，把历史帧切割，然后进行列平移之后，得到与当前帧的良好匹配， 良好的匹配意味着我们通过分割平移将历史帧对应的位姿旋转到当前帧对应位姿的朝向，那么，反过来，我们可以根据平移来求得旋转的角度。</p><p>假设距离最小时，对应的列的平移量为：</p><script type="math/tex; mode=display">n^*=\underset{n\in[N_s]}{\arg\min} \ d(I^q,I^c_n)\tag{5}</script><p>因此，历史帧与当前帧之间的旋转的角度为：</p><script type="math/tex; mode=display">\phi=\frac{2\pi}{N_s}\times n^*\tag{6}</script><p>这个旋转分辨率在作者代码中为$\frac{2\pi}{N_s}=\frac{2\pi}{60}=6°$，所以匹配的精确度小于$6°$，这并不是一个精确的值，需要进一步精确的话则需要使用ICP或者NDT匹配。因此可以作为ICP或者NDT匹配的初始位姿，用于<strong>精确匹配</strong>得到闭环约束相对位姿。</p><h1 id="解决时间复杂度问题"><a href="#解决时间复杂度问题" class="headerlink" title="解决时间复杂度问题"></a>解决时间复杂度问题</h1><p><strong>目的：</strong>ScanContext可以使用矩阵对应列的相似度来计算两帧的相似性，但是遍历所有历史帧的相似度计算量比较高，需要做一个快速初步筛选。</p><p><strong>思路：</strong>相似帧之间，落在同等半径的圆环中的点的数量应该相似，可以用来快速查找。</p><p>比如，某一帧中，在圆环$r_i,i\in[N_r]$中，被$[N_s]$个扇区分割为$[N_s]$个bin，对于相似的两帧，对应圆环中，含有点云的bin占有率应该相同，如公式$(8)$。通过这种方法可以进行<strong>第一阶段的粗略匹配</strong>。</p><p><strong>方法：</strong></p><p><img src="/images/ScanContext解析与实践/image-20220430164906076.png" alt="image-20220430164906076" style="zoom:50%;" /></p><p>这里作者引入了一个$ring\ key$的概念。</p><p><strong>（1）每一帧生成一个向量$k$</strong></p><p>$ring\ key$实质上就是$\mathrm{Scan Context}$的每一行$r$经过编码函数$\psi$编码成一个实数值后，$N_r$个圆环组成了一个$N_r$维向量的$ring\ key$，即为</p><script type="math/tex; mode=display">k=(\psi(r_1),...,\psi(r_{N_r})),\mathrm{where}\ \psi:r_i\rightarrow\mathbb{R}\tag{7}</script><p>其中，我们使用的环编码函数$\psi$是使用 $L_0$范数的环的占用率：</p><script type="math/tex; mode=display">\psi(r_i)=\frac{\parallel r_i \parallel_0}{N_s}\tag{8}</script><p>$\parallel r_i \parallel_0$表示半径$r_i$对应的圆环中非空分割单元的个数。</p><p><strong>（2）根据（1）中计算的向量，所有历史帧共同构建KDtree;</strong></p><p><strong>（3）使用当前帧对应的向量，在KDtree中查找，找到$n$个可能的相似帧，作为候选索引$\mathcal{C}$ 。</strong></p><p><strong>（4）使用$\mathrm{Scan Context}$进行第二阶段的精确匹配</strong></p><p>虽然不如$\mathrm{Scan Context}$信息丰富，但$ring\ key$支持快速搜索，以找到$n$个可能的候选闭环。使用距离公式将这些恒定数量的候选$\mathrm{Scan Context}$与要查询的$\mathrm{Scan Context}$进行比较。最接近的满足给定阈值$\tau$ 的候选项被选为重新访问的位置：</p><script type="math/tex; mode=display">c^*=\underset{c_k\in\mathcal{C} }{\arg\min}\ D(I^q,I^c),s.t. \ D<\tau\tag{9}</script><p>其中 $\mathcal{C}$ 是从 KD 树中提取的一组候选索引，$\tau$ 是给定的接受阈值。 $c^∗ $是确定为闭环的位置的索引。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;&lt;strong&gt;Scan Context&lt;/strong&gt; 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在&lt;strong&gt;IROS&lt;/strong&gt;(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="ScanContext" scheme="https://lukeyalvin.top/tags/ScanContext/"/>
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
  </entry>
  
  <entry>
    <title>ScanContext论文翻译</title>
    <link href="https://lukeyalvin.top/posts/79ac789e.html"/>
    <id>https://lukeyalvin.top/posts/79ac789e.html</id>
    <published>2022-04-29T08:07:21.546Z</published>
    <updated>2022-05-02T01:35:44.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p><strong>Scan Context</strong> 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在<strong>IROS</strong>(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="mathrm-Scan-Context-用于-3D-点云地图中地点识别的以自我为中心的空间描述子"><a href="#mathrm-Scan-Context-用于-3D-点云地图中地点识别的以自我为中心的空间描述子" class="headerlink" title="$\mathrm{Scan Context}$:用于 3D 点云地图中地点识别的以自我为中心的空间描述子"></a>$\mathrm{Scan Context}$:用于 3D 点云地图中地点识别的以自我为中心的空间描述子</h1><p><img src="/images/Scan-Context论文阅读/1-16512834289741.gif" alt="1"></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>与用于视觉场景的各种特征检测器和描述子相比，使用结构信息描述地点的研究相对较少。同时定位和建图 (SLAM) 的最新进展提供了环境的密集 3D 地图，并且定位是由不同的传感器提出的。针对基于结构信息的全局定位，我们提出了 $\mathrm{Scan Context}$，这是一种来自 3D 光检测和测距（激光雷达） (Light Detection and Ranging ，LiDAR) 扫描的基于非直方图的全局描述子。与先前研究的方法不同，所提出的方法直接从传感器记录可见空间的 3D 结构，而不依赖于直方图或先前的训练。此外，该方法提出了使用相似度分数来计算两个$\mathrm{Scan Context}$之间的距离，以及一种两阶段搜索算法来有效地检测回环。$\mathrm{Scan Context}$及其搜索算法使回环检测不受激光雷达视点变化的影响，从而可以在重新访问同一个地点和拐角等地方检测到闭环。$\mathrm{Scan Context}$性能已经通过 3D激光雷达扫描的各种基准数据集进行了评估，并且所提出的方法显示出充分改进的性能。</p><h1 id="Ⅰ-引言"><a href="#Ⅰ-引言" class="headerlink" title="Ⅰ.引言"></a>Ⅰ.引言</h1><p>在许多机器人应用中，位置识别是重要的问题。特别是对于 SLAM，这种识别为闭环提供了候选项，这对于纠正漂移误差和构建全局一致的地图至关重要 [1]。虽然闭环对机器人导航至关重要，但错误的匹配可能是灾难性的，需要仔细匹配。视觉识别随着相机传感器的广泛使用而流行，然而，由于光照变化和短期（例如，移动的物体）或长期（例如，季节）的变化，它本质上是困难的。因此，最近的文献集中在通过检查表示 [2] 和弹性后端 [3] 的鲁棒位置识别。</p><p>与这些视觉传感器不同，激光雷达最近因其对感知方差的强不变性而受到关注。早期，传统的局部关键点描述子 [4, 5, 6, 7] 最初是为计算机视觉中的 3D 模型设计的，尽管它们容易受到噪声的影响，但已被用于位置识别。基于激光雷达的位置识别方法已在机器人文献中广泛提出 [8, 9, 10]。这些工作侧重于从结构信息（例如点云）中以局部 [8] 和全局方式 [10] 开发描述子。</p><p>现有的基于 LiDAR 的位置识别方法一直试图克服两个问题。首先，无论视点变化如何，都需要描述子来实现旋转不变性。其次，噪声处理是这些空间描述子的另一个主题，因为点云的分辨率随距离而变化，并且法线是有噪声的。现有方法主要使用直方图[9,11,12]来解决上述两个问题。然而，由于直方图方法只提供场景的随机索引，描述场景的详细结构并不简单。这种限制使得描述子对于地点识别问题的可识别性降低，从而导致潜在的误匹配。</p><p><img src="/images/Scan-Context论文阅读/image-20220429164041335-16512834289762.png" alt="image-20220429164041335" style="zoom:50%;" /></p><p><img src="/images/Scan-Context论文阅读/image-20220429164059389-16512834289774.png" alt="image-20220429164059389" style="zoom:50%;" /></p><blockquote><p>图 1. 两步$\mathrm{Scan Context}$创建。使用来自 3D 扫描的点云的俯视图 (a)，我们将地面区域划分为 bin，根据方位角（在 LiDAR 框架内从 0 到 2π）和径向（从中心到最大感应范围）进行划分方向。我们将黄色区域称为一个环，将青色区域称为一个扇区，将黑色填充区域称为一个 bin。$\mathrm{Scan Context}$是（b）中的矩阵，它明确地保留了点云的绝对几何结构。 (a) 中描述的环和扇区在 (b) 中分别由相同颜色的列和行表示。从位于每个 bin 中的点中提取的代表值用作 (b) 的对应像素值。在本文中，我们使用 bin 中点的最大高度。</p></blockquote><p>在本文中，我们提出了 $\mathrm{Scan Context}$，这是一种具有匹配算法的新型空间描述子，专门针对使用单个 3D 扫描的户外地点识别。我们的表示将 3D 扫描中的整个点云编码为矩阵（图 1）。所提出的表示描述了以自我为中心的 2.5D 信息。该方法的贡献点是：</p><ul><li><strong>高效的 bin 编码功能。</strong>与现有的点云描述子 [7, 10] 不同，所提出的方法不需要计算 bin 中的点数，而是提出了一种更有效的用于位置识别的 bin 编码函数。这种编码对点云的密度和法线具有不变性。</li><li><strong>保留点云的内部结构。</strong>如图 1 所示，矩阵的每个元素值仅由属于 bin 的点云确定。因此，与将点的相对几何描述为直方图并丢失点的绝对位置信息的[9]不同，我们的方法通过有意避免使用直方图来保留点云的绝对内部结构。这提高了判别能力，还可以在计算距离时将查询扫描与候选扫描（在我们的实验中，6°方位角分辨率）进行视点对齐。因此，也可以通过使用$\mathrm{Scan Context}$来检测反向闭环。</li><li><strong>有效的两相匹配算法。</strong>为了实现可行的搜索时间，我们为第一个最近邻搜索提供了一个旋转不变的子描述子，并将其与成对相似度评分分层结合，从而避免搜索所有数据库进行闭环检测。</li><li><strong>针对其他最先进的空间描述子进行彻底验证。</strong>与其他现有的全局点云描述子相比，例如 M2DP [8]、形状函数集合 (ESF) [11] 和 Z 投影 [12]，所提出的方法具有实质性的改进。</li></ul><h1 id="Ⅱ-相关工作"><a href="#Ⅱ-相关工作" class="headerlink" title="Ⅱ.相关工作"></a>Ⅱ.相关工作</h1><p>移动机器人的位置识别方法可以分为基于视觉和基于激光雷达的方法。视觉方法已普遍用于 SLAM 文献中的地点识别 [13, 14, 15]。 FAB-MAP [13] 通过学习视觉词袋的生成模型，使用概率方法提高了鲁棒性。然而，视觉表示具有局限性，例如易受光照条件变化的影响[16]。已经提出了几种方法来克服这些问题。 SeqSLAM [17] 提出了基于道路的方法，并显示出比 FAB-MAP 大大提高的性能。 SRAL [2] 融合了几种不同的表示，例如颜色、GIST [18] 和 HOG [19]，用于长期视觉位置识别。</p><p>LiDAR 对上述这些感知变化具有很强的鲁棒性。基于 LiDAR 的方法被进一步分类为局部和全局描述子。局部描述子，例如 PFH [4]、SHOT [5]、shape context[7]或 spin image [6]，首先找到一个关键点，将附近的点分成 bin，并将周围 bin 的模式编码为直方图。Steder 等人提出了以词袋的方式利用点特征和完形描述子（gestalt descriptor） [20] 的位置识别方法[8]。</p><p>然而，这些关键点描述子显示出局限性，因为它们最初是为 3D 模型部分匹配而不是为位置识别而设计的。例如，与 3D 模型不同，3D 扫描（例如，来自 VLP-16）中的点云密度会随着与传感器的距离而变化。此外，由于现实世界中的非结构化对象（例如树），点的法线比模型噪声更大。因此，局部方法通常需要关键点的法线，因此不太适合户外的地点识别。</p><p>全局描述子不包括关键点检测阶段。 GLARE [9] 及其变体 [21, 22] 将点之间的几何关系编码为直方图，以代替搜索关键点和提取描述子。 ESF [11] 使用了由形状函数制成的直方图的串联。 Muhammad 和 Lacroix 提出了 Z 投影 [12]，它是法向量的直方图，以及具有两个距离函数的双阈值方案。Heet 等人提出了 M2DP [10]，它将扫描的整个 3D 点云投影到多个 2D 平面并提取 192 维紧凑的全局表示。M2DP 表现出比现有点云描述子更高的性能以及对噪声和分辨率变化的鲁棒性。如本段所述，全局描述子通常使用直方图。最近，SegMatch [23] 引入了一种基于分段的匹配算法。这是一种高级感知，但需要一个训练步骤，并且需要在全局参考框架中表示点。</p><p>在本文中，我们提出了一种新的位置描述子，称为$\mathrm{Scan Context}$，它将 3D 扫描的点云编码为矩阵。$\mathrm{Scan Context}$可以被认为是Shape Context [7] 的扩展，用于定位 3D LiDAR 扫描数据的位置识别。具体来说，$\mathrm{Scan Context}$包含三个组成部分：在每个 bin 中保留点云的绝对位置信息的表示、高效的 bin 编码函数和两步搜索算法。</p><h1 id="Ⅲ-mathrm-Scan-Context-进行地点识别"><a href="#Ⅲ-mathrm-Scan-Context-进行地点识别" class="headerlink" title="Ⅲ.$\mathrm{Scan Context}$进行地点识别"></a>Ⅲ.$\mathrm{Scan Context}$进行地点识别</h1><p>在本节中，我们描述了给定来自 3D 扫描的点云的$\mathrm{Scan Context}$创建，并提出了一种计算两个$\mathrm{Scan Context}$之间距离的度量。接下来，介绍两步搜索过程。使用$\mathrm{Scan Context}$进行位置识别的整体流程如图 2 所示。$\mathrm{Scan Context}$的创建和验证也可以在 scancontext.mp4 中找到。</p><h2 id="A-mathrm-Scan-Context"><a href="#A-mathrm-Scan-Context" class="headerlink" title="A.$\mathrm{Scan Context}$"></a>A.$\mathrm{Scan Context}$</h2><p>我们为户外地点识别定义了一个名为 $\mathrm{Scan Context}$ 的地点描述子。</p><p><img src="/images/Scan-Context论文阅读/image-20220429192701251-16512834289773.png" alt="image-20220429192701251" style="zoom: 50%;" /></p><blockquote><p>图 2. 算法概述。首先，将单个 3D 扫描中的点云编码到$\mathrm{Scan Context}$中。然后，从$\mathrm{Scan Context}$中对 $N_t$（环数）维向量进行编码，并用于检索最近的候选项以及 KD 树的构造。最后，将检索到的候选与查询$\mathrm{Scan Context}$进行比较。满足接受阈值并最接近查询的候选被认为是闭环。</p></blockquote><p>$\mathrm{Scan Context}$的关键思想受到 Belongie 等人提出的 Shape Context [7] 的启发，它将局部关键点周围的点云的几何形状编码为图像。然而他们的方法只是简单地计算点的数量来总结点的分布，我们的方法与他们的不同之处在于我们使用每个 bin 中点云的高度。使用高度的原因是为了有效地总结周围结构的垂直形状，而不需要大量的计算来分析点云的特征。此外，最大高度表示从传感器可以看到周围结构的哪一部分。这种以自我为中心的可视化在城市设计文献中一直是一个众所周知的概念，用于分析一个地方的身份[24, 25]。</p><p>与Shape Context [7] 类似，我们首先将 3D 扫描划分为传感器坐标中的方位角和径向 bin，但采用等间距的方式，如图 1(a) 所示。扫描的中心充当全局关键点，因此我们将$\mathrm{Scan Context}$称为以自我为中心的位置描述子。$N_s$ 和 $N_r$ 分别是扇区和环的数量。也就是说，如果我们将 LiDAR 传感器的最大感应范围设置为 $L_{max}$，则环之间的径向间隙为 $\frac{L_{max} }{N_r}$，扇形的中心角等于$\frac{2\pi}{N_s}$。在本文中，我们使用 $N_s= 60$ 和 $N_r = 20$。</p><p>因此，制作$\mathrm{Scan Context}$的第一个过程是将 3D 扫描的整个点划分为相互排斥的点云，如图 1(a) 所示。$\mathcal{P}_{ij}$是属于第$ i $个环和第 $j$ 个扇区重叠的 bin 的点集。符号 $[N_s]$ 等于$ \{1, 2, …, N_{s-1}, N_s\}$。因此，分区在数学上是</p><script type="math/tex; mode=display">\mathcal{P}=\underset{i\in[N_r],j\in[N_s]}{\cup}\mathcal{P}_{ij}\tag{1}</script><p>因为点云是按固定间隔划分的，所以远离传感器的 bin 的物理面积比近的 bin 更宽。但是，两者都被同等地编码到$\mathrm{Scan Context}$的单个像素中。因此，$\mathrm{Scan Context}$补偿了由于远点稀疏导致的信息量不足，并将附近的动态对象视为稀疏噪声。</p><p>在点云分区之后，使用该 bin 中的点云为每个 bin 分配一个实数值：</p><script type="math/tex; mode=display">\phi:\mathcal{P}_{ij}\rightarrow\mathbb{R}\tag{2}</script><p>我们使用最大高度，其灵感来自城市能见度分析 [24, 25]。因此，bin 编码函数为:</p><script type="math/tex; mode=display">\phi(\mathcal{P}_{ij})=\underset{p\in\mathcal{P}_{ij}}{\max}z(p)\tag{3}</script><p>其中 $z(\cdot ) $是返回点 $p$ 的$ z $坐标值的函数。我们为空的bin分配零。例如，如图 1(b) 所示，$\mathrm{Scan Context}$中的蓝色像素意味着与其 bin 对应的空间是空闲的，或者由于遮挡而未观察到。</p><p>通过上述过程，最终将$\mathrm{Scan Context}$ $I$ 表示为$ N_r\times N_s$ 矩阵:</p><script type="math/tex; mode=display">I=(a_{ij})\in\mathbb{R}^{N_r\times N_s},a_{ij}=\phi(\mathcal{P}_{ij})\tag{4}</script><p>为了对变换进行鲁棒的识别，我们通过$\mathit{ root\ shifting}$ 来增强 $\mathrm{Scan Context}$。通过这样做，在轻微运动扰动下从原始扫描中获取各种$\mathrm{Scan Context}$变得可行。</p><p>在重新访问到过的地方时，单个$\mathrm{Scan Context}$可能对平移运动下的扫描中心位置敏感。例如，当重新访问不同通道中的相同位置时，可能不会保留$\mathrm{Scan Context}$的行顺序。为了克服这种情况，我们根据水平间隔将原始点云转换为 $N_{trans}$ 个邻居（本文中使用$N_{trans}=8$  ），并将从这些$\mathit{ root\ shifting}$ 点云获得的$\mathrm{Scan Context}$存储在一起。我们假设即使在实际移动的位置也能获得类似的点云，这是有效的，除了少数情况下，比如一个新空间突然出现的交叉点。</p><h2 id="B-mathrm-Scan-Context-之间的相似度得分"><a href="#B-mathrm-Scan-Context-之间的相似度得分" class="headerlink" title="B. $\mathrm{Scan Context}$之间的相似度得分"></a>B. $\mathrm{Scan Context}$之间的相似度得分</h2><p>给定一个$\mathrm{Scan Context}$对，我们需要一个距离度量来衡量两个地方的相似性。$I^q$ 和$ I^c $分别是从查询点云和候选点云获取的$\mathrm{Scan Context}$。它们以列方式进行比较。也就是说，距离是同一索引处的列之间的距离之和。余弦距离用于计算相同索引处的两个列向量 $c^q_j $和 $c^c_j $之间的距离。此外，我们将总和除以总列数$N_s$用于归一化。因此，距离函数为:</p><script type="math/tex; mode=display">d(I^q,I^c)=\frac{1}{N_s}\sum^{N_s}_{j=1}(1-\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}).\tag{5}</script><p>考虑到贯穿扇区的一致性，基于列的比较对动态物体特别有效。然而，候选$\mathrm{Scan Context}$的列甚至可以在相同的地方移动，因为激光雷达的视角对于不同的地方是不同的(例如，在相反的方向或角落重新访问一个地方)。图3说明了这种情况。由于$\mathrm{Scan Context}$是依赖于传感器位置的表示，因此行顺序始终是一致的。但是，如果 LiDAR 传感器相对于全局坐标的坐标发生变化，则列顺序可能会有所不同。</p><p><img src="/images/Scan-Context论文阅读/image-20220429201446582-16512834290096.png" alt="image-20220429201446582" style="zoom:50%;" /></p><blockquote><p>图 3. 具有时间间隔的同一地点的$\mathrm{Scan Context}$示例。重新访问时传感器视点的变化导致$\mathrm{Scan Context}$的列移位，如 (a) 所示。但是，这两个矩阵包含相似的形状并显示相同的行顺序。</p></blockquote><p>为了解决这个问题，我们使用所有可能的列移位后的$\mathrm{Scan Context}$来计算距离，并找到最小距离。$I^c_n$ 是一个$\mathrm{Scan Context}$，它的第$n$列是从原始的$\mathrm{Scan Context}$偏移过来的。这与以$\frac{2\pi}{N_s}$分辨率粗略对齐两个点云以获取旋转分量中的偏航角的任务相同。然后，我们确定最佳对齐的列移位数量$(7)$和对应的距离$(6)$:</p><script type="math/tex; mode=display">\begin{align*}D(I^q,I^c)&=\underset{n\in[N_s]}{\min}d(I^q,I^c_n),\tag{6}\\n^*&=\underset{n\in[N_s]}{\arg\min}\ d(I^q,I^c_n),\tag{7}\end{align*}</script><p>请注意，此附加移位信息可以作为进一步定位细化的良好初始值，例如迭代最近点 (ICP)，如第 IV-C 节所示。</p><h2 id="C-两阶段搜索算法"><a href="#C-两阶段搜索算法" class="headerlink" title="C. 两阶段搜索算法"></a>C. 两阶段搜索算法</h2><p>当在位置识别的ScanContext搜索时，有三个主要的典型工作流：成对相似性评分、最近邻搜索和稀疏优化[26]。我们的搜索算法将成对评分和最近邻搜索分层融合，以获得可接受的搜索时间。</p><p>由于我们在(6)中的距离计算比其他全局描述子如[12，10]更加耗时，我们通过引入ring key提供了一个两阶段分层搜索算法。Ring key是一个具有旋转不变性的描述子，它是从$\mathrm{Scan Context}$中提取的。$\mathrm{Scan Context}$的每一行，$r$，都通过环形编码函数$\psi$编码成一个实数值。矢量<strong>$k$</strong>的第一个元素来自距离传感器最近的环，随后的元素来自下一个环，如图4所示。因此，ring key成为一个 $N_r$ 维向量，如 (8)：</p><script type="math/tex; mode=display">k=(\psi(r_1),...,\psi(r_{N_r})),\mathrm{where}\ \psi:r_i\rightarrow\mathbb{R}\tag{8}</script><p>我们使用的环编码函数$\psi$是使用 $L_0$范数的环的占用率：</p><script type="math/tex; mode=display">\psi(r_i)=\frac{\parallel r_i \parallel_0}{N_s}\tag{9}</script><p>由于占用率与视点无关，因此ring key实现了旋转不变性。</p><p><img src="/images/Scan-Context论文阅读/image-20220429203142763-16512834290095.png" alt="image-20220429203142763" style="zoom:50%;" /></p><blockquote><p>图 4. 快速搜索的ring key生成。</p></blockquote><p>虽然不如$\mathrm{Scan Context}$信息丰富，但ring key支持快速搜索，以找到可能的候选闭环。向量$k$用作构建KD树的key。同时，要查询扫描的ring key用于查找相似的key及其对应的扫描索引。将被检索的相似key的数量由用户决定。使用距离(6)将这些恒定数量的候选$\mathrm{Scan Context}$与要查询的$\mathrm{Scan Context}$进行比较。最接近的满足给定阈值的候选项被选为重新访问的位置:</p><script type="math/tex; mode=display">c^*=\underset{c_k\in\mathcal{C} }{\arg\min}\ D(I^q,I^c),s.t. \ D<\tau\tag{10}</script><p>其中 $\mathcal{C}$ 是从 KD 树中提取的一组候选索引，$\tau$ 是给定的接受阈值。 $c^∗ $是确定为闭环的位置的索引。</p><h1 id="Ⅳ-实验评估"><a href="#Ⅳ-实验评估" class="headerlink" title="Ⅳ.实验评估"></a>Ⅳ.实验评估</h1><p>略…….</p><h1 id="Ⅴ-结论"><a href="#Ⅴ-结论" class="headerlink" title="Ⅴ.结论"></a>Ⅴ.结论</h1><p>在这篇文章中，我们提出了一个空间描述子——$\mathrm{Scan Context}$，将一个地方概括为一个矩阵，这个矩阵明确描述了以自我为中心的环境的2.5D结构信息。与使用点云的现有全局描述子相比，$\mathrm{Scan Context}$在各种数据集上显示出更高的闭环检测性能。</p><p>在未来的工作中，我们计划通过引入额外的层来扩展$\mathrm{Scan Context}$。也就是说，其他bin编码函数(例如，bin的语义信息)可被用于提高性能，即使对于具有高度重复结构的数据集，如复杂城市激光雷达数据集。</p><p>Lidar定位：Scan Context<a href="https://zhuanlan.zhihu.com/p/359523177">https://zhuanlan.zhihu.com/p/359523177</a></p><p>Scan Context 介绍及理解<a href="https://zhuanlan.zhihu.com/p/393353116">https://zhuanlan.zhihu.com/p/393353116</a></p><p>从零开始做自动驾驶定位(二): 数据集<a href="https://zhuanlan.zhihu.com/p/104875159">https://zhuanlan.zhihu.com/p/104875159</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;&lt;strong&gt;Scan Context&lt;/strong&gt; 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在&lt;strong&gt;IROS&lt;/strong&gt;(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="ScanContext" scheme="https://lukeyalvin.top/tags/ScanContext/"/>
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端里程计方案-基于直接匹配的ICP&amp;NDT</title>
    <link href="https://lukeyalvin.top/posts/eb43aafd.html"/>
    <id>https://lukeyalvin.top/posts/eb43aafd.html</id>
    <published>2022-04-28T07:05:08.168Z</published>
    <updated>2022-05-02T13:33:15.163Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要介绍两种基于直接匹配的前端里程计方案，ICP以及NDT，重点介绍公式推导以及代码实现。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a><a href="https://lukeyalvin.top/posts/12311.html">ICP</a></h1><p>ICP即迭代最近点$（Iterative\ Closest\  Point）$的实现以及公式推导在视觉SLAM中已经提及，并进行了相关的公式推导和代码实现，详细查看：<a href="https://lukeyalvin.top/posts/12311.html">求解ICP</a>，这里不做具体展示。</p><p><img src="/images/前端里程计方案-基于直接匹配/image-20220428161431509.png" alt="image-20220428161431509" style="zoom: 67%;" /></p><h1 id="经典NDT"><a href="#经典NDT" class="headerlink" title="经典NDT"></a>经典NDT</h1><p>由于ICP迭代法一般般需要提供一个较好的初值，也就是需要粗配准，最终可能导致迭代结果可能会陷入局部最优，导致配准失败，往往达不到我们想要的效果。目前，实际工程之中，大多数使用另一种比较好的配准算法，NDT配准。</p><p>所谓NDT就是正态分布变换，作用与ICP一样用来估计两个点云之间的刚体变换。NDT算法主要的思路就是<strong>将目标点云刻画成多个概率分布</strong>，然后通过位姿变换关系将待配准点云转换到目标点云坐标系下，计算转换后待配准点云的总概率，并将此概率的负值作为目标函数，通过高斯牛顿迭代法优化该目标函数以求获得负的最小概率值(即最大概率值)．</p><p>由于其在配准过程中<strong>不利用对应点的特征计算和匹配</strong>，所以时间比其他方法快。这个配准算法耗时稳定，跟初值相关不大，初值误差大时，也能很好的纠正过来。因此，NDT算法因其具有较强的鲁棒性而被广泛的应用。</p><p><img src="/images/前端里程计方案-基于直接匹配/image-20220428161900963.png" alt="image-20220428161900963" style="zoom: 50%;" /></p><center>NDT算法流程</center><p>对点云进行相应的预处理之后，我们将空间划分为栅格（2D图像中的正方形或3D中的立方体），并统计落在栅格中的点，如图所示</p><p><img src="/images/前端里程计方案-基于直接匹配/image-20220428170225779.png" alt="image-20220428170225779" style="zoom:50%;" /></p><p>同样的，我们设上一帧点集和当前点集分别为：</p><script type="math/tex; mode=display">X=\{x_1,x_2,...,x_{N_x}\} \\Y=\{y_1,y_2,...,y_{N_y}\}</script><p>求$X$的均值：</p><script type="math/tex; mode=display">\mu=\frac{1}{N_x}\sum^{N_x}_{i=1}x_i</script><p>求$X$的协方差：</p><script type="math/tex; mode=display">\Sigma=\frac{1}{N_x-1}\sum^{N_x}_{i=1}(x_i-\mu)(x_i-\mu)^T</script><p>根据预测的位姿$R,t$，对点进行旋转和平移，得到上一帧的点云投影到当前帧下的点云$y_i^{\prime}$：</p><script type="math/tex; mode=display">y_i^{\prime}=T(p,y_i)=Ry_i+t</script><blockquote><p> 其中对于2D模型的点：$p=[t_x\ t_y\ \phi_z]^T$，对于3D模型的点：$p=[t_x\ t_y\ t_z\ \phi_x\ \phi_y\ \phi_z]^T$</p></blockquote><p>将当前点集$X$的均值$\mu$和协方差$\sum$，与投影点集$y_i^\prime$的每一个点做联系，构建如下的概率分布：</p><script type="math/tex; mode=display">f(X,y_i^\prime)=\frac{1}{\sqrt{2\pi}\sqrt{|\Sigma|} }\exp(-\frac{(y_i^\prime-\mu)^T\Sigma^{-1}(y_i^\prime-\mu)}{2})\tag{1}</script><p>然后求所有点的<strong>联合概率分布：</strong></p><script type="math/tex; mode=display">\begin{align*}\Psi&=\prod_{i=1}^{N_y}f(X,y_i^\prime)\\&=\prod_{i=1}^{N_y}\frac{1}{\sqrt{2\pi}\sqrt{|\Sigma|} }\exp(-\frac{(y_i^\prime-\mu)^T\Sigma^{-1}(y_i^\prime-\mu)}{2})\end{align*}\tag{2}</script><p>取对数，简化问题：</p><script type="math/tex; mode=display">\ln\Psi=\sum^{N_y}_{i=1}(-\frac{(y_i^\prime-\mu)^T\Sigma^{-1}(y_i^\prime-\mu)}{2}+\ln(\frac{1}{\sqrt{2\pi}\sqrt{|\Sigma|} }))\tag{3}</script><p>去除常数项：</p><script type="math/tex; mode=display">\max\Psi=\max\ln\Psi=\min\Psi_1=\min\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)\tag{4}</script><p>所以我们的目标函数就变成了：$\min\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)$，而接下来的任务就是根据这个目标函数求得对应的参数$R,t$。</p><p>令：</p><script type="math/tex; mode=display">\begin{align*}e_i(p)&=y_i^\prime-\mu\\F_i(p)&=\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)\\&=e_i(p)^T\Sigma^{-1}e_i(p)\end{align*}\tag{5}</script><p>因此目标函数为：</p><script type="math/tex; mode=display">\begin{align*}&\min\sum^{N_y}_{i=1}(y_i^\prime-\mu)^T{\Sigma}^{-1}(y_i^\prime-\mu)\\&=\min\sum^{N_y}_{i=1}F_i(p)\end{align*}\tag{6}</script><p>迭代优化，即找到$\Delta p$使得下式中的值达到最小：</p><script type="math/tex; mode=display">\min\sum^{N_y}_{i=1}F_i(p+\Delta p)=\sum^{N_y}_{i=1}e_i(p+\Delta p)^T\Sigma^{-1}e_i(p+\Delta p)\tag{7}</script><p>其中对$e_i(p+\Delta p)$进行一阶泰勒展开：</p><script type="math/tex; mode=display">\begin{align*}e_i(p+\Delta p)&\approx e_i(p)+\frac{de_i}{dp}\Delta p\\&=e_i(p)+J_i\Delta p\end{align*}\tag{8}</script><p>故而：</p><script type="math/tex; mode=display">\begin{align*}F_i(p+\Delta p)&=e_i(p+\Delta p)^T\Sigma^{-1}e_i(p+\Delta p)\\&\approx (e_i(p)+J_i\Delta p)^T\Sigma^{-1}(e_i(p)+J_i\Delta p)\\&=e_i(p)^T\Sigma^{-1}e_i(p)+2e_i(p)^T\Sigma^{-1}J_i\Delta p+\Delta p^TJ_i^T\Sigma^{-1}J_i\Delta p\\&=F_i(p)+2b_i^T\Delta p+\Delta p^TH_i\Delta p\end{align*}\tag{9}</script><p>其中：</p><script type="math/tex; mode=display">b_i^T=e_i(p)^T\Sigma^{-1}J_i，\ H_i=J_i^T\Sigma^{-1}J_i\tag{10}</script><p>因此，目标函数随自变量的变化为：</p><script type="math/tex; mode=display">\begin{align*}\Delta F_i(p)&=F_i(p+\Delta p)-F_i(p)\\&=2b_i^T\Delta p+\Delta p^TH_i\Delta p\end{align*}\tag{11}</script><p>上述优化问题转换为：找到$\Delta p$使得$\Delta F_i(p)$取得极小值，令其导数为零：</p><script type="math/tex; mode=display">\begin{align*}\frac{d\Delta F_i(p)}{d\Delta p}&=2b_i+2H_i\Delta p=0\\即：H_i\Delta p&=-b_i\end{align*}\tag{12}</script><p>根据$(10)$中的定义，只需要求$J_i$，即可求得$\Delta p $</p><script type="math/tex; mode=display">J_i=\frac{de_i}{dp}</script><h2 id="2D场景"><a href="#2D场景" class="headerlink" title="2D场景"></a>2D场景</h2><p>已知对于2D场景$p=[t_x\ t_y\ \phi_z]^T$，</p><script type="math/tex; mode=display">\begin{align*}y_i^{\prime}&=T(p,y_i)\\&=Ry_i+t\\&=\begin{bmatrix}\cos\phi_z&-\sin\phi_z\\\sin\phi_z&\cos\phi_z\end{bmatrix}y_i+\begin{bmatrix}t_x\\t_y\end{bmatrix}\\e_i&=y_i^{\prime}-\mu\end{align*}</script><p>雅可比矩阵：</p><script type="math/tex; mode=display">J_i=\begin{bmatrix}1&0&-y_{i1}\sin\phi_z-y_{i2}\cos\phi_z\\0&1&y_{i1}\cos\phi_z-y_{i2}\sin\phi_z\end{bmatrix}</script><h2 id="3D场景"><a href="#3D场景" class="headerlink" title="3D场景"></a>3D场景</h2><p>已知对于3D场景$p=[t_x\ t_y\ t_z\ \phi_x\ \phi_y\ \phi_z]^T$，</p><script type="math/tex; mode=display">\begin{align*}y_i^{\prime}&=T(p,y_i)\\&=Ry_i+t\\&=R_xR_yR_zy_i+t\\&=\begin{bmatrix}c_yc_z&-c_ys_z&s_y\\c_xs_z+s_xs_yc_z&c_xc_z-s_xs_ys_z&-s_xc_y\\s_xs_z-c_xs_yc_z&c_xs_ys_z+s_xc_z&c_xc_y\end{bmatrix}y_i+\begin{bmatrix}t_x\\t_y\\t_z\end{bmatrix}\\e_i&=y_i^{\prime}-\mu\end{align*}</script><p>雅可比矩阵：</p><script type="math/tex; mode=display">J_i=\begin{bmatrix}1&0&0&0&c&f\\0&1&0&a&d&g\\0&0&1&b&e&h\end{bmatrix}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}a&=y_{i1}(-s_xs_z+c_xs_yc_z)+y_{i2}(-s_xc_z-c_xs_ys_z)+y_{i3}(-c_xc_y)\\b&=y_{i1}(c_xs_z+s_xs_yc_z)+y_{i2}(c_xc_z-s_xs_ys_z)+y_{i3}(-s_xc_y)\\c&=y_{i1}(-s_yc_z)+y_{i2}(s_ys_z)+y_{i3}(c_y)\\d&=y_{i1}(s_xc_yc_z)+y_{i2}(-s_xc_ys_z)+y_{i3}(s_xs_y)\\e&=y_{i1}(-c_xc_yc_z)+y_{i2}(c_xc_ys_z)+y_{i3}(-c_xs_y)\\f&=y_{i1}(-c_ys_z)+y_{i2}(-c_yc_z)\\g&=y_{i1}(c_xc_z-s_xs_ys_z)+y_{i2}(-c_xs_z-s_xs_yc_z)\\h&=y_{i1}(s_xc_z+c_xs_ys_z)+y_{i2}(c_xs_yc_z-s_xs_z)\end{align*}</script><h1 id="其他NDT"><a href="#其他NDT" class="headerlink" title="其他NDT"></a>其他NDT</h1><p><img src="/images/前端里程计方案-基于直接匹配/image-20220428210054855.png" alt="image-20220428210054855" style="zoom: 67%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要介绍两种基于直接匹配的前端里程计方案，ICP以及NDT，重点介绍公式推导以及代码实现。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="ICP" scheme="https://lukeyalvin.top/tags/ICP/"/>
    
    <category term="NDT" scheme="https://lukeyalvin.top/tags/NDT/"/>
    
  </entry>
  
  <entry>
    <title>LeGO-LOAM论文翻译</title>
    <link href="https://lukeyalvin.top/posts/3766cfd.html"/>
    <id>https://lukeyalvin.top/posts/3766cfd.html</id>
    <published>2022-04-27T08:16:25.410Z</published>
    <updated>2022-04-30T02:19:08.259Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LeGO-LOAM是Tixiao Shan 和 Brendan Englot于2018年提出的使用激光雷达完成定位与三维建图的算法，全称为：Lightweight and Groud-Optimized Lidar Odometry and Mapping on Variable Terrain，从标题可以看出 LeGO-LOAM 为应对<strong>可变地面</strong>进行了地面优化，同时保证了轻量级。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块"><a href="#LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块" class="headerlink" title="LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块"></a>LeGO-LOAM——在可变地形上的轻量级的地面点优化的雷达里程计和建图模块</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们提出了一种轻量级和基于地面优化的激光雷达里程计和建图方法 LeGO-LOAM，用于地面车辆的实时六自由度姿态估计。LeGO-LOAM 是轻量级的，因为它可以在低功耗嵌入式系统上实现实时姿态估计。LeGOLOAM 是基于地面优化的，因为它在其分割和优化步骤中利用了地平面的存在。我们首先应用点云分割来滤除噪声，并进行特征提取以获得独特的平面和边缘特征。然后，使用两步 Levenberg-Marquardt 优化方法，使用平面和边缘特征来解决连续扫描中六自由度变换的不同分量。我们使用地面车辆的可变地形环境中收集的数据集，将 LeGO-LOAM 的性能与最先进的方法 LOAM 进行比较，并表明 LeGO-LOAM 在降低计算成本的情况下实现了相似或更好的精度。我们还将 LeGO-LOAM 集成到 SLAM 框架中，以消除漂移引起的位姿估计误差，并使用 KITTI 数据集进行了测试。</p><h1 id="Ⅰ-介绍"><a href="#Ⅰ-介绍" class="headerlink" title="Ⅰ.介绍"></a>Ⅰ.介绍</h1><p>在智能机器人的能力中，地图构建和状态估计是最基本的先决条件。人们一直致力于通过基于视觉和基于激光雷达的方法实现实时 6 自由度同时定位和建图 (SLAM)。尽管基于视觉的方法在闭环检测方面具有优势，但由于它们对照明和视点变化的敏感性，如果用作唯一的导航传感器，可能会使这些能力不可靠。另一方面，基于激光雷达的方法即使在夜间也能发挥作用，而且许多 3D 激光雷达的高分辨率允许在大光圈下远距离捕捉环境的精细细节。因此，本文重点介绍使用 3D 激光雷达来支持实时状态估计和建图。</p><p>寻找两次激光雷达扫描之间转换的典型方法是迭代最近点 (ICP) [1]。通过逐点查找对应关系，ICP 迭代对齐两组点，直到满足停止条件为止。但是当扫描包括大量点时，ICP 可能会遭受过高的计算成本。已经提出了许多 ICP 变体来提高其效率和准确性 [2]。 [3] 引入了一种点到平面 ICP 变体，将点与局部平面补丁匹配。Generalized-ICP [4] 提出了一种匹配来自两次扫描的局部平面补丁的方法。此外，一些 ICP 变体利用并行计算来提高效率 [5]-[8]。</p><p>基于特征的匹配方法越来越受到关注，因为它们通过提取环境中的代表性特征来减少计算资源。这些特征应该适用于有效匹配和视角不变。这些特征应适用于有效匹配和视点不变性。社区已经提出了许多检测器，例如点特征直方图（PFH）[9] 和视点特征直方图（VFH）[10]，用于使用简单有效的技术从点云中提取此类特征。[11] 中介绍了一种使用 Kanade-Tomasi 角点检测器从点云中提取通用特征的方法。[12] 中讨论了从密集点云中提取线和平面特征的框架。</p><p>社区还提出了许多使用特征进行点云配准的算法。 [13] 和 [14] 提出了一种在局部集群中执行点曲率计算的关键点选择算法，然后使用选定的关键点进行匹配和位置识别。通过将点云投影到距离图像（a range image）上并分析深度值的二阶导数，[15] 从具有高曲率的点中选择特征进行匹配和位置识别。假设环境由平面组成，在[16]中提出了一种基于平面的配准算法。户外环境，例如森林，可能会限制这种方法的应用。 [17] 中介绍了一种专为Velodyne 激光雷达设计的项圈线段 (collar line segments, CLS) 方法。CLS 使用扫描的两个连续“环”中的点随机生成线。因此生成了两条线云并用于配准，然而，这种方法受到随机生成线条的挑战。 [18]中提出了一种基于分割的配准算法。SegMatch 首先将分割应用于点云，然后根据其特征值和形状直方图为每个段计算一个特征向量。随机森林用于匹配来自两次扫描的片段。虽然这种方法可以用于在线姿态估计，但它只能提供大约 1Hz 的定位更新。</p><p>在 [19] 和 [20] 中提出了一种低漂移和实时激光雷达里程计和建图(LOAM) 方法。 LOAM 执行点特征到边缘/平面扫描匹配以找到扫描之间的对应关系。通过计算其局部区域中点的曲率（roughness）值来提取特征。选择具有高曲率（roughness）值值的点作为边缘特征。类似地，具有低曲率（roughness）值的点被指定为平面特征。通过将估计问题新颖地划分为两个单独的算法来实现实时性能。一种算法以高频率运行并以低精度估计传感器速度，另一种算法运行频率较低，但可以以高精度获得运动估计。将这两个估计融合在一起以产生高频和高精度的单个运动估计。在 KITTI 里程计基准站点 [21] 上，通过仅使用激光雷达的估算方法，LOAM 的结果精度达到最佳[21]。</p><p>在这项工作中，我们为配备 3D 激光雷达的地面车辆寻求可靠、实时的六自由度姿态估计，其方式适合在小型嵌入式系统上有效实施。由于几个原因，这样的任务并不简单。由于尺寸有限，许多无人地面车辆 (UGV) 没有悬架或强大的计算单元。小型 UGV 在多变的地形上行驶时经常遇到非平稳运动，因此，获取的数据往往会带有运动畸变。由于在较大的运动下，只有有限的重叠区域，因此，在两次连续扫描之间也很难找到可靠的特征对应。此外，从 3D 激光雷达接收到的大量点对使用有限的车载计算资源进行实时处理提出了挑战。</p><p>当我们为此类任务实施 LOAM 时，当 UGV 以平滑运动具有稳定的特征运行并由足够的计算资源支持时，我们可以获得低漂移运动估计。但是，当资源有限时，LOAM 的性能会下降。由于需要计算密集 3D 点云中每个点的曲率（roughness）值，轻量级嵌入式系统上特征提取的更新频率无法始终跟上传感器更新频率。无人车在嘈杂环境中的运行也对 LOAM 提出了挑战。由于激光雷达的安装位置在小型 UGV 上通常靠近地面，因此来自地面的传感器噪声可能会持续存在。例如，从草地返回的范围可能会导致高曲率（roughness）值。因此，可能会从这些点中提取不可靠的边缘特征。类似地，边缘或平面特征也可以从树叶返回的点中提取。这些特征对于扫描匹配通常不可靠，因为在两次连续扫描中可能看不到相同的草叶或叶子。使用这些功能可能会导致不准确的配准和大的漂移。</p><p>因此，我们提出了一种轻量级和地面优化的 LOAM (LeGO-LOAM)，用于在具有可变地形的复杂环境中对 UGV 进行姿态估计。LeGO-LOAM 是轻量级的，因为可以在嵌入式系统上实现实时姿态估计和建图。执行点云分割以丢弃在地面分离后可能代表不可靠特征的点。LeGO-LOAM 也是地面优化的，因为我们为姿势估计引入了两步优化。在第一步中，从地面提取的平面特征用于获得 $[t_z, θ_{roll}, θ_{pitch}]$。在第二步中，通过匹配从分割点云中提取的边缘特征来获得其余的变换$[t_x, t_y, θ_{yaw}]$。我们还集成了执行闭环以纠正运动估计漂移的能力。本文的其余部分安排如下。第二节介绍了用于实验的硬件。第三节详细描述了所提出的方法。第四节介绍了一系列在各种户外环境中的实验。</p><h1 id="Ⅱ-系统硬件"><a href="#Ⅱ-系统硬件" class="headerlink" title="Ⅱ.系统硬件"></a>Ⅱ.系统硬件</h1><p>本文提出的框架使用从 Velodyne VLP-16 和 HDL-64E 3D 激光雷达收集的数据集进行了验证。VLP-16 的测量范围可达 $100m$，精度为$ ± 3cm$。它的垂直视野 (FOV) 为 $30°(±15°)$，水平视野 (FOV) 为$360°$。$16 $通道传感器提供 $2° $的垂直角分辨率。水平角分辨率根据旋转速率从 $0.1° $到$ 0.4°$ 变化。在整篇论文中，我们选择了 $10Hz $的扫描速率，它提供了$ 0.2° $的水平角分辨率。 HDL-64E（在这项工作中通过 KITTI 数据集进行了探索）也具有 $360° $的水平 FOV，但还有$ 48 $个通道。 HDL-64E 的垂直 FOV 为$ 26.9°$。</p><p>本文中使用的 UGV 是 Clearpath Jackal。它由$ 270 $瓦时锂电池供电，最大速度为$ 2.0m/s$，最大有效载荷为 $20kg$。 Jackal 还配备了低成本惯性测量单元 (IMU)，即 CH Robotics UM6 方向传感器。</p><p>提议的框架在两台计算机上得到验证：一台 Nvidia Jetson TX2 和一台配备 2.5GHz i74710MQ CPU 的笔记本电脑。Jetson TX2 是一款配备 ARM Cortex-A57 CPU 的嵌入式计算设备。选择笔记本电脑 CPU 以匹配 [19] 和 [20] 中使用的计算硬件。本文所示的实验仅使用这些系统的 CPU。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220426195127090.png" alt="image-20220426195127090" style="zoom: 50%;" /></p><blockquote><p>图 1：LeGO-LOAM 的硬件和系统概览</p></blockquote><h1 id="Ⅲ-轻型激光雷达测距和建图"><a href="#Ⅲ-轻型激光雷达测距和建图" class="headerlink" title="Ⅲ.轻型激光雷达测距和建图"></a>Ⅲ.轻型激光雷达测距和建图</h1><h2 id="A-系统概述"><a href="#A-系统概述" class="headerlink" title="A.系统概述"></a>A.系统概述</h2><p>所提出框架的概述如图 $1$ 所示。系统从 3D 激光雷达接收输入并输出 6 DOF 姿态估计。整个系统分为五个模块。第一个是分割，采用单次扫描的点云并将其投影到范围图像上进行分割。然后将分割后的点云发送到特征提取模块。然后，激光雷达里程计使用从前一个模块中提取的特征来找到与连续扫描相关的变换。这些特征在激光雷达建图中得到进一步处理，将它们注册到全局点云地图。最后，变换积分模块将激光雷达里程计和激光雷达建图的姿态估计结果进行融合，输出最终的姿态估计。相对于 [19] 和 [20] 的原始通用 LOAM 框架，所提出的系统旨在提高地面车辆的效率和准确性。下面介绍这些模块的详细信息。</p><h2 id="B-分割"><a href="#B-分割" class="headerlink" title="B. 分割"></a>B. 分割</h2><p>令$ P_t = \{p_1, p_2, …, p_n\} $为在时间 $t $获取的点云，其中$p_i$ 是 $P_t $中的一个点。$ P_t$ 首先投影到范围图像上。投影距离图像的分辨率为 $1800 \times 16$，因为 VLP-16 的水平和垂直角分辨率分别为 $0.2° $和$ 2°$。$ P_t$ 中的每个有效点 $p_i$现在由范围图像中的唯一像素表示。与 $p_i$关联的范围值$r_i$表示从对应点 $p_i$到传感器的欧氏距离。由于斜坡地形在许多环境中都很常见，因此我们不认为地面是平坦的。在分割之前，对距离图像进行列式评估（可视为地平面估计 [22]），以提取地面点。在此过程之后，可能代表地面的点被标记为地面点，不用于后续分割（分类）。</p><p>然后，将基于图像的分割方法[23]应用于范围图像，将点分组为许多簇。来自同一簇的点被分配了一个唯一的标签。请注意，地面点是一种特殊类型的集群。将分割应用于点云可以提高处理效率和特征提取精度。假设机器人在嘈杂的环境中运行，小物体（例如树叶）可能会形成微不足道且不可靠的特征，因为在两次连续扫描中不太可能看到相同的叶子。为了使用分段点云进行快速可靠的特征提取，我们省略了少于 30 个点的集群。分割前后点云的可视化如图 2 所示。原始点云包含许多点，这些点是从周围的植被中获得的，这些点可能会产生不可靠的特征。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220426194420416.png" alt="image-20220426194420416" style="zoom: 67%;" /></p><blockquote><p>图 2：噪声环境中扫描的特征提取过程。原始点云如$(a)$所示。在$(b)$中，红点被标记为地面点，其余的点是分割后剩下的点。在$(c)$中，蓝色和黄色点表示 $F_e$ 和 $F_p$ 中的边缘和平面特征。在 $(d)$中，绿色和粉色点分别代表 $\mathbb{F}_e$ 和 $\mathbb{F}_p$ 中的边缘和平面特征。</p></blockquote><p>在这个过程之后，只有可能代表大物体的点（图$2(b)$ ）被保留下来，例如树干和地面点，以供进一步处理。同时，只有这些点保存在距离图像中。我们还获得每个点的三个属性：$(1) $其作为地面点或分割点的标签，$(2) $其在范围图像中的列和行索引，以及 $(3)$ 其范围值。这些属性将在以下模块中使用。</p><h2 id="C-特征提取"><a href="#C-特征提取" class="headerlink" title="C.特征提取"></a>C.特征提取</h2><p>特征提取过程类似于[20]中使用的方法。然而，我们不是从原始点云中提取特征，而是从地面点和分割点中提取特征。令 $S$ 为范围图像同一行中 $p_i$ 的连续点的集合。 $S$ 中的一半点位于 $p_i$ 的两侧。在本文中，我们设置 $|S|$设置为 $10$。 使用分割期间计算的范围值，我们可以评估点 $p_i$在$S$中的曲率（roughness）值，</p><script type="math/tex; mode=display">c=\frac{1}{|S|\cdot\parallel r_i \parallel} \parallel \underset{j\in S,j\ne i}{\sum}(r_j-r_i) \parallel \tag{1}</script><p>为了从各个方向均匀地提取特征，我们将距离图像水平划分为几个相等的子图像。然后我们根据它们的曲率（roughness）值$ c $，对子图像的每一行中的点进行排序。与 LOAM 类似，我们使用阈值$ c_{th}$来区分不同类型的特征。我们称$c$大于$ c_{th}$为边缘特征的点，$c$小于$ c_{th}$为平面特征的点。</p><p>然后从子图像的每一行中选取<strong>不属于地面</strong>，且有最大<code>c</code>值的$n_{\mathbb{F}_e}$个特征边。以相同方式选择具有最小$c$值的$n_{\mathbb{F}_p}$平面特征点（可以标记为地面点或分段点）。设 $\mathbb{F}_e$ 和$\mathbb{F}_p$是所有子图像的所有边缘和平面特征的集合，这些特征如图 $2(d)$所示。然后，我们从子图像的每一行中提取<strong>不属于地面</strong>的具有最大$c$的$n_{F_e}$个边缘特征。类似地，我们从子图像的每一行中提取<strong>必须是地面点</strong>的具有最小$c$的 $n_{F_p} $个平面特征。设$ F_e$ 和 $F_p$ 分别是这个过程中所有边缘和平面特征的集合。在这里，我们有 $F_e\subset  \mathbb{F}_e$和 $F_p \subset \mathbb{F}_p$。$ F_e$ 和 $F_p$ 的特征如图$ 2(c)$ 所示。在本文中，我们将 $360° $范围图像划分为 $6 $个子图像。每个子图像的分辨率为 $300 \times 16$。$n_{F_e}、n_{F_p}、n_{\mathbb{F}_e} $和$n_{\mathbb{F}_p}$ 分别选择为 $2、4、40$ 和 $80$。</p><h2 id="D-激光雷达里程计"><a href="#D-激光雷达里程计" class="headerlink" title="D.激光雷达里程计"></a>D.激光雷达里程计</h2><p>激光雷达里程计模块估计两次连续扫描之间的传感器运动。通过执行点到边缘和点到平面的扫描匹配来找到两次扫描之间的变换。换句话说，我们需要从前一次扫描的特征集 $\mathbb{F}^{t-1}_e$ 和$\mathbb{F}^{t-1}_p$ 中找到 $F^t_e$和 $F^t_p$中点的对应特征。为了简洁起见，找到这些对应关系的详细过程可以在[20]中找到。</p><p>但是，我们注意到可以进行一些更改以提高特征匹配的准确性和效率：</p><p>$1) $标签匹配：由于$F^t_e$和 $F^t_p$中的每个特征在分割后都用其标签进行编码，我们只能从 $\mathbb{F}^{t-1}_e$ 和$\mathbb{F}^{t-1}_p$中找到具有相同标签的对应关系。对于 $F^t_p$ 中的平面特征，只有在$\mathbb{F}^{t-1}_p$中标记为地面点的点才会被用于寻找对应的平面贴片(patch)。对于$F^t_e$中的边缘特征，在分割簇的$\mathbb{F}^{t-1}_e$中寻找对应的边缘线。以这种方式找到对应关系有助于提高匹配精度。换句话说，同一对象的匹配对应关系更有可能在两次扫描之间找到。这一过程也缩小了潜在匹配对象的范围。</p><p>$2)$两步L-M优化：在[20]中，将当前扫描的边缘和平面特征点之间的距离及其与前一次扫描的对应关系的一系列非线性表达式编译为单个综合距离向量。应用 Levenberg-Marquardt (L-M) 方法来找到两个连续扫描之间的最小距离变换。</p><p>我们在这里介绍一种两步 L-M 优化方法。最佳变换 $T $分两步找到：</p><p>$(1)$ 通过匹配$F^t_p$中的平面特征及其在 $\mathbb{F}^{t-1}_p$ 中的对应关系来估计$ [t_z, θ_{roll}, θ_{pitch}]$</p><p>$(2) $然后使用 $F^t_e$中的边缘特征及其在 $\mathbb{F}^{t-1}_e$ 中的对应关系，并同时使用 $[t_z, θ_{roll}, θ_{pitch}]$ 作为约束一起来估计剩余的 $[t_x, t_y, θ_{yaw}]$。需要注意的是，虽然$[t_x, t_y, θ_{yaw}]$也可以从第一个优化步骤中获得，但它们的准确度较低，得到的结果也不能继续放在第二步中使用。最后，通过融合 $[t_z, θ_{roll}, θ_{pitch}]$ 和$[t_x, t_y, θ_{yaw}]$找到两个连续扫描之间的$ 6D$ 变换。通过使用所提出的两步优化方法，我们观察到在计算时间减少约 $35\% $的同时可以实现类似的精度（表 III）。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427165436363.png" alt="image-20220427165436363" style="zoom: 33%;" /></p><blockquote><p>图 3：激光雷达里程计模块的两步优化。首先通过匹配从地面点提取的平面特征来获得$[t_z, θ_{roll}, θ_{pitch}]$。 然后使用从分割点提取的边缘特征进行估计，同时应用$[t_z, θ_{roll}, θ_{pitch}]$作为约束，从而获得$[t_x, t_y, θ_{yaw}]$</p></blockquote><h2 id="E-激光雷达建图"><a href="#E-激光雷达建图" class="headerlink" title="E. 激光雷达建图"></a>E. 激光雷达建图</h2><p>激光雷达建图模块运行频率较低，它将$\{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$中的特征与周围的点云图 $\overline Q^{t-1}$匹配，以进一步细化位姿变换，然后这里再次使用 L-M 方法得到最终的变换。我们请读者参考 [20] 中的描述，了解详细的匹配和优化过程。 LeGO-LOAM 的主要区别在于最终点云图的存储方式。我们不是保存单个点云图，而是保存每个单独的特征集$ \{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$。令 $M^{t−1} = \{\{\mathbb{F}^{1}_e, \mathbb{F}^{1}_p\}, …, \{\mathbb{F}^{t-1}_e, \mathbb{F}^{t-1}_p\}\} $是保存所有先前特征集的集合。 $M^{t−1}$中的每个特征集也与扫描时传感器的位姿相关联。那么 $\overline Q^{t-1}$可以通过两种方式从$M^{t−1}$获得。</p><p>在第一种方法中，通过选择传感器视野中的特征集来获得 $\overline Q^{t-1}$。为简单起见，我们可以选择传感器位姿在传感器当前位置 $100m$ 以内的特征集。然后将所选特征集转换并融合到单个周围地图$\overline Q^{t-1}$中。这种地图选择技术类似于[20]中使用的方法。</p><p>我们还可以将位姿图 SLAM 集成到 LeGO-LOAM 中。每个特征集的传感器位姿可以建模为位姿图中的一个节点。特征集$ \{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$可以看作是该节点的传感器测量数据。由于激光雷达建图模块的位姿估计漂移非常低，我们可以假设在短时间内没有漂移。这样，$\overline Q^{t-1}$可以通过选择最近的一组特征集来形成，即 $\overline Q^{t-1}= \{\{\mathbb{F}^{t-k}_e, \mathbb{F}^{t-k}_p\}, …, \{\mathbb{F}^{t-1}_e, \mathbb{F}^{t-1}_p\}\} $ ，其中$ k $定义了$\overline Q^{t-1}$的大小。然后，可以使用 L-M 优化后获得的变换添加$\overline Q^{t-1}$​中新节点和所选节点之间的空间约束。我们可以通过执行闭环检测来进一步消除该模块的漂移，在这种情况下，如果使用 ICP 在当前特征集和先前特征集之间找到匹配项，则会添加新约束。然后通过将位姿图发送到优化系统（例如 [24]）来更新传感器的估计位姿。请注意，只有 Sec 中的实验。 IV(D) 使用这种技术来创建它的周围地图。注意，只有第四节（D）中的实验使用此技术来创建其周围的地图。</p><h1 id="Ⅳ-实验"><a href="#Ⅳ-实验" class="headerlink" title="Ⅳ.实验"></a>Ⅳ.实验</h1><p>我们现在描述一系列实验，以定性和定量分析两种比较方法，LOAM 和 LeGO-LOAM，在两种硬件安排上，一个 Jetson TX2 和一个 Cortex-A57，一个笔记本电脑和一个 i7-4710MQ。这两种算法都是用 C++ 实现的，并使用 Ubuntu Linux1 中的机器人操作系统 (ROS) [25] 执行$^1$。</p><blockquote><p>$^1$LeGO-LOAM 的代码可在 <a href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">https://github.com/RobustFieldAutonomyLab/LeGO-LOAM</a> 获得</p></blockquote><h2 id="A-小型-UGV-测试"><a href="#A-小型-UGV-测试" class="headerlink" title="A. 小型 UGV 测试"></a>A. 小型 UGV 测试</h2><p>我们在植被覆盖的室外环境中手动驱动机器人。我们首先展示了在这种环境下特征提取的定性比较。使用这两种方法从同一扫描中提取的边缘和平面特征如图 4 所示。这些特征对应于第 III 节中发送到激光雷达建图模块的$\{\mathbb{F}^{t}_e, \mathbb{F}^{t}_p\}$。如图$4(d)$ 所示，LeGO-LOAM 的特征数量在点云分割后大大减少。从树叶返回的大部分点被丢弃，因为它们在多次扫描中不是稳定的特征。另一方面，由于从草地返回的点也非常嘈杂，因此在评估后会得出较大的粗曲率值。因此，使用原始 的LOAM， 不可避免地会从这些点中提取边缘特征。如图$4(c)$ 所示，从地面提取的边缘特征通常不可靠。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427090416034.png" alt="image-20220427090416034" style="zoom: 80%;" /></p><blockquote><p>图 4：在植被覆盖的室外环境中，从两种不同的激光雷达里程计和制图框架获得的边缘和平面特征。边缘和平面特征分别为绿色和粉红色。从 LOAM 获得的特征显示在$ (b) $和$ (c) $中。从 LeGO-LOAM 获得的特征如 $(d) $和$ (e)$ 所示。标签 (i) 表示树，(ii) 表示石墙， (iii) 表示机器人。</p></blockquote><p>虽然我们可以更改 LOAM 中提取边缘和平面特征的曲率阈值 $c_{th}$ 以减少特征数量并从草和树叶中过滤掉不稳定的特征，但在应用这些更改后我们会遇到更糟糕的结果。例如，我们可以增加$c_{th}$以从环境中提取更稳定的边缘特征，但如果机器人进入相对干净的环境，这种变化可能会导致有用的边缘特征数量不足。同样，当机器人从清洁环境移动到嘈杂环境时，减小$c_{th}$也会导致缺乏有用的平面特征。在这里的所有实验中，我们对 LOAM 和 LeGO-LOAM 使用相同的$c_{th}$。</p><p>现在我们在测试环境中比较两种方法的建图结果。为了模拟具有挑战性的潜在 UGV 操作场景，我们执行了一系列激进的偏航操作。请注意，在本文的所有实验中，这两种方法都提供了相同的初始平移和旋转估计（guess），该估计（guess）是从 IMU 获得的。运行60秒后得到的点云图如图5所示。由于不稳定特征导致的错误特征关联，LOAM 的地图在操作过程中会发散两次。图 $5(a)$中用白色箭头突出显示的三棵树干代表现实中的同一棵树。两种里程计方法的完整映射过程的可视化可以在视频附件中找到$^2$。</p><blockquote><p>$^2$<a href="https://youtu.be/O3tz_ftHV48">https://youtu.be/O3tz_ftHV48</a></p></blockquote><p><img src="/images/LeGO-LOAM论文翻译/image-20220427090607185.png" alt="image-20220427090607185" style="zoom:80%;" /></p><blockquote><p>图 5：LOAM 和 LeGO-LOAM 在图 $4(a) $所示地形上的地图。 $(a) $中用白色箭头标记的树代表同一棵树。</p></blockquote><h2 id="B-大规模-UGV-测试"><a href="#B-大规模-UGV-测试" class="headerlink" title="B. 大规模 UGV 测试"></a>B. 大规模 UGV 测试</h2><p>接下来，我们在三个大规模数据集上对 LOAM 和 LeGO-LOAM 进行定量比较，这将被称为实验$ 1、2 $和$ 3$。前两个是在史蒂文斯理工学院校园收集的，那里有许多建筑物、树木、道路和人行道。这些实验及其环境如图 6(a) 所示。实验 3 跨越了一条森林覆盖的远足小径，其中有树木、柏油路和被草和土壤覆盖的小径。执行实验 3 的环境如图 8 所示。每个实验的详细信息列在表 I 中。为了进行公平比较，每个实验显示的所有性能和准确度结果均在每个数据集的 10 次实时回放试验中平均得出。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427102855741.png" alt="image-20220427102855741" style="zoom: 50%;" /></p><p>1)实验1：第一个实验旨在证明LOAM和LeGO-LOAM都可以在具有平滑运动的城市环境中实现低漂移姿态估计。我们避免了激进的偏航动作，并且我们避免驾驶机器人穿过只能获得一些稳定特征的稀疏区域。在整个数据记录过程中，机器人在平坦的道路上运行。机器人的初始位置，如图6(b)所示，位于斜坡上。机器人以平均 1.35m/s 的平均速度行驶 807 秒后返回同一位置。</p><p>为了评估这两种方法的姿态估计精度，我们比较了最终姿态和初始姿态之间的平移和旋转差异。这里，通过所有实验，初始位姿定义为$ [0, 0, 0, 0, 0, 0]$。如表 V 所示，LOAM 和 LeGO-LOAM 在两种不同的硬件安排上都实现了相似的低漂移姿态估计。当在 Jetson 上运行时，来自 LeGO-LOAM 的最终地图如图 6(b) 所示。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427101541012.png" alt="image-20220427101541012"></p><blockquote><p>图 6：实验$1$和$2$的 LeGO-LOAM 图。$(c)$中的颜色变化表示真实的高程变化。由于实验 $1$ 中机器人的初始位置在斜坡上，因此 $(b)$ 中的颜色变化并不代表真实的高程变化。</p></blockquote><p>2)实验2：虽然实验2是在与实验1相同的环境中进行的，但它的轨迹略有不同，行驶在如图7(a)所示的人行道上。这条人行道代表了 LOAM 可能经常失败的环境。人行道的一端有一堵墙和柱子——从这些结构中提取的边缘和平面特征是稳定的。人行道的另一端是一片开阔的区域，上面覆盖着嘈杂的物体，即草和树，这将导致特征提取不可靠。因此，LOAM 的姿态估计在驶过这条人行道后会发散（图 7(b)和(d)）。LeGO-LOAM 没有这样的问题：1）没有从被草覆盖的地面中提取边缘特征，2）在分割后过滤掉来自树叶的噪声传感器读数。两种方法的精度比较如表 V 所示。在本实验中，LeGO-LOAM 的精度比 LOAM 高一个数量级。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427101616762.png" alt="image-20220427101616762"></p><blockquote><p>图 $7$：实验$ 2 $中 LOAM 在穿过史蒂文斯校园的人行道上发生故障的场景（上图 $(a)$ 中最左侧的人行道）。人行道的一端由附近建筑物的特征支撑。人行道的另一端主要被嘈杂的物体包围，即草和树。如果没有点云分割，将从这些对象中提取不可靠的边缘和平面特征。图像 $(b)$ 和 $(d)$ 显示 LOAM 在经过人行道后失效。</p></blockquote><p>3)实验 3：实验 3 的数据集是从森林远足小径记录的，其中 UGV 以 1.3m/s 的平均速度行驶。机器人行驶 35 分钟后返回初始位置。这种环境下的海拔变化约为 19 米。UGV 在三个路面上行驶：泥土覆盖的小径、沥青和被草覆盖的地面。这些表面的代表性图像分别显示在图 8 的底部。树木或灌木丛始终存在于道路的至少一侧。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427101634370.png" alt="image-20220427101634370" style="zoom:67%;" /></p><blockquote><p>图 8：实验$3$ LeGO-LOAM 建图结果。</p></blockquote><p>我们首先在这种环境下测试 LOAM 的准确性。生成的地图在所使用的两台计算机上的不同位置存在分歧。相对于 UGV 初始位置的最终平移和旋转误差在 Jetson 上为 69.40m 和 27.38°，在笔记本电脑上为 62.11m 和 8.50°。图 9(a) 和 (b) 显示了对两种硬件安排进行 10 次试验的结果轨迹。</p><p>当 LeGO-LOAM 应用于该数据集时，Jetson 上的最终相对平移和旋转误差为 13.93m 和 7.73°，笔记本电脑上为 14.87m 和 7.96°。 Jetson 上 LeGO-LOAM 的最终点云图如图 8 所示，叠加在卫星图像上。在图 8 的中心放大的局部地图显示，来自 LeGO-LOAM 的点云图与开放中可见的三棵树匹配得很好。在两台计算机上从 LeGO-LOAM 获得的所有路径之间显示出高度一致性。图 9(c) 和 (d) 显示了在每台计算机上运行的十次试验。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427103924914.png" alt="image-20220427103924914" style="zoom:50%;" /></p><blockquote><p>图 9：LOAM 和 LeGO-LOAM 在 10 次试验和 2 台计算机上生成的路径，以及实验 3 数据集。</p></blockquote><h2 id="C-基准测试结果"><a href="#C-基准测试结果" class="headerlink" title="C. 基准测试结果"></a>C. 基准测试结果</h2><p><strong>1)特征数量比较</strong>：我们在表II中展示了两种方法的特征提取比较。每次扫描的特征内容平均超过每个数据集的 10 次试验。点云分割后，对于集合$ F_e、F_p、\mathbb{F}_e $和$\mathbb{F}_p$，需要 LeGO-LOAM 处理的特征数量分别减少了至少$ 29\%、40\%、68\%$ 和 $72\%$。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427105750858.png" alt="image-20220427105750858" style="zoom:50%;" /></p><p><strong>2)迭代次数比较：</strong>应用提出的两步L-M优化方法的结果如表III所示。我们首先使用 LeGO-LOAM 应用原始 L-M 优化，这意味着我们最小化从边缘和平面特征一起获得的距离函数。然后我们对 LeGO-LOAM 应用两步 L-M 优化：①$F_p$中的平面特征用于获得$[t_z, θ_{roll}, θ_{pitch}]$，②利用$F_e$中的边缘特征得到$[t_x, t_y, θ_{yaw}]$。记录 L-M 方法在处理一次扫描后终止时的平均迭代次数以进行比较。当使用两步优化时，第一步优化在实验 1 和 2 的两次迭代中完成。虽然第二步优化的迭代次数与原始L-M方法的数量相似，但处理的特征较少。因此，在使用两步 L-M 优化后，激光雷达里程计的运行时间减少了 $34\%$ 至 $48\%$。两步优化的运行时间如表 IV 所示。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427105906074.png" alt="image-20220427105906074" style="zoom:50%;" /></p><p><strong>3)运行时间比较：</strong>LOAM 和$\rm{LeGO-LOAM}$ 的每个模块在两台计算机上的运行时间如表 IV 所示。使用所提出的框架，<strong>特征提取</strong>和<strong>激光雷达里程计</strong>模块的运行时间在 LeGO-LOAM 中减少了一个数量级。请注意，在 Jetson 上,这两个模块在 LOAM 中的运行时间超过 100 毫秒。导致许多扫描被跳过，因为 LOAM 在嵌入式系统上无法实现实时性能。使用 LeGO-LOAM 时，激光雷达建图的运行时间也减少了至少 $60\%$。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427110536203.png" alt="image-20220427110536203" style="zoom:50%;" /></p><p><strong>4)位姿误差比较：</strong>通过在所有实验中将初始位姿设置为$[0, 0, 0, 0, 0, 0]$，我们通过将最终位姿与初始位姿进行比较来计算相对位姿估计误差。表 V 列出了两台计算机上两种方法的旋转误差（以度为单位）和平移误差（以米为单位）。通过使用所提出的框架，LeGO-LOAM 可以以更少的计算时间实现相当或更好的位置估计精度。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427111646072.png" alt="image-20220427111646072" style="zoom:50%;" /></p><h2 id="D-使用-KITTI-数据集的闭环测试"><a href="#D-使用-KITTI-数据集的闭环测试" class="headerlink" title="D. 使用 KITTI 数据集的闭环测试"></a>D. 使用 KITTI 数据集的闭环测试</h2><p>我们的最终实验将 LeGO-LOAM 应用于 KITTI 数据集 [21]。由于在 [20] 中对 KITTI 数据集的 LOAM 测试以 10% 的实时速度运行，我们只探索 LeGO-LOAM 及其在嵌入式系统实时应用中的潜力，其中行程长度足够大需要完整的 SLAM 解决方案。LeGO-LOAM 在 Jetson 上使用序列 00 的结果如图 10 所示。为了在 Jetson 上实现实时性能，我们将 HDL-64E 的扫描下采样到与第 III 节中使用的相同范围图像VLP-16。换言之，每次扫描的 75% 的点在处理前都被省略掉了。 ICP在这里用于在位姿图中的节点之间添加约束。然后使用 iSAM2 [24] 优化该图。最后，我们使用优化后的图来校正传感器位姿和地图。更多闭环测试可以在视频附件中找到。</p><p><img src="/images/LeGO-LOAM论文翻译/image-20220427111714790.png" alt="image-20220427111714790" style="zoom:50%;" /></p><blockquote><p>图 10：LeGO-LOAM，KITTI 数据集闭环测试，使用 Jetson。颜色变化表示海拔变化。</p></blockquote><h1 id="Ⅴ-结论与讨论"><a href="#Ⅴ-结论与讨论" class="headerlink" title="Ⅴ.结论与讨论"></a>Ⅴ.结论与讨论</h1><p>我们提出了 LeGO-LOAM，一种轻量级和地面优化的激光雷达里程计和建图方法，用于在复杂环境中执行 UGV 的实时姿态估计。 LeGO-LOAM 是轻量级的，因为它可以在嵌入式系统上使用并实现实时性能。LeGO-LOAM 也是地面优化的，利用地面分离、点云分割和改进的 L-M 优化。在此过程中过滤掉可能代表不可靠特征的无价值点。两步 L-M 优化分别计算姿势变换的不同分量。所提出的方法在室外环境中收集的一系列 UGV 数据集上进行了评估。结果表明，与最先进的算法 LOAM 相比，LeGO-LOAM 可以达到相似或更好的精度。LeGO-LOAM 的计算时间也大大减少。未来的工作包括探索其在其他类型车辆中的应用。尽管 LeGO-LOAM 特别针对地面车辆的姿态估计进行了优化，但它的应用可能会扩展到其他车辆，例如无人机 (unmanned aerial vehicles，UAVs)，只需稍作改动。将 LeGO-LOAM 应用于 UAV 时，我们不会假设地面存在于扫描中。扫描的点云将在没有地面提取的情况下被分割。对于$ F_e、\mathbb{F}_e$ 和 $\mathbb{F}_p $的选择，特征提取过程是相同的。不是从标记为地面点的点中提取 $F_p$ 的平面特征，而是从所有分割点中选择 $F_p$ 中的特征，然后将使用原始的 L-M 方法来获得两次扫描之间的转换，而不是使用两步优化方法。尽管在这些变化之后计算时间会增加，但 LeGO-LOAM 仍然是有效的，因为在分割后在嘈杂的室外环境中会省略大量的点。估计的特征对应的准确性可能会提高，因为它们受益于分割。此外，使用 LeGO-LOAM 在线执行循环闭合的能力使其成为长时间导航任务的有用工具。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LeGO-LOAM是Tixiao Shan 和 Brendan Englot于2018年提出的使用激光雷达完成定位与三维建图的算法，全称为：Lightweight and Groud-Optimized Lidar Odometry and Mapping on Variable Terrain，从标题可以看出 LeGO-LOAM 为应对&lt;strong&gt;可变地面&lt;/strong&gt;进行了地面优化，同时保证了轻量级。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    <category term="LeGO-LOAM" scheme="https://lukeyalvin.top/tags/LeGO-LOAM/"/>
    
  </entry>
  
  <entry>
    <title>二、IMU工作原理、误差及其标定</title>
    <link href="https://lukeyalvin.top/posts/19228.html"/>
    <id>https://lukeyalvin.top/posts/19228.html</id>
    <published>2022-04-25T09:20:38.421Z</published>
    <updated>2022-05-10T12:09:58.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要对IMU的工作原理做详细的介绍，分析IMU中的确定性误差以及随机误差，并给出误差标定的方法，如确定性误差使用六面法标定，随机误差使用艾伦方差标定等。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-旋转运动学"><a href="#Ⅰ-旋转运动学" class="headerlink" title="Ⅰ.旋转运动学"></a>Ⅰ.旋转运动学</h1><h2 id="A-线速度与角速度"><a href="#A-线速度与角速度" class="headerlink" title="A.线速度与角速度"></a>A.线速度与角速度</h2><p>如图所示，粒子在坐标系中的$z=h$的平面内做圆周运动，坐标为$r=(a\cos\theta,a\sin\theta,h)$，对坐标求导得：</p><script type="math/tex; mode=display">\begin{align*}\dot r&=(-a\dot\theta\sin\theta,a\dot\theta\cos\theta,0)^T\\&=\begin{bmatrix}0&-\dot\theta&0\\\dot\theta&0&0\\0&0&0\end{bmatrix}\begin{bmatrix}a\cos\theta\\a\sin\theta\\h\end{bmatrix}\\&=w^{\land} r\end{align*}\tag{1}</script><p>其中$w$是角速度，它是一个矢量，即$w=\begin{bmatrix}0\\0\\ \dot\theta\end{bmatrix}=\dot\theta z$,其中$|\dot\theta|$是角速度的大小。对公式$(1)$取模：</p><script type="math/tex; mode=display">|\dot r|=|w||r|sin\phi=a|\dot\theta|</script><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422093936869.png" alt="image-20220422093936869" style="zoom:50%;" /></p><h2 id="B-旋转坐标系下的运动学"><a href="#B-旋转坐标系下的运动学" class="headerlink" title="B.旋转坐标系下的运动学"></a>B.旋转坐标系下的运动学</h2><p>如图，考虑两个坐标系，一个是世界坐标系(惯性坐标系)$W$，它本身是静止不动的；一个是机器人本体坐标系$B$，它本身在做角速度为$w_B$的纯旋转，设质量块在坐标系$B$下做速度为$v_B$，加速度为$a_B$的匀加速直线运动，它在$B$坐标系下坐标为$r_B=(x_1,x_2,x_3)^T$，设从坐标系世界坐标系$W$到是机器人本体坐标系$B$只考虑旋转的时候，旋转矩阵$R_{WB}$。</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422155242434.png" alt="image-20220422155242434"></p><p>这里定义一些变量：</p><blockquote><p>①设物体在坐标系$B$下做速度为$v_B$，加速度为$a_B$，对应在坐标系$W$下的速度为$v_W$，加速度为$a_W$</p><p>并且设坐标系$B$下的速度和加速度在坐标系$W$下的表示分别为：$v=R_{WB}v_B$，$a=R_{WB}a_B$，一定注意这里的$v\ne v_W,a\ne a_W$</p><p>②设坐标轴$B$旋转的角速度为$w_B$，对应在世界坐标系中其旋转的角速度变为$w_W$，且$w_W=R_{WB}w_B$</p><p>③设物体在坐标系$B$下的坐标为$r_B$，对应在坐标系$W$下的坐标为$r_W$，且$r_W=R_{WB}r_B$</p></blockquote><p>则对应到世界坐标系下：</p><script type="math/tex; mode=display">r_W(t)=x_1(t)i+x_2(t)j+x_3(t)k=R_{WB}r_B</script><p>一般简写为：$r_B=x_ie_i$</p><p>经过一番定义之后，我们考虑几个问题:</p><ul><li><strong>求物体在$W$坐标系下的速度</strong></li></ul><p>对时间求导：</p><script type="math/tex; mode=display">\begin{align*}\dot r_W=v_W&=R_{WB}\dot r_B+\dot R_{WB} r_B\\&=R_{WB}v_B+w_W^{\land} r_W \ \ \ \ 参见公式(3) \\ &=v+w_W^{\land} r_W\Leftrightarrow v=v_W-w_W^{\land} r_W\\\end{align*}\tag{2}</script><p>其中$w_W=R_{WB}w_b$表示body坐标系$B$的角速度在世界坐标系$W$下的表示。具体推导参见公式$(3)$.</p><p>这里可以明显看出$v\ne v_W$，两者之间相差一个$w_W^{\land} r_W$项。</p><hr><p>推导$\dot R_{WB} r_B$，使用右乘扰动模型:</p><script type="math/tex; mode=display">\begin{align*}\dot R_{WB} r_B&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}\exp([w_B\Delta t]^{\land})r_B-R_{WB}r_B}{\Delta t}\\&\approx\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}(I+[w_B\Delta t]^{\land})r_B-R_{WB}r_B}{\Delta t}\\&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}[w_B\Delta t]^{\land}r_B}{\Delta t}\\&=\underset{\Delta t \rightarrow0}{lim}\frac{-R_{WB}r_B^{\land}[w_B\Delta t]}{\Delta t}\\&=-R_{WB}r_B^{\land}w_B\\ &=R_{WB}w_B^{\land}r_B\\&=(R_{WB}w_B)^{\land}R_{WB}r_B\\&=w^{\land}_Wr_W\end{align*}\tag{3}</script><hr><ul><li><strong>求物体在$W$坐标系下的加速度</strong></li></ul><p>对时间求导：</p><script type="math/tex; mode=display">\begin{align*}\ddot r_W =\dot v_W = a_W&=\frac{d(R_{WB}v_B+w_W^{\land}\dot r_W)}{dt}\\&=R_{WB}\dot v_B+\dot R_{WB} v_B+w_W^{\land}\dot r_W+\dot w_W^{\land}r_W\\&=a+w^{\land}v+(w^{\land}v+w^{\land}(w^{\land} r_W))+\dot w^{\land}r_W\\&=a+2w^{\land}v+w^{\land}(w^{\land} r_W)+\dot w^{\land}r_W\\\end{align*}\tag{4}</script><p>上式的每一项的推导见下面。这里可以明显看出$a\ne a_W$，两者之间相差三个项，分别是<strong>科氏力：$2w^{\land}v$，离心力：$w^{\land}(w^{\land} r_W)$、欧拉力：$\dot w^{\land}r_W$。</strong></p><hr><ul><li>第一项：</li></ul><script type="math/tex; mode=display">R_{WB}\dot v_B=R_{WB}a_B=a</script><ul><li>第二项：</li></ul><p>参考公式$(3)$，很容易就可以推出来：</p><script type="math/tex; mode=display">\begin{align*}\dot R_{WB} v_B&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}\exp([w_B\Delta t]^{\land})v_B-R_{WB}v_B}{\Delta t}\\&=(R_{WB}w_B)^{\land}R_{WB}r_B\\&=w^{\land}_Wv\end{align*}</script><ul><li>第三项：</li></ul><script type="math/tex; mode=display">\begin{align*}w_W^{\land}\dot r_W&=w_W^{\land}(v+w_W^{\land}r_W)\\&=w_W^{\land}v+w_W^{\land}(w_W^{\land}r_W)\end{align*}</script><hr><p><strong>整个过程的作用是什么？</strong></p><p>我们在<strong>已知$B$坐标系下的物体的加速度、速度以及旋转轴的角速度</strong>，（这里的B就是我们今天的”IMU”），我们就可以求得对应世界坐标系下的相应的物理量，那么相应的求可以求得世界坐标系下的位姿（速度积分得到位姿）、四元数（根据角速度）。</p><p>大篇幅地介绍这个案例，主要是使读者明白，三维世界中的运动物体，在旋转的坐标系下（IMU坐标系）,如何将其状态量转换到世界坐标系下。以及转换之后各个状态量多出来了什么？</p><h1 id="Ⅱ-IMU-工作原理"><a href="#Ⅱ-IMU-工作原理" class="headerlink" title="Ⅱ.IMU 工作原理"></a>Ⅱ.IMU 工作原理</h1><h2 id="A-加速度计工作原理"><a href="#A-加速度计工作原理" class="headerlink" title="A.加速度计工作原理"></a>A.加速度计工作原理</h2><p>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示:</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422191601477.png" alt="image-20220422191601477.png" style="zoom:33%;" /></p><p>注意这里的加速度计测量值$a_m$为弹簧拉力对应的加速度，所以有：</p><script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g\tag{5}</script><p>其中$f $为弹簧拉力，$a$ 为物体在惯性系下的加速度，$g$为重力加速度。</p><p>另外，实际的加速度计大都是$MEMS $加速度计，它利用电容或者电阻桥来等原理来测量$ a_m$</p><p>其原理可以参考：<a href="https://m.elecfans.com/article/596137.html"><strong>MEMS 加速度传感器的原理与构造介绍</strong></a></p><p>通常情况下我们假设地球表面为惯性参考系，但是对于高端的测量单元来说，这种精度远远不够（需要考虑地球自转的影响），所以就将惯性参考系的原点记为地球的质心，而位于地球表面的坐标系称为地面参考系或东北天坐标系（ENU坐标系）, 如下图所示。在此坐标系下$g=(0,0,-9.81)^T$</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422192532908.png" alt="image-20220422192532908.png" style="zoom:33%;" /></p><p>假设 IMU 坐标系就是 ENU 坐标系，$R_{WB }= I$，静止时有$a=0,a_m=-g$，自由落体时有$a=g,a_m=0$</p><h2 id="B-陀螺仪测量原理"><a href="#B-陀螺仪测量原理" class="headerlink" title="B.陀螺仪测量原理"></a>B.陀螺仪测量原理</h2><p>陀螺仪侦测的是角速度。其工作原理基于科里奥利力的原理：当一个物体在坐标系中直线移动时，假设坐标系做一个旋转，那么在旋转的过程中，物体会感受到一个垂直的力和垂直方向的加速度。</p><p>按测量原理分有<strong>振动陀螺</strong>，<strong>光纤陀螺</strong>等。</p><p><img src="/images/2-IMU运动学模型以及误差模型/陀螺仪.gif" alt="陀螺仪.gif"></p><p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 科氏力（Coriolis force ）来间接得到角速度。MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴，比如，如图示，高速运动的物体速度为$v$，在旋转坐标系下，物体会受到科氏力的影响，我们通过求科氏力就可以求得角速度$w$的大小。</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422195814350.png" alt="image-20220422195814350.png" style="zoom:33%;" /></p><p>但是实际制作的过程中我们不只是使用一个质量块，而是使用两个质量块，就是<strong>音叉陀螺仪</strong>，如图所示，叉子的中间为旋转轴，叉子左右两个质量块，做方反的正弦运动，质量块受到的科氏力方向相反。</p><p><img src="/images/2-IMU运动学模型以及误差模型/20210905220130.png" alt="20210905220130.png" style="zoom: 33%;" /></p><p>当两个完全相同的质量块的运动方向相反，但是旋转相同的时候，它们就会受到相反的科氏力以及相同的外部加速度影响力。将两个质量块所受到该方向上的力做差，就会得到两倍的科氏力。</p><p><strong>但是为啥要用这么做呢? 一个质量块不行么？</strong></p><p>①利用二倍的科氏力对应的电压指数更大，测量也变得更准确；②因为有可能在科氏力方向上物体本身具有一定的加速度，所以利用音叉陀螺仪构成差分模型，可以将两个外部力相互抵消（科氏力方向物体本身的加速度），消除自身的影响，是的获得的科氏力更准。</p><p>但是，实际上，两个质量块不可能完全一致，也就是说陀螺仪的测量可能会受到外部加速度的影响，即常称的 <strong>G-sensitivity</strong>，一般的IMU手册里面都会有这个指数，它的含义就是告诉你IMU受加速度影响的系数有多大。</p><h1 id="Ⅲ-IMU-中的误差及其标定"><a href="#Ⅲ-IMU-中的误差及其标定" class="headerlink" title="Ⅲ.IMU 中的误差及其标定"></a>Ⅲ.IMU 中的误差及其标定</h1><p>误差的分类：加速度计和陀螺仪的误差可以分为：确定性误差以及随机的误差，确定性的误差一般是事先通过标定确定，但是随机误差通常情况下假设噪声服从的是高斯分布。</p><h2 id="A-确定性误差与标定"><a href="#A-确定性误差与标定" class="headerlink" title="A.确定性误差与标定"></a>A.确定性误差与标定</h2><h3 id="1-确定性误差"><a href="#1-确定性误差" class="headerlink" title="1.确定性误差"></a>1.确定性误差</h3><ul><li><strong>Bias</strong></li></ul><p>理论上，当没有外部作用时，IMU 传感器的输出应该为$0$。但是，实际数据存在一个偏置$ b$。加速度计 bias 对位姿估计的影响：</p><script type="math/tex; mode=display">v_{err}=b_at,\ \ \ p_{err}=\frac{1}{2}b_at^2</script><p>这里的$p_{err}$指的是位移，因为有时间$t$的存在，为了区分，将位移定义为$p$.</p><ul><li><strong>Scale(刻度系数误差)</strong></li></ul><p>scale 可以看成是实际数值和传感器输出值之间的比值。</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422204953295.png" alt="image-20220422204953295.png" style="zoom:33%;" /></p><ul><li><strong>Nonorthogonality/Misalignment Errors(安装误差)</strong></li></ul><p>特别的在多轴的IMU传感器中，由于制作工艺的问题，有可能对导致$xyz$轴并不是严格意义的正交，如下图所示，$z$轴并不是严格意义上与$xOy$平面垂直，则会影响对应的$x,y$上的分量。</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220422204127003.png" alt="image-20220422204127003.png" style="zoom:33%;" /></p><p>加上之前的scale的影响：</p><script type="math/tex; mode=display">\begin{align*}scale+Misalignment:&\\&\begin{bmatrix}l_{ax}\\l_{ay}\\l_{az}\end{bmatrix}=\begin{bmatrix}s_{xx}&m_{xy}&m_{xz}\\m_{yx}&s_{yy}&m_{yz}\\m_{zx}&m_{zy}&s_{zz}\end{bmatrix}\begin{bmatrix}a_{x}\\a_{y}\\a_{z}\end{bmatrix}\end{align*}</script><h3 id="2-确定性误差的标定"><a href="#2-确定性误差的标定" class="headerlink" title="2.确定性误差的标定"></a>2.确定性误差的标定</h3><h4 id="六面法标定加速度计和陀螺仪"><a href="#六面法标定加速度计和陀螺仪" class="headerlink" title="六面法标定加速度计和陀螺仪"></a>六面法标定加速度计和陀螺仪</h4><p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。<br>如果各个轴都是正交的，那很容易得到 bias 和 scale：</p><p>因为静止状态下，向上和向下所得到IMU的示数相加正好抵消掉了重力的影响，所以两次测量相加得到两倍的bias；</p><p>向上和向下所得到IMU的示数相减可以抵消bias;</p><script type="math/tex; mode=display">b=\frac{l^{up}_f+l^{down}_f}{2}\\S=\frac{l^{up}_f-l^{down}_f}{2g}\tag{6}</script><p>其中，$l $为加速度计某个轴的测量值，$g$ 为当地的重力加速度</p><p><strong>考虑轴间误差的时候，实际加速度和测量值之间的关系为：</strong></p><p>当考虑轴间的误差的时候，就变成$L = S · a + b$，其中$S$为$3\times3$的矩阵，</p><script type="math/tex; mode=display">\begin{bmatrix}l_{ax}\\l_{ay}\\l_{az}\end{bmatrix}=\begin{bmatrix}s_{xx}&m_{xy}&m_{xz}\\m_{yx}&s_{yy}&m_{yz}\\m_{zx}&m_{zy}&s_{zz}\end{bmatrix}\begin{bmatrix}a_{x}\\a_{y}\\a_{z}\end{bmatrix}+\begin{bmatrix}b_{ax}\\b_{ay}\\b_{az}\end{bmatrix}\tag{7}</script><p>水平放置$6$面，就会得到$6$个$a$向量，加速度的理论值为</p><script type="math/tex; mode=display">a_1=\begin{bmatrix}g\\0\\0\end{bmatrix},a_2=\begin{bmatrix}-g\\0\\0\end{bmatrix},a_3=\begin{bmatrix}0\\g\\0\end{bmatrix},a_4=\begin{bmatrix}0\\-g\\0\end{bmatrix},a_5=\begin{bmatrix}0\\0\\g\end{bmatrix},a_6=\begin{bmatrix}0\\0\\-g\end{bmatrix}</script><p>对应的$L$为$L=\begin{bmatrix}l_1&amp;l_2&amp;l_3&amp;l_4&amp;l_5&amp;l_6\end{bmatrix}$</p><p>在得知六组数据$(a_1,l_1)…(a_6.l_6)$，我们就可以利用最小二乘就可以得出$S$和$b$的具体值。线性最小二乘可以参考：<a href="https://lukeyalvin.top/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/">线性最小二乘</a></p><p><strong>同理陀螺仪的六面法标定与其类似，和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这里的$6 $面是指各个轴顺时针和逆时针旋转。</strong></p><h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><p>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</p><p>两种标定方法：</p><ul><li>soak method：控制恒温室的温度值，然后读取传感器数值进行标定。</li><li>ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</li></ul><h2 id="B-随机误差与标定"><a href="#B-随机误差与标定" class="headerlink" title="B.随机误差与标定"></a>B.随机误差与标定</h2><h3 id="1-随机误差"><a href="#1-随机误差" class="headerlink" title="1.随机误差"></a>1.随机误差</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>IMU 数据<strong>连续时间</strong>上受到一个均值为$ 0$，方差为$\sigma$，各时刻之间相互独立的高斯过程$ n(t)$：</p><script type="math/tex; mode=display">\begin{align*}&E[n(t)]\equiv0\\&E[n(t_1)n(t_2)]=\sigma^2\delta(t_1-t_2)\end{align*}\tag{8}</script><p>其中$\delta()$表示狄拉克函数。</p><p>实际上，IMU 传感器获取的数据为<strong>离散采样</strong>，离散和连续高斯白噪声的方差之间存在如下转换关系：</p><p>定义$n_d[k]$</p><script type="math/tex; mode=display">\begin{align*}n_d[k]\triangleq n(t_0+t_1)≃\frac{1}{\Delta t}\int^{t_0+\Delta t}_{t_0}{n(\tau)}dt\end{align*}</script><p>对其求方差$Var(X)=E[(X-\mu)^2]$,已知均值为$0$，$X=n_d[k]$：</p><script type="math/tex; mode=display">\begin{align*}E(n_d[k]^2)&=E(\frac{1}{\Delta t^2}\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{n(\tau)}{n(t)}d\tau dt)\\&=E(\frac{\sigma^2}{\Delta t^2}\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{\delta(t-\tau)}d\tau dt)\\&=E(\frac{\sigma^2}{\Delta t})\end{align*}\tag{9}</script><p>对应相等，可得：</p><script type="math/tex; mode=display">n_d[k]=\sigma_dw[k]\tag{10}</script><p>其中，</p><script type="math/tex; mode=display">w[k]\sim N(0,1)\\\sigma_d=\sigma\frac{1}{\sqrt{\Delta t} }\tag{11}</script><p><strong>也就是说高斯白噪声的连续时间到离散时间之间差一个$\frac{1}{\sqrt{\Delta t} }$ ，$\sqrt{\Delta t} $是传感器的采样时间。</strong></p><h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走。</p><script type="math/tex; mode=display">\dot b(t)=n(t)=\sigma_bw(t)\tag{12}</script><p>其中$ w $是方差为$ 1 $的白噪声。</p><p>同样，离散和连续之间的转换：</p><p>定义$b_d[k]$</p><script type="math/tex; mode=display">b_d[k]\triangleq b(t_0)+\int^{t_0+\Delta t}_{t_0}{n(t)}dt</script><p>求方差：</p><script type="math/tex; mode=display">\begin{align*}E((b_d[k]-b_d[k-1])^2)&=E(\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{n(t)}{n(\tau)}d\tau dt)\\&=E(\sigma_b^2\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}\delta (t-\tau)d\tau dt)\\&=E(\sigma_b^2\Delta t)\end{align*}\tag{13}</script><p>所以：</p><script type="math/tex; mode=display">b_d[k]=b_d[k-1]+\sigma_{bd}w[k]\tag{14}</script><p>其中：</p><script type="math/tex; mode=display">w[k]\sim N(0,1)\\\sigma_{bd}=\sigma_b \sqrt{\Delta t}\tag{15}</script><p><strong>bias 随机游走的噪声方差从连续时间到离散之间需要乘以</strong>$\sqrt{\Delta t}$</p><h3 id="2-随机误差的标定"><a href="#2-随机误差的标定" class="headerlink" title="2.随机误差的标定"></a>2.随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><blockquote><p>在统计学中描述随机变量的两个经典参数是均值和方差，早期在定量表征原子钟的频率稳定度时采用的就是经典方差方法。1996 年，学者 D.W.Allan 在分析铯原子钟频标的频率稳定度时发现经典方差随着时间的增长而发散，为了解决该问题，提出了一种新的评定方法，后来称为艾伦方差。由于惯性器件也具有振荡器的特征，Allan 方差分析也被广泛应用于惯性器件的随机误差建模，IEEE 标准中就将 Allan 方差方法引入到了激光陀螺的建模分析。</p></blockquote><p>具体的流程如下：</p><p>①保持传感器绝对静止获取数据。</p><p>②对数据进行分段，设定时间段的时长，如下图所示。</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220423162306358.png" alt="image-20220423162306358" style="zoom:50%;" /></p><p>③将传感器数据按照时间段进行平均。</p><p>④计算方差，绘制艾伦曲线。</p><p>得到的艾伦曲线如下图所示：</p><p><img src="/images/2-IMU运动学模型以及误差模型/image-20220423162352964.png" alt="image-20220423162352964" style="zoom: 33%;" /></p><p>从艾伦方差曲线中可以辨识出 IMU 的五种噪声，分别为：量化噪声、角度随机游走、零偏不稳定性噪声，角速率随机游走，速率斜坡，一般在 IMU 噪声辨识中用的比较多的是中间 3 种。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要对IMU的工作原理做详细的介绍，分析IMU中的确定性误差以及随机误差，并给出误差标定的方法，如确定性误差使用六面法标定，随机误差使用艾伦方差标定等。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="IMU误差模型" scheme="https://lukeyalvin.top/tags/IMU%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>一、VIO概述以及三维刚体运动知识点回顾</title>
    <link href="https://lukeyalvin.top/posts/28639.html"/>
    <id>https://lukeyalvin.top/posts/28639.html</id>
    <published>2022-04-25T09:17:10.447Z</published>
    <updated>2022-05-11T06:20:51.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要通过引言部分，提出问什么引入VIO以及它的作用是什么，其次介绍VIO的基本概念，并为了后续内容的展开，回顾了一些基本的数学基础。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="引言：Why-VIO"><a href="#引言：Why-VIO" class="headerlink" title="引言：Why VIO ?"></a>引言：Why VIO ?</h1><h2 id="VO-的缺陷"><a href="#VO-的缺陷" class="headerlink" title="VO 的缺陷"></a>VO 的缺陷</h2><p>结合之前所学，我们首先考虑纯视觉的SLAM，即VO；</p><p>首先是<strong>单目视觉SLAM:</strong> 它的优点就是便宜，简单易用，但是缺点也很明显，就是单目没有深度信息，主要存在三个方面的缺陷：①初度不确定性；②需要初始化；③存在尺度漂移；基于这些问题，这里不做详细的展开；</p><p>为了解决单目视觉存在的问题，我们开始使用<strong>双目相机和 RGBD 相机</strong>，因为它们可以测量深度，这样的话就不存在初始化和尺度上的问题了，但是双目相机的标定很复杂，且视差计算深度比较消耗资源，而RGBD对环境的要求也比较苛刻、测量距离也很有限，其标定也比较复杂。</p><p>但是由于传感器主要是相机，因此，<strong>纯视觉</strong>存在一些共性的弊端：比如在<strong>光照变化较大时，纹理特征缺失、快速运动导致模糊的情况下无法使用</strong>等缺陷；其中快速运动导致无法使用，主要是因为快速运动可能会导致跟丢，由于纯视觉不做任何处理，大部分都是基于第一帧作为世界坐标系而建立的，而不是相对于地球水平面 (世界坐标系) 的位姿，后者却是导航中真正需要的位姿，换言之，<strong>视觉方法估计的位姿不能和重力方向对齐</strong>。这可能会出现车在地上开，运动轨迹天上飞的现象。</p><h2 id="VIO-的优点"><a href="#VIO-的优点" class="headerlink" title="VIO 的优点"></a>VIO 的优点</h2><p>VIO 就是一种非常优美的解决方式，因为 IMU 可以提供物理世界的尺度，短时间内也能提供比较准确的<strong>位姿估计</strong>，还能<strong>估计出惯性坐标系</strong>。这种互补的性质，让 VIO 在近几年得到了极大的关注。VIO能够解决这些问题的基础是它的初始化，VIO 初始化会把视觉 SLAM 所缺的东西全部都先估计出来，包括<strong>尺度信息，重力向量，位姿速度</strong>。</p><p>通过将 IMU 估计的位姿序列和相机估计的位姿序列对齐可以<strong>估计出相机轨迹的真实尺度</strong>，而且 IMU 可以很好地预测出图像帧的位姿以及上一时刻特征点在下帧图像的位置，<strong>提高特征跟踪算法匹配速度和应对快速旋转的算法鲁棒性</strong>，最后 IMU 中加速度计提供的重力向量可以<strong>将估计的位置转为实际导航需要的世界坐标系中</strong>。</p><p>另外还需要通过视觉 SLAM 帮助 IMU 去搞定陀螺仪和加速度计的初始 bias。如果这些东西一开始估计的很差，那整个系统的准确性会急剧下降。基于滤波的很可能很快就发散得很远了，基于非线性优化的可能经常会陷入局部最优解。</p><p>综合以上，融合 IMU 和视觉信息的 VINS 算法可以很大程度地提高单目 SLAM 算法性能，是一种低成本高性能的导航方案，在机器人、AR/VR 领域得到了很大的关注。</p><h1 id="Ⅰ-VIO-概述"><a href="#Ⅰ-VIO-概述" class="headerlink" title="Ⅰ.VIO 概述"></a>Ⅰ.VIO 概述</h1><h2 id="A-IMU与视觉里程"><a href="#A-IMU与视觉里程" class="headerlink" title="A.IMU与视觉里程"></a>A.IMU与视觉里程</h2><p>IMU（Inertial Measurement Unit），惯性测量单元，用于测量物体三轴姿态角(或角速率)以及加速度的装置。一般情况下，一个IMU内会装有三轴的陀螺仪和三个方向的加速度计，分别用来测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。为了提高可靠性，还可以为每个轴配备更多的传感器。一般而言IMU要安装在被测物体的重心上。</p><ul><li>典型 6 轴 IMU 本身由一个陀螺仪和一个加速度计组成，分别测量自身的角速度和加速度，并以较高频率（≥ 100Hz）返回。</li></ul><p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420150139375.png" alt="image-20220420150139375" style="zoom: 33%;" /></p><ul><li>但是IMU，受自身温度、零偏、振动等因素干扰，积分得到的平移和旋转容易漂移</li></ul><p>手机等电子产品多使用价格低廉的 MEMS IMU（如 MPU 6050），自动驾驶类则多使用几万元的 IMU（如 Apollo 中使用的 Novatel SPAN-IGM-A1）</p><p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420150543613.png" alt="image-20220420150543613" style="zoom: 50%;" /></p><p>视觉 Visual Odometry</p><ul><li>以图像形式记录数据，频率较低（15 − 60Hz 居多）</li><li>通过图像特征点或像素推断相机运动，因此容易受成像质量的影响。</li></ul><p><strong>IMU 与视觉定位方案优势与劣势对比：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">方案</th><th style="text-align:center">IMU</th><th style="text-align:center">视觉</th></tr></thead><tbody><tr><td style="text-align:center">优势</td><td style="text-align:center">快速响应<br/>不受成像质量影响<br/>角速度普遍比较准确<br/>可估计绝对尺度</td><td style="text-align:center">（静止）不产生漂移<br/>直接测量旋转与平移</td></tr><tr><td style="text-align:center">劣势</td><td style="text-align:center">存在零偏<br/>低精度 IMU 积分位姿发散<br/>高精度价格昂贵</td><td style="text-align:center">受图像遮挡、运动物体干扰<br/>单目视觉无法测量尺度<br/>单目纯旋转运动无法估计<br/>快速运动时易丢失</td></tr></tbody></table></div><p>整体上，视觉和 IMU 定位方案存在一定互补性质：</p><ul><li>IMU 适合计算短时间、快速的运动；</li><li>视觉适合计算长时间、慢速的运动。</li></ul><p>同时，可利用视觉定位信息来估计 IMU 的零偏，减少 IMU 由零偏导致的发散和累积误差；反之，IMU 可以为视觉提供快速运动时的定位。</p><h2 id="B-VIO"><a href="#B-VIO" class="headerlink" title="B.VIO"></a>B.VIO</h2><p>VIO：（Visual-Inertial Odometry）视觉惯性里程计，有时候也叫视觉惯性系统（VINS，visual-inertial system），是融合相机和IMU数据实现SLAM的算法。</p><p>IMU 数据可与多种定位方案融合，比如自动驾驶中通常用 IMU+GPS/差分 GPS/RTK 的融合定位方案，<br>形成 GNSS-INS 组合导航系统，达到厘米组定位精度；头戴式 AR/VR 头盔则多使用视觉 +IMU 的 VIO 定位系统，形成高帧率定位方案。</p><p>根据融合框架的区别VIO可以分为紧耦合和松耦合：</p><ul><li><strong>松耦合</strong></li></ul><p>松耦合将 IMU 定位与视觉/GNSS 的位姿直接进行融合，融合过程对二者本身不产生影响，作为后处理方式输出。典型方案为卡尔曼滤波器。</p><p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420151628700.png" alt="image-20220420151628700" style="zoom: 33%;" /></p><ul><li><strong>紧耦合</strong></li></ul><p>紧耦合则是使用两个传感器的原始数据共同估计一组变量，传感器噪声也是相互影响的，紧耦合算法上比较复杂，但充分利用了传感器数据，可以实现更好的效果，是目前研究的重点。典型方案为 MSCKF 和非线性优化。</p><p><img src="/images/1-VIO概述以及三维刚体运动知识点回顾/image-20220420151708384.png" alt="image-20220420151708384" style="zoom:33%;" /></p><p><strong>为什么要使用紧耦合？</strong></p><ul><li>单纯凭（单目）视觉或 IMU 都不具备估计 Pose 的能力：视觉存在尺度不确定性、IMU 存在零偏导致漂移；</li><li>松耦合中，视觉内部 BA 没有 IMU 的信息，在整体层面来看不是最优的。</li><li>紧耦合可以一次性建模所有的运动和测量信息，更容易达到最优。</li></ul><h1 id="Ⅱ-知识点回顾"><a href="#Ⅱ-知识点回顾" class="headerlink" title="Ⅱ.知识点回顾"></a>Ⅱ.知识点回顾</h1><h2 id="A-三维刚体运动"><a href="#A-三维刚体运动" class="headerlink" title="A.三维刚体运动"></a>A.三维刚体运动</h2><p>在三维刚体运动中，我们定义机器人上的各种坐标系，世界坐标系$W$，IMU坐标系(Body系)$I$，相机坐标系$C$。通过十四讲的学习我们可以知道，坐标系之间的转换可以通过$SE(3)$给出，比如$I$到$W$坐标系的变换矩阵为$T_{WI}$:</p><script type="math/tex; mode=display">T_{WI}=\begin{bmatrix}R_{WI}&t_{WI}\\0^T&1\end{bmatrix}\in\mathbb{R}^{4×4}\tag{1}</script><p>其中，$R_{WI}$为$3×3$的旋转矩阵，$t_{WI}$为平移向量。我们可以用$T_{WI}$右乘一个$I$坐标系下的坐标，将得到该点$W$系下的坐标。</p><h2 id="B-四元数"><a href="#B-四元数" class="headerlink" title="B.四元数"></a>B.四元数</h2><p>三维刚体的运动可以有旋转矩阵来表达，也可以用四元数$q$描述。四元数有一个实部和三个虚部。我们把实部写在前：</p><script type="math/tex; mode=display">q=[q_0,q_1,q_2,q_3]^T或q=[w,x,y,z]^T\tag{2}</script><p>其中 $q_0$ 为实部，$[q_1, q_2, q_3]^T$为虚部。因为实部为标量，虚部为矢量，所以也可记为：</p><script type="math/tex; mode=display">q=[s,\pmb{v}]^T\tag{3}</script><p>其中 $s $为标量，$\pmb{v}$为虚部的矢量。</p><p><strong>四元数的乘法运算：</strong></p><script type="math/tex; mode=display">\begin{align*}q_a\otimes q_b&=w_aw_b − x_ax_b − y_ay_b − z_az_b\\&+ (w_ax_b + x_aw_b + y_az_b − z_ay_b)i\\&+ (w_ay_b − x_az_b + y_aw_b + z_ax_b) j\\&+ (w_az_b + x_ay_b − y_ax_b + z_aw_b) k.\end{align*}\tag{4}</script><p>或者是：</p><script type="math/tex; mode=display">q_a\otimes q_b=[s_as_b-\pmb{v}_a^T\pmb{v}_b,s_a\pmb{v}_b+s_b\pmb{v}_a+\pmb{v}_a\times\pmb{v}_b]^T\tag{5}</script><p>四元数的其他四则运算，不作具体展开，参阅《视觉SLAM十四讲》。</p><p><strong>四元数表示旋转：</strong></p><p>另外单位四元数可表达任意三维旋转，且无奇异性。如设轴角为$w$和$\theta$，那么它对应的四元数为：</p><script type="math/tex; mode=display">q=[cos\frac{\theta}{2},wsin\frac{\theta}{2}]^T\tag{6}</script><p>利用此性质可推导四元数求导。</p><p><strong>四元数的求导：</strong></p><p>四元数时间导数：设初始旋转为 $q = [s, \pmb{v}]$，然后，发生了角轴为 $w, \theta$ 的旋转（右乘，对应四元数记作$\Delta q=[cos\frac{\theta}{2},wsin\frac{\theta}{2}]^T$），那么 $q $相对该旋转的导数为：</p><script type="math/tex; mode=display">\begin{align*}\underset{\theta \rightarrow 0}{lim}\frac{q\otimes \Delta q-q}{\theta}&=\underset{\theta \rightarrow 0}{lim}\frac{[s \cos\frac{\theta}{2}-\pmb{v}^Tw \sin\frac{\theta}{2},sw \sin\frac{\theta}{2}+cos\frac{\theta}{2}\pmb{v}+\pmb{v}\times w \sin\frac{\theta}{2}]^T-q}{\theta}\\&=\underset{\theta \rightarrow 0}{lim}\frac{[s (\cos\frac{\theta}{2}-1)-\pmb{v}^Tw \sin\frac{\theta}{2},sw \sin\frac{\theta}{2}+(\cos\frac{\theta}{2}-1)\pmb{v}+\pmb{v}\times w \sin\frac{\theta}{2}]^T}{\theta}\\&=[-\frac{1}{2}\pmb{v}^Tw,\frac{1}{2}sw+\frac{1}{2}\pmb{v}\times w]^T\\&=q\otimes[0,\frac{1}{2}w]^T\end{align*}\tag{7}</script><p>因此，若角速度为 $w$，那么旋转的时间导数即为：</p><script type="math/tex; mode=display">\dot q= q\otimes[0,\frac{1}{2}w]^T\tag{8}</script><h2 id="C-李代数"><a href="#C-李代数" class="headerlink" title="C.李代数"></a>C.李代数</h2><p>除了利用四元数求导，亦可利用李代数进行旋转求导。<br>使用旋转矩阵$R$时，角速度为 $w$，那么 $R$ 相对于时间的导数可写作：</p><script type="math/tex; mode=display">\dot R= Rw^{\land}\tag{9}</script><p>该式被称为<strong>泊松公式</strong>（Possion’s equation），其中${\land}$为反对称矩阵算子：</p><script type="math/tex; mode=display">w^{\land}=\begin{bmatrix}0&-w_3&w_2\\w_3&0&-w_1\\-w_2&w_1&0\end{bmatrix}\tag{10}</script><p>其实结合之前的知识，可以发现，这里的$w^{\land}$不就是旋转矩阵对应的李代数$\mathfrak{so}(3)$嘛，十四讲里面用的是$\phi^{\land}$。</p><p><strong>$\mathfrak{so}(3)$导数：</strong></p><p>在优化带有旋转的函数时，通常计算一个增量 $\phi\in \mathfrak{so}(3)$，然后用它更新当前估计值：</p><script type="math/tex; mode=display">R\leftarrow R\ exp(\phi^{\land})\tag{11}</script><p>其中$exp$为$\mathfrak{so}(3)$至$SO(3)$上的指数映射。</p><blockquote><p>注意：</p><blockquote><p>①不同的$R$函数，具体的导数形式也不同</p><p>②在程序中，不必区分$R$是以矩阵存储或是以四元数存储，只需按照该式更新即可。</p></blockquote></blockquote><h2 id="D-扰动模型的雅可比"><a href="#D-扰动模型的雅可比" class="headerlink" title="D.扰动模型的雅可比"></a>D.扰动模型的雅可比</h2><p><strong>常见的一些雅可比：</strong>（以自变量为$R$举例）</p><ul><li>旋转点的左扰动雅可比：</li></ul><p>这里将对$R$进行一次的扰动$\Delta R$加在其对应的李代数$\varphi $上，而非李群上。</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial(Rp)}{\partial \varphi}&=\underset{\varphi\rightarrow0}{lim}\frac{exp(\varphi^{\land})\cdot exp(\phi^{\land})p-exp(\phi^{\land})p}{\varphi}\\&\approx \underset{\varphi\rightarrow0}{lim}\frac{(I+\varphi^{\land})\cdot exp(\phi^{\land})p-exp(\phi^{\land})p}{\varphi} \ \ \ 一阶泰勒展开\\&=\underset{\varphi\rightarrow0}{lim}\frac{\varphi^{\land}Rp}{\varphi} \ \ \ 根据 a^{\land}b=-b^{\land}a\\&=\underset{\varphi\rightarrow0}{lim}\frac{-(Rp)^{\land}\varphi}{\varphi}\\&=-(Rp)^{\land}\end{align*}\tag{12}</script><ul><li>旋转点的右扰动雅可比：</li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial(Rp)}{\partial \varphi}&=\underset{\varphi\rightarrow0}{lim}\frac{ exp(\phi^{\land})\cdot exp(\varphi^{\land})p-exp(\phi^{\land})p}{\varphi}\\&\approx \underset{\varphi\rightarrow0}{lim}\frac{ exp(\phi^{\land})\cdot(I+\varphi^{\land})p-exp(\phi^{\land})p}{\varphi} \ \ \ 一阶泰勒展开\\&=\underset{\varphi\rightarrow0}{lim}\frac{R\varphi^{\land}p}{\varphi} \ \ \ 根据 a^{\land}b=-b^{\land}a\\&=\underset{\varphi\rightarrow0}{lim}\frac{-Rp^{\land}\varphi}{\varphi}\\&=-Rp^{\land}\end{align*}\tag{13}</script><ul><li>旋转连乘的雅可比：</li></ul><p>①这里将对$R_2$进行一次的扰动$\Delta R_2$加在其对应的李代数$\phi $上，而非李群上。</p><script type="math/tex; mode=display">\begin{align*}\frac{d\ ln(R_1R_2)^{\lor} }{dR_2}&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\cdot exp(\phi^{\land}))^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&\approx\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2)^{\lor}+J^{-1}_r\phi-ln(R_1R_2)^{\lor} }{\phi}\\&=J^{-1}_r(ln(R_1R_2)^{\lor})\end{align*}\tag{14}</script><p>第一步到第二步使用的是$BCH$近似公式：</p><script type="math/tex; mode=display">\ln (\exp(\phi_{1}^{\land})\exp(\phi_{2}^{\land}) )^{\lor} \approx\left\{ \begin{array}{l}J_l(\phi_{2})^{-1}\phi_{1}+\phi_{2}\ \ \ \ 当\phi_{1}为小量\\J_r(\phi_{1})^{-1}\phi_{2}+\phi_{1}\ \ \ \ 当\phi_{2}为小量    \\\end{array} \right.\tag{15}</script><p>此处就是：对任意$R$</p><script type="math/tex; mode=display">\ln (R\exp(\phi^{\land}) )^{\lor} \approx\ln(R)^{\lor}+J_r^{-1}\phi\tag{16}</script><p>其中$J_r^{-1}$为$SO(3)$上的右雅可比：</p><script type="math/tex; mode=display">J_r^{-1}(\theta w)=\frac{1}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})ww^T+\frac{\theta}{2}w^{\land}\tag{17}</script><p>②这里将对$R_1$进行一次的扰动$\Delta R_1$加在其对应的李代数$\phi $上，而非李群上。</p><script type="math/tex; mode=display">\begin{align*}\frac{d\ ln(R_1R_2)^{\lor} }{dR_2}&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1\cdot \exp(\phi^{\land})\ R_2)^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\cdot[R_2^T\cdot \exp(\phi^{\land})\ R_2])^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\exp((R_2^T\phi)^{\land}))^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&=J^{-1}_r(ln(R_1R_2)^{\lor})R_2^T\end{align*}\tag{18}</script><p>第一步到第二步用到了$sO(3)$的伴随性质：</p><script type="math/tex; mode=display">R^T\exp(\phi^{\land})R=\exp((R^T\phi)^{\land})\tag{19}</script><p>有关 $SE(3)$：由于$ SE(3)$ 李代数性质复杂，在 VIO 中，我们通常使用$SO(3) + t $的形式表达旋转和平移。对平移部分使用矢量更新而非$SE(3) $上的更新。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要通过引言部分，提出问什么引入VIO以及它的作用是什么，其次介绍VIO的基本概念，并为了后续内容的展开，回顾了一些基本的数学基础。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="刚体运动" scheme="https://lukeyalvin.top/tags/%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>aloam_velodyney源代码深度解析</title>
    <link href="https://lukeyalvin.top/posts/60089.html"/>
    <id>https://lukeyalvin.top/posts/60089.html</id>
    <published>2022-04-18T01:31:17.245Z</published>
    <updated>2022-04-26T03:24:18.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>体验过LOAM代码之后，大多数人应该对源代码有种不太好的印象，我觉得更多是因为LOAM作者受当时发展的局限，没有使用像现在流行的李代数、Eigen、Ceres等，A-LOAM就在其基础上对源代码进行了改进，最明显的就是坐标变化部分引入了Eigen，优化部分使用Ceres自动求导代替LOAM作者手推的ICP优化部分，代码变得十分简洁，但是同时也降低了LOAM算法的效率。尽管如此，这位香港大学的秦师兄写的代码还是很让人佩服的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>首先看一下ROS节点图，明显可以发现比LOAM的简洁太多了：</p><p><img src="/images/aloam源码解析/1308994-20200506202232477-859678963.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;体验过LOAM代码之后，大多数人应该对源代码有种不太好的印象，我觉得更多是因为LOAM作者受当时发展的局限，没有使用像现在流行的李代数、Eigen、Ceres等，A-LOAM就在其基础上对源代码进行了改进，最明显的就是坐标变化部分引入了Eigen，优化部分使用Ceres自动求导代替LOAM作者手推的ICP优化部分，代码变得十分简洁，但是同时也降低了LOAM算法的效率。尽管如此，这位香港大学的秦师兄写的代码还是很让人佩服的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM项目实践" scheme="https://lukeyalvin.top/categories/SLAM%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="ALOAM" scheme="https://lukeyalvin.top/tags/ALOAM/"/>
    
  </entry>
  
</feed>
