<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lukey Alvin</title>
  
  <subtitle>一份耕耘,一份收获</subtitle>
  <link href="https://lukeyalvin.top/atom.xml" rel="self"/>
  
  <link href="https://lukeyalvin.top/"/>
  <updated>2022-05-22T06:21:37.030Z</updated>
  <id>https://lukeyalvin.top/</id>
  
  <author>
    <name>爱喝烫水的阿水哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VINS-Mono+noetic编译与运行</title>
    <link href="https://lukeyalvin.top/posts/4698a117.html"/>
    <id>https://lukeyalvin.top/posts/4698a117.html</id>
    <published>2022-05-22T05:11:12.000Z</published>
    <updated>2022-05-22T06:21:37.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS-Mono开源代码下载地址位于：<a href="https://github.com/HKUST-Aerial-Robotics/VINS-Mono，Ubuntu">https://github.com/HKUST-Aerial-Robotics/VINS-Mono，Ubuntu</a> 16.04, ROS Kinetic, OpenCV 3.3.1, Eigen 3.3.3等，这里我利用Ubuntu 20.04编译运行，会涉及一些错误，记录个人的一些解决方案以及经验。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522132936409.png" alt="image-20220522132936409" style="zoom:50%;" /></p><p>贴一张我“师兄”的回答，可是我就喜欢给自己找麻烦，因为我真的不想为了运行一个数据集重装系统，太费时费力而且损失巨大，当然，你如果系统啥都没有，当我没说，我依稀记得当初装各种各样的环境崩溃的样子，尤其是装ROS 期间遇到的墙的问题。</p><p><strong>能装吗？能！麻烦吗？并不麻烦！</strong></p><h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><p>比如Eigen，我这里下载的是3.3.8，如果你是3.3.7也没关系，主要是Ceres 这里选择1.2的版本，因为代码中CmakeLists 都是用 C++11编译的，最新版的Ceres-solver2.0.0采用的是C++14编译，因此如果你是2.0以上的版本，将所有文件夹下的CMakeList文件全部修改为C++14编译即可</p><h1 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h1><p>创建一个工作空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p VINS_WS/src</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/HKUST-Aerial-Robotics/VINS-Mono.git</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>当然，如果一切顺利本文就结束了。但是由于我使用的是 Ubuntu 20.04 对应的 ROS 版本是 noetic ，noetic 本身的就带有 opencv4 的版本，而VINS-Mono 的 openCV 的依赖是OpenCV 3.3.1，这就是冲突所在。</p><p><a href="http://www.ceres-solver.org/installation.html">Ceres-Solver网站</a></p><p><a href="https://gitlab.com/libeigen/eigen/-/releases/3.3.8">Eigen 3.3.8</a></p><h1 id="OpenCV冲突问题"><a href="#OpenCV冲突问题" class="headerlink" title="OpenCV冲突问题"></a>OpenCV冲突问题</h1><p>你可能会遇到：</p><p><span style="color:red;">error: ‘CV_BGR2GRAY’ was not declared in this scope</span></p><p><span style="color:red;"> error: ‘CV_FONT_HERSHEY_SIMPLEX’ was not declared in this scope</span></p><p>这些都是版本冲突的问题，你可能也搜索到了一些解决方案，但是基本上，方向错了，治标不治本。</p><p>例如：在报错的地方加入头文件，指定引用的OpenCV版本等，这里不提了。</p><p>下面提出两种解决方案，本人实际测试的第二种，第一种盲猜可以。</p><h2 id="方案一：把vins-mono代码全部改成opencv4的版本"><a href="#方案一：把vins-mono代码全部改成opencv4的版本" class="headerlink" title="方案一：把vins-mono代码全部改成opencv4的版本"></a>方案一：把vins-mono代码全部改成opencv4的版本</h2><p>将源代码下的所有CMakeList.txt中的find_package(OpenCV REQUIRED)，</p><p>改成find_package(OpenCV 4 REQUIRED)</p><p>主要是下面几个文件夹下的CMakeList.txt</p><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522133842189.png" alt="image-20220522133842189" style="zoom: 80%;" /></p><p>然后重新编译运行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>按照论文步骤，打开三个窗口，分别执行三个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#窗口1:</span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">roslaunch vins_estimator euroc.launch </span><br><span class="line"><span class="comment">#窗口2:</span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">roslaunch vins_estimator vins_rviz.launch</span><br><span class="line"><span class="comment">#窗口3:</span></span><br><span class="line">rosbag play YOUR_PATH_TO_DATASET/MH_01_easy.bag </span><br></pre></td></tr></table></figure><p>如果你运行成功了，那就结束了。</p><h1 id="方案二：cv-bridge改成opencv3版本"><a href="#方案二：cv-bridge改成opencv3版本" class="headerlink" title="方案二：cv_bridge改成opencv3版本"></a>方案二：cv_bridge改成opencv3版本</h1><p><strong>1.卸载原来版本的cv_bridge</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove ros-melodic-cv-bridge</span><br></pre></td></tr></table></figure><p><strong>2.下载新版本cv_bridge</strong></p><p>网址：<a href="https://link.zhihu.com/?target=https%3A//github.com/ros-perception/vision_opencv">https://link.zhihu.com/?target=https%3A//github.com/ros-perception/vision_opencv</a></p><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522135758327.png" alt="image-20220522135758327"></p><p>克隆到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ros-perception/vision_opencv.git</span><br><span class="line"><span class="built_in">cd</span> cv_bridge</span><br></pre></td></tr></table></figure><p><strong>3.修改cv_bridge中的CMakeLists.txt</strong></p><p>find_package(OpenCV 3.4.10 REQUIRED) //改成你安装的opencv的版本；</p><p>查看自己opencv版本的命令：opencv_version</p><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522140034382.png" alt="image-20220522140034382" style="zoom: 67%;" /></p><p><strong>4.cmake单独编译cv_bridge</strong></p><p>在cv_bridge文件夹下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><strong>5.在开源代码需要的cmaklist.txt中添加cv_bridge的cmake路径</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(cv_bridge_DIR /usr/local/share/cv_bridge/cmake)  <span class="comment">#在find_package前面</span></span><br></pre></td></tr></table></figure><p>然后重新编译运行源代码即可！</p><h1 id="其他错误"><a href="#其他错误" class="headerlink" title="其他错误"></a>其他错误</h1><p>如果遇到如下错误，仍然是你的CV 版本不匹配导致的！</p><p>比如在执行 <code>roslaunch vins_estimator euroc.launch</code> 报错：</p><p><span style="color:red;">[feature_tracker-2] process has died [pid 18837, exit code -11, cmd/home/whd/catkin_ws/devel/lib/feature_tracker/feature_tracker __name:=feature_tracker _log:=/home/whd/.ros/log/580e83ec-bfee-11ec-9f41-c979c54caf40/feature_tracker-2.log].<br>log file:/home/whd/.ros/log/580e83ec-bfee-11ec-9f41-c979c54caf40/feature_tracker-2*.log</span></p><p><span style="color:red;">[pose_graph-4] process has died [pid 18839, exit code -11, cmd/home/whd/catkin_ws/devel/lib/pose_graph/pose_graph_name:=pose_graph__log:=/home/whd/.ros/log/580e83ec-bfee-11ec-9f41-c979c54caf40/pose_graph-4.log].<br>log file: /home/whd/.ros/log/580e83ec-bfee-11ec-9f41-c979c54caf40/pose_graph-4*.log</span></p><p>意思是，有两个节点死掉了……</p><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522134853518.png" alt="image-20220522134853518"></p><p>没必要吧，兄弟，不用重装系统啊！</p><p>检查你的选用的方案漏没漏？</p><hr><p>另外，在执行rviz 时我还遇到了如下错误：</p><p><span style="color:red;">[Error] Unable to create the rendering window after 100 tries.</span></p><p>这是由于显卡低造成 rviz 闪退无法正常启动，在 ROS 官网搜索，确定是 <a href="https://so.csdn.net/so/search?q=OpenGL&amp;spm=1001.2101.3001.7020">OpenGL</a> 或其它的问题，评论推荐重新安装显卡驱动。但在 CSDN 上无意间找到了一个解决方案，能够完美解决该问题。解决方法：<br>依次输入三行指令安装更新最好重启一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-x-swat/updates</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522141229347.png" alt="image-20220522141229347"></p><p><img src="/images/VINS-Mono-noetic编译与运行/image-20220522141346992.png" alt="image-20220522141346992"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/418227536">Matebook14 Ubuntu20.04 ROS-Noetic运行VINS-MONO</a></p><p><a href="https://zhuanlan.zhihu.com/p/392939687">解决cv_bridge和opencv之间版本匹配问题</a></p><p><a href="https://blog.csdn.net/weixin_43421058/article/details/119139425#commentBox">Ubuntu20.04下成功运行VINS-mono</a></p><p><a href="https://blog.csdn.net/Haiyang19980818/article/details/121491244">ROS错误记录</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS-Mono开源代码下载地址位于：&lt;a href=&quot;https://github.com/HKUST-Aerial-Robotics/VINS-Mono，Ubuntu&quot;&gt;https://github.com/HKUST-Aerial-Robotics/VINS-Mono，Ubuntu&lt;/a&gt; 16.04, ROS Kinetic, OpenCV 3.3.1, Eigen 3.3.3等，这里我利用Ubuntu 20.04编译运行，会涉及一些错误，记录个人的一些解决方案以及经验。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="SLAM项目实践" scheme="https://lukeyalvin.top/categories/SLAM%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_5-后端非线性优化_视觉约束</title>
    <link href="https://lukeyalvin.top/posts/1b2b3846.html"/>
    <id>https://lukeyalvin.top/posts/1b2b3846.html</id>
    <published>2022-05-20T09:18:21.000Z</published>
    <updated>2022-05-20T14:22:37.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍后端非线性优化中的视觉约束。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-状态向量与目标函数"><a href="#Ⅰ-状态向量与目标函数" class="headerlink" title="Ⅰ.  状态向量与目标函数"></a>Ⅰ.  状态向量与目标函数</h1><p>状态向量共包括滑动窗口内的 $n+1$ 个所有 IMU 状态$\mathbf{x}_k,k\in[0,n]$（包括位置、朝向、速度、加速度计 $bias$ 和陀螺仪 $bias$）、 Camera 到 IMU 的外参 $\mathbf{x}^b_c$、 $m+1$ 个 3D 点的逆深度$\lambda_l,l\in[0,m]$：  </p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}&=[\mathbf{x}_0,\mathbf{x}_1,···,\mathbf{x}_n,\mathbf{x}^b_c,\lambda_0,\lambda_1,···,\lambda_m]\\\mathbf{x}_k&=[\mathbf{p}^w_{b_k},\mathbf{v}^w_{b_k},\mathbf{q}^w_{b_k},\mathbf{b}_a,\mathbf{b}_g],k\in[0,n]\\\mathbf{x}^b_c&=[\mathbf{p}^b_c,\mathbf{q}^b_c]\end{align*}\tag{1}</script><p> $n$ 是关键帧的总数，$m$ 是滑动窗口中的特征总数。 $λ_l$ 是第 $l$ 个特征与其第一次观察的逆深度。</p><p>使用 BA 公式，我们最小化所有测量残差的先验和马氏距离之和，以获得<strong>最大后验估计</strong>为：</p><script type="math/tex; mode=display">\underset{\mathcal{X} }{\min}\left\{\underbrace{\parallel \mathbf{r}_p-\mathbf{H}_p\mathcal{X} \parallel^2}_{边缘化的先验信息}+\underbrace{\sum_{k\in\mathcal{B} }\parallel\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})  \parallel^2_{\mathbf{P}^{b_k}_{b_{k+1} } } }_{IMU 测量残差}+\underbrace{\sum_{(l,j)\in\mathcal{C} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) \parallel^2_{\mathbf{P}^{c_j}_l })}_{视觉的重投影残差}\right\}\tag{2}</script><p>其中 $\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})$ 和 $\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) $ 分别是 IMU 和视觉测量的残差。 $\mathcal{B}$ 是所有 IMU 测量值的集合，$\mathcal{C}$  是在当前滑动窗口中至少观察到两次的特征集合。 $\{\mathbf{r}_p, \mathbf{H}_p\}$ 是来自边缘化的先验信息。 三种残差都是用马氏距离表示。</p><h1 id="Ⅱ-视觉约束"><a href="#Ⅱ-视觉约束" class="headerlink" title="Ⅱ. 视觉约束"></a>Ⅱ. 视觉约束</h1><h2 id="A-残差"><a href="#A-残差" class="headerlink" title="A. 残差"></a>A. 残差</h2><p>视觉残差是重投影误差， 对于第 $l$ 个路标点 $P$，将 $P$ 从第一次观看到它的第 i 个相机坐标系，转换到当前的第 $j $个相机坐标系下的像素坐标，可定义<strong>视觉误差项</strong>为：  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X})&=[\mathbf{b}_1,\mathbf{b}_2]^T\cdot(\hat{\overline{\mathcal{P} } }^{c_j}_l-\frac{\mathcal{P}^{c_j}_l}{\parallel\mathcal{P}^{c_j}_l \parallel^2})\\\end{align*}\tag{3}</script><p> $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 为第 $l$ 个路标点在第 $j$ 个相机归一化相机坐标系中的<strong>观察到的坐标</strong>：  </p><script type="math/tex; mode=display">\hat{\overline{\mathcal{P} } }^{c_j}_l=\pi^{-1}_c\left(\begin{bmatrix}\hat{u}^{c_j}_l\\\hat{v}^{c_j}_l \end{bmatrix}\right)\tag{4}</script><p>$\mathcal{P}^{c_j}_l$ 是估计第 $i$ 个图像中发生的第 $l$个特征的第一次观察，<strong>转换到</strong>第 $j$ 个相机归一化相机坐标系中的<strong>理论的坐标</strong>:  </p><script type="math/tex; mode=display">\mathcal{P}^{c_j}_l =\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}\tag{5}</script><p>其中， $[\hat{u}^{c_i}_l,\hat{v}^{c_i}_l]$ 是第 $i$ 个图像中发生的第 $l$个特征的第一次观察。 $[\hat{u}^{c_j}_l,\hat{v}^{c_j}_l]$ 是对第 $j$ 个图像中相同特征的观察。 $\pi^{-1}_c$ 是反投影函数，它使用相机内在参数将像素位置转换为单位向量。</p><script type="math/tex; mode=display">\overline{\mathcal{P} }^{c_i}_l=\pi^{-1}_c\left(\begin{bmatrix}\hat{u}^{c_i}_l\\\hat{v}^{c_i}_l \end{bmatrix}\right)\tag{6}</script><p>由于视觉残差的自由度为 $2$，我们将残差向量投影到切平面上。  $\mathbf{b}_1$ 和 $\mathbf{b}_2$  是两个任意选择的<strong>正交基</strong>，它们跨越 $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 的切平面，如图所示。在 $(2)$ 中使用的方差 $\mathbf{P}^{c_j}_l$ 也从像素坐标传播到单位球体上.</p><p><img src="/images/VINS-Mono-5-后端非线性优化-视觉约束/image-20220520195143150.png" alt="image-20220520195143150" style="zoom:50%;" /></p><blockquote><p>单位球面上的视觉残差图。 $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 是在第 $j$ 帧中观察第 $l$ 个特征的单位向量。$\mathcal{P}^{c_j}_l$  是通过将其在第 $i$ 帧中的第一个观察值转换为第 $j$ 帧来预测的单位球体上的特征测量。残差定义在  $\hat{\overline{\mathcal{P} } }^{c_j}_l$  的切平面上</p></blockquote><p>这里给出公式 $(5)$ 的推导：</p><p><img src="/images/VINS-Mono-5-后端非线性优化-视觉约束/image-20220520195055396.png" alt="image-20220520195055396"></p><p>设特征 $l$ 点 在第 $i$ 帧被观测到的像素坐标系下的坐标为： $\mathcal{P}_{uv_i}$ ，在世界坐标系下的坐标为：$\mathcal{P}^w_l$，则根据变换矩阵可得：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{P}_{uv_i}&=\lambda_l\pi_c\left({\mathbf{T}^b_c}^{-1}{\mathbf{T}^w_{b_i} }^{-1}\mathcal{P}^w_l  \right)\\\Leftrightarrow \mathcal{P}^w_l&=\mathbf{T}^w_{b_i}\mathbf{T}^b_c\frac{1}{\lambda_l}{\pi_c}^{-1}(\mathcal{P}_{uv_i})\\&=\mathbf{T}^w_{b_i}\mathbf{T}^b_c\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l\\\mathcal{P}^w_l&=\begin{bmatrix}\mathbf{R}^w_{b_i}&\mathbf{p}^w_{b_i}\\0&1\end{bmatrix}\begin{bmatrix}\mathbf{R}^b_c&\mathbf{p}^b_c\\0&1\end{bmatrix}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l\\&=\begin{bmatrix}\mathbf{R}^w_{b_i}\mathbf{R}^b_c&\mathbf{R}^w_{b_i}\mathbf{p}^b_c+\mathbf{p}^w_{b_i}\\0&1\end{bmatrix}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l\\&=\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}\end{align*}\tag{IIA-1}</script><p> 设特征 $l$ 点 在第 $j$ 帧被观测到的相机坐标系下的坐标为： $\mathcal{P}^{c_j}_{l}$ </p><script type="math/tex; mode=display">\begin{align*}\mathcal{P}^{c_j}_l&={\mathbf{T}^b_c}^{-1}{\mathbf{T}^w_{b_j} }^{-1}\mathcal{P}^w_l \\\Leftrightarrow \mathcal{P}^w_l&=\mathbf{T}^w_{b_j}\mathbf{T}^b_c\mathcal{P}^{c_j}_l\\\mathcal{P}^w_l&=\begin{bmatrix}\mathbf{R}^w_{b_j}&\mathbf{p}^w_{b_j}\\0&1\end{bmatrix}\begin{bmatrix}\mathbf{R}^b_c&\mathbf{p}^b_c\\0&1\end{bmatrix}\mathcal{P}^{c_j}_l\\&=\begin{bmatrix}\mathbf{R}^w_{b_j}\mathbf{R}^b_c&\mathbf{R}^w_{b_j}\mathbf{p}^b_c+\mathbf{p}^w_{b_j}\\0&1\end{bmatrix}\mathcal{P}^{c_j}_l\\&=\mathbf{R}^{w}_{b_j}\left(\mathbf{R}^{b}_{c}\mathcal{P}^{c_j}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_j}\end{align*}\tag{IIA-2}</script><p>将 $\mathrm{(IIA-1)}$ 带入 $\mathrm{(IIA-2)}$ ，可以得到：</p><script type="math/tex; mode=display">\begin{align*}&\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}=\mathbf{R}^{w}_{b_j}\left(\mathbf{R}^{b}_{c}\mathcal{P}^{c_j}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_j}\\&\Rightarrow\mathcal{P}^{c_j}_l =\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}\end{align*}\tag{IIA-3}</script><h2 id="B-优化变量"><a href="#B-优化变量" class="headerlink" title="B. 优化变量"></a>B. 优化变量</h2><p>待优化变量主要是 $i$ 和 $j$ 两个时刻相机的位姿以及逆深度：</p><script type="math/tex; mode=display">[\mathbf{p}^w_{b_i},\mathbf{q}^w_{b_i}],\ \ \ \ \ [\mathbf{p}^w_{b_j},\mathbf{q}^w_{b_j}],\ \ \ \ \ [\mathbf{p}^b_{c},\mathbf{q}^b_{c}],\ \ \ \ \ \lambda_l\tag{7}</script><h2 id="C-Jacobian"><a href="#C-Jacobian" class="headerlink" title="C. Jacobian"></a>C. Jacobian</h2><p>综上所述，我们所得到的残差指的是，将第 $i$ 帧图像中发生的第 $l$个特征的第一次观察的像素坐标系（观测值：$\overline{\mathcal{P} }^{c_i}_l$），经过坐标变换，转移到第 $j$ 帧相机归一化相机坐标系中，得到 $\mathcal{P}^{c_j}_l$，与第 $l$ 个路标点在第 $j$ 帧相机归一化相机坐标系中的<strong>观察到的坐标</strong>$\hat{\overline{\mathcal{P} } }^{c_j}_l$ 做比较，理论上，它们是相等的，但是由于存在噪声，故而存在偏差。因此，我们的目的就是优化位姿来最小化残差。</p><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian：</p><script type="math/tex; mode=display">\mathbf{J}[0]^{3\times7}=\left[\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_i} },\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_i} }\right]=\begin{bmatrix}\mathbf{R}^c_b\mathbf{R}^{b_j}_w&-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)^{\land}\end{bmatrix}\tag{J0}</script><hr><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_i} }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_i} }&=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_i} }\\&=\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{p}^w_{b_i} }\\&=\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{p}^w_{b_i} }\\&=\mathbf{R}^c_b\mathbf{R}^{b_j}_w\end{align*}\tag{J0-1}</script><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_i} }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_i} }&=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_i} }\\&=\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{q}^w_{b_i} }\\&=\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{q}^w_{b_i} }\\&=\underset{\delta\theta^w_{b_i}\rightarrow0 }{\lim}\frac{\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\delta\theta^w_{b_i} }\\&=\underset{\delta\theta^w_{b_i}\rightarrow0 }{\lim}\frac{\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)}{\delta\theta^w_{b_i} }\\&=\underset{\delta\theta^w_{b_i}\rightarrow0 }{\lim}\frac{\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\exp({\delta\theta^w_{b_i} }^{\land})\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)-(···)}{\delta\theta^w_{b_i} }\\&=\underset{\delta\theta^w_{b_i}\rightarrow0 }{\lim}\frac{\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}(I+{\delta\theta^w_{b_i} }^{\land})\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)-(···)}{\delta\theta^w_{b_i} }\\&=\underset{\delta\theta^w_{b_i}\rightarrow0 }{\lim}\frac{\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}{\delta\theta^w_{b_i} }^{\land}\left[\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)\right]}{\delta\theta^w_{b_i} }\\&=-\underset{\delta\theta^w_{b_i}\rightarrow0 }{\lim}\frac{\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\left[\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)\right]^{\land}\delta\theta^w_{b_i}}{\delta\theta^w_{b_i} }\\&=-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\left[\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)\right]^{\land}\end{align*}\tag{J0-2}</script><hr><script type="math/tex; mode=display">\mathbf{J}[1]^{3\times7}=\left[\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_j} },\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_j} }\right]=\begin{bmatrix}-\mathbf{R}^c_b\mathbf{R}^{b_j}_w&\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_j}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]\right\}^{\land}\end{bmatrix}\tag{J1}</script><hr><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_j} }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_j} }&=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_j} }\\&=\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{p}^w_{b_j} }\\&=\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{p}^w_{b_j} }\\&=-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\end{align*}\tag{J1-1}</script><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_j} }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_j} }&=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_j} }\\&=\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{q}^w_{b_j} }\\&=\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{q}^w_{b_j} }\\&=\frac{\partial \mathbf{R}^c_b\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]}{\partial\mathbf{q}^w_{b_j} }\\&=\underset{\delta\theta^w_{b_j}\rightarrow0 }{\lim}\frac{\ \mathbf{R}^c_b\left[\mathbf{R}^{b_j}_w\exp({\delta\theta^w_{b_j} }^{\land}) \right]^{-1}\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]}{\delta\theta^w_{b_j} }\\&=\underset{\delta\theta^w_{b_j}\rightarrow0 }{\lim}\frac{ \mathbf{R}^c_b(-{\delta\theta^w_{b_j} }^{\land}){\mathbf{R}^{b_j}_w }^{-1}\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]}{\delta\theta^w_{b_j} }\\&=-\underset{\delta\theta^w_{b_j}\rightarrow0 }{\lim}\frac{ \mathbf{R}^c_b({\delta\theta^w_{b_j} })^{\land}\mathbf{R}^w_{b_j}\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]}{\delta\theta^w_{b_j} }\\&=\underset{\delta\theta^w_{b_j}\rightarrow0 }{\lim}\frac{ \mathbf{R}^c_b\left\{\mathbf{R}^w_{b_j}\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]\right\}^{\land}({\delta\theta^w_{b_j} })}{\delta\theta^w_{b_j} }\\&= \mathbf{R}^c_b\left\{\mathbf{R}^w_{b_j}\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]\right\}^{\land}\end{align*}\tag{J1-2}</script><hr><script type="math/tex; mode=display">\begin{align*}\mathbf{J}[2]^{3\times7}&=\left[\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^b_c },\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^b_c }\right]\\&=\begin{bmatrix}\mathbf{R}^c_b(\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}-I_{3\times3})\\-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\left(\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l} \right)^{\land}+\left(\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l} \right)^{\land}+\left\{\mathbf{R}^c_b\left[\mathbf{R}^{b_j}_w\left(\mathbf{R}^w_{b_i}\mathbf{p}^{b}_{c}+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right)-\mathbf{p}^{b}_{c}\right]\right\}^{\land}\end{bmatrix}^T\end{align*}\tag{J2}</script><hr><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^b_c }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^b_c}&=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^b_c}\\&=\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{p}^b_c}\\&=\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{p}^b_c }\\&=\frac{\partial\  \mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\mathbf{p}^{b}_{c}-\mathbf{R}^c_b\mathbf{p}^{b}_{c}}{\partial\mathbf{p}^b_c }\\&=\mathbf{R}^c_b(\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}-I_{3\times3})\end{align*}\tag{J2-1}</script><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^b_c }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^b_c }=&\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^b_c }\\=&\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{q}^b_c }\\=&\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\mathbf{q}^b_c }\\=&\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{ \left[\mathbf{R}^c_b\exp({\delta\theta^b_c}^{\land})\right]^{-1}\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\exp({\delta\theta^b_c}^{\land})\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\partial\mathbf{q}^b_c }\\=&\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{ (I-{\delta\theta^b_c}^{\land})\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}(I+{\delta\theta^b_c}^{\land})\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\partial\mathbf{q}^b_c }\\=&\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}({\delta\theta^b_c}^{\land})\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\partial\mathbf{q}^b_c }\\&-\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{-{\delta\theta^b_c}^{\land}\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}(I+{\delta\theta^b_c}^{\land})\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\partial\mathbf{q}^b_c }\\\approx&\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}({\delta\theta^b_c}^{\land})\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\partial\mathbf{q}^b_c }\\&-\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{-{\delta\theta^b_c}^{\land}\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}}{\partial\mathbf{q}^b_c }\\=&\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{\mathbf{R}^b_c\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\mathbf{R}^{b}_{c}({\delta\theta^b_c}^{\land})\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}}{\partial\mathbf{q}^b_c }-\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{ {\delta\theta^b_c}^{\land}\left\{\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\} \right\}}{\partial\mathbf{q}^b_c }\\=&\underset{\delta\theta^b_c\rightarrow0 }{\lim}\frac{\mathbf{R}^b_c\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\mathbf{R}^{b}_{c}({\delta\theta^b_c}^{\land})\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}-{\delta\theta^b_c}^{\land}\left\{\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\} \right\}}{\partial\mathbf{q}^b_c }\\=&-\mathbf{R}^b_c\mathbf{R}^{b_j}_w\mathbf{R}^{w}_{b_i}\mathbf{R}^{b}_{c}\left[\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}\right]^{\land}+\left\{\mathbf{R}^b_c\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\} \right\}^{\land}\\=&-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\left(\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l} \right)^{\land}+\left(\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l} \right)^{\land}+\left\{\mathbf{R}^c_b\left[\mathbf{R}^{b_j}_w\left(\mathbf{R}^w_{b_i}\mathbf{p}^{b}_{c}+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right)-\mathbf{p}^{b}_{c}\right]\right\}^{\land}\end{align*}\tag{J2-2}</script><hr><script type="math/tex; mode=display">\mathbf{J}[3]^{3\times1}=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\lambda_l }=-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l^2}\tag{J3}</script><ul><li><strong>推导 $\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\lambda_l }$:</strong></li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\lambda_l}&=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\lambda_l}\\&=\frac{\partial (\mathcal{P}^{c_j}_l- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\lambda_l}\\&=\frac{\partial (\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}- \hat{\overline{\mathcal{P} } }^{c_j}_l)}{\partial\lambda_l}\\&=-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l^2}\end{align*}\tag{J3-1}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍后端非线性优化中的视觉约束。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_4-后端非线性优化_IMU约束</title>
    <link href="https://lukeyalvin.top/posts/70ecd932.html"/>
    <id>https://lukeyalvin.top/posts/70ecd932.html</id>
    <published>2022-05-20T09:18:00.000Z</published>
    <updated>2022-05-20T10:08:49.921Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍后端非线性优化中的IMU约束。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-状态向量与目标函数"><a href="#Ⅰ-状态向量与目标函数" class="headerlink" title="Ⅰ.  状态向量与目标函数"></a>Ⅰ.  状态向量与目标函数</h1><p>状态向量共包括滑动窗口内的 $n+1$ 个所有 IMU 状态$\mathbf{x}_k,k\in[0,n]$（包括位置、朝向、速度、加速度计 $bias$ 和陀螺仪 $bias$）、 Camera 到 IMU 的外参 $\mathbf{x}^b_c$、 $m+1$ 个 3D 点的逆深度$\lambda_l,l\in[0,m]$：  </p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}&=[\mathbf{x}_0,\mathbf{x}_1,···,\mathbf{x}_n,\mathbf{x}^b_c,\lambda_0,\lambda_1,···,\lambda_m]\\\mathbf{x}_k&=[\mathbf{p}^w_{b_k},\mathbf{v}^w_{b_k},\mathbf{q}^w_{b_k},\mathbf{b}_a,\mathbf{b}_g],k\in[0,n]\\\mathbf{x}^b_c&=[\mathbf{p}^b_c,\mathbf{q}^b_c]\end{align*}\tag{1}</script><p> $n$ 是关键帧的总数，$m$ 是滑动窗口中的特征总数。 $λ_l$ 是第 $l$ 个特征与其第一次观察的逆深度。</p><p>使用 BA 公式，我们最小化所有测量残差的先验和马氏距离之和，以获得<strong>最大后验估计</strong>为：</p><script type="math/tex; mode=display">\underset{\mathcal{X} }{\min}\left\{\underbrace{\parallel \mathbf{r}_p-\mathbf{H}_p\mathcal{X} \parallel^2}_{边缘化的先验信息}+\underbrace{\sum_{k\in\mathcal{B} }\parallel\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})  \parallel^2_{\mathbf{P}^{b_k}_{b_{k+1} } } }_{IMU 测量残差}+\underbrace{\sum_{(l,j)\in\mathcal{C} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) \parallel^2_{\mathbf{P}^{c_j}_l })}_{视觉的重投影残差}\right\}\tag{2}</script><p>其中 $\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})$ 和 $\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) $ 分别是 IMU 和视觉测量的残差。 $\mathcal{B}$ 是所有 IMU 测量值的集合，$\mathcal{C}$  是在当前滑动窗口中至少观察到两次的特征集合。 $\{\mathbf{r}_p, \mathbf{H}_p\}$ 是来自边缘化的先验信息。 三种残差都是用马氏距离表示。</p><h1 id="Ⅱ-IMU-约束"><a href="#Ⅱ-IMU-约束" class="headerlink" title="Ⅱ. IMU 约束"></a>Ⅱ. IMU 约束</h1><h2 id="残差"><a href="#残差" class="headerlink" title="残差"></a>残差</h2><p>两帧之间的 PVQ 和 $bias$ 的变化量的差  :</p><script type="math/tex; mode=display">\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})=\begin{bmatrix}\delta {\alpha}^{b_k}_{b_{k+1} }\\\delta {\theta}^{b_k}_{b_{k+1} }\\\delta {\beta}^{b_k}_{b_{k+1} }\\\delta {b}_{a}\\\delta {b}_{g}\end{bmatrix}=\begin{align*}\begin{bmatrix}\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}+\frac{1}{2}g^w\Delta t_k^2-\mathbf{v}^w_{b_k}\Delta t_k)-\hat{\alpha}^{b_k}_{b_{k+1} }\\2[{\mathbf{q}^w_{b_k}}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz}\\\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_{k+1} }-\mathbf{v}^w_{b_k}+g^w\Delta t_k)-\hat{\beta}^{b_k}_{b_{k+1} }\\\mathbf{b}_{ab_{k+1} }-\mathbf{b}_{ab_k}\\\mathbf{b}_{wb_{k+1} }-\mathbf{b}_{wb_k}\\\end{bmatrix}\end{align*}\tag{3}</script><p>其中各增量关于 bias 的 Jacobian 可从公式 $(4)$ 的 大 Jacobian 中的相应位置获得。 上面与其中各增量关于 $bias$ 的 Jacobian 可从公式 $(4)$ 的大 Jacobian 中的相应位置获得。</p><script type="math/tex; mode=display">{\mathbf{J}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{J}_{k}\tag{4}</script><h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>待优化变量主要为两个时刻的 PVQ 以及 $bais$:</p><script type="math/tex; mode=display">\begin{align*}k时刻&： [\mathbf{p}^w_{b_k},\mathbf{q}^w_{b_k}],[\mathbf{v}^w_{b_k},\mathbf{b}_{a_k},\mathbf{b}_{w_k}]\\k+1时刻&：[\mathbf{p}^w_{b_{k+1} },\mathbf{q}^w_{b_{k+1} }],[\mathbf{v}^w_{b_{k+1}  },\mathbf{b}_{a_{k+1} },\mathbf{b}_{w_{k+1} }]\\\end{align*}</script><h2 id="Jacobian"><a href="#Jacobian" class="headerlink" title="Jacobian"></a>Jacobian</h2><p>计算 Jacobian 时，残差对应的求偏导对象为上面的优化变量，但是计算时采用扰动方式计算，即扰动为 ：</p><script type="math/tex; mode=display">\begin{align*}k时刻&： [\delta\mathbf{p}^w_{b_k},\delta\theta^w_{b_k}],[\delta\mathbf{v}^w_{b_k},\delta\mathbf{b}_{a_k},\delta\mathbf{b}_{w_k}]\\k+1时刻&：[\delta\mathbf{p}^w_{b_{k+1} },\delta\theta^w_{b_{k+1} }],[\delta\mathbf{v}^w_{b_{k+1}  },\delta\mathbf{b}_{a_{k+1} },\delta\mathbf{b}_{w_{k+1} }]\\\end{align*}</script><script type="math/tex; mode=display">\mathbf{J}[0]^{15\times7}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{p}^w_{b_k} },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{q}^w_{b_k} }]=\begin{bmatrix}-\mathbf{R}^{b_k}_w&\left[\mathbf{R}^{b_k}_w\left(\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}-\mathbf{v}^w_{b_k}\Delta t_k+\frac{1}{2}g^w\Delta t_k^2\right) \right]^{\land}\\0&-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]_{3\times3}\mathcal{L}\left[\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\\0&\left[\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_{k+1} }-\mathbf{v}^w_{b_k}+g^w\Delta t_k)\right]^{\land}\\0&0\\0&0\\\end{bmatrix}\tag{J0}</script><hr><ul><li><strong>推导 $\mathbf{J}[0]$</strong></li></ul><p>定义：$\mathbf{J}[0]_{[i,j]}$ 表示矩阵 $\mathbf{J}[0]$ 的 第 $i$  行 第 $j$ 列；</p><p>首先是 $\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{p}^w_{b_k} }$，显然，由公式 $(3)$，对于 $\mathbf{r}_{\mathcal{B} } $ 而言，只有 $\delta {\alpha}^{b_k}_{b_{k+1} }$ 对 $\mathbf{p}^w_{b_k}$ 求偏导才有值，其他为0，这就组成 $(J0)$ 里矩阵的第一列；</p><p>对于矩阵的 $\mathbf{J}[0]_{[2,1]}$ 和  $\mathbf{J}[0]_{[2,3]}$，可以使用旋转矩阵的左乘扰动模型来求：</p><p>这里为了书写方便，令 $\mathcal{P}^w=\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}+<br>\frac{1}{2}g^w\Delta t_k^2-\mathbf{v}^w_{b_k}\Delta t_k$</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta {\alpha}^{b_k}_{b_{k+1} } }{\partial \mathbf{p}^w_{b_k} }&=\frac{\partial \left[\mathbf{R}^{b_k}_w\mathcal{P}^w-\hat{\alpha}^{b_k}_{b_{k+1} }\right]}{\partial \mathbf{p}^w_{b_k} }\\&=\underset{\varphi\rightarrow0}{\lim}\frac{(\mathbf{R}^{b_k}_w\exp(\varphi^{\land}))^{-1}\mathcal{P}^w }{\delta\varphi}\\&\approx\underset{\varphi\rightarrow0}{\lim}\frac{(I-\varphi^{\land})\exp(\phi^{\land})\mathcal{P}^w-\exp(\phi^{\land})\mathcal{P} }{\delta\varphi}\\&=\underset{\varphi\rightarrow0}{\lim}-\frac{\varphi^{\land}\mathbf{R}^{b_k}_w\mathcal{P}^w }{\delta\varphi}\\&=\underset{\varphi\rightarrow0}{\lim}\frac{[\mathbf{R}^{b_k}_w\mathcal{P}^w]^{\land}\varphi }{\delta\varphi}\\&=[\mathbf{R}^{b_k}_w\mathcal{P}^w]^{\land}\end{align*}\tag{J0-1}</script><p>因此，对于$\mathbf{J}[0]_{[2,1]}$ 和  $\mathbf{J}[0]_{[2,3]}$，他们仅仅是 $\mathcal{P}^w$ 不同，推导过程都是一样的。</p><p>关键是对于$\mathbf{J}[0]_{[2,2]}$  的推导，是比较关键的，对应的雅可比为 $\frac{\partial \delta {\theta}^{b_k}_{b_{k+1} } }{\partial \mathbf{q}^w_{b_k} }$：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta {\theta}^{b_k}_{b_{k+1} } }{\partial \mathbf{q}^w_{b_k} }&=\frac{\partial 2[{\mathbf{q}^w_{b_k}}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz} }{\partial \mathbf{q}^w_{b_k} }\\&=2\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\left(\mathbf{q}_{b_k}^w\otimes\begin{bmatrix}1\\\frac{\delta\theta^{w}_{b_k} }{2} \end{bmatrix} \right)^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}-\left(\mathbf{q}_{b_k}^w\otimes\begin{bmatrix}1\\0\end{bmatrix} \right)^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=2\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\begin{bmatrix}1\\-\frac{\delta\theta^{w}_{b_k} }{2} \end{bmatrix}\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}-\begin{bmatrix}1\\0 \end{bmatrix}\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=2\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\left(\begin{bmatrix}1\\-\frac{\delta\theta^{w}_{b_k} }{2} \end{bmatrix}-\begin{bmatrix}1\\0 \end{bmatrix}\right)\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\begin{bmatrix}0\\-\delta\theta^{w}_{b_k} \end{bmatrix}\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\otimes\begin{bmatrix}0\\-\delta\theta^{w}_{b_k} \end{bmatrix}}{\delta {\theta}^{w}_{b_k} }\\&=-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\\\end{align*}\tag{J0-2}</script><p>对于四元数的左右乘，在第二节的$\mathrm{(IA-3)}$ 提到过，这里再次作展示：</p><p>我们设四元数 $\mathbf{q}=[x,y,z,s]$为 $\mathbf{q}=[w,s]$，则：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}_a)&=\Omega(w)+sI_{4\times4}=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\\\mathcal{L}(\mathbf{q}_a)&=\Psi(w)+sI_{4\times4}=\begin{bmatrix}w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\end{align*}\tag{5}</script><p>则有：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}^{-1})=\Omega(-w)+sI_{4\times4}&=\begin{bmatrix}w^{\land}&-w\\w^T&0\end{bmatrix}+sI_{4\times4}\\\mathcal{L}(\mathbf{q}^{-1})=\Omega(-w)+sI_{4\times4}&=\begin{bmatrix}-w^{\land}&-w\\w^T&0\end{bmatrix}+sI_{4\times4}\\\end{align*}\tag{6}</script><p> 如果我们只取左上角的 $3\times3$ 虚部部分，则有：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}^{-1})=sI_{3\times3}+w^{\land}=\mathcal{L}(\mathbf{q})_{3\times3}\\\mathcal{L}(\mathbf{q}^{-1})=sI_{3\times3}-w^{\land}=\mathcal{R}(\mathbf{q})_{3\times3}\end{align*}\tag{7}</script><p>故而 $\mathrm{(J0-2)}$ 可以整理如下：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta {\theta}^{b_k}_{b_{k+1} } }{\partial \mathbf{q}^w_{b_k} }&=-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\\&=-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]_{3\times3}\mathcal{L}\left[\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\end{align*}\tag{J0-3}</script><p><strong>证毕！</strong></p><hr><script type="math/tex; mode=display">\mathbf{J}[1]^{15\times9}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{v}^w_{b_k} },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{a_k} },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{w_k} }]=\begin{bmatrix}-\mathbf{R}^{b_k}_w\Delta t&-\mathbf{J}^{\alpha}_{b_a}&-\mathbf{J}^{\alpha}_{b_w}\\0&0&-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\mathbf{J}^{\gamma}_{b_w}\\-\mathbf{R}^{b_k}_w&-\mathbf{J}^{\beta}_{b_a}&-\mathbf{J}^{\beta}_{b_w}\\0&-\mathbf{I}&0\\0&0&-\mathbf{I}\end{bmatrix}\tag{J1}</script><hr><ul><li><strong>推导 $\mathbf{J}[1]$</strong></li></ul><p>首先第一列的求导都是直接可以看出来的，这里不做推导。</p><p>论文中， $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$  关于偏差的一阶近似可以写成：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&\approx \hat{\alpha}^{b_k}_{b_{k+1} }+\mathbf{J}^{\alpha}_{b_a}\delta b_{a_k}+\mathbf{J}^{\alpha}_{b_w}\delta b_{w_k}\\\beta^{b_k}_{b_{k+1} }&\approx \hat{\beta}^{b_k}_{b_{k+1} }+\mathbf{J}^{\beta}_{b_a}\delta b_{a_k}+\mathbf{J}^{\beta}_{b_w}\delta b_{w_k}\\\gamma^{b_k}_{b_{k+1} }&\approx \hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\end{align*}\tag{8}</script><p>其中 $\mathbf{J}^{\alpha}_{b_a}$ 和 是 $\mathbf{J}^{\alpha}_{b_{k+1} }$ 中的子块矩阵，其位置对应于 $\frac{\delta\alpha^{b_k}_{b_{k+1} } }{\delta b_{a_k} }$ 。 $\mathbf{J}^{\alpha}_{b_w}、\mathbf{J}^{\beta}_{b_a}、\mathbf{J}^{\beta}_{b_w}、\mathbf{J}^{\gamma}_{b_w}$ 也使用相同的含义。当偏差的估计发生轻微变化时，我们使用 $(8)$ 来近似地校正预积分结果，而不是重新传播。</p><p>这里主要对 $\mathbf{J[1]}_{[2,3]}$ 进行推导，对应的雅可比为 $\frac{\partial \delta\theta^{b_k}_{b_{k+1}} }{\partial\mathbf{q}^{w}_{k+1} }$:</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta\theta^{b_k}_{b_{k+1}} }{\partial b_{w_k} }&=\frac{\partial 2[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz} }{\partial b_{w_k} }\\&=2\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\left[\hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\right]}^{-1}-{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\left[\hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\0 \end{bmatrix}\right]}^{-1}}{\delta b_{w_k}}\\&=2\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\begin{bmatrix}0\\-\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}}\otimes{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1}}{\delta b_{w_k}}\\&=\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\begin{bmatrix}0\\-\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}}\otimes{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1}}{\delta b_{w_k}}\\&=\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\otimes\mathcal{R}\left[{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1} \right]\otimes{\begin{bmatrix}0\\-\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix} }}{\delta b_{w_k}}\\&=-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1} \right]\mathbf{J}^{\gamma}_{b_w}\\&=-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]_{3\times3}\mathcal{L}\left[\hat{\gamma}^{b_k}_{b_{k+1} } \right]_{3\times3}\mathbf{J}^{\gamma}_{b_w}\\&=-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\mathbf{J}^{\gamma}_{b_w}\end{align*}\tag{J1-1}</script><p><strong>证毕！</strong></p><hr><script type="math/tex; mode=display">\mathbf{J}[2]^{15\times7}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{p}^w_{b_{k+1} } },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{q}^w_{b_{k+1} } }]=\begin{bmatrix}\mathbf{R}^{b_k}_w&0\\0&\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\\0&0\\0&0\\0&0\\\end{bmatrix}\tag{J2}</script><hr><ul><li><strong>推导 $\mathbf{J}[2]$</strong></li></ul><p>主要是对 $\mathbf{J}[2]_{[2,2]}$ 进行推导，即 $\frac{\partial \delta\theta^{b_k}_{b_{k+1}} } {\partial \mathbf{q}^w_{b_{k+1} } }$：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta\theta^{b_k}_{b_{k+1}} } {\partial \mathbf{q}^w_{b_{k+1} } }&=\frac{\partial 2[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz} }{\partial \mathbf{q}^w_{b_{k+1} } }\\&=2\underset{\delta\theta^w_{b_{k+1} }\rightarrow0}{\lim}\frac{{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{\delta\theta^w_{b_{k+1} } }{2}\end{bmatrix}\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} -{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\begin{bmatrix}1\\0\end{bmatrix}\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} }{\delta\theta^w_{b_{k+1} } }\\&=\underset{\delta\theta^w_{b_{k+1} }\rightarrow0}{\lim}\frac{{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\begin{bmatrix}0\\\delta\theta^w_{b_{k+1} }\end{bmatrix}\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} }{\delta\theta^w_{b_{k+1} } }\\&=\underset{\delta\theta^w_{b_{k+1} }\rightarrow0}{\lim}\frac{\mathcal{L}[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }]\mathcal{R}[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} ]\begin{bmatrix}0\\\delta\theta^w_{b_{k+1} }\end{bmatrix}}{\delta\theta^w_{b_{k+1} } }\\&=\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\\&=\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\right]_{3\times3}\mathcal{L}\left[(\hat{\gamma}^{b_k}_{b_{k+1} }) \right]_{3\times3}\\&=\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\end{align*}</script><p><strong>证毕！</strong></p><hr><script type="math/tex; mode=display">\mathbf{J}[3]^{15\times9}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{v}^w_{b_{k+1} } },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{a_{k+1} } },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{w_{k+1} } }]=\begin{bmatrix}0&0&0\\0&0&0\\\mathbf{R}^{b_k}_w&0&0\\0&\mathbf{I}&0\\0&0&\mathbf{I}\\\end{bmatrix}\tag{J3}</script><p>这个不需要证，应该可以直接看出来。</p><hr><p>上面公式在代码中对应： <code>class IMUFactor : public ceres::SizedCostFunction&lt;15, 7, 9, 7, 9&gt;</code><br>对于 <code>Evaluate</code> 输入 <code>double const *const *parameters, parameters[0], parameters[1], parameters[2],parameters[3]</code> 分别对应 $4$ 个输入参数, 它们的长度依次是 $7,9,7,9$，分别对应 $4$ 个优化变量的<br>参数块。  </p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>代码 <code>IMUFactor::Evaluate()</code> 中 <code>residual</code> 还乘以一个<strong>信息矩阵</strong> <code>sqrt_info</code>，这是因为真正的优化项其实是 马氏距离：$d = \mathbf{r}^T\mathbf{P}^{-1}\mathbf{r}$， $\mathbf{P}$ 是协方差， 又因为 Ceres 只接受最小二乘优化， 也就是  $\min(e^Te)$, 所以把 $\mathbf{P}$ 做 LLT 分解， 即 $𝐿𝐿^T= \mathbf{P}^{-1}$, 则有：  </p><script type="math/tex; mode=display">d=\mathbf{r}^TLL^T\mathbf{r}=(L^T\mathbf{r})^T(L^T\mathbf{r})\tag{9}</script><p>令 $\mathbf{r}^{\prime} = L^T\mathbf{r}$ 作为新的优化误差, 这样就能用 Ceres 求解了。<strong>马氏距离距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大</strong>, 着重优化那些比较确定的残差。若写成 <code>“sqrt_info.setIdentity()”</code> 相当于不加权。  </p><p>其中，$\mathbf{P}$ 是协方差，由之前提出的递推公式得到：</p><p>协方差的迭代公式为：  </p><script type="math/tex; mode=display">{\mathbf{P}^{b_k}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{P}^{b_k}_{k}\mathbf{F}^T+\mathbf{V}\mathbf{Q}\mathbf{V}^T\tag{10}</script><p>其中， 初始值 $\mathbf{P}^{b_k}_{b_k}=0$。 $\mathbf{Q}$ 为表示噪声项的对角协方差矩阵：</p><script type="math/tex; mode=display">\mathbf{Q}^{18\times18}=\begin{bmatrix}\sigma^2_{a}&0&0&0&0&0\\0&\sigma^2_{w}&0&0&0&0\\0&0&\sigma^2_{a}&0&0&0\\0&0&0&\sigma^2_{w}&0&0\\0&0&0&0&\sigma^2_{b_a}&0\\0&0&0&0&0&\sigma^2_{b_w}\\\end{bmatrix}\tag{11}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍后端非线性优化中的IMU约束。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_3-PVQ增量误差、协方差及雅可比推导</title>
    <link href="https://lukeyalvin.top/posts/6eff9a87.html"/>
    <id>https://lukeyalvin.top/posts/6eff9a87.html</id>
    <published>2022-05-20T09:17:43.000Z</published>
    <updated>2022-05-20T10:05:40.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍PVQ增量误差、协方差及雅可比推导。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h2 id="Ⅰ-连续形式下"><a href="#Ⅰ-连续形式下" class="headerlink" title="Ⅰ.  连续形式下"></a>Ⅰ.  连续形式下</h2><h3 id="A-PVQ增量误差"><a href="#A-PVQ增量误差" class="headerlink" title="A. PVQ增量误差"></a>A. PVQ增量误差</h3><p>IMU 在每一个时刻积分出来的值是有误差的，下面我们对误差进行分析。首先我们直<br>接给出在 t 时刻误差项的导数 ：（即推导出 $(8)$ 的误差项的连续时间线性化方程）</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}\delta \dot{\alpha}^{b_k}_t\\\delta \dot{\beta}^{b_k}_t\\\delta \dot{\theta}^{b_k}_t\\\delta \dot{b}_{a_t}\\\delta \dot{b}_{w_t}\\\end{bmatrix}&=\begin{bmatrix}0&\mathbf{I}&0&0&0\\0&0&-\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}]^{\land}&-\mathbf{R}^{b_k}_t&0\\0&0&-[\hat{w}_t-b_{w_t}]^{\land}&0&-\mathbf{I}\\0&0&0&0&0\\0&0&0&0&0\\\end{bmatrix}\begin{bmatrix}\delta {\alpha}^{b_k}_t\\\delta {\beta}^{b_k}_t\\\delta {\theta}^{b_k}_t\\\delta {b}_{a_t}\\\delta {b}_{w_t}\\\end{bmatrix}+\begin{bmatrix}0&0&0&0\\-\mathbf{R}^{b_k}_t&0&0&0\\0&-\mathbf{I}&0&0\\0&0&\mathbf{I}&0\\0&0&0&\mathbf{I}\\\end{bmatrix}\begin{bmatrix}\mathbf{n}_a\\\mathbf{n}_w\\\mathbf{n}_{b_a}\\\mathbf{n}_{b_w}\end{bmatrix}\\&=\mathbf{F}_t\delta\mathbf{z}^{b_k}_t+\mathbf{G}_t\mathbf{n}_t\end{align*}\tag{1}</script><p>其中：$\mathbf{F}^{15\times15}_t,\mathbf{G}^{15\times12}_t,\delta{\mathbf{z}^{b_k}_t}^{15\times1},\mathbf{n}^{12\times1}_t$，下面给出其推导过程。</p><p>在推导之前，引入两个概念：</p><p>​    ① $true$：        真实测量值，包含了噪声 ，包括附加噪声和随机游走</p><p>​    ① $nominal$：无噪声的理论值  </p><ul><li><strong>对于 $\dot{\beta}^{b_k}_t$ 的推导：</strong></li></ul><p>易知$\delta \dot{\beta}^{b_k}_t={\dot{\beta}^{b_k}_t}_{true}-{\dot{\beta}^{b_k}_t}_{nominal}$，我们分别推导${\dot{\beta}^{b_k}_t}_{true}$ 以及${\dot{\beta}^{b_k}_t}_{nominal}$ :</p><script type="math/tex; mode=display">\begin{align*}{\dot{\beta}^{b_k}_t}_{true}&={\mathbf{R}^{b_k}_t}_{true}({\hat{a}_t}_{true}-{b_{a_t} }_{true})\\&=\mathbf{R}^{b_k}_t\exp(\delta\theta^{\land})(\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t})\\&=\mathbf{R}^{b_k}_t(I+\delta\theta^{\land})(\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t})\\&=\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t}+\delta\theta^{\land}(\hat{a}_t-b_{a_t})]\\&=\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t}-(\hat{a}_t-b_{a_t})^{\land}\delta\theta]\\{\dot{\beta}^{b_k}_t}_{nominal}&=\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})\end{align*}\tag{IA-1}</script><p>因此，可以得到：</p><script type="math/tex; mode=display">\begin{align*}\delta \dot{\beta}^{b_k}_t&={\dot{\beta}^{b_k}_t}_{true}-{\dot{\beta}^{b_k}_t}_{nominal}\\&=\mathbf{R}^{b_k}_t[-n_a-\delta b_{a_t}-(\hat{a}_t-b_{a_t})^{\land}\delta\theta]\\&=-\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})^{\land}\delta\theta-\mathbf{R}^{b_k}_t\delta b_{a_t}-\mathbf{R}^{b_k}_tn_a\end{align*}\tag{IA-2}</script><ul><li><strong>对于 $\dot{\theta}^{b_k}_t$ 的推导：</strong></li></ul><p>由公式 $(IA-5)$ 可知：</p><script type="math/tex; mode=display">\begin{align*}{\dot{\mathbf{q} }_t}_{true}&=\frac{1}{2}{\mathbf{q}_t}_{true}\otimes\begin{bmatrix}w_{ture}\\0\end{bmatrix}\\&=\frac{1}{2}\mathbf{q}_t\otimes\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}\\{\dot{\mathbf{q} }_t}_{nominal}&=\dot{\mathbf{q} }_t\\&=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\\\end{align*}\tag{IA-3}</script><p>根据导数的性质，又有：</p><script type="math/tex; mode=display">\begin{align*}{\dot{\mathbf{q} }_t}_{true}&=\dot{\overbrace{\mathbf{q}_t\otimes\delta \mathbf{q} } }\\&=\dot{\mathbf{q} }_t\otimes\delta \mathbf{q}+\mathbf{q}_t\otimes\dot{\delta \mathbf{q} }\\&=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}+\mathbf{q}_t\otimes\dot{\delta \mathbf{q} }\\\end{align*}\tag{IA-4}</script><p>综合$ (\mathrm{IA-3})$ 和 $ (\mathrm{IA-4})$：</p><script type="math/tex; mode=display">\begin{align*}&\frac{1}{2}\mathbf{q}_t\otimes\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}+\mathbf{q}_t\otimes\dot{\delta \mathbf{q} }\\&\Leftrightarrow \frac{1}{2}\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}=\frac{1}{2}\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}+\dot{\delta \mathbf{q} }\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}-\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\mathcal{R}\left(\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}  \right)\delta \mathbf{q}-\mathcal{L}\left(\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix} \right)\delta\mathbf{q}\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\left(\begin{bmatrix}-(\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t})^{\land}&\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\-(\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t})^T&0 \end{bmatrix}-\begin{bmatrix}(\hat{w}_t-b_{w_t})^{\land}&\hat{w}_t-b_{w_t}\\-(\hat{w}_t-b_{w_t})^T&0\end{bmatrix}\right)\begin{bmatrix}\frac{\delta\theta}{2}\\1\end{bmatrix}\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\begin{bmatrix}-(2\hat{w}_t-2b_{w_t}-n_w-\delta b_{w_t})^{\land}&-n_w-\delta b_{w_t}\\(n_w+\delta b_{w_t})^T&0 \end{bmatrix}\begin{bmatrix}\frac{\delta\theta}{2}\\1\end{bmatrix}\end{align*}</script><p>上式左侧也可以写成：</p><script type="math/tex; mode=display">2\dot{\delta \mathbf{q} }=\begin{bmatrix}\dot{\delta\theta}\\0\end{bmatrix}=\begin{bmatrix}-(2\hat{w}_t-2b_{w_t}-n_w-\delta b_{w_t})^{\land}&-n_w-\delta b_{w_t}\\(n_w+\delta b_{w_t})^T&0 \end{bmatrix}\begin{bmatrix}\frac{\delta\theta}{2}\\1\end{bmatrix}</script><p>故而，可得到：</p><script type="math/tex; mode=display">\begin{align*}\dot{\delta\theta}&=-(2\hat{w}_t-2b_{w_t}-n_w-\delta b_{w_t})^{\land}\frac{\delta\theta}{2}-n_w-\delta b_{w_t}\\&\approx-(\hat{w}_t-b_{w_t})^{\land}\delta\theta-n_w-\delta b_{w_t}\end{align*}\tag{IA-5}</script><ul><li><strong>其他的推导</strong></li></ul><p>对于 $\delta \dot{\alpha}^{b_k}_t$ 而言，我们知道加速度和速度之间就是相差一个导数，因此：$\delta \dot{\alpha}^{b_k}_t=\delta \beta^{b_k}_t$</p><p>对于 $\delta \dot{b}_{a_t}$ 和 $\delta \dot{b}_{w_t}$​ ，已知加速度偏差和陀螺仪偏置被建模为<strong>随机游走</strong>，其导数为高斯，$n_{b_a}\sim\mathcal{N}(0, \sigma^2_{b_a}),n_{b_w}\sim\mathcal{N}(0, \sigma^2_{b_w})$：</p><script type="math/tex; mode=display">\dot{b}_{a_t}=n_{b_a},\ \ \ \ \ \ \dot{b}_{w_t}=n_{b_w}</script><p>故而： $\delta \dot{b}_{a_t}=\delta\mathbf{n_{b_a} }$  ,    $\delta \dot{b}_{w_t}=\delta\mathbf{n_{b_w} }$  </p><h3 id="B-协方差及雅可比"><a href="#B-协方差及雅可比" class="headerlink" title="B. 协方差及雅可比"></a>B. 协方差及雅可比</h3><p>对于公式 $(1)$ 可以简写为：</p><script type="math/tex; mode=display">\delta\dot{\mathbf{z} }^{b_k}_t=\mathbf{F}_t\delta\mathbf{z}^{b_k}_t+\mathbf{G}_t\mathbf{n}_t\tag{2}</script><p>根据导数定义可知：$\delta\dot{\mathbf{z} }^{b_k}_t=\underset{\delta t\rightarrow0}{\lim}\frac{\delta\mathbf{z}^{b_k}_{t+\delta t}+\delta\mathbf{z}^{b_k}_t}{\delta t}$   </p><script type="math/tex; mode=display">\begin{align*}\delta\mathbf{z}^{b_k}_{t+\delta t}&=\delta\mathbf{z}^{b_k}_{t}+\delta\dot{\mathbf{z} }^{b_k}_t \delta t\\&=(\mathbf{I}+\mathbf{F}_t\delta t)\delta\mathbf{z}^{b_k}_t+(\mathbf{G}_t\delta t)\mathbf{n}_t\\&=\mathbf{F}\delta\mathbf{z}^{b_k}_t+\mathbf{V}\mathbf{n}_t\end{align*}\tag{3}</script><p>其中，$\mathbf{F}=\mathbf{I}+\mathbf{F}_t\delta t,\mathbf{V}=\mathbf{G}_t\delta t$。</p><p>这里我们对公式 $(3)$ 的 IMU 误差运动方程再说明，将上式和 EKF 对比可知，上式恰好给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测量误差与上一个时刻的成线性关系，这样<strong>我们根据当前时刻的值，可以预测出下一个时刻的均值和协方差</strong>，而公式 $(3)$ 给出的是均值预测，协方差预测公式如下：  </p><script type="math/tex; mode=display">\mathbf{P}^{b_k}_{t+\delta t}=(\mathbf{I}+\mathbf{F}_t\delta t)\mathbf{P}^{b_k}_{t}(\mathbf{I}+\mathbf{F}_t\delta t)^T+(\mathbf{G}_t\delta t)\mathbf{Q}_t(\mathbf{G}_t\delta t)^T,t\in[k,k+1]\tag{4}</script><p>上式给出了协方差的迭代公式，初始值 $\mathbf{P}^{b_k}_{b_k}=0$。其中， $\mathbf{Q}$ 为表示噪声项的对角协方差矩阵：  </p><script type="math/tex; mode=display">\mathbf{Q}^{12\times12}=\begin{bmatrix}\delta^2_{a}&0&0&0\\0&\delta^2_{w}&0&0\\ 0&0&\delta^2_{b_a}&0\\  0&0&0&\delta^2_{b_w}\\ \end{bmatrix}\tag{5}</script><p>另外根据 $(3)$ 式可获得误差项的 Jacobian 的迭代公式：  </p><script type="math/tex; mode=display">\mathbf{J}_{t+\delta t}=(\mathbf{I}+\mathbf{F}_t\delta t)\mathbf{J}_\tag{6}t</script><p>其中，Jacobian 的初始值 $\mathbf{J}^{b_k}_{b_k}=\mathbf{I}$</p><h2 id="Ⅱ-离散形式下"><a href="#Ⅱ-离散形式下" class="headerlink" title="Ⅱ. 离散形式下"></a>Ⅱ. 离散形式下</h2><h3 id="A-PVQ增量误差-1"><a href="#A-PVQ增量误差-1" class="headerlink" title="A. PVQ增量误差"></a>A. PVQ增量误差</h3><p>我们首先直接给出 PVQ 增量误差在离散形式下的矩阵形式，为了与代码一致，我们修改下变量顺序，这和代码中 <code>midPointIntegration()</code> 函数是一致的。 （ 但不知为何计算的 V 中与前四个噪声项相关的差个负号？ ）  </p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}\delta\alpha_{k+1}\\ \delta\theta_{k+1}\\ \delta\beta_{k+1}\\ \delta b_{a_{k+1} }\\ \delta b_{w_{k+1} }\\ \end{bmatrix}&=\begin{bmatrix}\mathbf{I}&f_{12}&\delta t&f_{14}&f_{15}\\0&f_{22}&0&0&-\delta t\\0&f_{32}&\mathbf{I}&f_{34}&f_{35}\\0&0&0&\mathbf{I}&0\\0&0&0&0&\mathbf{I}\end{bmatrix}\begin{bmatrix}\delta\alpha_k\\\delta\theta_k\\\delta\beta_k\\\delta b_{a_k}\\\delta b_{w_k}\\ \end{bmatrix}+\begin{bmatrix}g_{11}&g_{12}&g_{13}&g_{14}&0&0\\0&\frac{1}{2}\delta t&0&\frac{1}{2}\delta t&0&0\\\frac{1}{2}\mathbf{R}_k\delta t&g_{32}&\frac{1}{2}\mathbf{R}_k\delta t&g_{34}&0&0\\0&0&0&0&\delta t&0\\0&0&0&0&0&\delta t\end{bmatrix}\begin{bmatrix}\mathbf{n}_{a_k}\\ \mathbf{n}_{w_k}\\ \mathbf{n}_{a_{k+1} }\\ \mathbf{n}_{w_{k+1} }\\ \mathbf{n}_{b_a}\\ \mathbf{n}_{b_w}\\ \end{bmatrix}\\&=\mathbf{F}\begin{bmatrix}\delta\alpha_k\\\delta\theta_k\\\delta\beta_k\\\delta b_{a_k}\\\delta b_{w_k}\\ \end{bmatrix}+\mathbf{G}\begin{bmatrix}\mathbf{n}_{a_k}\\ \mathbf{n}_{w_k}\\ \mathbf{n}_{a_{k+1} }\\ \mathbf{n}_{w_{k+1} }\\ \mathbf{n}_{b_a}\\ \mathbf{n}_{b_w}\\ \end{bmatrix}\\\end{align*}\tag{7}</script><p>$\mathbf{F},\mathbf{G}$为两个时刻间的协方差传递矩阵。</p><p>下面给出推导过程。</p><p>首先是两个比较简单的：</p><script type="math/tex; mode=display">\delta b_{a_{k+1} }=\delta b_{a_k}+\delta t\mathbf{n}_a \\\delta b_{w_{k+1} }=\delta b_{w_k}+\delta t\mathbf{n}_w \\</script><p>主要推导其他三个：$\delta\alpha_{k+1}, \delta\theta_{k+1}, \delta\beta_{k+1}$，分别推导：</p><ul><li><strong>对于 $\delta\theta_{k+1}$ 的推导</strong></li></ul><p>由公式 $\mathrm{(IA-5)}$ 可知，角度误差的连续形式为：</p><script type="math/tex; mode=display">\dot{\delta\theta}\approx-(\hat{w}_t-b_{w_t})^{\land}\delta\theta-n_w-\delta b_{w_t}</script><p>则离散形式为：</p><script type="math/tex; mode=display">\dot{\delta\theta_k}\approx-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta\theta_k-\frac{n_{w_k}+n_{w_{k+1} } }{2}-\delta b_{w_k}</script><p>由导数的定义：</p><script type="math/tex; mode=display">\begin{align*}\delta\theta_{k+1} &=\delta\theta_{k}+\dot{\delta\theta_{k} }\ \delta t\\&=f_{22}\ {\color{red}\delta\theta_{k} }-\delta t\  {\color{red}\delta b_{w_k} }-\frac{\delta t}{2}{\color{red}n_{w_k} }  -\frac{\delta t}{2}{\color{red}n_{w_{k+1} } }\end{align*}\tag{IIA-1}</script><p>其中，</p><script type="math/tex; mode=display">f_{22}=I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t\tag{IIA-2}</script><ul><li><strong>对于 $\delta\beta_{k+1}$ 的推导</strong></li></ul><p>由公式 $\mathrm{(IA-2)}$ 可知，速度误差的连续形式为：</p><script type="math/tex; mode=display">\delta \dot{\beta}^{b_k}_t=-\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})^{\land}\delta\theta-\mathbf{R}^{b_k}_t\delta b_{a_t}-\mathbf{R}^{b_k}_tn_a</script><p>则离散形式为：</p><script type="math/tex; mode=display">\delta \dot{\beta}^{b_k}_t=-\frac{\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}\delta\theta_k+\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\delta\theta_{k+1} }{2}-\frac{\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1} }{2}\delta b_{a_k}-\frac{\mathbf{R}^{b_k}_kn_{a_k}+\mathbf{R}^{b_{k} }_{k+1}n_{a_{k+1} } }{2}</script><p>将公式 $\mathrm{(IIA-1)}$ 代入上式：</p><script type="math/tex; mode=display">\begin{align*}\delta \dot{\beta}^{b_k}_t=&-\frac{1}{2}\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}\delta\theta_k\\&-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\left\{\left[ I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t \right]\delta\theta_{k}-\frac{n_{w_k}+n_{w_{k+1} } }{2}\delta t-\delta b_{w_k}\delta t\right\}\\&-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta b_{a_k}-\frac{1}{2}\mathbf{R}^{b_k}_kn_{a_k}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}n_{a_{k+1} }\\=&\left\{-\frac{1}{2}\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\left[ I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t \right]\right\}\delta\theta_{k}\\&+\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}n_{w_k}+\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}(\hat{a}_{k+1} -b_{a_k})^{\land}n_{w_{k+1} }+\frac{\delta t}{2}\mathbf{R}^{b_{k} }_{k+1}(\hat{a}_{k+1} -b_{a_k})^{\land}\delta b_{w_k}\\&-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta b_{a_k}-\frac{1}{2}\mathbf{R}^{b_k}_kn_{a_k}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}n_{a_{k+1} }\\\end{align*}</script><p>同理，由导数的定义可知：</p><script type="math/tex; mode=display">\begin{align*}\delta \beta^{b_k}_{k+1}&=\delta \beta^{b_k}_k+\delta \dot{\beta}^{b_k}_t\ \delta t\\=&f_{32}\ {\color{red}\delta\theta_k}+{\color{red}\delta \beta^{b_k}_k}-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ {\color{red}\delta b_{a_k} }+f_{35}\ {\color{red}\delta b_{w_k} }\\&-\frac{1}{2}\mathbf{R}^{b_k}_k\delta t\ {\color{red}n_{a_k} }+g_{32}\ {\color{red}n_{w_k} }-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}\delta t\ {\color{red}n_{a_{k+1} } }+g_{34}\ {\color{red}n_{w_{k+1} } }\end{align*}\tag{IIA-3}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}f_{32}&=-\frac{1}{2}\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}\delta t-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\left[ I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t \right]\delta t\\f_{35}&=\frac{\delta t}{2}\mathbf{R}^{b_{k} }_{k+1}(\hat{a}_{k+1} -b_{a_k})^{\land}\delta t^2\\g_{32}&=\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\delta t^2\\g_{34}&=\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\delta t^2\\\end{align*}\tag{IIA-4}</script><ul><li><strong>对于 $\delta\alpha_{k+1}$ 的推导</strong></li></ul><p>我们知道加速度和速度之间就是相差一个导数，因此：$\delta \dot{\alpha}^{b_k}_t=\delta \beta^{b_k}_t$</p><p>则离散形式为：</p><script type="math/tex; mode=display">\begin{align*}\delta \dot{\alpha}^{b_k}_k=&\frac{1}{2}(\delta \beta^{b_k}_k+\delta \beta^{b_k}_{k+1})\\=&\frac{1}{2}(\delta \beta^{b_k}_k+\delta \beta^{b_k}_k+f_{32}\ \delta\theta_k+f_{35}\ \delta b_{w_k}+g_{32}\ n_{w_k}+g_{34}\ n_{w_{k+1} }\\&-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{1}{2}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} })\\=&\delta \beta^{b_k}_k+\frac{1}{2}f_{32}\ \delta\theta_k+\frac{1}{2}f_{35}\ \delta b_{w_k}+\frac{1}{2}g_{32}\ n_{w_k}+\frac{1}{2}g_{34}\ n_{w_{k+1} }\\&-\frac{1}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{1}{4}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{1}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} }\\\end{align*}</script><p>同理，由导数的定义可知：</p><script type="math/tex; mode=display">\begin{align*}\delta\alpha_{k+1}&=\delta\alpha_{k}+\delta \dot{\alpha}^{b_k}_k\ \delta t\\=&\delta\alpha_{k}+(\delta \beta^{b_k}_k+\frac{1}{2}f_{32}\ \delta\theta_k+\frac{1}{2}f_{35}\ \delta b_{w_k}+\frac{1}{2}g_{32}\ n_{w_k}+\frac{1}{2}g_{34}\ n_{w_{k+1} }\\&-\frac{1}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{1}{4}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{1}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} })\delta t\\=&\delta\alpha_{k}+\delta \beta^{b_k}_k\delta t+\frac{\delta t}{2}f_{32}\ \delta\theta_k+\frac{\delta t}{2}f_{35}\ \delta b_{w_k}+\frac{\delta t}{2}g_{32}\ n_{w_k}+\frac{\delta t}{2}g_{34}\ n_{w_{k+1} }\\&-\frac{\delta t}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{\delta t}{4}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} }\\=&{\color{red}\delta\alpha_{k} }+\frac{\delta t}{2}f_{32}\ {\color{red}\delta\theta_k}+\delta t\ {\color{red}\delta \beta^{b_k}_k}-\frac{\delta t}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ {\color{red}\delta b_{a_k} }+\frac{\delta t}{2}f_{35}\ {\color{red}\delta b_{w_k} }\\&-\frac{\delta t}{4}\mathbf{R}^{b_k}_k\delta t\ {\color{red}n_{a_k} }+\frac{\delta t}{2}g_{32}\ {\color{red}n_{w_k} }-\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ {\color{red}n_{a_{k+1} } }+\frac{\delta t}{2}g_{34}\ {\color{red}n_{w_{k+1} } }\\\end{align*}\tag{IIA-5}</script><p>所以：</p><script type="math/tex; mode=display">\begin{align*}f_{12}&=\frac{\delta t}{2}f_{32}\\f_{14}&=-\frac{\delta t}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\\f_{15}&=\frac{\delta t}{2}f_{35}\\g_{11}&=-\frac{\delta t}{4}\mathbf{R}^{b_k}_k\delta t\\g_{12}&=\frac{\delta t}{2}g_{32}\\g_{13}&=-\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\\g_{14}&=\frac{\delta t}{2}g_{34}\\\end{align*}\tag{IIA-6}</script><h3 id="B-协方差及雅可比-1"><a href="#B-协方差及雅可比-1" class="headerlink" title="B. 协方差及雅可比"></a>B. 协方差及雅可比</h3><p>公式 $(7)$ 可以简写为：</p><script type="math/tex; mode=display">\delta{\mathbf{z}_{k+1} }^{15\times1}=\mathbf{F}^{15\times15}\delta{\mathbf{z}_k}^{15\times1}+\mathbf{V}^{15\times18}\mathbf{Q}^{18\times1}\tag{8}</script><p>协方差的迭代公式为：  </p><script type="math/tex; mode=display">{\mathbf{P}^{b_k}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{P}^{b_k}_{k}\mathbf{F}^T+\mathbf{V}\mathbf{Q}\mathbf{V}^T\tag{9}</script><p>其中， 初始值 $\mathbf{P}^{b_k}_{b_k}=0$。 $\mathbf{Q}$ 为表示噪声项的对角协方差矩阵：  </p><script type="math/tex; mode=display">\mathbf{Q}^{18\times18}=\begin{bmatrix}\sigma^2_{a}&0&0&0&0&0\\0&\sigma^2_{w}&0&0&0&0\\0&0&\sigma^2_{a}&0&0&0\\0&0&0&\sigma^2_{w}&0&0\\0&0&0&0&\sigma^2_{b_a}&0\\0&0&0&0&0&\sigma^2_{b_w}\\\end{bmatrix}\tag{10}</script><p>另外根据 $(8)$ 式可获得误差项的 Jacobian 的迭代公式：  </p><script type="math/tex; mode=display">{\mathbf{J}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{J}_{k}\tag{11}</script><p>其中， Jacobian 的初始值为 $\mathbf{J}_k= \mathbf{I}$。 这里计算出来的 $\mathbf{J}_{k+1}$ 只是为了给后面提供对 $bias$ 的 Jacobian。  </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍PVQ增量误差、协方差及雅可比推导。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_2-IMU预积分公式推导</title>
    <link href="https://lukeyalvin.top/posts/9c201995.html"/>
    <id>https://lukeyalvin.top/posts/9c201995.html</id>
    <published>2022-05-20T09:17:31.000Z</published>
    <updated>2022-05-20T11:55:25.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍IMU预积分公式推导。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="VINS公式推导：IMU预积分公式推导"><a href="#VINS公式推导：IMU预积分公式推导" class="headerlink" title="VINS公式推导：IMU预积分公式推导"></a>VINS公式推导：IMU预积分公式推导</h1><h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><p>我们将 $(·)^w$ 视为世界坐标系。重力方向与世界坐标系的 $z$ 轴对齐。$ (·)^b$是body 坐标系，我们定义它和IMU 坐标系一样。$ (·)^c $ 是相机坐标系。</p><p>我们使用旋转矩阵 $R$ 和 Hamilton 四元数 $q$ 来表示旋转。我们主要在状态向量中使用四元数，但旋转矩阵也用于方便地旋转三维向量。  $q^w_b , p^w_b$ 是从本体坐标系到世界坐标系的旋转和平移。$b_k$ 是拍摄第 $k$ 张图像时的本体坐标系。 $c_k$ 是拍摄第 $k$ 张图像时的相机帧。 $\otimes$ 表示两个四元数之间的乘法运算。$g^w = [0, 0, g]^T$ 是世界坐标系中的重力矢量。最后，我们将 $\hat{(·)}$ 表示为某个量的噪声测量或估计。</p><p>···Ⅳ·Ⅴ·Ⅵ·Ⅶ·Ⅷ·Ⅸ·Ⅹ·Ⅺ·Ⅻ</p><h2 id="IMU-噪声模型"><a href="#IMU-噪声模型" class="headerlink" title="IMU 噪声模型"></a>IMU 噪声模型</h2><p>IMU 的原始陀螺仪和加速度计测量值 $\hat{w}$ 和 $\hat{a}$ 由下式给出：</p><script type="math/tex; mode=display">\begin{align*}\hat{a}_t&=a_t+b_{a_t}+R^t_wg^w+n_a\\\hat{w}_t&=w_t+b_{w_t}+n_w\end{align*}\tag{1}</script><p>我们假设加速度和陀螺仪测量中的<strong>附加噪声</strong>是高斯噪声，$n_a\sim\mathcal{N}(0,\sigma^2_a),n_w\sim\mathcal{N}(0,\sigma^2_w)$。加速度偏差和陀螺仪偏差被建模为<strong>随机游走</strong>，其导数为高斯，$n_{b_a}\sim\mathcal{N}(0, \sigma^2_{b_a}),n_{b_w}\sim\mathcal{N}(0, \sigma^2_{b_w})$：</p><script type="math/tex; mode=display">\dot{b}_{a_t}=n_{b_a},\ \ \ \ \ \ \dot{b}_{w_t}=n_{b_w}\tag{2}</script><h2 id="Ⅰ-当前时刻-PVQ"><a href="#Ⅰ-当前时刻-PVQ" class="headerlink" title="Ⅰ.  当前时刻 PVQ"></a>Ⅰ.  当前时刻 PVQ</h2><h3 id="A-连续形式"><a href="#A-连续形式" class="headerlink" title="A.连续形式"></a>A.连续形式</h3><p><img src="/images/VINS-Mono-2-IMU预积分公式推导/image-20220520195515606.png" alt="image-20220520195515606" style="zoom: 50%;" /></p><p>将第 $k$ 帧和第 $k+1$ 帧之间的所有 IMU 进行积分，可得第 $k+1$ 帧的位置、速度和旋转<br>（ PVQ）,作为视觉估计的初始值，这里的旋转采用的四元数。  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{p}^w_{b_{k+1} }&=\mathbf{p}^w_{b_k}+\mathbf{v}^w_{b_k}\Delta t_k+\iint_{t\in[t_k, t_{k+1}]}(\mathbf{R}^w_t(\hat{a}_t-b_{a_t}-n_a)-g^w)dt^2\\\mathbf{v}^w_{b_{k+1} }&=\mathbf{v}^w_{b_k}+\int_{t\in[t_k, t_{k+1}]}(\mathbf{R}^w_t(\hat{a}_t-b_{a_t}-n_a)-g^w)dt\\\mathbf{q}^w_{b_{k+1} }&=\mathbf{q}^w_{b_k}\otimes\int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t}-n_w)\mathbf{q}^{b_k}_tdt\end{align*}\tag{3}</script><p>其中 $\hat{w}$ 和 $\hat{a}$ 分别是 IMU 的原始陀螺仪和加速度计测量值，$\Delta t_k$ 是时间间隔  $[t_k, t_{k+1}]$ 之间的持续时间。且</p><script type="math/tex; mode=display">\Omega(w)=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix},w^{\land}=\begin{bmatrix}0&-w_z&w_y\\w_z&0&-w_x\\-w_y&w_x&0\end{bmatrix}\tag{4}</script><p>其中，$w=\hat{w}_t-b_{w_t}-n_w$</p><p>对于基于四元数的IMU积分，这里做进一步推导，</p><p>公式(1)的 IMU 连续形式下的旋转状态推导如下，首先可写成：  </p><script type="math/tex; mode=display">\mathbf{q}^w_{b_{k+1} }=\mathbf{q}^w_{b_{k} }\otimes\int_{t\in[k,k+1]}\dot{\mathbf{q}}_tdt\tag{IA-1}</script><p>设四元数 $\mathbf{q}=[x,y,z,s]$，由四元数的左乘右乘：</p><script type="math/tex; mode=display">\begin{align*}\mathbf{q}_a\otimes\mathbf{q}_b&=\mathcal{R}(\mathbf{q}_b)\otimes\mathbf{q}_a=\begin{bmatrix}s_b&z_b&-y_b&x_b\\-z_b&s_b&x_b&y_b\\y_b&-x_b&s_b&z_b\\-x_b&-y_b&-z_b&s_b\\\end{bmatrix}\begin{bmatrix}x_a\\y_a\\z_a\\s_a\end{bmatrix}\\&=\mathcal{L}(\mathbf{q}_a)\otimes\mathbf{q}_b=\begin{bmatrix}s_a&-z_a&y_a&x_a\\z_a&s_a&-x_a&y_a\\-y_a&x_a&s_a&z_a\\-x_a&-y_a&-z_a&s_a\\\end{bmatrix}\begin{bmatrix}x_b\\y_b\\z_b\\s_b\end{bmatrix}\end{align*}\tag{IA-2}</script><p>为了简化以上的形式，我们设四元数 $\mathbf{q}=[x,y,z,s]$为 $\mathbf{q}=[w,s]$，则：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}_a)&=\Omega(w)+sI_{4\times4}=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\\\mathcal{L}(\mathbf{q}_a)&=\Psi(w)+sI_{4\times4}=\begin{bmatrix}w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\end{align*}\tag{IA-3}</script><p> 因此，可以推导<strong>四元数的导数</strong>：这里也可以参考：<a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0">四元数求导</a></p><script type="math/tex; mode=display">\begin{align*}\dot{\mathbf{q} }_t&=\underset{\delta t}{\lim}\frac{1}{\delta t}(\mathbf{q}_{t+\delta t}-\mathbf{q}_t)\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}(\mathbf{q}_t\otimes\mathbf{q}^t_{t+\delta t}-\mathbf{q}_t\otimes\begin{bmatrix}0\\1\end{bmatrix})\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}\left(\mathbf{q}_t\otimes\begin{bmatrix}\mathbf{n}\sin\frac{\theta}{2}\\\cos\frac{\theta}{2}\end{bmatrix}-\mathbf{q}_t\otimes\begin{bmatrix}0\\1\end{bmatrix}\right)\\&\approx\underset{\delta t}{\lim}\frac{1}{\delta t}\left(\mathbf{q}_t\otimes\begin{bmatrix}\mathbf{n}\frac{\theta}{2}\\1\end{bmatrix}-\mathbf{q}_t\otimes\begin{bmatrix}0\\1\end{bmatrix}\right)\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}\left[\mathcal{R}\left(\begin{bmatrix}\mathbf{n}\frac{\theta}{2}\\1\end{bmatrix}\right)-\mathcal{R}\left(\begin{bmatrix}0\\1\end{bmatrix}\right)\right]\mathbf{q}_t\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}\begin{bmatrix}-\frac{\theta\mathbf{n}}{2}^{\land}&\frac{\theta\mathbf{n}}{2}\\-\frac{\theta\mathbf{n}}{2}^T&0\end{bmatrix}\mathbf{q}_t\end{align*}\tag{IA-4}</script><p>其中，$\mathbf{n}$ 表示旋转轴，而角速度定义有：$w=\underset{\delta t}{\lim}\frac{\mathbf{n}\theta}{\delta t}$，则有：</p><script type="math/tex; mode=display">\dot{\mathbf{q} }_t=\frac{1}{2}\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix}\mathbf{q}_t=\frac{1}{2}\Omega(w)\mathbf{q}_t=\frac{1}{2}\mathcal{R}\left(\begin{bmatrix}w\\0\end{bmatrix}\right)\mathbf{q}_t=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}w\\0\end{bmatrix}\tag{IA-5}</script><h3 id="B-中值法离散形式"><a href="#B-中值法离散形式" class="headerlink" title="B.中值法离散形式"></a>B.中值法离散形式</h3><p>公式 $(1)$ 给出的是连续时刻的相机当前 PVQ 的迭代公式，实际上，IMU在工作的时候是离散采集数据，所以代码中使用的也是离散形式，为了跟代码一致，下面给出基于中值法的公式，（还有基于欧拉法的公式，但是代码中使用的是前者）， 即从第 $i$ 个 IMU 时刻到第 $i+1$ 个 IMU 时刻的积分过程， 这与 <code>Estimator::processIMU()</code> 函数中的 <code>Ps[j]</code>、 <code>Rs[j]</code> 和 <code>Vs[j]</code> 是一致的，（代码中的 $j$ 时刻即为此处的 $i+1$），IMU 积分出来的第 $j$ 时刻的物理量可以作为第 $j$ 帧图像的初始值。  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{p}^w_{b_{i+1} }&=\mathbf{p}^w_{b_i}+\mathbf{v}^w_{b_i}\delta t+\frac{1}{2}\overline{\hat{a} }_i\delta t^2\\\mathbf{v}^w_{b_{i+1} }&=\mathbf{v}^w_{b_i}+\overline{\hat{a} }_i\delta t\\\mathbf{q}^w_{b_{i+1} }&=\mathbf{q}^w_{b_i}\otimes\begin{bmatrix} 1\\\frac{1}{2}\overline{\hat{w} }_i\delta t \end{bmatrix}\end{align*}\tag{5}</script><p>其中使用 mid-point 方法，即两个相邻时刻 $i$ 到 $j$ 的位姿是用两个时刻的测量值 $ a,w $ 的平均值来计算：</p><script type="math/tex; mode=display">\begin{align*}\overline{\hat{a} }_i&=\frac{1}{2}[\mathbf{q}_i(\hat{a}_i-b_{a_i})-g^w+\mathbf{q}_{i+1}(\hat{a}_{i+1}-b_{a_i})-g^w]\\\overline{\hat{w} }_i&=\frac{1}{2}(\hat{w}_i+\hat{w}_{i+1})-b_{w_i}\end{align*}\tag{6}</script><h2 id="Ⅱ-两帧之间-PVQ"><a href="#Ⅱ-两帧之间-PVQ" class="headerlink" title="Ⅱ. 两帧之间 PVQ"></a>Ⅱ. 两帧之间 PVQ</h2><h3 id="A-连续形式-1"><a href="#A-连续形式-1" class="headerlink" title="A.连续形式"></a>A.连续形式</h3><p>观察公式 $(3)$ 可知， IMU 的预积分需要依赖与第 $k$ 帧的 $\mathbf{v}$ 和 $\mathbf{R}$ ，当我们在后端进行非线性优化时，需要迭代更新第 $k$ 帧的 $\mathbf{v}$ 和 $\mathbf{R}$ ，这将导致我们需要根据每次迭代后值重新进行积分，这将非常耗时。</p><p>因此，我们考虑将优化变量从第 $k$ 帧到第 $k+1$ 帧的 IMU 预积分项中分离开来， 通过对公式 $(3)$ 左右两侧各乘 $\mathbf{R}^{b_k}_{w}$，可化简为：  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{R}^{b_k}_w\mathbf{p}^w_{b_{k+1} }&=\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_k}+\mathbf{v}^w_{b_k}\Delta t_k-\frac{1}{2}g^w\Delta t_k^2)+\alpha^{b_k}_{b_{k+1} }\\\mathbf{R}^{b_k}_w\mathbf{v}^w_{b_{k+1} }&=\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_k}-g^w\Delta t_k)+\beta^{b_k}_{b_{k+1} }\\\mathbf{q}^{b_k}_w\otimes\mathbf{q}^w_{b_{k+1} }&=\gamma^{b_k}_{b_{k+1} }\end{align*}\tag{7}</script><p>其中，</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&=\iint_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t}-n_a)dt^2\\\beta ^{b_k}_{b_{k+1} }&=\int_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t}-n_a)dt\\\gamma^{b_k}_{b_{k+1} }&= \int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t}-n_w)\gamma^{b_k}_tdt\end{align*}\tag{8}</script><p>可以看出，预积分项 $(8)$ 可以仅通过以 $b_k$ (表示第 $k$ 帧时的本体坐标系) 作为参考系的 IMU 测量来获得。</p><p> $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$ 与IMU的 $bais$ 有关，而 $bais$ 也是我们需要优化的变量，这将导致的问题是，当每次迭代时，我们得到一个新的 $bais$ ，又得根据公式 $(8)$ 重新对第 $k$ 帧和第 $k+1$ 帧之间的 IMU 预积分，非常耗时。</p><p>当 $bais$ 的估计发生变化时，如果变化很小，我们通过它们对 $bais$ 的一阶近似来调整 $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$ ，否则我们进行重新传播。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传播 IMU 测量。一阶近似如下：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&\approx \hat{\alpha}^{b_k}_{b_{k+1} }+\mathbf{J}^{\alpha}_{b_a}\delta b_{a_k}+\mathbf{J}^{\alpha}_{b_w}\delta b_{w_k}\\\beta^{b_k}_{b_{k+1} }&\approx \hat{\beta}^{b_k}_{b_{k+1} }+\mathbf{J}^{\beta}_{b_a}\delta b_{a_k}+\mathbf{J}^{\beta}_{b_w}\delta b_{w_k}\\\gamma^{b_k}_{b_{k+1} }&\approx \hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\end{align*}\tag{9}</script><p>其中 $\mathbf{J}^{\alpha}_{b_a}$ 和 是 $\mathbf{J}^{\alpha}_{b_{k+1} }$ 中的子块矩阵，其位置对应于 $\frac{\delta\alpha^{b_k}_{b_{k+1} } }{\delta b_{a_k} }$ 。 $\mathbf{J}^{\alpha}_{b_w}、\mathbf{J}^{\beta}_{b_a}、\mathbf{J}^{\beta}_{b_w}、\mathbf{J}^{\gamma}_{b_w}$ 也使用相同的含义。</p><h3 id="B-离散形式"><a href="#B-离散形式" class="headerlink" title="B.离散形式"></a>B.离散形式</h3><h4 id="欧拉法"><a href="#欧拉法" class="headerlink" title="欧拉法"></a>欧拉法</h4><p>下面给出离散时刻的 IMU 预积分公式， 首先按照<strong>论文中采用的欧拉法</strong>， 给出第 $i$ 个 IMU<br>时刻与第 $i+1$ 个 IMU 时刻的变量关系为：  </p><script type="math/tex; mode=display">\begin{align*}\hat{\alpha}^{b_k}_{i+1}&=\hat{\alpha}^{b_k}_{i}+\hat{\beta}^{b_k}_{i}\delta t+\frac{1}{2}\overline{\hat{a} }_i^{\prime}\delta t^2\\\hat{\beta}^{b_k}_{i+1}&=\hat{\beta}^{b_k}_{i}+\overline{\hat{a} }_i^{\prime}\delta t\\\hat{\gamma}^{b_k}_{i+1}&=\hat{\gamma}^{b_k}_{i}\otimes\hat{\gamma}^{i}_{i+1}=\hat{\gamma}^{b_k}_{i}\otimes\begin{bmatrix}1\\\frac{1}{2}\overline{\hat{w} }_i^{\prime}\delta t\end{bmatrix}\\\end{align*}\tag{10}</script><p>使用欧拉法，即两个相邻时刻 $i$ 到 $i+1$的位姿是用第 $i$ 时刻的测量值 $\overline{\hat{a} }_i^{\prime}, \overline{\hat{w} }_i^{\prime}$ 来计算:</p><script type="math/tex; mode=display">\begin{align*}\overline{\hat{a} }_i^{\prime}&=\mathbf{R}(\hat{\gamma}^{b_k}_{i})(\hat{a}_i-b_{a_i})\\\overline{\hat{w} }_i^{\prime}&=\hat{w}_i-b_{w_i}\end{align*}\tag{11}</script><h4 id="中值法"><a href="#中值法" class="headerlink" title="中值法"></a>中值法</h4><p>下面给出<strong>代码中采用的基于中值法</strong>的 IMU 预积分公式，这与 <code>Estimator::processIMU()</code> 函<br>数中的 <code>IntegrationBase::push_back()</code>上是一致的。注意这里跟公式 $(5)$ 是不一样的，这里积分出来的是前后两帧之间的 IMU 增量信息，而公式 $(5)$ 给出的当前帧时刻的物理量信息。  </p><script type="math/tex; mode=display">\begin{align*}\hat{\alpha}^{b_k}_{i+1}&=\hat{\alpha}^{b_k}_{i}+\hat{\beta}^{b_k}_{i}\delta t+\frac{1}{2}\overline{\hat{a} }_i^{\prime} \delta t^2\\\hat{\beta}^{b_k}_{i+1}&=\hat{\beta}^{b_k}_{i}+\overline{\hat{a} }_i^{\prime}\delta t\\\hat{\gamma}^{b_k}_{i+1}&=\hat{\gamma}^{b_k}_{i}\otimes\hat{\gamma}^{i}_{i+1}=\hat{\gamma}^{b_k}_{i}\otimes\begin{bmatrix}1\\\frac{1}{2}\overline{\hat{w} }_i^{\prime}\delta t\end{bmatrix}\\\end{align*}\tag{12}</script><p>其中，  </p><script type="math/tex; mode=display">\begin{align*}\overline{\hat{a} }_i^{\prime}&=\frac{1}{2}[\mathbf{q}_i(\hat{a}_i-b_{a_i})+\mathbf{q}_{i+1}(\hat{a}_{i+1}-b_{a_i})]\\\overline{\hat{w} }_i^{\prime}&=\frac{1}{2}(\hat{w}_i+\hat{w}_{i+1})-b_{w_i}\end{align*}\tag{13}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍IMU预积分公式推导。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_1-总体框架</title>
    <link href="https://lukeyalvin.top/posts/3cf7a3c1.html"/>
    <id>https://lukeyalvin.top/posts/3cf7a3c1.html</id>
    <published>2022-05-20T09:17:11.000Z</published>
    <updated>2022-05-20T11:54:05.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍整体框架。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/images/VINS-Mono-1-总体框架/image-20220520195226204.png" alt="image-20220520195226204"></p><p>VINS 的功能模块如图所示，可以分为五个部分：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化；代码中主要开启了四个线程，分别是：前端图像跟踪、后端非线性优化（其中初始化和 IMU 预积分在这个线程中）、闭环检测、闭环优化。  </p><h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h2><p>预处理主要指的是视觉前端里的图像处理以及IMU 测量量的处理。</p><p><strong>图像：</strong>提取图像 Harris 角点， 利用<strong>金字塔光流</strong>跟踪相邻帧，利用<strong>基础矩阵模型的RANSAC算法</strong>进行异常点剔除  ，最后将跟踪到的特征点 push 到图像队列中，并通知后端进行处理。  </p><p>另外，在此步骤中还选择了关键帧。  并定义两种选择关键帧的标准：① 与上一个关键帧的平均视差和某个特定阈值相比较；② 跟踪质量。</p><p><strong>IMU：</strong> 将 IMU 数据进行积分，得到当前时刻的位置、速度和旋转（ <strong>PVQ</strong>），同时计算在后端优化中将用到的相邻帧的<strong>预积分增量</strong>，及预积分误差的 <strong>Jacobian 矩阵</strong>和<strong>协方差项</strong>。 </p><p>这里涉及基于四元数的 IMU 推导过程，具体查看：</p><p>LK光流法：<a href="https://blog.csdn.net/sgfmby1994/article/details/68489944">总结：光流—LK光流—基于金字塔分层的LK光流—中值流</a></p><p>基础矩阵模型的RANSAC算法：<a href="https://blog.csdn.net/qq_38898129/article/details/93982154">计算机视觉：RANSAC剔除基础矩阵F错误匹配(Python实现)</a></p><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><p>首先， 利用 SFM 进行纯视觉估计滑窗内所有帧的位姿及 3D 点逆深度， 最后与 IMU 预<br>积分进行对齐求解初始化参数 。</p><p>SfM算法：<a href="https://zhuanlan.zhihu.com/p/55712813">基于单目视觉的三维重建算法综述</a>、<a href="https://blog.csdn.net/qq_20791919/article/details/74936438">SFM算法流程</a>、<a href="https://blog.csdn.net/Mahabharata_/article/details/70799695">[CV] Structure from motion（SFM）- 附我的实现结果</a></p><p>逆深度：<a href="https://blog.csdn.net/weixin_39568744/article/details/88582406">SLAM中的逆深度及参数化问题</a></p><h2 id="3-后端滑窗优化"><a href="#3-后端滑窗优化" class="headerlink" title="3. 后端滑窗优化"></a>3. 后端滑窗优化</h2><p>将视觉约束（视觉测量残差）、 IMU 约束（IMU测量残差）和闭环约束放在一个大的目标函数中进行非线性优化，求解滑窗内所有帧的 PVQ、 bias 等 。</p><h2 id="4-闭环检测和优化"><a href="#4-闭环检测和优化" class="headerlink" title="4. 闭环检测和优化"></a>4. 闭环检测和优化</h2><p>利用 DBoW 进行<strong>闭环检测</strong>，当检测成功后进行<strong>重定位</strong>，最后对整个相机轨迹进行<strong>闭环优</strong><br><strong>化</strong>。  </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍整体框架。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>七、滑动窗口算法</title>
    <link href="https://lukeyalvin.top/posts/a39e0cda.html"/>
    <id>https://lukeyalvin.top/posts/a39e0cda.html</id>
    <published>2022-05-13T06:57:20.000Z</published>
    <updated>2022-05-16T00:49:11.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>在学习滑动窗口算法之前，推荐读者先阅读，<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>以及<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>，这两篇博客奠定了本文的基础，有助于对本文的理解。</p><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>我们知道，SLAM中的优化问题，就是优化一个最小二乘的问题，这里我们首先介绍一个引例。</p><p>如下图所示，存在这么一个图模型，对于图模型大家肯定不是很陌生，了解过g2o的都应该很清楚，图中圆圈表示顶点，是待优化的变量，而顶点之间的边，表示的顶点之间构建的残差。</p><p><img src="/images/滑动窗口算法/image-20220513195856537.png" alt="image-20220513195856537" style="zoom:50%;" /></p><blockquote><p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p></blockquote><p>对于这样一个系统，我们首先构建出最小二乘，如下：</p><script type="math/tex; mode=display">\xi^*=\underset{\xi}{\arg\min}\frac{1}{2}\sum_i\parallel r_i \parallel^2_{\Sigma_i}\tag{1}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p><p>根据文章<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>中提到的，SLAM优化问题，最终运动观测方程优化的部分是<strong>马氏距离</strong>，残差项即为<strong>马氏距离</strong>:</p><script type="math/tex; mode=display">\parallel r_i \parallel^2_{\Sigma_i}=r^T\Sigma^{-1}r\tag{2}</script><p>其中 $\Sigma$ 表示残差的<strong>协方差矩阵</strong>， $\Sigma^{-1}$ 表示残差的<strong>信息矩阵</strong>，因此，此处相当于一种<strong>加权的</strong>最小二乘问题。</p><p>应用高斯牛顿法，可以求解上述最小二乘问题的<strong>正规方程</strong>：</p><script type="math/tex; mode=display">J^T\Sigma^{-1}J\ \delta\xi = -J^T\Sigma^{-1}\ r\tag{3}</script><p>其中海塞矩阵 $H=J^T\Sigma^{-1}J$，矩阵 $g= -J^T\Sigma^{-1}\ r$，雅可比矩阵为：</p><script type="math/tex; mode=display">J=\frac{\partial r}{\partial \xi}=\begin{bmatrix}\frac{\partial r_{12} }{\partial \xi}\\\frac{\partial r_{13} }{\partial \xi}\\\frac{\partial r_{14} }{\partial \xi}\\\frac{\partial r_{15} }{\partial \xi}\\\frac{\partial r_{56} }{\partial \xi}\end{bmatrix}=\begin{bmatrix}J_1\\J_2\\J_3\\J_4\\J_5\\J_6 \end{bmatrix}\tag{4}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p><p>矩阵乘法公式 $(3)$ 可以写成连加：</p><script type="math/tex; mode=display">\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i J_i\ \delta\xi=-\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i\ r\tag{5}</script><p>由于每个残差只和某几个状态量有关，因此，雅克比矩阵求导时，无关项的雅克比为 0。比如</p><script type="math/tex; mode=display">J_2=\frac{\partial r_{13} }{\partial \xi}=\begin{bmatrix}\frac{\partial r_{13} }{\partial \xi_1}&0&\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\end{bmatrix}\tag{6}</script><p>对应的新的信息矩阵：</p><script type="math/tex; mode=display">Λ_2=J^T_2\Sigma^{-1}_2J_2=\begin{bmatrix}(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\end{bmatrix}\tag{7}</script><p>同理，可以计算 $Λ_1 , Λ_3 , Λ_4 , Λ_5 $，并且也是稀疏的。</p><p><strong>将五个残差的信息矩阵加起来</strong>，得到样例最终的<strong>信息矩阵</strong> $Λ$，可视化如下：</p><p><img src="/images/滑动窗口算法/image-20220513203817364.png" alt="image-20220513203817364" style="zoom: 33%;" /></p><p>关于稀疏矩阵。我们知道，可以用舒尔消元法或者称之为边缘化，来使之变得稠密，减少计算量。</p><h1 id="基于边际概率的滑动窗口算法"><a href="#基于边际概率的滑动窗口算法" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h1><h2 id="什么是滑动窗口算法？"><a href="#什么是滑动窗口算法？" class="headerlink" title="什么是滑动窗口算法？"></a>什么是滑动窗口算法？</h2><p><strong>什么是滑动窗口算法</strong></p><p>在引例的条件下，我们知道，一般情况下，SLAM问题构建的残差的信息矩阵是一个稀疏矩阵，在此基础上，我们讨论SLAM中的滑动窗口算法。</p><p>所谓的滑动窗口算法，并没有明确的定义，我做了一个动图，其展示的过程就是滑动窗口算法：</p><p><img src="/images/滑动窗口算法/cell-16526620480511.gif" alt="cell"></p><p>**为什么使用滑动窗口算法？</p><p>那么，使用它有什么好处呢？在文章开篇的概述中已经提及，这里再做强调：</p><ul><li>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</li><li>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态<strong>增加或移除优化变量</strong>。</li></ul><p>其实它的作用也是动图中展示的，我们优化的变量就是红色框中的部分，外部的变量不断增加进来，一些历史的变量做清除。</p><p><strong>滑动窗口中的关键问题是什么？</strong></p><p>但是我们需要考虑的关键就是，如何增加或者移除？直接移除吗？比如引例中的变量 $\xi_1$如果直接把顶点连同边一起移除，那么所有的其他变量之间的边可就都没了，边就是误差项，误差都没了，如何优化？这是下面我们需要介绍的重要内容。</p><p><strong>滑动窗口算法大致流程</strong></p><p>① 增加新的变量进入最小二乘系统优化</p><p>② 如果变量数目达到了一定的维度，则移除老的变量。</p><p>③ SLAM 系统不断循环前面两步</p><h2 id="基于边际概率的滑动窗口算法-1"><a href="#基于边际概率的滑动窗口算法-1" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h2><p>关于这里，有必要回顾文章<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>中的案例，会对此有更加深刻的理解。</p><p>直接丢弃变量和对应的测量值，会损失信息。因此，我们需要选择一种“优雅的”方式丢掉历史信息，正确的做法是使用<strong>边际概率</strong>，将丢弃变量所携带的信息传递给剩余变量。意思就是，历史变量虽然被移除了，但是它的“影响力”还在。</p><p>还是用引例，我们将引例中的历史变量 $\xi_1$ 丢掉，应该如何操作呢？</p><blockquote><p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p></blockquote><p><img src="/images/滑动窗口算法/image-20220513210526896.png" alt="image-20220513210526896"></p><p>很明显，去除历史变量 $\xi_1$ 之后，其他出现了互相之间的关联，这就是说历史变量 $\xi_1$ 虽然被去除了，但是它把自己的信息传递给其他变量了，虽然自己凉了，但是完成了火炬的传递。</p><p><strong>结论：</strong><span style="color:red;"><strong>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</strong></span> 另外，marg的这一特征也给我们启示，就是在SLAM运动观测模型中，marg特征点的时候，我们要<strong>marg那些不被其他帧观测到的特征点</strong>。因为他们不会显著的使得 H 变得稠密。对于那些被其他帧观测到的特征点，要么就别设置为marg，要么就宁愿丢弃，这就是okvis和dso中用到的一些策略。</p><hr><p>那么，如果在移除变量 $\xi_1$ 的同时，加入新的变量 $\xi_7$，整个信息矩阵又如何变化呢？</p><p>如下图所示，在 $t \in [0, k]$s 时刻, 系统中状态量为 $\xi_i , i \in [1, 6]$。</p><p>在第 $k $ 时刻，最小二乘优化完以后，marg 掉变量 $\xi_1$  。被 marg 的状态量记为 $x_m$ , 剩余的变量 $ξ_i , i \in [2, 5]$ 记为 $x_r $，marg 发生以后， $x_m$ 所有的变量以及对应的测量将被丢弃。同时，这部分信息通过 marg 操作传递给了保留变量 $x_r$ 。</p><p>第 $k^′$ 时刻，加入新的观测和状态量  $\xi_7$，新的变量  $\xi_7$ 跟老的变量  $\xi_2$ 之间存在观测信息，能构建残差 $r_{27}$ 。然后开始新一轮最小二乘优化。</p><p><img src="/images/滑动窗口算法/image-20220513213728826.png" alt="image-20220513213728826"></p><p>新残差加上之前 <strong>marg 留下的信息</strong>，构建新的最小二乘系统，对应的信息矩阵的变化如下图所示：</p><p><img src="/images/滑动窗口算法/image-20220513212137697.png" alt="image-20220513212137697" style="zoom:40%;" /></p><p>注意：  $\xi_2$  自身的信息矩阵由两部分组成，一部分是原来的$Λ^{\prime}$  中的老信息，另一部分是新生成的 $Λ_6$中的新信息，这会使得系统存在<strong>潜在风险</strong>。</p><p>新老信息融合的问题在于<strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。对于零空间的介绍在后文中。</p><hr><p><span style="color:red;"><strong>marg 留下的信息到底是啥？</strong></span></p><p>marg 发生后，留下的到底是什么信息？  </p><p>marg 前，变量 $x_m$ （指将要被 marg 的变量，$\xi_i,i=1$）以及对应测量 $\mathcal{S}_m$ （指的是与 $\xi_1$ 构成的边 $r_{1j},j\in[2,5]$）构建的最小二乘信息矩阵为（使用高斯牛顿）：  </p><script type="math/tex; mode=display">\begin{align*}b_m(k)&=\begin{bmatrix}b_{mm}(k)\\b_{mr}(k)\end{bmatrix}=-\sum_{(i,j)\in\mathcal{S}_m}J^T_{ij}(k)\Sigma^{-1}_{ij}r_{ij}\\Λ_m(k)&=\begin{bmatrix}Λ_{mm}(k)&Λ_{mr}(k)\\Λ_{rm}(k)&Λ_{rr}(k)\end{bmatrix}=\sum_{(i,j)\in\mathcal{S}_m}J^T_{ij}(k)\Sigma^{-1}_{ij}J_{ij}(k)\end{align*}\tag{8}</script><p>然后marg掉  $\xi_1$ ，即丢掉变418133364量  $x_m$ ， 而 $x_m$ 的测量信息，传递给了变量  $x_r$ （指的是 marg 剩余后的变量 $\xi_i,i\in[2,5]$）:  </p><script type="math/tex; mode=display">\begin{align*}b_p(k)&=b_{mr}(k)-Λ_{rm}(k)Λ^{-1}_{mm}(k)b_{mm}(k)\\Λ_p(k)&=Λ_{rr}(k)-Λ_{rm}(k)Λ^{-1}_{mm}(k)Λ_{mm}(k)\end{align*}\tag{9}</script><p>下标 p 表示 prior. 即这些信息将构建一个关于 $x_r$ 的先验信息。</p><p>由：</p><script type="math/tex; mode=display">\begin{align*}Λ_p(k)\delta x&=b_p(k)\\J^T_{p}(k)\Sigma^{-1}J_{p}(k)\ \delta x&= -J^T_{p}(k)\Sigma^{-1}r_p(k)\end{align*}\tag{10}</script><p>因此，我们可以从 $b_p(k),Λ_p(k)$反解出一个残差 $r_p(k)$ 和对应的雅可比矩阵 $J_{p}(k)$ ，需要注意的是<strong>，随着变量 $x_r(k)$ 的后续不断优化变化，残差 $r_p(k)$ 或者 $b_p(k)$ 也跟着变换，但是雅可比 $J_{p}(k)$ 则固定不变了。</strong></p><p>在 $k^′$ 时刻，新残差 $r_{27}$ 和先验信息  $b_p(k),Λ_p(k)$ 以及残差 $r_{56}$ 构建新的最小二乘问题 :</p><script type="math/tex; mode=display">\begin{align*}b_m(k^′)&=\Pi^Tb_p(k)-\sum_{(i,j)\in\mathcal{S}_a(k^′)}J^T_{ij}(k^′)\Sigma^{-1}_{ij}r_{ij}(k^′)\\Λ_m(k^′)&=\Pi^TΛ_p(k) \Pi+\sum_{(i,j)\in\mathcal{S}_a(k^′)}J^T_{ij}(k^′)\Sigma^{-1}_{ij}J_{ij}(k^′)\end{align*}\tag{11}</script><p>其中，$\Pi=[I_{dim\ x_r}\ \ 0]$用来将矩阵的维度进行扩张。 $\mathcal{S}_a$ 用来表示除被marg 掉的测量以外的其他测量，包括原本的与marg 变量无关的  $r_{56}$，以及新加入的变量 $r_{27}$。  </p><p><strong>出现的问题</strong></p><p>由于  $ξ_2$  的信息由两部分组成：</p><ul><li><p>一部分是marg 前的先验信息  $Λ_p(k)$ ，在marg 后，由于被 marg 的变量以及对应的测量已被丢弃，因此之前的雅可比不会被更新了，因此公式 $(11)$ 的等号右侧第一部分的线性化点是<strong>不变的</strong>；</p></li><li><p>另一部分信息就是新的边 $r_{27}$ ，其雅克比会随着 $ξ_2$  的迭代更新而不断在最新的线性化点处计算，因此公式 $(11)$ 的等号右侧第二部分的线性化点是<strong>不断变化的</strong>；</p></li><li><strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，它们在相加的时候，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。</li></ul><h2 id="信息矩阵的零空间变化"><a href="#信息矩阵的零空间变化" class="headerlink" title="信息矩阵的零空间变化"></a>信息矩阵的零空间变化</h2><p>滑动窗口算法优化的时候，信息矩阵如公式 $(11)$ 变成了两部分，且这两部分计算雅克比时的<strong>线性化点不同</strong>。这可能会导致信息矩阵的零空间发生变化，从而在求解时引入错误信息。  </p><p>这里引用贺博的博客：<a href="https://blog.csdn.net/heyijia0327/article/details/52822104?spm=1001.2014.3001.5501">SLAM中的marginalization 和 Schur complement</a></p><p><img src="/images/滑动窗口算法/image-20220514165208897-16526621209192.png" alt="image-20220514165208897" style="zoom: 33%;" /></p><p>在刘毅(稀疏毅)，王京，晓佳等人讨论下，对这张图作出了如下解释：</p><p>四张能量图中，第一张是说明能量函数 $E$ 由两个同样的非线性函数 $E_1$和 $E_2$组成，我们令函数 $E=0$，这时方程的解为 $x y = 1$ ，对应图中深蓝色的一条曲线。</p><p>第二张能量函数图中的 $E_1^′$对应函数  $E_1$ 在点 $(0.5,1.4)$ 处的二阶泰勒展开;</p><p>第三张能量函数图中的 $E_2^′$ 对应函数在  $E_2$ 点 $(1.2,0.5)$ 处的二阶泰勒展开。注意这两个近似的能量函数 $E_1^′$ 和 $E_2^′$是在不同的线性点附近对原函数展开得到的。</p><p>最后一张图就是把这个近似得到的能量函数合并起来，对整个系统 $E$ 的二阶近似。</p><p>从第四个能量函数图中，我们发现一个大问题，能量函数为 $0$ 的解由以前的一条曲线变成了一个点，<strong>不确定性的东西变得确定了</strong>，专业的术语叫<strong>不可观的状态变量变得可观了</strong>，说明我们人为的引入了错误的信息。回到marg过程，上面这个例子告诉我们，marg 时，被 marg 的那些变量的雅克比已经不更新了，而此时留在滑动窗口里的其他变量的雅克比要用和 marg 时一样的线性点，就是 $FEJ,(first\ estimate\ jocabian)$ 算法，不要用新的线性点了。</p><hr><p><strong>FEJ 算法：</strong>$FEJ,(first\ estimate\ jocabian)$ ,不同残差对同一个状态求雅克比时，线性化点必须一致。这样就能避免零空间退化而使得不可观变量变得可观。  比如: 引例中计算 $r_{27}$ 对 $ξ_2$ 的雅克比时， $ξ_2$ 的线性话点必须和 $r_{12}$对其求导时一致。  </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="滑动窗口算法" scheme="https://lukeyalvin.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VSLAM中的非线性优化</title>
    <link href="https://lukeyalvin.top/posts/48933.html"/>
    <id>https://lukeyalvin.top/posts/48933.html</id>
    <published>2022-05-13T06:57:20.000Z</published>
    <updated>2022-05-17T05:59:46.738Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经典 SLAM 模型。它由一个状态方程和一个运动方程构成：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},u_{k})+w_{k}\\z_{k,j}&=h(y_j,x_k)+v_{k,j}\end{align*}\tag{1}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$</p><p>对应视觉$SLAM$，这里的 $x_k $乃是相机的位姿，$u_k$ 是运动传感器的读数（有时也叫输入），$y_j$代表的是相机在$x_k $处观察到的路标，并且观察到$y_j$后，产生了一个观测数据 $z_{k,j}$。整个方程里面，求解相机的位姿$x_k $就是一个定位的问题，而求解路标$y_j$就是一个建图的过程，但是由于噪声$w_{k}，v_{k,j}$的影响，我们得到的传感器数据$u_k$ 和$z_{k,j}$肯定不是完全准确的，因此需要使用这两组不太准确的数据，寻找一个相对最优的相机位姿$x_k $以及路标$y_j$。这个过程就是SLAM中的非线性优化问题。</p><h2 id="需要优化什么？"><a href="#需要优化什么？" class="headerlink" title="需要优化什么？"></a>需要优化什么？</h2><p>我们把所有带估计的数据放在一个集合：</p><script type="math/tex; mode=display">x=\left\{x_1,....,x_N,y_1,...y_M\}\right.\tag{2}</script><p>那么，我们的问题就变成求已知输入数据 $u$ 和观测数据 $z$ 的条件下，计算状态 $x$ 的条件概率分布：</p><script type="math/tex; mode=display">P(x|z,u)\tag{3}</script><hr><p>但是多数情况下，我们只有相机观察到的一帧帧的图片$z_{k,j}$，即只考虑观测方程带来的数据时，没有运动传感器$u_k$ ，这个概率分布就变成$P(x|z)$，利用贝叶斯法则：</p><script type="math/tex; mode=display">P(x|z)=\frac{P(z|x)P(x)}{P(z)}∝P (z|x) P (x) .\tag{4}</script><p>$\frac{P(z|x)P(x)}{P(z)}$称为<strong>后验估计</strong>，$P (z|x)$ 称为<strong>似然</strong>，另一部分$ P (x)$ 称为<strong>先验</strong>。</p><p>直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下，后验概率最大化（Maximize a Posterior，MAP），则是可行的：</p><script type="math/tex; mode=display">x^∗_{MAP} = \arg \max P (x|z) = \arg \max P (z|x)P (x).\tag{5}</script><p>但是当我们不知道机器人位姿大概在什么地方，此时就没有了先验,那么，可以求解$x $的最大似然估计（Maximize Likelihood Estimation, MLE）：</p><script type="math/tex; mode=display">x^∗_{MLE} = \arg \max P (z|x)\tag{6}</script><p>最大似然估计的含义就是：相机在什么样的状态下（这里指集合$x$即为相机位姿$x_{k}$以及路标$y_{j}$），最可能产生当前观测到的数据$z_{k,j}$。</p><p><strong>所以我们需要优化的内容就是：求解最优的$x_k , y_j$，使得观测方程带来的最小误差，此时就是求$x$（或者是说$x_k , y_j$）的最大似然然估计。</strong></p><h2 id="最小二乘问题"><a href="#最小二乘问题" class="headerlink" title="最小二乘问题"></a>最小二乘问题</h2><p>只考虑观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{7}</script><p>由于我们假设了噪声项 $v_k ∼ N (0, Q)$，所以观测数据的条件概率为：</p><script type="math/tex; mode=display">P (z_{j,k} |x_k , y_j ) = N (h(y_j , x_k ), Q) .\tag{8}</script><p>我们的目标就是最大化$x_k , y_j$，使得该状态下最可能产生当前观测到的数据$z_{k,j}$。</p><p>考虑一个任意的高维高斯分布 $x ∼ N (\mu, \Sigma)$，它的概率密度函数展开形式为:</p><script type="math/tex; mode=display">\begin{align*}p(x)=\frac{1}{\sqrt{(2\pi)^N det(\Sigma)} }exp(−(x−\mu)\Sigma^{-1} (x−\mu))\end{align*}\tag{9}</script><p>取负对数:</p><script type="math/tex; mode=display">\begin{align*}-ln(p(x))=\frac{1}{2}ln((2\pi)^N det(Σ))+\frac{1}{2}(x−\mu)^TΣ^{-1} (x−\mu)\end{align*}\tag{10}</script><p>对原分布求最大化相当于对负对数求最小化。在最小化上式的 $x$ 时，第一项与 $x $无关，可以略去于是，只要最小化右侧的二次型项，也称为<strong>马氏距离</strong>。带入 SLAM 观测模型：</p><script type="math/tex; mode=display">x^*=\arg\min\left((z_{k,j}-h(x_k,y_j))^TQ^{-1}_{k,j}(z_{k,j}-h(x_k,y_j))\right)\tag{11}</script><p>定义：</p><script type="math/tex; mode=display">\begin{align*}e_{v,k}&=x_k-f(x_{k-1},u_k)\\e_{u,j,k}&=z_{k,j}-h(x_k,y_j)\end{align*}\tag{12}</script><p>考虑运动与观测方程结合来看，我们求解的就是总的<strong>误差的平方和</strong>：</p><script type="math/tex; mode=display">J(x)=\sum_ke^T_{v,k}R^{-1}e_{v,k}+\sum_k\sum_je^T_{y,k,j}Q^{-1}e_{y,k,j}\tag{13}</script><p>这就得到了一个总体意义下的<strong>最小二乘问题</strong>（Least Square Problem）。我们明白它的最优解等价于状态的最大似然估计。直观来讲，由于噪声的存在，当我们把估计的轨迹与地图代入 SLAM 的运动、观测方程中时，它们并不会完美的成立。这时候怎么办呢？我们把状态的估计值进行微调，使得整体的误差下降一些。当然这个下降也有限度，它一般会到达一个极小值。这就是一个典型非线性优化的过程。</p><h2 id="非线性函数线性化"><a href="#非线性函数线性化" class="headerlink" title="非线性函数线性化"></a>非线性函数线性化</h2><p>在非线性优化的过程中，由于高斯分布经过非线性映射后不会再符合高斯分布，因此，一般我们对非线性进行线性化，这里用到泰勒级数：</p><p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}\tag{14}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f^\prime(x_0)(x-x_0)\tag{15}</script><p>如果对于二维以上的，我们的一阶泰勒展开如下：</p><script type="math/tex; mode=display">\begin{align*}f(x，y)&=f(x_0)+\frac{\partial f}{\partial x}|_{x=x_0}(x-x_0)\\&=f(x_0)+J(x)(x-x_0)\end{align*}\tag{16}</script><p>这里的雅克比矩阵代表的就是$f(x)$对于$x$的偏导数。</p><h1 id="求解非线性最小二乘"><a href="#求解非线性最小二乘" class="headerlink" title="求解非线性最小二乘"></a>求解非线性最小二乘</h1><p>对于上文，我们知道通过把最大似然估计问题转化为最小化其负对数的问题，其实就是求解一个非线性函数的最小值的问题，我们暂且考虑一个问题，我们有一个非线性的函数$f(x)$，如何求解它的最小值？</p><p>这就是一个简单的最小二乘问题：</p><script type="math/tex; mode=display">\underset{x}{min}\frac{1}{2}\parallel f(x) \parallel^2\tag{17}</script><p>这里自变量 $x\in \mathbb R^n$ ，$f $是任意一个非线性函数，我们设它有 $m $维：$f (x) \in \mathbb R^m$ 。</p><p>一般求解就是类似于二元函数求极值，对$x$求导，使得$\frac{df}{dx}=0$，即可得到$f(x)$的极值，但是也不是绝对的，我们知道这个点可能是极大值、极小值也可能是鞍点，因此需要比较所有使得$\frac{df}{dx}=0$的自变量对应的函数值$f(x)$.</p><p>但是在SLAM中，$f(x)$将是一个复杂的非线性方程，所以一般我们使用迭代的方法，从一个初始值出发，不断地更新当前的优化变量，使目标函数下降，具体步骤如下：</p><ul><li>给定某个初始值$ x_0$</li><li>对于第$k$次迭代，寻找一个增量$\Delta x_k$，使得$\parallel f(x_k+\Delta x_k)\parallel^2_2$达到极小值。</li><li>若$\Delta x_k$足够小，则停止</li><li>否则，令$x_{k+1}=x_k+\Delta x_k$，返回第二步。</li></ul><p>这让求解导函数为零的问题，变成了一个不断寻找梯度并下降的过程。直到某个时刻增量非常小，无法再使函数下降。此时算法收敛，目标达到了一个极小，我们完成了寻找极小值的过程。在这个过程中，我们只要找到迭代点的梯度方向即可，而无需寻找全局导函数为零的情况。</p><hr><p><strong>如何寻找$\Delta x_k$?</strong></p><h2 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h2><p>我们之前介绍过非线性的线性化方法，我们可以将一个非线性函数在某个点附件进行泰勒展开。</p><p>比如：对于增量方程在$x$附近进行泰勒展开：</p><script type="math/tex; mode=display">\parallel f(x+\Delta x)\parallel^2_2\approx\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{18}</script><p>这里$J$是 $\parallel f(x)\parallel^2$ 关于$ x $的导数（雅可比矩阵），而$ H $则是二阶导数（海塞（Hessian）矩阵）。保留一阶二阶分别就对应了一阶梯度法和二阶梯度法。</p><h3 id="一阶梯度法"><a href="#一阶梯度法" class="headerlink" title="一阶梯度法"></a>一阶梯度法</h3><script type="math/tex; mode=display">\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x\tag{19}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">\Delta x^*=-J^T(x)\tag{20}</script><p>当然，我们还需要该方向上取一个步长$\lambda$，求得最快的下降方式。这种方法被称为<strong>最速下降法</strong>。但是它本身也有缺点：最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。</p><h3 id="二阶梯度-牛顿法"><a href="#二阶梯度-牛顿法" class="headerlink" title="二阶梯度(牛顿法)"></a>二阶梯度(牛顿法)</h3><script type="math/tex; mode=display">\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{21}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">H\Delta x=-J^T.\tag{22}</script><p>但是牛顿法需要计算目标函数的 $H $矩阵，这在问题规模较大时非常困难，我们通常倾向于避免$ H $的计算。</p><h2 id="Gauss-Newton"><a href="#Gauss-Newton" class="headerlink" title="Gauss-Newton"></a>Gauss-Newton</h2><p>Gauss Newton 是最优化算法里面最简单的方法之一。它的思想是$f(x)$而不是$f(x)^2$在$x$处进行一阶泰勒展开：</p><script type="math/tex; mode=display">f(x+\Delta x)\approx f(x)+J(x)\Delta x\tag{23}</script><p>这里$ J (x)$ 为$ f (x) $关于$ x$ 的导数，实际上是一个$ m × n$ 的矩阵，也是一个雅可比矩阵。</p><p>当前的目标是为了寻找下降矢量 $\Delta x$，使得$ f(x+\Delta x)$达到最小。为了求 $\Delta x$，我们需要解一个线性的最小二乘问题：</p><script type="math/tex; mode=display">\Delta x^*=\arg\min\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2\tag{24}</script><p>对上式平方项进行展开：</p><script type="math/tex; mode=display">\begin{align*}\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2&=\frac{1}{2}\left(f(x)+J(x)\Delta x)^T(f(x)+J(x)\Delta x\right)\\&=\frac{1}{2}\left(\parallel f(x)\parallel^2_2+2f(x)^TJ(x)\Delta x+\Delta x^TJ(x)^TJ(x)\Delta x\right)\\\end{align*}\tag{25}</script><p>求上式关于 $\Delta x$ 的导数，并令其为零：</p><script type="math/tex; mode=display">2J(x)^Tf(x)+2J(x)^TJ(x)\Delta x=0\tag{26}</script><p>化简：</p><script type="math/tex; mode=display">J(x)^TJ(x)\Delta x=-J(x)^Tf(x)\tag{27}</script><p>要求解的变量是  $\Delta x$，因此这是一个线性方程组，我们称它为增量方程，也可以称为<strong>高斯牛顿方程 (Gauss Newton equations)</strong> 或者<strong>正规方程 (Normal equations)</strong>。我们把左边的系数定义为 $H$，右边定义为 $g$，那么上式变为：</p><script type="math/tex; mode=display">H \Delta x=g\tag{28}</script><p>对比牛顿法可见，Gauss-Newton 用$J(x)^TJ(x)$作为牛顿法中二阶 Hessian 矩阵的近似，从而省略了计算 $H $的过程。求解增量方程是整个优化问题的核心所在。</p><p>Gauss Newton 求解步骤：</p><ul><li>给定初始值$x_0$</li><li>对于第$k$次迭代，求出当前的雅可比矩阵$J(x_k)和误差$$f(x_k)$</li><li>求解增量方程：$H \Delta x=g$</li><li>若$\Delta x_k$足够小，则停止。否则，令$x_{k+1}=x_k+\Delta x_k$，返回步骤2.</li></ul><p>整个步骤中，增量方程的求解占据着主要地位。原则上，它要求我们所用的近似 $H$ 矩阵是可逆的（而且是正定的），但实际数据中计算得到的 $J(x)^TJ(x)$却只有半正定性。也就是说，在使用 Gauss Newton 方法时，可能出现$J(x)^TJ(x)$为<strong>奇异矩阵</strong>或者<strong>病态 (ill-condition)</strong> 的情况，此时增量的稳定性较差，导致算法不收敛。</p><p>更严重的是，就算我们假设$ H $非奇异也非病态，如果我们求出来的步长$ ∆x $太大，也会导致我们采用的局部近似不够准确，这样一来我们甚至都无法保证它的迭代收敛，哪怕是让目标函数变得更大都是有可能的。</p><h2 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h2><p>由于 Gauss-Newton 方法中采用的近似二阶泰勒展开<strong>只能在展开点附近有较好的近似效果</strong>，所以我们很自然地想到应该给 $\Delta x$ 添加一个信赖区域（$Trust\ Region$），不能让它太大而使得近似不准确。非线性优化种有一系列这类方法，这类方法也被称之为信赖区域方法 $ (Trust\ Region\ Method)$。<strong>在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</strong> </p><p>那么如何确定这个信赖区域的范围呢？一个比较好的方法是<strong>根据我们的近似模型跟实际函数之间的差异来确定这个范围</strong>：如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。因此，考虑使用 $(29)$ 来判断泰勒近似是否够好。</p><script type="math/tex; mode=display">\rho=\frac{f(x+\Delta x)-f(x)}{J(x)\Delta x }\tag{29}</script><p>$\rho$ 的分子是<strong>实际函数下降</strong>的值，分母是<strong>近似模型下降</strong>的值。如果 $\rho$ 接近于 1，则近似是好的。如果 $\rho$  太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。反之，如果 $\rho$  比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513154553510.png" alt="image-20220513154553510" style="zoom: 67%;" /></p><p>我们用 Lagrange 乘子将$(6.24)$ 转化为一个无约束优化问题：</p><script type="math/tex; mode=display">\underset{\Delta x_K}{\min}\frac{1}{2}\parallel f(x_k)+J(x_k)\Delta x_k\parallel^2=\frac{\lambda}{2}\parallel D\Delta x \parallel^2\tag{30}</script><p>类似于 Gauss-Newton 中的做法，把它展开后，我们发现该方法最终也是计算增量的线性方程：</p><script type="math/tex; mode=display">(H+\lambda D^TD)\Delta x=g\tag{31}</script><p>可以看到，增量方程相比于 Gauss-Newton，多了一项 $\lambda D^T D$。如果考虑它的简化形 式，即 $D = I$，那么相当于求解：</p><script type="math/tex; mode=display">(H+\lambda I)\Delta x=g\tag{32}</script><p>我们看到，当参数 $λ$ 比较小时，$H $占主要地位，这说明二次近似模型在该范围内是比 较好的，L-M 方法更接近于 G-N 法。另一方面，当 $λ$ 比较大时，$λI $占据主要地位，L-M 更接近于一阶梯度下降法（即最速下降），这说明附近的二次近似不够好。L-M 的求解方 式，可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题，提供更稳定更准确 的增量 $∆x$。</p><h1 id="BA求解"><a href="#BA求解" class="headerlink" title="BA求解"></a>BA求解</h1><p>通过前文。我们知道SLAM 中的优化问题什么，而且我们知道优化的数学工具最小二乘法，那么如何进行优化，就是我们下面讨论的主要问题。</p><h2 id="投影模型"><a href="#投影模型" class="headerlink" title="投影模型"></a>投影模型</h2><p>从一个世界坐标系中的点 $p$ 出发，把相机的内外参数和畸变都考虑进来，最后投影成像素坐标，一共需要如下几个步骤：</p><ol><li>首先，把世界坐标转换到相机坐标，这里将用到相机外参数$ (R, t)$：</li></ol><script type="math/tex; mode=display">P^\prime=Rp+t=[X^\prime,Y^\prime,Z^\prime]^T\tag{33}</script><ol><li>然后，将 $P^\prime$ 投至归一化平面，得到归一化坐标：</li></ol><script type="math/tex; mode=display">P_c=[u_c,v_c,1]^T=[\frac{X^\prime}{Z^\prime},\frac{Y^\prime}{Z^\prime},1]^T\tag{34}</script><ol><li>对归一化坐标去畸变，得到去畸变后的坐标。这里暂时只考虑径向畸变：</li></ol><script type="math/tex; mode=display">\begin{align*}u_c^\prime=u_c(1+k_1r_c^2+k_2r_c^4)\\v_c^\prime=v_c(1+k_1r_c^2+k_2r_c^4)\\\end{align*}\tag{35}</script><ol><li>最后，根据内参模型，计算像素坐标：</li></ol><script type="math/tex; mode=display">\begin{align*}u_s=f_xu_c^\prime+c_x\\v_s=f_yv_c^\prime+c_y\end{align*}\tag{36}</script><p>对于观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{37}</script><p>这里的 $x$ 指代此时相机的位姿，即外参 $R, t$，它对应的李代数为 $ξ$。路标 $y$ 即这里的三维点 $p$，而观测数据则是像素坐标$z = [u_s , v_s ]^T $。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220405145736323.png" alt="image-20220405145736323"></p><p>以最小二乘的角度来考虑，那么可以列写关于此次观测的误差：</p><script type="math/tex; mode=display">e=z-h(\xi,p)\tag{38}</script><p>设 $z_{ij}$为在位姿 $\xi_i $处观察路标 $p_j $产生的数据，那么整体的损失函数（Cost Function）为：</p><script type="math/tex; mode=display">\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}\parallel^2=\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel z_{ij}-h(ξ_i,p_j) \parallel^2\tag{39}</script><p>对这个最小二乘进行求解，相当于对位姿和路标同时作了调整，也就是所谓的$BA$。</p><h2 id="BA求解-1"><a href="#BA求解-1" class="headerlink" title="BA求解"></a>BA求解</h2><p>在整体 $BA$目标函数上，我们必须把自变量定义成所有待优化的变量：</p><script type="math/tex; mode=display">x=[\xi_1,...,\xi_m,p_1,...,p_n]^T\tag{40}</script><p>相应的，增量方程中的$ ∆x $则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}+F_{ij}\Delta\xi_i+E_{ij}\Delta p_i \parallel^2\tag{41}</script><p>其中$ F_{ij} $表示整个代价函数在当前状态下对<strong>相机姿态</strong>的偏导数，而 $E_{ij}$ 表示该函数对<strong>路标点位置</strong>的偏导。</p><p><strong>观测相机方程关于相机位姿的导数矩阵：</strong></p><script type="math/tex; mode=display">\begin{align*}F&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\\end{align*}\tag{42}</script><p><strong>观测相机方程关于特征点的导数矩阵</strong></p><script type="math/tex; mode=display">E=\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}R\tag{43}</script><p>关于$E,F$雅可比矩阵的具体求导过程，可以查阅：<a href="https://lukeyalvin.top/posts/20908.html">ch7_求解PnP并使用BA优化</a></p><p>现在，把相机位姿变量放在一起：</p><script type="math/tex; mode=display">x_c=[\xi_1,\xi_2,...,\xi_m]\in\mathbb{R}^{6m}\tag{44}</script><p>并把空间点的变量也放在一起：</p><script type="math/tex; mode=display">x_p=[p_1,p_2,...,p_n]^T\in \mathbb{R}^{3n}\tag{45}</script><p>目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e+F\Delta x_c+E_\Delta x_p \parallel^2\tag{46}</script><p>需要注意的是，该式从一个由<strong>很多个小型二次项之和</strong>，变成了一个更整体的样子。这里的雅可比矩阵 $E $和$ F$ 必须是整体目标函数对整体变量的导数，它将是一个很大块的矩阵，而里头每个小分块，需要由每个误差项的导数 $F_{ij} $和 $E_{ij}$ “拼凑”起来。然后，无论我们使用 $G-N$ 还是$ L-M $方法，最后都将面对增量线性方程：</p><script type="math/tex; mode=display">H\Delta x = g\tag{47}</script><p>如果是高斯牛顿，$H$ 取$J^TJ$；列文伯格是 $J^T J + λI $的形式</p><p>由于我们把变量归类成了位姿和空间点两种，所以雅可比矩阵可以分块为：</p><script type="math/tex; mode=display">J=\begin{bmatrix}F & E\end{bmatrix}\tag{48}</script><p>其中$F$是$2 × 6$的矩阵，$E$是$2 × 3$的矩阵.</p><p>以 G-N 为例，则 H 矩阵为：</p><script type="math/tex; mode=display">H=J^TJ=\begin{bmatrix}F^TF & F^TE\\E^TF & E^TE\end{bmatrix}\tag{49}</script><p>在SLAM中我们会考虑H矩阵的稀疏性，进而加速BA的求解。</p><h2 id="稀疏性和边缘化"><a href="#稀疏性和边缘化" class="headerlink" title="稀疏性和边缘化"></a>稀疏性和边缘化</h2><p>在视觉 SLAM 中，一个图像就会提出数百个特征点，大大增加了这个线性方程的规模。如果直接对 H 求逆来计算增量方程，由于矩阵求逆是复杂度为 $O(n^3 )$ 的操作，这是非常消耗计算资源的。幸运地是，这里的 H 矩阵是有一定的特殊结构的。利用这个特殊结构，我们可以加速求解过程。</p><p>21 世纪视觉 SLAM 的一个重要进展是认识到了矩阵 H 的稀疏结构，并发现该结构可以自然、显式地用图优化来表示 。</p><p>举例：假设一个场景内有 $2$ 个相机位姿 $(C_1 , C_2 )$ 和 $6$ 个路标 $(P_1 , P_2 , P_3 , P_4 , P_5 , P_6 )$。这些相机和点云所对应的变量为 $ξ_i , i = 1, 2$ 以及 $p_j , j = 1, . . . , 6$。相机 $C_1$ 观测到路标 $P_1 , P_2 , P_3 , P_4$ ，相机 $C_2$ 观测到了路标 $P_3 , P_4 , P_5 , P_6$ 。</p><p>如图所示：相机和路标以圆形节点表示。如果 $i$ 相机能够观测到 $j$ 点云，我们就在它们对应的节点连上一条边。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513160409346.png" alt="image-20220513160409346" style="zoom: 33%;" /></p><p>可以推出该场景下的 BA 目标函数应该是：</p><script type="math/tex; mode=display">\frac{1}{2}\left(\parallel e_{11} \parallel^2+\parallel e_{12} \parallel^2+\parallel e_{13} \parallel^2+\parallel e_{14} \parallel^2+\parallel e_{23} \parallel^2+\parallel e_{24} \parallel^2+\parallel e_{25} \parallel^2+\parallel e_{26} \parallel^2\right)\tag{50}</script><p>这里的 $e_{ij}$ 使用之前定义过的代价函数，即式 $(39)$。以 $e_{11}$ 为例，它描述了在 $C_1$ 看到了 $P_1$ 这件事，与其他的相机位姿和路标无关。令 $J_{11}$  为  $e_{11}$  所对应的雅可比矩阵，不难看出  $e_{11}$  对相机变量 $\xi_2$ 和路标点 $p_2 , . . . , p_6$ 的偏导都为 0。我们把所有变量以 $x = (ξ_1 , ξ_2 , p_1 , . . . , p_6 )^T$ 的顺序摆放，则有：</p><script type="math/tex; mode=display">J_{11}=\frac{\partial e_{11} }{\partial x}=\left(\frac{\partial e_{11} }{\partial \xi_1},0,\frac{\partial e_{11} }{\partial p_1},0,0,0,0,0\right)\tag{51}</script><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161314472.png" alt="image-20220513161314472" style="zoom:50%;" /></p><p>类似地，可以推导出如下图案：</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161435601.png" alt="image-20220513161435601" style="zoom: 50%;" /></p><p>现在考虑更一般的情况，假如我们有 $m$ 个相机位姿，$n $ 个路标点。由于通常路标数量 远远会比相机多，于是有 $n ≫ m$。由上面推理可知，实际当中的 H 矩阵会像下图所示的那样。它的左上角块显得非常小，而右下角的对角块占据了大量地方。除此之外，非 对角部分则分布着散乱的观测数据。由于它的形状很像箭头，又称为<strong>箭头形（Arrow-like） 矩阵</strong>。同时它又很像一把镐子，所以也叫<strong>镐形矩阵</strong>。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161821872.png" alt="image-20220513161821872" style="zoom: 33%;" /></p><p>于是，对应的线性方程组也可以由 $H∆x = g $ 变为如下形式：</p><script type="math/tex; mode=display">\begin{bmatrix}B&E\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}v\\w\end{bmatrix}\tag{52}</script><p>其中 $B$ 是对角块矩阵，每个对角块的维度和相机参数的维度相同，对角块的个数是相机变量的个数。由于路标数量会远远大于相机变量个数，所以 $C$ 往往也远大于 $B$。三 维空间中每个路标点为三维，于是 $C$ 矩阵为对角块矩阵，每个块为 $3 \times 3$ 维矩阵。</p><p>考虑到对角块矩阵求逆的难度远小于对一般矩阵的求逆难度，我们对线性方程组进行高斯消元，目标是消去右上角的非对角部分 $E$，得：</p><script type="math/tex; mode=display">\begin{bmatrix}I&-EC^{-1}\\0&I\end{bmatrix}\begin{bmatrix}B&E\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}I&-EC^{-1}\\0&I\end{bmatrix}\begin{bmatrix}v\\w\end{bmatrix}\tag{53}</script><p>整理得：</p><script type="math/tex; mode=display">\begin{bmatrix}B-EC^{-1}E^T&0\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}v-EC^{-1}w\\w\end{bmatrix}\tag{54}</script><p>经过消元之后，第一行方程组变成和 $∆x_p$ 无关的项。单独把它拿出来，得到关于位姿部分的增量方程：</p><script type="math/tex; mode=display">[B-EC^{-1}E^T]\Delta x_c=v-EC^{-1}w\tag{55}</script><p>这个线性方程组的维度和 $B$ 矩阵一样。我们的做法是先求解这个方程，然后把解得 的 $∆x_c$ 代入到原方程，然后求解 $∆x_p$ 。</p><script type="math/tex; mode=display">\Delta x_p=C^{-1}(w-E^T\Delta x_c)\tag{56}</script><p>这个过程称为 <strong>Marginalization</strong>，或者 <strong>Schur 消元 (Schur Elimination)</strong>。</p><p>我们记 式 $(55)$ 中的 $\Delta x_c$的系数为 $S=B-EC^{-1}E^T$ ，我们看一下它的稀疏性：</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513165129947.png" alt="image-20220513165129947" style="zoom: 33%;" /></p><p>$S$ 矩阵的非对角线上的非零矩阵块，表示了该处对应的两个相机变量之间存在着共同观测的路标点，有时候称为<strong>共视（Co-visibility）</strong>。反之，如果该块为零，则表示这两个相机没有共同观测。如上图所示的稀疏矩阵，左上角前 $4 \times 4$ 个矩阵块可以表示对应的相 机变量 $C_1 , C_2 , C_3 , C_4$ 之间有共同观测。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="最小二乘法" scheme="https://lukeyalvin.top/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"/>
    
    <category term="后端优化" scheme="https://lukeyalvin.top/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    <category term="BA与图优化" scheme="https://lukeyalvin.top/tags/BA%E4%B8%8E%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>高斯分布、协方差矩阵以及舒尔补的应用</title>
    <link href="https://lukeyalvin.top/posts/2613d057.html"/>
    <id>https://lukeyalvin.top/posts/2613d057.html</id>
    <published>2022-05-11T12:38:35.000Z</published>
    <updated>2022-05-20T11:59:47.778Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="概率与概率密度"><a href="#概率与概率密度" class="headerlink" title="概率与概率密度"></a>概率与概率密度</h2><p><img src="/images/SLAM中的概率基础/image-20220511204935450.png" alt="image-20220511204935450" style="zoom:50%;" /></p><p>图中，函数 $p(x)$ 表示 $x$ 在区间 $[a,b]$ 上的<strong>概率密度</strong>，它表示的是随机变量在区间的分布情况。</p><p>$Pr$ 代表的是 $x$ 在区间 $[c,d]$ 上的<strong>概率</strong>，它是概率密度函数的积分：</p><script type="math/tex; mode=display">Pr(c\leq x \leq d)=\int^d_c p(x)dx\tag{1}</script><p>我们平时所说“高斯分布”、“非高斯分布”均是指它的概率密度。</p><h2 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h2><p><strong>联合概率</strong>表示两个事件共同发生的概率。事件 $A$ 和事件 $B$ 的联合概率表示为 $P(A\cap B),P(A,B),P(AB)$ </p><p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ 的联合概率密度函数可以表示为 $p(x,y)$，其积分表示 $x,y$ 同处在某个区间的概率，满足下式：</p><script type="math/tex; mode=display">\int^b_a\int^s_rp(x,y)dydx=1\tag{2}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p><script type="math/tex; mode=display">p(x,y)=p(x)p(y)\tag{3}</script><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>就是事件 $A$ 在事件 $B$ 发生的条件下发生的概率。即为 $P(B|A)$.</p><p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ ，当在 $y$ 已知的前提下，$x$ 的概率分布满足下式：</p><script type="math/tex; mode=display">p(x)=\int^s_r p(x|y)p(y)dy\tag{4}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p><script type="math/tex; mode=display">p(x|y)=p(x)\tag{5}</script><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>联合概率分解成条件概率和边缘概率的乘积，即</p><script type="math/tex; mode=display">p(x,y)=p(x|y)p(y)=p(y|x)p(x)\tag{6}</script><p>重新整理，即可得贝叶斯公式</p><script type="math/tex; mode=display">p(x|y)=\frac{p(y|x)p(x)}{p(y)}\tag{7}</script><h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>贝叶斯推断可以理解为贝叶斯公式的运用，它是指，如果已知<strong>先验</strong>概率密度函数 $p(x)$，以及<strong>传感器模型</strong> $p(y|x)$，那么就可以根据贝叶斯公式推断出<strong>后验</strong>概率密度。</p><script type="math/tex; mode=display">p(x|y)=\frac{p(y|x)p(x)}{\int p(y|x)p(x)dx}\tag{8}</script><p>实际中，贝叶斯推断有时也叫贝叶斯估计。</p><h2 id="高斯概率密度函数"><a href="#高斯概率密度函数" class="headerlink" title="高斯概率密度函数"></a>高斯概率密度函数</h2><p><strong>一维情况下，</strong>高斯概率密度函数表示：</p><script type="math/tex; mode=display">p(x|\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2} }\exp(-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2})\tag{9}</script><p>其中 $\mu$ 为均值， $\sigma$ 为方差。</p><p><strong>多维情况下，</strong>高斯概率密度函数表示为：</p><script type="math/tex; mode=display">p(x|\mu,\Sigma)=\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)\tag{10}</script><p>其中 $\mu$ 为均值， $\Sigma$ 为方差。</p><p>一般把高斯分布写成 $x\sim\mathcal{N}(\mu,\Sigma)$。</p><h2 id="联合高斯概率密度函数"><a href="#联合高斯概率密度函数" class="headerlink" title="联合高斯概率密度函数"></a>联合高斯概率密度函数</h2><p>若有高斯分布：</p><script type="math/tex; mode=display">\begin{align*}p(x)&=\mathcal{N}(\mu_x,\Sigma_{xx})\\p(x)&=\mathcal{N}(\mu_y,\Sigma_{yy})\end{align*}\tag{11}</script><p>则它们的联合概率密度函数可以表示为:</p><script type="math/tex; mode=display">p(x,y)=\mathcal{N}\left(\begin{bmatrix}\mu_x\\\mu_y\end{bmatrix},\begin{bmatrix}\Sigma_{xx}&\Sigma_{xy}\\\Sigma_{yx}&\Sigma_{yy}\end{bmatrix}\right)\tag{12}</script><p>由于联合概率满足下式:</p><script type="math/tex; mode=display">p(x,y)=p(x|y)p(y)\tag{13}</script><p>该式在高斯分布的前提下可以重新分解。</p><h1 id="高斯分布和协方差矩阵"><a href="#高斯分布和协方差矩阵" class="headerlink" title="高斯分布和协方差矩阵"></a>高斯分布和协方差矩阵</h1><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>由公式 $(10)$可知，零均值的多元高斯分布有如下概率形式：</p><script type="math/tex; mode=display">\begin{align*}p(x)=&\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(-\frac{1}{2}x^T\Sigma^{-1}x\right)\\=&\frac{1}{Z }\exp\left(-\frac{1}{2}x^T\Sigma^{-1}x\right)\end{align*}\tag{14}</script><p>其中 $\Sigma$ 是<strong>协方差矩阵</strong>，协方差矩阵的逆记作 $Λ = \Sigma^{-1}$ ，也称之为<strong>信息矩阵</strong>。</p><p>比如变量 $x$ 为三维的变量时，协方差矩阵为:</p><script type="math/tex; mode=display">\Sigma=\begin{bmatrix}\Sigma_{11}&\Sigma_{12}&\Sigma_{13}\\\Sigma_{21}&\Sigma_{22}&\Sigma_{23}\\\Sigma_{31}&\Sigma_{32}&\Sigma_{33}\end{bmatrix}\tag{15}</script><p>根据协方差的定义，其中 $Σ_{ij} = E(x_ix_j ) $为对应元素求期望。</p><p>关于协方差矩阵的一些案例介绍，可以查看，<a href="https://lukeyalvin.top/posts/8369.html#%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">协方差矩阵</a></p><h2 id="协方差矩阵与信息矩阵"><a href="#协方差矩阵与信息矩阵" class="headerlink" title="协方差矩阵与信息矩阵"></a>协方差矩阵与信息矩阵</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>设 $x_2$ 为室外的温度，$x_1 , x_3$ 分别为房间 $1$ 和房间 $3$ 的室内温度:</p><script type="math/tex; mode=display">\begin{align*}x_2&=v_2\\x_1&=w_1x_2+v_1\\x_3&=w_3x_2+v_3\\\end{align*}\tag{16}</script><p>其中，$w_i$ 为正的常数值，$v_i$ 相互独立，且各自服从协方差矩阵为 $\sigma_i^2$ 的高斯分布。</p><p><img src="/images/SLAM中的概率基础/image-20220512153417672.png" alt="image-20220512153417672" style="zoom:25%;" /></p><p>从上述关系，根据协方差公式的计算方式，我们可以写出 $x$ 的协方差矩阵，先从对角元素开始计算：</p><script type="math/tex; mode=display">\begin{align*}\Sigma_{11}=E(x_1x_1)&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1})({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1}))\\&={\color{red}w_1^2}E({\color{green}v_2^2})+2{\color{red}w_1}E({\color{red}v_1}{\color{green}v_2})+E({\color{red}v_1^2})\\&={\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}\end{align*}\tag{17}</script><p>同理有 $\Sigma_{22}={\color{green}\sigma_2^2},\Sigma_{33}={\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}$ ，对于协方差矩阵的非对角元素：</p><script type="math/tex; mode=display">\begin{align*}\Sigma_{12}&=E(x_1x_2)=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} ){\color{green}v_2})={\color{red}w_1}{\color{green}\sigma_2^2}\\\Sigma_{13}&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} )({\color{blue}w_3}{\color{green}v_2}+{\color{blue}v_3} ))={\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\end{align*}\tag{18}</script><p>以此类推，可以得到整个<strong>协方差矩阵</strong>：</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}\end{bmatrix}\end{align*}\tag{19}</script><p>通过计算<strong>联合高斯分布</strong>从而得到协方差矩阵的逆：</p><script type="math/tex; mode=display">\begin{align*}p(x_1,x_2,x_3)&=p(x_2)p(x_1|x_2)p(x_3|x_2)\\&={\color{green}\frac{1}{Z_2}\exp(-\frac{x^2_2}{2\sigma_2^2})}{\color{red}\frac{1}{Z_1}\exp(-\frac{(x_1-w_1x_2)^2}{2\sigma_1^2})}{\color{blue}\frac{1}{Z_3}\exp(-\frac{(x_3-w_3x_2)^2}{2\sigma_3^2})}\\&=\frac{1}{Z}\exp(-x_2^2[{\color{green}\frac{1}{2\sigma_2^2} }+{\color{red}\frac{w_1^2}{2\sigma_1^2} }-{\color{blue}\frac{w_3^2}{2\sigma_3^2} }]-x_1^2{\color{red}\frac{1}{2\sigma_1^2} }+2x_1x_2{\color{red}\frac{w_1}{2\sigma_1^2} }-x_3^2{\color{blue}\frac{1}{2\sigma_3^2} }+2x_3x_2{\color{blue}\frac{w_3}{2\sigma_3^2} })\\&=\frac{1}{Z}\exp(-\frac{1}{2}\begin{bmatrix}x_1&x_2&x_3\end{bmatrix}\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&{\color{blue}-\frac{w_3}{\sigma_3^2} }\\0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix})\end{align*}\tag{20}</script><p>由此得到协方差矩阵的逆，即<strong>信息矩阵</strong>：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&{\color{blue}-\frac{w_3}{\sigma_3^2} }\\0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }\end{bmatrix}\tag{21}</script><p><strong>总结：</strong></p><p><font color="#660066">协方差矩阵中，非对角元素 $\Sigma_{ij}&gt;0，i\ne j$ 表示两个变量之间是<strong>正相关</strong>；非对角元素 $\Sigma_{ij}=0，i\ne j$ 表示两个变量之间是<strong>相互独立</strong>；</font><br /></p><p><font color="#660066">信息矩阵中，非对角元素 $Λ_{ij}&lt;0，i\ne j$ 甚至于  $Λ_{ij}=0，i\ne j$ ，比如 $Λ_{12} &lt; 0$   表示在变量 $x_3$ 发生的条件下，元素 $x_1$ 和 $x_2$ <strong>正相关</strong>。  </font><br /></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>类似与案例一，定义 $x_1,x_2,x_3$ 关系如下：</p><script type="math/tex; mode=display">x_2=w_1x_1+w_3x_3+v_2\tag{22}</script><p>比如特征三角化，两个相机 pose 得到特征三维坐标。</p><p><img src="/images/SLAM中的概率基础/image-20220512164657043.png" alt="image-20220512164657043" style="zoom:25%;" /></p><p>同理，根据协方差矩阵的定义，可以得到协方差矩阵：</p><script type="math/tex; mode=display">\Sigma=\begin{bmatrix}{\color{red}\sigma_1^2}&{\color{red}w_1} {\color{red}\sigma_1^2}&0\\{\color{red}w_1} {\color{red}\sigma_1^2}&{\color{green}\sigma_2^2}+{\color{red}w_1} {\color{red}\sigma_1^2}+{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}w_3}  {\color{blue}\sigma_3^2}\\0&{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}\sigma_3^2}\end{bmatrix}\tag{23}</script><p><strong>协方差矩阵中非对角元素为 0 表示变量之 间没有相关性。</strong>这是否意味着信息矩阵中也会为 0 呢？</p><p>同样的方法求得协方差矩阵的逆，即<strong>信息矩阵</strong>：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }+{\color{green}\frac{w_1^2}{\sigma_2^2} }&{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{w_1w_3}{\sigma_2^2} }\\{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{1}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }\\{\color{green}\frac{w_1w_3}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }&{\color{BLUE}\frac{1}{\sigma_3^2} }+{\color{green}\frac{w_3^2}{\sigma_2^2} }\end{bmatrix}\tag{24}</script><p><strong>总结：</strong></p><p><span style="color:red;">虽然 $x_1$ 和 $x_3$ <strong>不相关</strong>，但是不说明他们的信息矩阵对应元素 $Λ_{13}$<br>为 0；恰恰信息矩阵中 $Λ_{13} &gt; 0$, 表示的是在变量 $x_2$ 发生的条件下，变 量$x_1$ 和 $x_3$ 成<strong>负相关</strong>。对应上面的例子即  $x_2$ 为常数，<strong>如果 $x_1$  大，则 $x_3$ 小</strong>。</span></p><p><strong>样例的意义: 非常有助于我们了解 SLAM 的信息矩阵 H 的组成。</strong></p><h3 id="去除案例1中变量"><a href="#去除案例1中变量" class="headerlink" title="去除案例1中变量"></a>去除案例1中变量</h3><p>如果我们移除变量，信息矩阵或协方差矩阵如何变化呢?</p><p>比如对于案例一来说，去除变量$x_3$，那么它的信息矩阵或协方差矩阵如何变化呢?</p><p><img src="/images/SLAM中的概率基础/image-20220512170647991.png" alt="image-20220512170647991" style="zoom:25%;" /></p><p>利用协方差的计算公式可知，$x_1 , x_2$ 计算协方差时跟 $x_3$ ，并无关系，所以:</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }\\\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }&\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }&\xcancel{ {\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2} }\end{bmatrix}\end{align*}\tag{25}</script><p>就能得到去除 $x_3$  后的协方差矩阵：</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}\\\end{bmatrix}\end{align*}\tag{26}</script><p>同样，我们只418133364需要把信息矩阵公式 $(16)$ 中 $x_3$  对应的部分 (蓝色) 去掉 就可以:</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&\xcancel{0}\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2}+\xcancel{ {\color{blue}\frac{w_3^2}{\sigma_3^2} } } }&\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }\\\xcancel{0}&\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }&\xcancel{ {\color{blue}-\frac{1}{\sigma_3^2} } }\end{bmatrix}\tag{27}</script><p>从而得到：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\\end{bmatrix}\tag{28}</script><p>是不是非常简单？但是问题在于：<strong>实际操作过程中并不会有这种颜色标记。</strong></p><p>这时，需要引入 marginalization <strong>(边缘化)</strong> 和 Schur’s complement <strong>(舒尔补)</strong>来解决这个问题。</p><h1 id="舒尔补及其应用"><a href="#舒尔补及其应用" class="headerlink" title="舒尔补及其应用"></a>舒尔补及其应用</h1><h2 id="舒尔补的概念"><a href="#舒尔补的概念" class="headerlink" title="舒尔补的概念"></a>舒尔补的概念</h2><p>给定任意矩阵块 $M$，如下所示：</p><script type="math/tex; mode=display">M=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{29}</script><p>如果，矩阵块 $D$ 是可逆的，则 $A − BD^{−1} C$称之为 $D$ 关于 $M$ 的舒尔补。</p><p>如果，矩阵块 $A$ 是可逆的，则 $D − CA^{−1} B$ 称之为 $A$ 关于 $M$ 的舒尔补。</p><h2 id="舒尔补的来由"><a href="#舒尔补的来由" class="headerlink" title="舒尔补的来由"></a>舒尔补的来由</h2><p>将 $M$ 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&B\\C&D\end{bmatrix}=\begin{bmatrix}A&B\\0&\Delta_A\end{bmatrix}\\\begin{bmatrix}A&B\\C&D\end{bmatrix}\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&0\\C&\Delta_A\end{bmatrix}\end{align*}\tag{30}</script><p>其中：$∆_A = D − CA^{−1} B$。联合起来，将 $M$ 变形成对角形：</p><script type="math/tex; mode=display">\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&B\\C&D\end{bmatrix}\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\tag{31}</script><p>反过来，我们又能从对角形恢复成矩阵 $M$：</p><script type="math/tex; mode=display">\begin{bmatrix}I&0\\CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\begin{bmatrix}I&A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{32}</script><h2 id="舒尔补分解的好处"><a href="#舒尔补分解的好处" class="headerlink" title="舒尔补分解的好处"></a>舒尔补分解的好处</h2><p><strong>快速求解矩阵 M 的逆</strong>。由于矩阵 $M$ 可以写成：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}=\begin{bmatrix}I&0\\CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\begin{bmatrix}I&A^{-1}B\\0&I\end{bmatrix}\tag{33}</script><p>由此可得到矩阵 $M$ 的逆：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\tag{34}</script><p>我们发现，原本复杂的求逆矩阵的过程变得更加容易了。</p><h2 id="舒尔补应用于多元高斯分布"><a href="#舒尔补应用于多元高斯分布" class="headerlink" title="舒尔补应用于多元高斯分布"></a>舒尔补应用于多元高斯分布</h2><p>假设多元变量 $x$ 服从高斯分布，且由两部分组成：$x=\begin{bmatrix}a\\b\end{bmatrix}$，变量之间的协方差矩阵为：</p><script type="math/tex; mode=display">K=\begin{bmatrix}Cov(a,a)&Cov(a,b)\\Cov(b,a)&Cov(b,b)\end{bmatrix}=\begin{bmatrix}A&C^T\\C&D\end{bmatrix}\tag{35}</script><p>依据公式 $(6)$ ，变量 $x$ 的概率分布为：</p><script type="math/tex; mode=display">P(a,b)=p(b|a)p(a)∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\tag{36}</script><p>利用舒尔补进行分解指数部分：</p><script type="math/tex; mode=display">\begin{align*}&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}I&-A^{-1}C^T\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a^T&(b-CA^{-1}a)^T\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}a\\b-CA^{-1}a\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)+(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)\right)\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\&∝p(a)p(b|a)\end{align*}\tag{37}</script><p>类似与公式 $(6)$ 的贝叶斯公式，我们将联合概率分解成条件概率和边缘概率的乘积。对于高斯分布而言，我们可以从多元高斯分布 $P(a,b)$ 中分解得到边际概率 $p(a)$ 和 条件概率 $p(b|a)$。</p><h3 id="P-a-P-b-a-的协方差矩阵"><a href="#P-a-P-b-a-的协方差矩阵" class="headerlink" title="$P(a), P(b|a)$ 的协方差矩阵"></a>$P(a), P(b|a)$ 的协方差矩阵</h3><p>$P(a)$ 的启示:</p><script type="math/tex; mode=display">P(a)∝\exp\left(-\frac{1}{2}a^TA^{-1}a\right)\sim\mathcal{N}(0,A)\tag{38}</script><p><span style="color:red;"><strong>启示：边际概率的协方差就是从联合分布中取对应的矩阵块就行了。</strong></span></p><p>$P(b|a)$ 的启示:</p><script type="math/tex; mode=display">P(b|a)∝\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T\Delta_A^{-1}(b-CA^{-1}a)\tag{39}\right)</script><p><span style="color:red;"><strong>启示：$P(b|a)\sim \mathcal{N} (CA^{−1} a,\Delta_A )$。条件概率的协方差变为 $a$ 对应的舒尔补，均值也变了。</strong></span></p><h3 id="P-a-P-b-a-的信息矩阵"><a href="#P-a-P-b-a-的信息矩阵" class="headerlink" title="$P(a), P(b|a)$ 的信息矩阵"></a>$P(a), P(b|a)$ 的信息矩阵</h3><p><strong>为什么要讨论 $P (a), P (b|a)$ 的信息矩阵？</strong><br>因为基于优化的 SLAM 问题中，我们往往直接操作的是<strong>信息矩阵</strong>，而不是协方差矩阵。所以，有必要知道边际概率，条件概率的信息矩阵是何形式。</p><p>假设已知<strong>联合分布的信息矩阵</strong>：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\tag{40}</script><p>另外，由公式 $(34)$ 可知，协方差矩阵各块和信息矩阵之间有：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}A^{-1}+A^{-1}C^T\Delta_A^{-1}CA^{-1}&-A^{-1}C^T\Delta_A^{-1}\\-\Delta_A^{-1}CA^{-1}&\Delta_A^{-1}\end{bmatrix}\triangleq\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\tag{41}</script><p>其中：$∆_A^{-1} = [D − CA^{−1} B]^{-1}$。</p><p>由条件概率 $P (b|a)$ 的<strong>协方差矩阵</strong>为 $∆_A$ 以及公式 $(41)$，易得其<strong>信息矩阵</strong>为：</p><script type="math/tex; mode=display">∆_A^{-1}=Λ_{bb}\tag{42}</script><p>由边际概率 $P (a)$ 的<strong>协方差矩阵</strong>为 $A$ 以及公式$(41)$，易得其<strong>信息矩阵</strong>为：</p><script type="math/tex; mode=display">A^{-1}=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\tag{43}</script><p>由此我们就知道如何从<strong>联合分布的信息矩阵</strong>中求解 $P ( a )$和 $P(b|a)$ 的<strong>信息矩阵</strong>了。</p><h2 id="回顾样例"><a href="#回顾样例" class="headerlink" title="回顾样例"></a>回顾样例</h2><p>回顾 “<strong>去除案例1中变量</strong>” 中去除变量 $x_3$ 的操作</p><p><img src="/images/SLAM中的概率基础/image-20220512213456958.png" alt="image-20220512213456958" style="zoom: 33%;" /></p><p>从联合分布 $P (x_1 , x_2 , x_3 )$中 marg 掉变量 $x_3$ ，即 $P (x_1 , x_2 )$ 对应的信息矩阵可以用公式 $(43)$ 得到。</p><script type="math/tex; mode=display">\begin{align*}\Sigma^{-1}_2&=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\\&=Λ_{aa}-\begin{bmatrix}0\\-\frac{w_3}{\sigma^2_3}\end{bmatrix}\sigma^2_3\begin{bmatrix}0&-\frac{w_3}{\sigma^2_3}\end{bmatrix}\\&=Λ_{aa}-\begin{bmatrix}0&0\\0&\frac{w_3}{\sigma^2_3}\end{bmatrix}\\&=\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\\end{bmatrix}\end{align*}\tag{44}</script><p>这么操作，就使得在已知<strong>联合分布的信息矩阵</strong>的前提下，我们通过舒尔补的操作，即 $(44)$ 中的 $Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}$，65                   </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。 条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。</strong> 表格总结如下:</p><script type="math/tex; mode=display">P(a,b)=\mathcal{N}\left(\begin{bmatrix}\mu_a\\\mu_b\end{bmatrix},\begin{bmatrix}\Sigma_{aa}&\Sigma_{ab}\\\Sigma_{ba}&\Sigma_{bb}\end{bmatrix}\right)=\mathcal{N}^{-1}\left(\begin{bmatrix}\eta_a\\\eta_b\end{bmatrix},\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\right)\tag{45}</script><p><img src="/images/SLAM中的概率基础/image-20220512215118251.png" alt="image-20220512215118251" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学基础" scheme="https://lukeyalvin.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="概率基础" scheme="https://lukeyalvin.top/tags/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    
    <category term="舒尔补" scheme="https://lukeyalvin.top/tags/%E8%88%92%E5%B0%94%E8%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_0-论文翻译</title>
    <link href="https://lukeyalvin.top/posts/159ef5f4.html"/>
    <id>https://lukeyalvin.top/posts/159ef5f4.html</id>
    <published>2022-05-11T08:37:45.000Z</published>
    <updated>2022-05-22T06:16:35.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节主要对原始论文进行翻译。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="VINS-Mono"><a href="#VINS-Mono" class="headerlink" title="VINS-Mono"></a>VINS-Mono</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>摘要：由相机和低成本惯性测量单元 (IMU) 组成的单目视觉惯性系统 (VINS) 构成了用于度量六自由度 (DOF) 状态估计的最小传感器套件。然而，缺乏直接距离测量，在 IMU 处理、估计器初始化、外部校准和非线性优化方面提出了重大挑战。在这项工作中，我们介绍了 VINS-Mono：一种强大且通用的单目视觉惯性状态估计器。我们的方法从<strong>估计器初始化</strong>和故障恢复的稳健程序开始。通过<strong>融合预积分</strong>的 IMU 测量和特征观测，使用一种基于<strong>紧耦合</strong>、<strong>非线性优化</strong>的方法来获得高精度的视觉惯性里程计。<strong>回环检测</strong>模块与我们的紧密耦合公式相结合，可以以最小的计算开销实现重新定位。我们还执行了四个自由度<strong>位姿图优化</strong>，以强制执行<strong>全局一致性</strong>。我们在公共数据集和真实世界的实验中验证了我们系统的性能，并与其他最先进的算法进行了比较。我们还在 MAV 平台上执行机载闭环自主飞行，并将算法移植到基于 iOS 的演示中。我们强调，所提出的工作是一个可靠、完整且通用的系统，适用于需要高精度定位的不同应用。我们为 PC$^1$ 和 iOS $^2$ 移动设备开源了我们的实现。</p><blockquote><p>$^1$<a href="https://github.com/HKUST-Aerial-Robotics/VINS-Mono">https://github.com/HKUST-Aerial-Robotics/VINS-Mono</a><br>$^2$ <a href="https://github.com/HKUST-Aerial-Robotics/VINS-Mobile">https://github.com/HKUST-Aerial-Robotics/VINS-Mobile</a></p></blockquote><p>索引词——单目视觉惯性系统、状态估计、传感器融合、同时定位和建图 。</p><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>状态估计无疑是机器人导航、自动驾驶、虚拟现实和增强现实 (AR) 等广泛应用的最基本模块。仅使用单目相机的方法由于其体积小、成本低和易于硬件设置而在该领域获得了极大的兴趣[1]-[5]。然而，单目视觉系统无法恢复公制尺度，因此限制了它们在现实世界机器人应用中的使用。最近，我们看到了用低成本惯性测量单元（IMU）辅助单目视觉系统的增长趋势。这种单目视觉惯性系统 (VINS) 的主要优点是<strong>公制刻度，以及滚动和俯仰角可观</strong>。这使得需要度量状态估计的导航任务成为可能。此外，IMU 测量的集成可以通过弥补由于光照变化、无纹理区域或运动模糊造成的视觉轨迹损失之间的差距，从而显着提高运动跟踪性能。单目VINS不仅在地面机器人和无人机上广泛使用，而且在移动设备上也很实用。它在尺寸、重量和功耗方面对自我和环境感知都有很大的优势。</p><p>但是，有几个问题会影响单目 VINS 的使用。第一个是<strong>严格的初始化</strong>。由于缺乏直接的距离测量，很难将单目视觉结构与惯性测量直接融合。同样认识到 VINS 是高度非线性的这一事实，我们看到了估计器初始化方面的重大挑战。在大多数情况下，系统应该从已知的静止位置启动，并在开始时缓慢而小心地移动，这限制了其在实践中的使用。另一个问题是，对于视觉惯性里程计 (VIO)，<strong>长期漂移</strong>是不可避免的。为了消除漂移，必须开发回环检测、重新定位和全局优化。除了这些关键问题外，对地图保存和重用的需求正在增长。</p><p>为了解决所有这些问题，我们提出了 VINS-Mono，这是一种强大且通用的单目视觉惯性状态估计器，它是我们之前三项工作的组合和扩展 [6]-[8]。 VINS-Mono 包含以下功能：</p><ul><li>能够从未知初始状态引导系统的稳健初始化过程；</li><li>紧耦合、基于优化的单目 VIO 与相机-IMU 外部校准和 IMU 偏差校正；</li><li>在线重定位和四自由度（DOF）全局位姿图优化；</li><li>位姿图复用，可以保存、加载和合并多个局部位姿图。</li></ul><p>在这些功能中，稳健的初始化、重定位和位姿图重用是我们的技术贡献，这些贡献来自我们之前的工作 [6]-[8]。工程贡献包括开源系统集成、无人机导航实时演示和移动应用。整个系统已成功应用于小规模 AR 场景、中规模无人机导航和大规模状态估计任务，如图 1 所示。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220516104928638.png" alt="image-20220516104928638" style="zoom:33%;" /></p><blockquote><p>(a) 轨迹（蓝色）和特征位置（红色）</p></blockquote><p><img src="/images/VINS-Mono-0-论文翻译/image-20220516105005304.png" alt="image-20220516105005304" style="zoom:33%;" /></p><blockquote><p>(b) 用谷歌地图覆盖的轨迹以进行视觉比较</p><p>图 1 所提出的单目视觉惯性状态估计器的室外实验结果。数据是在正常行走条件下由手持单目相机-IMU 设置收集的。它包括场地内的两个完整圆和附近车道上的两个半圆。总轨迹长度为 2.5 公里。实验视频可在多媒体附件中找到。</p></blockquote><p>本文的其余部分的结构如下：在第二节中，我们讨论了相关的文献。在第三节中，我们对完整的系统框架进行了概述。在第四节中，给出了视觉的预处理和IMU测量值的预积分步骤。在第五节中，我们讨论了估计器的初始化过程。在第六节中提出了一种紧耦合、自标定、非线性优化的单目VIO。第七节和第八节分别给出了紧耦合重定位和全局位姿图优化。实施细节和实验结果见第九节。最后，第十节本文对研究方向进行了探讨和展望。</p><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>关于基于单目视觉的状态估计/里程计SLAM的学术工作非常广泛。值得注意的方法包括PTAM[1]、SVO[2]、LSD-SLAM[3]、DSO[5]和ORB-SLAM[4]。显然，尝试对任何方法进行全面回顾都无法完整。然而，在这一节中，我们跳过了关于只使用视觉的方法的讨论，而只专注于关于单目视觉惯性状态估计的最相关的结果。</p><p>处理视觉和惯性测量的最简单方法是<strong>松耦合传感器融合</strong> [9]、[10]，其中 IMU 被视为一个独立模块，以辅助从运动的视觉结构中获得的仅视觉姿态估计。融合通常由扩展卡尔曼滤波器 (EKF) 完成，其中 IMU 用于状态传播，而视觉位姿用于更新。此外，紧耦合的视觉惯性算法要么基于 EKF[11]-[13]，，要么基于图优化 [14]-[19]，，其中相机和IMU测量值是从原始测量水平联合优化的。一种流行的<strong>基于 EKF 的 VIO 方法</strong>是 <strong>MSCKF</strong> [11]、[12]。 MSCKF 在状态向量中维护几个先前的相机位姿，并使用跨多个相机视图的相同特征的视觉测量来形成多约束更新。 SR-ISWF  [20]、[21] 是 MSCKF 的扩展。它采用<strong>平方根</strong>（$squareroot$）形式[14]实现单精度表示，避免了较差的数值性质。该方法采用<strong>逆滤波器</strong>进行迭代再线性化，使其与基于优化的算法相当。<strong>批量图优化或集束调整技术</strong>（$Batch\ graph\ optimization\<br>or\ bundle\ adjustment\ techniques\ ,BA$）维护和优化所有测量值以获得最优状态估计。为了达到恒定的处理时间，流行的基于图的VIO方法[15]、[17]、[18]通常采用<strong>边缘化</strong>过去的状态和测量来优化最近状态的有界滑动窗口。由于对非线性系统迭代求解的计算要求很高，很少有基于图的非线性系统能够在资源受限的平台（如手机上）实现实时性能。</p><p>对于视觉测量处理，根据<strong>视觉残差模型</strong>的定义，算法可分为<strong>直接法</strong>和<strong>间接法</strong>。直接法 [2] [3] [22]<strong>最小化光度误差</strong>，而间接法<strong>最小化几何位移</strong>。直接法因其吸引区域小，需要很好的初始估计，而间接法 [12]、[15]、[17]在提取和匹配特征时需要额外的计算资源。间接法由于其成熟性和鲁棒性，在实际工程部署中得到了广泛的应用。然而，直接法更容易扩展到稠密建图，因为它们是直接在像素级别上操作的。</p><p>在实践中，IMU 通常以比相机高得多的速率获取数据。已经提出了不同的方法来处理高速 IMU 测量。最直接的方法是在基于 EKF 的方法 [9]、[11] 中使用 IMU 进行状态传播。在图优化公式中，为了避免重复的IMU重复积分，提出了一种有效的方法，即<strong>IMU预积分</strong>($IMU\ pre-integration$)。这种方法在[23]中首次提出的，它<strong>用欧拉角来参数化旋转误差</strong>。[16] 使用连续时间误差状态动力学推导出协方差传播。然而IMU偏置被忽略了。在 [19] 和 [24]中通过增加后验IMU偏置校正，进一步改进了预积分理论。</p><p>精确的初始值对于引导任何单目VINS是至关重要的。在 [17] 和 [25] 中提出了一种利用短期IMU预积分相对旋转的线性估计器初始化方法。但是，该方法不对陀螺仪偏置进行建模，也不能模拟原始投影方程中的传感器噪声。在实际应用中，当视觉特性远离传感器套件时，这会导致不可靠的初始化。在[26]中给出了单目视觉惯性初始化问题的一种封闭解。随后，在[27]中提出了通过添加陀螺仪偏置校准来扩展这种封闭形式的解决方案。这些方法无法对惯性积分中的不确定性进行建模，因为它们依赖于长时间内 IMU 测量的双重积分。在[28]中，提出了一种基于SVO [2]的重新初始化和故障恢复算法。需要一个额外的向下距离传感器来恢复公制刻度。 [18] 中介绍了一种建立在流行的 ORB-SLAM [4] 之上的初始化算法。据研究，尺度收敛所需的时间可以超过 10 s。这可能会给机器人导航任务带来问题，这些任务一开始就需要规模估计。</p><p>里程计方法，无论它们所依赖的基础数学公式如何，都会在全局平移和方向上长期漂移。为此，闭环在长期运营中发挥着重要作用。 ORB-SLAM [4] 能够闭合回环    并重用地图，这利用了词袋 [29]。一个 7-DOF [30]（位置、方向和比例）位姿图优化跟随循环检测。</p><h1 id="三、概述"><a href="#三、概述" class="headerlink" title="三、概述"></a>三、概述</h1><p>所提出的单目视觉惯性状态估计器的结构如图 2 所示。该系统从测量<strong>预处理开始</strong>（参见第 IV 节），其中提取和跟踪特征，并对两个连续帧之间的 IMU 测量进行预积分。<strong>初始化过程</strong>（参见第 V 节）提供了所有必要的值，包括姿态、速度、重力矢量、陀螺仪偏差和三维 (3-D) 特征位置，用于引导后续基于非线性优化的 VIO。带有<strong>重定位</strong>（参见第 VII 节）模块的 <strong>VIO</strong>（参见第 VI 节）紧密融合了预积分的 IMU 测量、特征观察。最后，<strong>位姿图优化模块</strong>（参见第 VIII 节）采用经过几何验证的重定位结果，并执行全局优化以消除漂移。它还实现了位姿图重用。 VIO 和位姿图优化模块在单独的线程中同时运行。</p><p>与适用于立体相机的最先进的 VIO 算法 OKVIS [15] 相比，我们的算法是专门为单目相机设计的。因此，我们特别提出了初始化程序、关键帧选择标准，并使用和处理大视场 (FOV) 相机以获得更好的跟踪性能。此外，我们的算法提出了一个完整的系统，具有闭环和位姿图重用模块。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220516110348319.png" alt="image-20220516110348319"></p><blockquote><p>图 2. 一个框图，说明了所提出的单目视觉惯性状态估计器的完整流程。</p></blockquote><p>我们现在定义我们在整篇论文中使用的符号和坐标系定义。我们将 $(·)^w$ 视为世界坐标系。重力方向与世界坐标系的 $z$ 轴对齐。$ (·)^b$是body 坐标系，我们定义它和IMU 坐标系一样。$ (·)^c $ 是相机坐标系。我们使用旋转矩阵 $R$ 和 Hamilton 四元数 $q$ 来表示旋转。我们主要在状态向量中使用四元数，但旋转矩阵也用于方便地旋转三维向量。  $q^w_b , p^w_b$ 是从本体坐标系到世界坐标系的旋转和平移。$b_k$ 是拍摄第 $k$ 张图像时的本体坐标系。 $c_k$ 是拍摄第 $k$ 张图像时的相机帧。 $\otimes$ 表示两个四元数之间的乘法运算。$g^w = [0, 0, g]^T$ 是世界坐标系中的重力矢量。最后，我们将 $\hat{(·)}$ 表示为某个量的噪声测量或估计。</p><h1 id="四、测量预处理"><a href="#四、测量预处理" class="headerlink" title="四、测量预处理"></a>四、测量预处理</h1><p>本节介绍惯性和单目视觉测量的预处理步骤。对于视觉测量，我们跟踪连续帧之间的特征并检测最新帧中的新特征。对于 IMU 测量，我们将它们预积分在两个连续的帧之间。请注意，我们使用的低成本 IMU 的测量值会受到偏差和噪声的影响。因此，我们在 IMU 预积分过程中特别考虑了偏差。</p><h2 id="A-视觉处理前端"><a href="#A-视觉处理前端" class="headerlink" title="A. 视觉处理前端"></a>A. 视觉处理前端</h2><p>对于每一幅新图像，<strong>KLT 稀疏光流算法</strong>对现有特征进行跟踪[29]。同时，检测新的角点特征[30]以保证每个图像特征的最小数目 (100-300)。该检测器通过设置两个相邻特征之间像素的最小间隔强制实现均匀的特征分布。二维特征首先是不失真的，然后在通过剔除异常点后，投影到一个单位球面上。利用<strong>基础矩阵模型的RANSAC算法</strong>进行异常点剔除。</p><p>在此步骤中还选择了关键帧。我们有两个关键帧选择标准。第一是<strong>与上一个关键帧的平均视差</strong>。如果在当前帧和最新关键帧之间跟踪的特征点的平均视差超出某个特定阈值，则将该帧视为新的关键帧。请注意，不仅平移，旋转也会产生视差。<strong>然而，特征点无法在纯旋转运动中三角化。为了避免这种情况，在计算视差时我们使用陀螺仪测量值的短时积分来补偿旋转</strong>。请注意，此旋转补偿仅用于关键帧选择，而不涉及VINS公式中的旋转计算。为此，即使陀螺仪含有较大的噪声或存在偏置，也只会导致次优的关键帧选择结果，不会直接影响估计质量。另一个标准是<strong>跟踪质量</strong>。如果跟踪的特征数量低于某一阈值，我们将此帧视为新的关键帧。这个标准是为了避免跟踪特征完全丢失。</p><h2 id="B-IMU-预积分"><a href="#B-IMU-预积分" class="headerlink" title="B. IMU 预积分"></a>B. IMU 预积分</h2><p>我们遵循我们之前基于连续时间四元数的 IMU 预积分推导 [16]，并将 IMU 偏差的处理包括为 [19] 和 [24]。我们注意到，我们当前的 IMU 预积分过程与 [19] 和 [24] 共享几乎相同的数值结果，但使用不同的推导。所以，我们在这里只做一个简单的介绍。有关基于四元数的推导的详细信息，请参见附录 A。</p><p>（1）<strong>IMU 噪声和偏置：</strong>IMU 测量，在本体坐标系中测量，结合了反重力的力和平台动力学，并受到加速度偏差 $b_a$、陀螺仪偏差 $b_w$ 和附加噪声的影响。IMU 的原始陀螺仪和加速度计测量值 $\hat{w}$ 和 $\hat{a}$ 由下式给出：</p><script type="math/tex; mode=display">\begin{align*}\hat{a}_t&=a_t+b_{a_t}+R^t_wg^w+n_a\\\hat{w}_t&=w_t+b_{w_t}+n_w\end{align*}\tag{1}</script><p>I我们假设加速度和陀螺仪测量中的<strong>附加噪声</strong>是高斯噪声，$n_a\sim\mathcal{N}(0,\sigma^2_a),n_w\sim\mathcal{N}(0,\sigma^2_w)$。加速度偏差和陀螺仪偏差被建模为<strong>随机游走</strong>，其导数为高斯，$n_{b_a}\sim\mathcal{N}(0, \sigma^2_{b_a}),n_{b_w}\sim\mathcal{N}(0, \sigma^2_{b_w})$：</p><script type="math/tex; mode=display">\dot{b}_{a_t}=n_{b_a},\ \ \ \ \ \ \dot{b}_{w_t}=n_{b_w}\tag{2}</script><p>（2）<strong>预积分：</strong>对于两个时间连续帧 $b_k$ 和 $b_{k+1}$，在时间间隔 $[t_k , t_{k+1}]$ 内存在多个惯性测量。给定偏差估计，我们将它们整合到局部框架  $b_k$  中：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&=\iint_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})dt^2\\\beta ^{b_k}_{b_{k+1} }&=\int_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})dt\\\gamma^{b_k}_{b_{k+1} }&= \int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t})\gamma^{b_k}_tdt\end{align*}\tag{3}</script><p>其中，</p><script type="math/tex; mode=display">\Omega(w)=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix},w^{\land}=\begin{bmatrix}0&-w_z&w_y\\w_z&0&-w_x\\-w_y&w_x&0\end{bmatrix}\tag{4}</script><p>$α、β$  和 $γ$ 的协方差 $\mathbf{P}^{b_k}_{b_{k+1} }$ 也相应地传播。可以看出，预积分项 $(3)$ 可以通过将 $b_k$ 作为给定偏差的参考系单独使用 IMU 测量来获得。</p><p>（3）<strong>偏差校正：</strong>如果偏差的估计变化很小，我们通过它们关于偏差的一阶近似来调整 $\alpha^{b_k}_{b_{k+1} }$ 、$\beta^{b_k}_{b_{k+1} }$和 $\gamma^{b_k}_{b_{k+1} }$ 为：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&\approx \hat{\alpha}^{b_k}_{b_{k+1} }+\mathbf{J}^{\alpha}_{b_a}\delta b_{a_k}+\mathbf{J}^{\alpha}_{b_w}\delta b_{w_k}\\\beta^{b_k}_{b_{k+1} }&\approx \hat{\beta}^{b_k}_{b_{k+1} }+\mathbf{J}^{\beta}_{b_a}\delta b_{a_k}+\mathbf{J}^{\beta}_{b_w}\delta b_{w_k}\\\gamma^{b_k}_{b_{k+1} }&\approx \hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\end{align*}\tag{5}</script><p>否则，当偏差的估计发生显着变化时，我们会在新的偏差估计下进行重新传播。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传播 IMU 测量。</p><h1 id="五、估计器初始化"><a href="#五、估计器初始化" class="headerlink" title="五、估计器初始化"></a>五、估计器初始化</h1><p>单目紧耦合 VIO 是一个高度非线性的系统，一开始就需要一个准确的初始值。<strong>我们通过将 IMU 预集成与纯视觉结构松耦合对齐来获得必要的初始值</strong>。</p><h2 id="A-滑动窗口纯视觉-SfM"><a href="#A-滑动窗口纯视觉-SfM" class="headerlink" title="A. 滑动窗口纯视觉 SfM"></a>A. 滑动窗口纯视觉 SfM</h2><p>初始化过程从纯视觉 SfM 开始，以估计最大比例的相机姿势和特征位置图。</p><p>我们保持了帧的滑动窗口来限制计算复杂度。首先，我们检查了最新帧与之前所有帧之间的特征对应关系。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪 (超过30个跟踪特征) 和足够的视差 (超过20个的旋转补偿像素)，我们<strong>使用五点法 [33] 恢复这两个帧之间的相对旋转和尺度平移</strong>。否则，我们将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，我们任意设置尺度，并<strong>对这两个帧中观察到的所有特征进行三角化</strong>。基于这些三角特征，<strong>采用PnP[35]来估计窗口中所有其他帧的姿态</strong>。最后，<strong>应用全局光束平差法 (BA) [36]最小化所有特征观测的重投影误差</strong>。由于我们还没有关于世界坐标系的任何知识，我们将第一个相机坐标系 $(·)^{c_0}$ 设置为 SfM 的参考坐标系。所有帧的位姿  $(\overline {\mathbf{p} }_{c_k}^{c_0}，{\mathbf{q} }_{c_k}^{c_0})$ 和特征位置表示相对于 $(·)^{c_0}$ 。假设摄像机和IMU之间有一个粗略测量的外部参数 $({\mathbf{p} }_c^b,{\mathbf{q} }_c^b)$，我们可以将姿态从相机坐标系转换到物体 (IMU) 坐标系。</p><script type="math/tex; mode=display">\begin{align*}{\mathbf{q} }_{b_k}^{c_0}&={\mathbf{q} }_{c_k}^{c_0}\otimes({\mathbf{q} }_c^b)^{-1}\\s\overline {\mathbf{p} }_{b_k}^{c_0}&=s\overline {\mathbf{p} }_{c_k}^{c_0}-{\mathbf{R} }_{b_k}^{c_0}{\mathbf{p} }_c^b\end{align*}\tag{6}</script><p>其中 $s$ 将视觉结构与公制比例对齐的缩放参数。解决这个缩放参数是实现初始化成功的关键。</p><h2 id="B-视觉惯性对齐"><a href="#B-视觉惯性对齐" class="headerlink" title="B. 视觉惯性对齐"></a>B. 视觉惯性对齐</h2><p>视觉惯性对齐的示意图如图 3 所示。基本思想是将按比例放大的视觉结构与 IMU 预积分相匹配。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220517085904500.png" alt="image-20220517085904500" style="zoom:50%;" /></p><blockquote><p>图 3. 估计器初始化的视觉惯性对齐过程示意图。其基本思想是用IMU预积分匹配up-to-scale的视觉结构。</p></blockquote><p>（1）<strong>陀螺仪偏置标定：</strong>考虑窗口中连续两帧 $b_k$ 和 $b_{k+1}$，我们从视觉 SfM 中得到旋转 ${\mathbf{q} }_{b_k}^{c_0}$ 和 ${\mathbf{q} }_{b_{k+1} }^{c_0}$ ，从IMU预积分得到的相对约束 $\hat{\gamma}^{b_k}_{b_{k+1} }$。我们对陀螺仪偏置求IMU预积分项的线性化，并最小化以下代价函数：</p><script type="math/tex; mode=display">\underset{\delta b_w}{\min}\sum_{k\in\mathcal{B} }\parallel{ {\mathbf{q} }_{b_{k+1} }^{c_0} }^{-1}\otimes{\mathbf{q} }_{b_k}^{c_0}\otimes\gamma^{b_k}_{b_{k+1} }\parallel^2\\\gamma^{b_k}_{b_{k+1} }\approx\hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w} \end{bmatrix}\tag{7}</script><p>其中 $\mathcal{B}$ 是索引窗口中的所有帧。利用第四部分推导出的偏置雅可比矩阵，给出了 $\hat{\gamma}^{b_k}_{b_{k+1} }$ 对陀螺仪偏置的一阶近似。这样，我们得到了陀螺仪偏置 $b_w$ 的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分量 $ \hat{\alpha}^{b_k}_{b_{k+1} },\hat{\beta}^{b_k}_{b_{k+1} },\hat{\gamma}^{b_k}_{b_{k+1} }$。</p><p>（2）<strong>速度、重力向量和尺度初始化：</strong>在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：</p><script type="math/tex; mode=display">\mathcal{X}_I=[\mathbf{v}^{b_0}_{b_0},\mathbf{v}^{b_1}_{b_1},···,\mathbf{v}^{b_n}_{b_n},g^{c_0},s]\tag{8}</script><p>其中 $\mathbf{v}^{b_k}_{b_k}$ 是拍摄第 $k$ 张图像时本体坐标系中的速度，$g^{c_0}$ 是 $c_0$ 帧中的重力矢量，$s$ 将单目 SfM 缩放为公制单位。</p><p>考虑窗口中连续的两个帧 $b_k$ 和 $b_{k+1}$，我们有以下等式：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&=\mathbf{R}^{b_k}_{c_0}(s(\overline{\mathbf{p} }_{b_{k+1} }^{c_0}-\overline{\mathbf{p} }_{b_{k} }^{c_0})+\frac{1}{2}g^{c_0}\Delta t^2_k-\mathbf{R}_{b_k}^{c_0}\mathbf{v}^{b_k}_{b_k}\Delta t_k)\\\beta^{b_k}_{b_{k+1} }&=\mathbf{R}^{b_k}_{c_0}(\mathbf{R}_{b_{k+1} }^{c_0}\mathbf{v}^{b_{k+1} }_{b_{k+1} }+g^{c_0}\Delta t_k-\mathbf{R}_{b_k}^{c_0}\mathbf{v}^{b_k}_{b_k})\end{align*}\tag{9}</script><p>我们可以将 $(6)$ 和 $(9)$ 组合成以下线性测量模型：</p><script type="math/tex; mode=display">\hat{\mathbf{z} }^{b_k}_{b_{k+1} }=\begin{bmatrix}\hat{\alpha}^{b_k}_{b_{k+1} }-\mathbf{p}^b_c+\mathbf{R}^{b_k}_{c_0}\mathbf{R}^{c_0}_{b_{k+1} }\mathbf{p}^b_c\\\hat{\beta}^{b_k}_{b_{k+1} }\end{bmatrix}=\mathbf{H}^{b_k}_{b_{k+1} }\mathcal{X}_I+\mathbf{n}^{b_k}_{b_{k+1} }\tag{10}</script><p>其中，</p><script type="math/tex; mode=display">\mathbf{H}^{b_k}_{b_{k+1} }=\begin{bmatrix}-\mathbf{I}\Delta t_k&0&\frac{1}{2}\mathbf{R}^{b_k}_{c_0}\Delta t_k^2&\mathbf{R}^{b_k}_{c_0}(\overline {\mathbf{p} }_{c_{k+1} }^{c_0}-\overline {\mathbf{p} }_{c_k}^{c_0})\\-\mathbf{I}&\mathbf{R}^{b_k}_{c_0}\mathbf{R}^{c_0}_{b_{k+1} }&\mathbf{R}^{b_k}_{c_0}\Delta t_k&0\end{bmatrix}\tag{11}</script><p>可以看出，$\mathbf{R}^{b_k}_{c_0},\ \mathbf{R}^{c_0}_{b_{k+1} },\ \overline {\mathbf{p} }_{c_k}^{c_0}$ 和  $ \overline {\mathbf{p} }_{c_{k+1} }^{c_0}$ 是从up-to-scale 单目视觉SfM 中得到的。 $\Delta t_k$ 是两个连续帧之间的时间间隔。通过解决这个线性最小二乘问题:</p><script type="math/tex; mode=display">\underset{\mathcal{X}_I}{\min}\sum_{k\in\mathcal{B} }\parallel\hat{\mathbf{z} }^{b_k}_{b_{k+1} }-\mathbf{H}^{b_k}_{b_{k+1} }\mathcal{X}_I \parallel^2\tag{12}</script><p>我们可以获得窗口中每一帧本体坐标系的速度、视觉参考帧 $(·)^{c_0}$ 中的重力矢量以及比例参数。</p><p>（3）<strong>重力细化：</strong>通过约束量值，可以对原线性初始化步骤得到的重力向量进行细化。在大多数情况下，重力向量的大小是已知的。这导致重力向量只剩2个自由度。因此，我们在其切线空间上用两个变量重新参数化重力。我们的重力向量受到 $g(\overline{\hat{g} } + \delta g)$ 的扰动，$\delta g = w_1b_1 + w_2b_2$，其中 $g$ 是已知的重力大小，$\overline{\hat{g} }$  是表示重力方向的单位向量。 $b_1$ 和 $b_2$ 是跨越切平面的两个正交基，如图 4 所示。 $w_1$ 和 $w_2$ 分别是对  $b_1$ 和 $b_2$ 的二维扰动。我们可以任意找到任何旋转切线空间的 $b_1$ 和 $b_2$ 集合。然后，我们用  $g(\overline{\hat{g} } + \delta g)$  将  $g$ 代入 $(9)$，并与其他状态变量一起求解 维 $δg$。这个过程迭代了几次，直到 $\hat{g}$ 收敛。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521200811442.png" alt="image-20220521200811442" style="zoom:33%;" /></p><blockquote><p>图 4. 2自由度重力扰动示意图。由于重力的大小是已知的，$g$ 位于半径 $g ≈ 9.81 m/s^2$ 的球体上。重力在当前估计附近受到扰动，因为  $g(\overline{\hat{g} } + \delta g)$ ，$\delta g = w_1b_1 + w_2b_2$,  其中 $b_1$ 和 $b_2$ 是跨越切线空间的两个正交基。</p></blockquote><p>（3）<strong>完成初始化：</strong>对重力向量进行细化后，我们可以通过将重力旋转到 $z$ 轴得到世界坐标系和相机坐标系 $c_0$ 之间的旋转 $\mathbf{q}^w_{c_0}$。然后我们将所有变量从参考坐标系 $(·)^{c_0}$ 旋转到世界坐标系 $(·)^w$ 。本体坐标系速度也将旋转到世界坐标系。来自视觉 SfM 的平移分量将被缩放为公制单位。至此，初始化过程完成，所有这些度量值将被馈送到紧密耦合的单目 VIO。</p><h1 id="六、紧耦合单目VIO"><a href="#六、紧耦合单目VIO" class="headerlink" title="六、紧耦合单目VIO"></a>六、紧耦合单目VIO</h1><p>在估计器初始化之后，我们继续使用基于滑动窗口的紧密耦合单目 VIO，以实现高精度和稳健的状态估计。滑动窗口公式的说明如图 5 所示。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220516150129486.png" alt="image-20220516150129486"></p><blockquote><p>图 5. 带有重定位的滑动窗口单目 VIO 示意图。滑动窗口中存在多个相机位姿、IMU 测量和视觉测量。它是与 IMU、视觉和闭环检测紧密耦合的公式。</p></blockquote><h2 id="A-公式"><a href="#A-公式" class="headerlink" title="A.公式"></a>A.公式</h2><p>滑动窗口中的全状态向量定义为:</p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}&=[\mathbf{x}_0,\mathbf{x}_1,···,\mathbf{x}_n,\mathbf{x}^b_c,\lambda_0,\lambda_1,···,\lambda_m]\\\mathbf{x}_k&=[\mathbf{p}^w_{b_k},\mathbf{v}^w_{b_k},\mathbf{q}^w_{b_k},\mathbf{b}_a,\mathbf{b}_g],k\in[0,n]\\\mathbf{x}^b_c&=[\mathbf{p}^b_c,\mathbf{q}^b_c]\end{align*}\tag{13}</script><p>其中 $\mathbf{x}_k$ 是捕获第 $k$ 个图像时的 IMU 状态。它包含 IMU 在世界坐标系中的位置、速度和方向，以及 IMU 主体框架中的加速度偏差和陀螺仪偏差。 $n$ 是关键帧的总数，$m$ 是滑动窗口中的特征总数。 $λ_l$ 是第 $l$ 个特征与其第一次观察的逆深度。</p><p>我们使用 BA 公式。我们最小化所有测量残差的先验和马氏距离之和，以获得最大后验估计为：</p><script type="math/tex; mode=display">\underset{\mathcal{X} }{\min}\left\{\parallel \mathbf{r}_p-\mathbf{H}_p\mathcal{X} \parallel^2+\sum_{k\in\mathcal{B} }\parallel\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})  \parallel^2_{\mathbf{P}^{b_k}_{b_{k+1} } }+\sum_{(l,j)\in\mathcal{C} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) \parallel^2_{\mathbf{P}^{c_j}_l })\right\}\tag{14}</script><p>其中 Huber 范数 [37] 定义为:</p><script type="math/tex; mode=display">\rho(s)=\left\{ \begin{array}{l}    s\ \  \ \  \ \  \ \  \ \  \ \  \ \  \ \  \ \  s\leq1\\    2\sqrt{s}-1\ \  \ \  \ \  s>1\\\end{array} \right. \tag{15}</script><p>其中 $\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})$ 和 $\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) $ 分别是 IMU 和视觉测量的残差。剩余残差的详细定义将在第 VI-B 和 VI-C 节中介绍。 $\mathcal{B}$ 是所有 IMU 测量值的集合，$\mathcal{C}$  是在当前滑动窗口中至少观察到两次的特征集合。 $\{\mathbf{r}_p, \mathbf{H}_p\}$ 是来自边缘化的先验信息。 Ceres 求解器 [38] 用于解决这个非线性问题。</p><h2 id="B-IMU-测量残差"><a href="#B-IMU-测量残差" class="headerlink" title="B. IMU 测量残差"></a>B. IMU 测量残差</h2><p>考虑滑动窗口中两个连续帧 $b_k$ 和 $b_{k+1}$ 内的 IMU 测量值，预积分 IMU 测量值的残差可以定义为:</p><script type="math/tex; mode=display">\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})=\begin{bmatrix}\delta {\alpha}^{b_k}_{b_{k+1} }\\\delta {\beta}^{b_k}_{b_{k+1} }\\\delta {\theta}^{b_k}_{b_{k+1} }\\\delta {b}_{a}\\\delta {b}_{g}\end{bmatrix}=\begin{align*}\begin{bmatrix}\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}+\frac{1}{2}g^w\Delta t_k^2-\mathbf{v}^w_{b_k}\Delta t_k)-\hat{\alpha}^{b_k}_{b_{k+1} }\\\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_{k+1} }-\mathbf{v}^w_{b_k}+g^w\Delta t_k)-\hat{\beta}^{b_k}_{b_{k+1} }\\2[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz}\\\mathbf{b}_{ab_{k+1} }-\mathbf{b}_{ab_k}\\\mathbf{b}_{wb_{k+1} }-\mathbf{b}_{wb_k}\\\end{bmatrix}\end{align*}\tag{16}</script><p>其中，$[·]_{xyz}$ 是提取四元数 $\mathbf{q}$ 的向量部分，以进行误差状态表示。$\delta {\theta}^{b_k}_{b_{k+1} }$ 是四元数的三维误差状态表示。 $[ \hat{\alpha}^{b_k}_{b_{k+1} },\hat{\beta}^{b_k}_{b_{k+1} },\hat{\gamma}^{b_k}_{b_{k+1} }]$ 是在两个连续图像帧的间隔时间内使用仅包含噪声的加速度计和陀螺仪测量值预积分的IMU测量项。加速度计和陀螺仪偏置也包括在在线校正的残差项中。</p><h2 id="C-视觉测量残差"><a href="#C-视觉测量残差" class="headerlink" title="C. 视觉测量残差"></a>C. 视觉测量残差</h2><p>与在广义图像平面上定义重投影误差的传统针孔相机模型相比，我们在单位球面上定义相机测量残差。几乎所有类型的相机（包括广角相机、鱼眼相机或全向相机）的光学器件都可以建模为连接单位球体表面的单位射线。考虑在第 $i$ 个图像中首先观察到的第 $l$ 个特征，第 $j$ 个图像中特征观察的残差定义为:</p><script type="math/tex; mode=display">\begin{align*}\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X})&=[\mathbf{b}_1,\mathbf{b}_2]^T\cdot(\hat{\overline{\mathcal{P} } }^{c_j}_l-\frac{\mathcal{P}^{c_j}_l}{\parallel\mathcal{P}^{c_j}_l \parallel^2})\\\hat{\overline{\mathcal{P} } }^{c_j}_l&=\pi^{-1}_c\left(\begin{bmatrix}\hat{u}^{c_j}_l\\\hat{v}^{c_j}_l \end{bmatrix}\right)\\\mathcal{P}^{c_j}_l &=\mathbf{R}^c_b\left(\mathbf{R}^{b_j}_w\left(\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\pi^{-1}_c\left(\begin{bmatrix}\hat{u}^{c_i}_l\\\hat{v}^{c_i}_l \end{bmatrix}\right)+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right)-\mathbf{p}^{b}_{c}\right)\end{align*}\tag{17}</script><p>其中 $[\hat{u}^{c_i}_l,\hat{v}^{c_i}_l]$ 是第 $i$ 个图像中发生的第 $l$个特征的第一次观察。 $[\hat{u}^{c_j}_l,\hat{v}^{c_j}_l]$ 是对第 j 个图像中相同特征的观察。 $\pi^{-1}_c$ 是反投影函数，它使用相机内在参数将像素位置转换为单位向量。由于视觉残差的自由度为 2，我们将残差向量投影到切平面上。  $b_1$ 和 $b_2$  是两个任意选择的正交基，它们跨越 $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 的切平面，如图 6 所示。在 $(14)$ 中使用的方差 $\mathbf{P}^{c_j}_l$ 也从像素坐标传播到单位球体上.</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521200846809.png" alt="image-20220521200846809" style="zoom:43%;" /></p><blockquote><p>图 6. 单位球面上的视觉残差图。 $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 是在第 $j$ 帧中观察第 $l$ 个特征的单位向量。$\mathcal{P}^{c_j}_l$  是通过将其在第 $i$ 帧中的第一个观察值转换为第 $j$ 帧来预测的单位球体上的特征测量。残差定义在  $\hat{\overline{\mathcal{P} } }^{c_j}_l$  的切平面上</p></blockquote><h2 id="D-边缘化"><a href="#D-边缘化" class="headerlink" title="D. 边缘化"></a>D. 边缘化</h2><p>为了限制我们基于优化的 VIO 的计算复杂性，加入了边缘化。我们从滑动窗口中选择性地边缘化 IMU 状态 $\mathbf{x}_k$ 和特征 $λ_l$，同时将对应于边缘化状态的测量值转换为先验。</p><p>如图 7 所示，当第二个最新帧是关键帧时，它将停留在窗口中，并且最旧的帧与其相应的测量值一起被边缘化。否则，如果第二个最新帧是非关键帧，我们会抛出视觉测量并保留连接到该非关键帧的 IMU 测量。为了保持系统的稀疏性，我们不会边缘化所有非关键帧的测量值。我们的边缘化方案旨在将空间分离的关键帧保留在窗口中。这确保了特征三角测量有足够的视差，并最大限度地提高了在大激励下保持加速度计测量的概率。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521200953625.png" alt="image-20220521200953625" style="zoom: 43%;" /></p><blockquote><p>图 7. 我们的边缘化策略说明。如果第二个最新帧是关键帧，我们会将其保留在窗口中，并边缘化最旧的帧及其相应的视觉和惯性测量值。边缘化的测量值变成了先验值。如果第二个最新帧不是关键帧，我们将简单地删除该帧及其所有相应的视觉测量。但是，对于非关键帧会保留预积分惯性测量值，并且预积分过程会继续到下一帧。</p></blockquote><p>边缘化是利用Schur补[39]进行的。我们基于与移除状态相关的所有边缘化测量值构造一个新的先验。新的先验项被添加到现有的先验项中。</p><p>我们确实注意到，边缘化导致了线性化点的早期固定，这可能导致次优估计结果。然而，由于小型漂移对于VIO来说是可以接受的，我们认为边缘化所造成的负面效果并不重要。</p><h2 id="E-摄像机速率状态估计的纯运动视觉惯性优化"><a href="#E-摄像机速率状态估计的纯运动视觉惯性优化" class="headerlink" title="E. 摄像机速率状态估计的纯运动视觉惯性优化"></a>E. 摄像机速率状态估计的纯运动视觉惯性优化</h2><p>对于计算能力较低的设备如手机，由于对非线性优化的计算要求很高，紧耦合单目VIO无法实现摄像机速率输出。为此，我们采用了一种轻量级的纯运动视觉惯性优化，以提升状态估计速率到相机速率(30Hz)。</p><p>纯运动单目视觉惯性BA的代价函数与 $(14)$ 中单目VIO的代价函数相同。然而我们只对固定数量的最新IMU状态的姿态和速度进行了优化，而不是对滑动窗口中的所有状态进行优化。我们将特征深度、外部参数、偏置和旧的IMU状态这些不希望优化的状态作为常量来处理。我们使用所有的视觉和惯性测量来进行纯运动的优化。这导致了比单帧PnP方法更平滑的状态估计。图8显示了提出方法的插图。与在最先进的嵌入式计算机上可能导致超过 $50ms$ 的完全紧耦合单目VIO不同，这种纯运动的视觉惯性优化只需大约 $5ms$ 来计算。这使得低延迟的相机频率进行位姿估计对无人机和AR应用特别有利。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201107818.png" alt="image-20220521201107818" style="zoom:43%;" /></p><blockquote><p>图 8. 相机速率输出的仅运动优化图示。</p></blockquote><h2 id="F-IMU前向传递以达到IMU速率状态估计"><a href="#F-IMU前向传递以达到IMU速率状态估计" class="headerlink" title="F. IMU前向传递以达到IMU速率状态估计"></a>F. IMU前向传递以达到IMU速率状态估计</h2><p>IMU 测量的速度比视觉测量高得多。尽管我们的 VIO 的频率受到图像捕获频率的限制，但我们仍然可以使用最近的 IMU 测量值直接传播最新的 VIO 估计值，以实现 IMU 速率性能。高频状态估计可以用作闭环闭合的状态反馈。 IX-C 节介绍了利用该 IMU 速率状态估计的自主飞行实验。</p><h1 id="七、重定位"><a href="#七、重定位" class="headerlink" title="七、重定位"></a>七、重定位</h1><p>我们的滑动窗口和边缘化方案限制了计算复杂度，但它也为系统引入了累积漂移。为了消除漂移，提出了一种与单目 VIO 无缝集成的紧密耦合重定位模块。重新定位过程从一个闭环检测模块开始，该模块识别已经访问过的地方。然后建立闭环候选和当前帧之间的特征级连接。这些特征对应紧密集成到单目 VIO 模块中，从而以最少的计算量实现无漂移状态估计。多个特征的多次观察直接用于重定位，从而获得更高的精度和更好的状态估计平滑度。图 9(a) 显示了重定位过程的图解说明。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201129052.png" alt="image-20220521201129052" style="zoom:40%;" /></p><blockquote><p>(a) 重新定位程序。它从仅 VIO 的姿势估计开始（蓝色）。记录过去的状态（绿色）。如果检测到最新关键帧的闭环（参见第 VII-A 节），如第二个图中的红线所示，则发生了重新定位。请注意，由于使用特征级对应进行重定位，我们能够合并来自多个过去关键帧的闭环约束（参见第 VII-C 节），如最后三个图中所示。</p></blockquote><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201235377.png" alt="image-20220521201235377" style="zoom:43%;" /></p><blockquote><p>(b) 全局位姿图优化。当关键帧从滑动窗口边缘化时，它被添加到姿势图中。如果此关键帧与任何其他过去的关键帧之间存在循环，则表示为 4-DOF 相对刚体变换的闭环约束也将添加到位姿图中。位姿图在一个单独的线程中使用所有相对位姿约束（参见第 VIII-C 节）进行优化，并且重新定位模块始终相对于最新的位姿图配置运行。</p><p>图 9. 说明重定位和位姿图优化过程的图表。</p></blockquote><h2 id="A-回环检测"><a href="#A-回环检测" class="headerlink" title="A. 回环检测"></a>A. 回环检测</h2><p>我们利用 DBoW2 [29]，一种最先进的词袋位置识别方法，用于回环检测。除了用于单目 VIO 的角点特征外，BRIEF 描述符 [40] 还检测和描述了 500 个角点。</p><p>额外的角点特征用于在循环检测中实现更好的召回率。描述符被视为视觉词来查询视觉数据库。 DBoW2 在时间和几何一致性检查后返回闭环候选。我们保留所有用于特征检索的简要描述符，但丢弃原始图像以减少内存消耗。</p><h2 id="B-特征检索"><a href="#B-特征检索" class="headerlink" title="B. 特征检索"></a>B. 特征检索</h2><p>当检测到闭环时，通过检索特征对应关系来建立局部滑动窗口和闭环候选之间的连接。通过简要描述符匹配找到对应关系。描述符匹配可能会导致一些错误的匹配对。为此，我们使用两步几何异常值剔除，如图 10 所示。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201302610.png" alt="image-20220521201302610" style="zoom:50%;" /></p><blockquote><p>图 10. 闭环期间特征检索的描述符匹配和异常值去除。 (a) 简要描述符匹配结果。 (b) 第一步：2-D-2-D 异常值剔除结果。 (c) 第二步：3-D-2-D 异常值剔除结果。</p></blockquote><p>1、2D-2D：RANSAC[33]的基本矩阵检验。我们利用当前图像中检索到的特征的二维观测和回环候选图像进行基本矩阵检验。<br>2、3D-2D：RANSAC的 PnP 检验。基于特征在局部滑动窗口中已知的三维位置，以及回环候选图像中的二维观测，进行 PnP 检验。</p><p>在异常值剔除后，我们将此候选者视为正确的闭环检测并执行重新定位。</p><h2 id="C-紧耦合重定位"><a href="#C-紧耦合重定位" class="headerlink" title="C. 紧耦合重定位"></a>C. 紧耦合重定位</h2><p>重新定位过程有效地将当前滑动窗口与过去的姿势对齐。在重新定位期间，我们将所有闭环帧的姿势视为常数。我们使用所有 IMU 测量、局部视觉测量和检索到的特征对应来共同优化滑动窗口。我们可以很容易地编写由闭环框架 $v$ 观察到的检索特征的视觉测量模型，使其与 VIO 中的视觉测量相同，如 $(17)$。唯一的区别是，取自 位姿图（参见第 VIII 节），或直接取自 过去的里程计输出（如果这是第一次重新定位）的闭环帧的位姿 $(\hat{\mathbf{q} }^w_v, \hat{\mathbf{p} }^w_v)$ 被处理作为常数。为此，我们可以在 $(14)$ 中稍微修改非线性代价函数，增加回环项：</p><script type="math/tex; mode=display">\begin{align*}\underset{\mathcal{X} }{\min}\parallel \mathbf{r}_p-\mathbf{H}_p\mathcal{X} \parallel^2&+\sum_{k\in\mathcal{B} }\parallel\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})  \parallel^2_{\mathbf{P}^{b_k}_{b_{k+1} } }+\sum_{(l,j)\in\mathcal{C} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) \parallel^2_{\mathbf{P}^{c_j}_l })\\&+\underbrace{\sum_{(l,v)\in\mathcal{L} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{v}_{l},\mathcal{X},\hat{\mathbf{q} }^w_v, \hat{\mathbf{p} }^w_v) \parallel^2_{\mathbf{P}^{c_v}_l })}_{闭环帧中的重投影误差}\end{align*}\tag{18}</script><p>其中 $\mathcal{L}$ 是闭环帧中检索到的特征的观察集。 $(l, v) $表示在回环帧 $v$ 中观察到的第 $l$ 个特征。请注意，尽管代价函数与 $(14)$ 略有不同，但要解决的状态的维数保持不变，因为回环帧的位姿被视为常数。当使用当前滑动窗口建立多个闭环时，我们同时使用来自所有帧的所有闭环特征对应进行优化。这为重新定位提供了多视图约束，从而获得更高的准确性和更好的平滑度。重新定位后保持一致性的全局优化将在第 VIII 节中讨论。</p><h1 id="八、-全局位姿图优化"><a href="#八、-全局位姿图优化" class="headerlink" title="八、 全局位姿图优化"></a>八、 全局位姿图优化</h1><p>重新定位后，开发了额外的位姿图优化步骤，以确保将一组过去的位姿注册到全局一致的配置中。</p><h2 id="A-四个累积漂移方向"><a href="#A-四个累积漂移方向" class="headerlink" title="A. 四个累积漂移方向"></a>A. 四个累积漂移方向</h2><p>得益于重力的惯性测量，在 VINS 中可以完全观察到滚动角 (roll) 和俯仰角 (pitch)。如图 11 所示，随着物体的移动，3-D 位置和旋转相对于参考系发生了变化。但是，我们可以通过重力矢量确定水平面，这意味着我们始终观察绝对的滚动角 (roll) 和俯仰角 (pitch)。因此，滚动角 (roll) 和俯仰角 (pitch) 是世界坐标系中的绝对状态，而 $x、y、z$ 和 yaw 是相对于参考坐标系的相对估计。累积漂移仅发生在 $x、y、z$ 和偏航角中。为了充分利用有效信息并有效地纠正漂移，我们修复了无漂移滚动角 (roll) 和俯仰角 (pitch)，并且仅在 4-DOF 中执行位姿图优化。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201318125.png" alt="image-20220521201318125" style="zoom:50%;" /></p><blockquote><p>图 11. 四个漂移方向示意图。随着物体的移动，$x、y、z$ 和偏航角相对于参考系发生了相对变化。绝对滚动角 (roll) 和俯仰角 (pitch) 可以由重力矢量的水平面确定。</p></blockquote><h2 id="B-将关键帧添加到姿势图中"><a href="#B-将关键帧添加到姿势图中" class="headerlink" title="B. 将关键帧添加到姿势图中"></a>B. 将关键帧添加到姿势图中</h2><p>在 VIO 过程之后，关键帧被添加到位姿图中。每个关键帧都作为位姿图中的一个顶点，它通过两种类型的边与其他顶点连接，如图 12 所示。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201330728.png" alt="image-20220521201330728" style="zoom: 50%;" /></p><blockquote><p>图 12. 姿态图说明。关键帧作为位姿图中的一个顶点，它通过顺序边和循环边连接其他顶点。每条边代表相对平移和相对偏航 (yaw)。</p></blockquote><p>1）顺序边(Sequential Edge)：一个关键帧为其先前的关键帧建立了几个顺序边。顺序边表示两个关键帧之间的相对变换，直接取自 VIO。考虑到关键帧 $i$ 及其先前的关键帧 $j$ 之一，顺序边仅包含相对位置 $\hat{\mathbf{p} }^i_{ij}$ 和偏航角  $\hat{\psi}_{ij}$ 。</p><script type="math/tex; mode=display">\begin{align*}\hat{\mathbf{p} }^i_{ij}&={\hat{\mathbf{R} }^w_{i} }^{-1}(\hat{\mathbf{p} }^w_{j}-\hat{\mathbf{p} }^w_{i})\\\hat{\psi}_{ij}&=\hat{\psi}_{j}-\hat{\psi}_{i}\end{align*}\tag{19}</script><p>2）回环边(Loop Closure Edge)：如果新边缘化的关键帧有一个回环连接，它将与回环帧通过一个回环边在位姿图图中连接。同样，闭环边缘只包含与 $(19)$ 相同定义的四自由度相对位姿变换。回环边的值由重定位结果得出。</p><h2 id="C-四自由度位姿图优化"><a href="#C-四自由度位姿图优化" class="headerlink" title="C. 四自由度位姿图优化"></a>C. 四自由度位姿图优化</h2><p>我们将帧 $i$ 和 $j$ 之间的边缘残差最小定义为:</p><script type="math/tex; mode=display">\mathbf{r}_{i,j}(\mathbf{p}^w_i,\psi_i,\mathbf{p}^w_j,\psi_j)=\begin{bmatrix}\mathbf{R}(\hat{\phi_i},\hat{\theta}_i,\hat{\psi}_i)^{-1}(\mathbf{p}^w_j-\mathbf{p}^w_i)-\hat{\mathbf{p} }^i_{ij}\\\psi_j-\psi_i-\hat{\psi}_{ij}\end{bmatrix}\tag{20}</script><p>其中 $\hat{\phi_i}$ 和 $\hat{\theta}_i$ 是滚转角和俯仰角的固定估计值，它们是从单目 VIO 获得的。</p><p>通过最小化以下代价函数来优化顺序边和闭环边的整个图：</p><script type="math/tex; mode=display">\underset{\mathbf{p},\psi}{\,min}\left\{\sum_{(i,j)\in\mathcal{S} }\parallel\mathbf{r}_{i,j}\parallel^2+\sum_{(i,j)\in\mathcal{L} }\rho(\parallel\mathbf{r}_{i,j}\parallel^2)\right\}\tag{21}</script><p>其中 $\mathcal{S}$ 是所有连续边的集合， $\mathcal{L}$  是所有闭环边的集合。尽管紧耦合的重定位已经有助于消除错误的闭合回环，但我们添加了另一个 Huber 范数 $ρ(·) $ 以进一步减少任何可能的错误闭环的影响。相比之下，我们没有对顺序边使用任何稳健的规范，因为这些边是从 VIO 中提取的，它已经包含足够的异常值拒绝机制。</p><p>位姿图优化和重新定位（参见第 VII-C 节）在两个单独的线程中异步运行。这使得只要可用，就可以立即使用最优化的位姿图进行重新定位。同样，即使当前的位姿图优化尚未完成，仍然可以使用现有的位姿图配置进行重新定位。该过程如图 9(b) 所示。</p><h2 id="D-位姿图合并"><a href="#D-位姿图合并" class="headerlink" title="D. 位姿图合并"></a>D. 位姿图合并</h2><p>位姿图不仅可以优化当前地图，还可以将当前地图与之前构建的地图合并。如果我们加载了之前构建的地图并检测到两个地图之间的闭环连接，我们可以将它们合并在一起。由于所有边都是相对约束，因此位姿图优化通过循环连接自动将两个地图合并在一起。如图 13 所示，当前地图被循环边缘拉入前一个地图。每个顶点和每条边都是相对变量，因此，我们只需要固定位姿图中的第一个顶点。</p><p><img src="/images/VINS-Mono-0-论文翻译/image-20220521201348827.png" alt="image-20220521201348827" style="zoom: 50%;" /></p><blockquote><p>图 13. 地图合并示意图。黄色的图是之前建好的地图。蓝色图为当前地图。根据闭环连接合并两个地图。</p></blockquote><h2 id="E-位姿图保存"><a href="#E-位姿图保存" class="headerlink" title="E. 位姿图保存"></a>E. 位姿图保存</h2><p>我们的位姿图的结构非常简单。我们只需要保存顶点和边，以及每个关键帧（顶点）的描述符。原始图像被丢弃以减少内存消耗。具体来说，我们为第 $i$ 个关键帧保存的状态是:</p><script type="math/tex; mode=display">[i,\hat{\mathbf{p} }^w_i,\hat{\mathbf{q} }^w_i,v,\hat{\mathbf{p} }^i_{iv},\hat{\psi}_{iv},\mathbf{D}(u,v,des)]\tag{22}</script><p>其中 $i$ 是帧索引，$\hat{\mathbf{p} }^w_i$ 和 $\hat{\mathbf{q} }^w_i$  分别是来自 VIO 的位置和方向。如果这个帧有一个闭环帧，$v$ 是闭环帧的索引。 $\hat{\mathbf{p} }^i_{iv}$ 和 $\hat{\psi}_{iv}$ 是这两帧之间通过重定位得到的相对位置和偏航角。$\mathbf{D}(u,v,des)$ 是特征集。每个特征都包含二维位置及其简要描述符。</p><h2 id="F-位姿图加载"><a href="#F-位姿图加载" class="headerlink" title="F 位姿图加载"></a>F 位姿图加载</h2><p>我们使用相同的保存格式来加载关键帧。每个关键帧都是位姿图中的一个顶点。顶点的初始位姿是 $\hat{\mathbf{p} }^w_i$ 和 $\hat{\mathbf{q} }^w_i$   。闭环边缘直接由回环信息 $\hat{\mathbf{p} }^i_{iv}$ 和 $\hat{\psi}_{iv}$ 建立。每个关键帧与其相邻关键帧建立几个连续的边，如 $(19)$。加载位姿图后，我们立即执行一次全局 4自由度位姿图。位姿图保存和加载的速度与位姿图的大小呈线性相关。</p><h1 id="九、实验"><a href="#九、实验" class="headerlink" title="九、实验"></a>九、实验</h1><p>略</p><h1 id="十、结论和未来的工作"><a href="#十、结论和未来的工作" class="headerlink" title="十、结论和未来的工作"></a>十、结论和未来的工作</h1><p>在本文中，我们提出了一种鲁棒且通用的单目视觉惯性估计器。我们的方法在 IMU 预积分、估计器初始化、在线外部校准、紧耦合 VIO、重定位和高效全局优化方面具有最先进和新颖的解决方案。通过与其他最先进的开源实现进行比较，我们展示了卓越的性能。为了社区的利益，我们开源了 PC 和 iOS 实现。</p><p>尽管基于特征的 VINS 估计器已经达到了实际部署的成熟度，但我们仍然看到了未来研究的许多方向。根据运动和环境的不同，单目 VINS 可能会达到弱可观测甚至退化的条件。我们对评估单目 VINS 可观察性特性的在线方法以及在线生成运动计划以恢复可观察性感兴趣。另一个研究方向涉及单目 VINS 在各种消费设备上的大规模部署，例如 Android 手机。该应用需要在线校准几乎所有传感器的内部和外部参数，以及校准质量的在线识别。最后，我们有兴趣根据单目 VINS 的结果生成密集地图。我们在无人机导航中应用的单目视觉惯性稠密建图的第一个结果在 [47] 中提出。但是，仍然需要进行广泛的研究以进一步提高系统的准确性和鲁棒性。</p><h1 id="附录：基于四元数的-IMU-预积分"><a href="#附录：基于四元数的-IMU-预积分" class="headerlink" title="附录：基于四元数的 IMU 预积分"></a>附录：基于四元数的 IMU 预积分</h1><p>给定对应于图像帧 $b_k$ 和 $b_{k+1}$ 的两个时刻，位置、速度和方向状态可以在世界帧中的时间间隔 $[t_k, t_{k+1}]$ 期间通过惯性测量传播：</p><script type="math/tex; mode=display">\begin{align*}\mathbf{p}^w_{b_{k+1} }&=\mathbf{p}^w_{b_k}+\mathbf{v}^w_{b_k}\Delta t_k+\iint_{t\in[t_k, t_{k+1}]}(\mathbf{R}^w_t(\hat{a}_t-b_{a_t}-n_a)-g^w)dt^2\\\mathbf{v}^w_{b_{k+1} }&=\mathbf{v}^w_{b_k}+\int_{t\in[t_k, t_{k+1}]}(\mathbf{R}^w_t(\hat{a}_t-b_{a_t}-n_a)-g^w)dt\\\mathbf{q}^w_{b_{k+1} }&=\mathbf{q}^w_{b_k}\otimes\int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t}-n_w)\mathbf{q}^{b_k}_tdt\end{align*}\tag{23}</script><p>其中，</p><script type="math/tex; mode=display">\Omega(w)=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix},w^{\land}=\begin{bmatrix}0&-w_z&w_y\\w_z&0&-w_x\\-w_y&w_x&0\end{bmatrix}\tag{24}</script><p>$\Delta t_k$ 是时间间隔  $[t_k, t_{k+1}]$ 之间的持续时间。</p><p>可以看出，IMU状态传播需要帧 $b_k$ 的旋转、位置和速度。当这些起始状态发生变化时，我们需要重新传播 IMU 测量值。特别是在基于优化的算法中，每次调整姿势时，我们都需要在它们之间重新传播 IMU 测量值。这种传播策略在计算上要求很高。为了避免重复传播，我们采用预积分算法。</p><p>将参考坐标系从世界坐标系变为局部坐标系 $b_k$ 后，我们只能对与线加速度$\hat a$ 和角速度 $\hat w$ 相关的部分进行预积分如下：</p><script type="math/tex; mode=display">\begin{align*}\mathbf{R}^{b_k}_w\mathbf{p}^w_{b_{k+1} }&=\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_k}+\mathbf{v}^w_{b_k}\Delta t_k-\frac{1}{2}g^w\Delta t_k^2)+\alpha^{b_k}_{b_{k+1} }\\\mathbf{R}^{b_k}_w\mathbf{v}^w_{b_{k+1} }&=\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_k}-g^w\Delta t_k)+\beta^{b_k}_{b_{k+1} }\\\mathbf{q}^{b_k}_w\mathbf{q}^w_{b_{k+1} }&=\gamma^{b_k}_{b_{k+1} }\end{align*}\tag{25}</script><p>其中，</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&=\iint_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t}-n_a)dt^2\\\beta ^{b_k}_{b_{k+1} }&=\int_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t}-n_a)dt\\\gamma^{b_k}_{b_{k+1} }&= \int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t}-n_w)\gamma^{b_k}_tdt\end{align*}\tag{26}</script><p>可以看出，预积分项 $(26)$ 可以仅通过以 $b_k$ 作为参考系的 IMU 测量来获得。 $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$ 仅与IMU偏差有关，与 $b_k$ 和 $b_{k+1}$ 中的其他状态无关。当偏差的估计发生变化时，如果变化很小，我们通过它们对偏差的一阶近似来调整 $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$ ，否则我们进行重新传播。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传播 IMU 测量。</p><p>对于离散时间的实现，可以应用不同的数值积分方法，例如欧拉、中点、RK4 积分。这里选择欧拉积分来演示过程，以便于理解（我们在实现代码中使用了中点积分）。</p><p>一开始，$\alpha^{b_k}_{b_k},\beta^{b_k}_{b_k}$ 为0，$\gamma^{b_k}_{b_k}$ 为单位四元数。 $(26)$ 中的 $\alpha、\beta、\gamma$ 的平均值按如下方式逐步传播。请注意，增加的噪声项 $n_a、n_w$ 是未知的，在实现中被视为零。这得到了预积分项的估计值，用 $\hat{(·)}$ 标记：</p><script type="math/tex; mode=display">\begin{align*}\hat{\alpha}^{b_k}_{i+1}&=\hat{\alpha}^{b_k}_{i}+\hat{\beta}^{b_k}_{i}\delta t^2+\frac{1}{2}\mathbf{R}(\hat{\gamma}^{b_k}_{i})(\hat{a}_i-b_{a_i})\delta t^2\\\hat{\beta}^{b_k}_{i+1}&=\hat{\beta}^{b_k}_{i}+\mathbf{R}(\hat{\gamma}^{b_k}_{i})(\hat{a}_i-b_{a_i})\delta t\\\hat{\gamma}^{b_k}_{i+1}&=\hat{\gamma}^{b_k}_{i}\otimes\begin{bmatrix}1\\\frac{1}{2}(\hat{w}_i-b_{w_i})\delta t\end{bmatrix}\\\end{align*}\tag{27}</script><p>$i$ 是在 $[t_k, t_{k+1}]$ 中IMU测量值对应的离散时刻。 $\delta t$ 是两次 IMU 测量 $i$ 和 $i + 1$ 之间的时间间隔。</p><p>然后我们处理<strong>协方差传播</strong>。由于四维旋转四元数 $\gamma^{b_k}_t$ 被过度参数化，我们将其误差项定义为围绕其均值的扰动：</p><script type="math/tex; mode=display">\gamma^{b_k}_t\approx\hat{\gamma}^{b_k}_t\otimes\begin{bmatrix}1\\\frac{1}{2}\delta \theta^{b_k}_t\end{bmatrix}\tag{28}</script><p>其中 $\theta^{b_k}_t$ 是三维小扰动。</p><p>我们可以推导出 $(26)$ 的误差项的连续时间线性化方程：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}\delta \dot{\alpha}^{b_k}_t\\\delta \dot{\beta}^{b_k}_t\\\delta \dot{\theta}^{b_k}_t\\\delta \dot{b}_{a_t}\\\delta \dot{b}_{w_t}\\\end{bmatrix}&=\begin{bmatrix}0&\mathbf{I}&0&0&0\\0&0&-\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}]^{\land}&-\mathbf{R}^{b_k}_t&0\\0&0&-[\hat{w}_t-b_{w_t}]^{\land}&0&-\mathbf{I}\\0&0&0&0&0\\0&0&0&0&0\\\end{bmatrix}\begin{bmatrix}\delta {\alpha}^{b_k}_t\\\delta {\beta}^{b_k}_t\\\delta {\theta}^{b_k}_t\\\delta {b}_{a_t}\\\delta {b}_{w_t}\\\end{bmatrix}+\begin{bmatrix}0&0&0&0\\-\mathbf{R}^{b_k}_t&0&0&0\\0&-\mathbf{I}&0&0\\0&0&\mathbf{I}&0\\0&0&0&\mathbf{I}\\\end{bmatrix}\begin{bmatrix}\mathbf{n}_a\\\mathbf{n}_w\\\mathbf{n}_{b_a}\\\mathbf{n}_{b_w}\end{bmatrix}\\&=\mathbf{F}_t\delta\mathbf{z}^{b_k}_t+\mathbf{G}_t\mathbf{n}_t\end{align*}\tag{29}</script><p>在零阶保持离散化中，$\mathbf{F}_t$ 在积分期间是恒定的，因此对于给定的时间步长 $\delta t$，$\mathbf{F}_d=\exp(\mathbf{F}_t\delta t)$ 。通过展开指数级数并省略高阶项，我们得到 $\mathbf{F}_d \approx I + \mathbf{F}_t\delta t$。使用连续时间噪声协方差矩阵$ \mathbf{Q}_t = diag(\sigma^2_a, \sigma^2_w, \sigma^2_{b_a}, \sigma^2_{b_w})$，离散时间噪声协方差矩阵计算为：</p><script type="math/tex; mode=display">\begin{align*}\mathbf{Q}_d&=\int^{\delta t}_0 \mathbf{F}_d(\tau)\mathbf{G}_t\mathbf{Q}_t\mathbf{G}_t^T\mathbf{F}_d(\tau)^T\\&=\delta t\mathbf{F}_d\mathbf{G}_t\mathbf{Q}_t\mathbf{G}_t^T\mathbf{F}_d^T\\&\approx\delta t\mathbf{G}_t\mathbf{Q}_t\mathbf{G}_t^T\\\end{align*}\tag{30}</script><p>协方差 $\mathbf{P}^{b_k}_{b_{k+1} }$ 可以通过初始协方差 $\mathbf{P}^{b_k}_{b_k}= 0$ 传播如下：</p><script type="math/tex; mode=display">\mathbf{P}^{b_k}_{t+\delta t}=(\mathbf{I}+\mathbf{F}_t\delta t)\mathbf{P}^{b_k}_{t}(\mathbf{I}+\mathbf{F}_t\delta t)^T+\delta t\mathbf{G}_t\mathbf{Q}_t\mathbf{G}_t^T,t\in[k,k+1]\tag{31}</script><p>同时，一阶雅可比矩阵也可以通过初始雅可比  $\mathbf{J}_{b_k}=\mathbf{I}$  进行递归计算：</p><script type="math/tex; mode=display">\mathbf{J}_{t+\delta t}=(\mathbf{I}+\mathbf{F}_t\delta t)\mathbf{J}_t,t\in[k,k+1]\tag{32}</script><p>使用这个递归公式，我们得到协方差矩阵 $\mathbf{P}^{b_k}_{b_{k+1} }$  和雅可比 $\mathbf{J}_{b_{k+1} }$ 。  $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$  关于偏差的一阶近似可以写成：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&\approx \hat{\alpha}^{b_k}_{b_{k+1} }+\mathbf{J}^{\alpha}_{b_a}\delta b_{a_k}+\mathbf{J}^{\alpha}_{b_w}\delta b_{w_k}\\\beta^{b_k}_{b_{k+1} }&\approx \hat{\beta}^{b_k}_{b_{k+1} }+\mathbf{J}^{\beta}_{b_a}\delta b_{a_k}+\mathbf{J}^{\beta}_{b_w}\delta b_{w_k}\\\gamma^{b_k}_{b_{k+1} }&\approx \hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\end{align*}\tag{33}</script><p>其中 $\mathbf{J}^{\alpha}_{b_a}$ 和 是 $\mathbf{J}^{\alpha}_{b_{k+1} }$ 中的子块矩阵，其位置对应于 $\frac{\delta\alpha^{b_k}_{b_{k+1} } }{\delta b_{a_k} }$ 。 $\mathbf{J}^{\alpha}_{b_w}、\mathbf{J}^{\beta}_{b_a}、\mathbf{J}^{\beta}_{b_w}、\mathbf{J}^{\gamma}_{b_w}$ 也使用相同的含义。当偏差的估计发生轻微变化时，我们使用 $(33)$ 来近似地校正预积分结果，而不是重新传播。</p><p>现在我们可以写下 IMU 测量模型及其对应的协方差  $\mathbf{P}^{b_k}_{b_{k+1} }$  ：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}\hat{\alpha}^{b_k}_{b_{k+1} }\\\hat{\beta}^{b_k}_{b_{k+1} }\\\hat{\gamma}^{b_k}_{b_{k+1} }\\0\\0\end{bmatrix}=\begin{bmatrix}\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}+\frac{1}{2}g^w\Delta t_k^2-\mathbf{v}^w_{b_k}\Delta t_k)\\\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_{k+1} }-\mathbf{v}^w_{b_k}+g^w\Delta t_k)\\{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\\\mathbf{b}_{ab_{k+1} }-\mathbf{b}_{ab_k}\\\mathbf{b}_{wb_{k+1} }-\mathbf{b}_{wb_k}\\\end{bmatrix}\end{align*}\tag{34}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节主要对原始论文进行翻译。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>六、VIO视觉残差的构建以及雅可比的求取</title>
    <link href="https://lukeyalvin.top/posts/c041a7d0.html"/>
    <id>https://lukeyalvin.top/posts/c041a7d0.html</id>
    <published>2022-05-10T11:40:18.000Z</published>
    <updated>2022-05-17T06:00:49.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p><h1 id="VIO残差构建"><a href="#VIO残差构建" class="headerlink" title="VIO残差构建"></a>VIO残差构建</h1><p>VIO重投影误差：</p><p>具体详解见：<a href="https://lukeyalvin.top/posts/ddbf64.html#VIO%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE"><a href="https://lukeyalvin.top/posts/ddbf64.html#VIO重投影误差">VIO重投影误差</a></a></p><p><img src="/images/5-VIO视觉残差的构建以及雅可比的求取/image-20220505205125811-16522560257751.png" alt="image-20220505205125811" style="zoom: 33%;" /></p><p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p><script type="math/tex; mode=display">\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{1}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u_{cj}\\\frac{Y_{cj} }{Z_{cj} }-v_{cj}\end{bmatrix}\tag{2}</script><h1 id="VIO残差的雅可比推导"><a href="#VIO残差的雅可比推导" class="headerlink" title="VIO残差的雅可比推导"></a>VIO残差的雅可比推导</h1><p>按照变换矩阵和旋转矩阵之间的关系：</p><script type="math/tex; mode=display">\begin{align*}T_{bc}^{-1}&=\begin{bmatrix}R^T_{bc}&-R^T_{bc}p_{bc}\\0^T&1\end{bmatrix},\ T_{wb_j}^{-1}=\begin{bmatrix}R^T_{wb_j}&-R^T_{wb_j}p_{wb_j}\\0^T&1\end{bmatrix}\\T_{wb_j}&=\begin{bmatrix}R^T_{wb_j}&p_{wb_j}\\0^T&1\end{bmatrix},\ \ \ \ \  \ \  \ T_{bc}=\begin{bmatrix}R^T_{bc}&p_{bc}\\0^T&1\end{bmatrix}\end{align*}\tag{3}</script><p>根据公式$(3)$将公式$(1)$中拆分成三维坐标形式：</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}=\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\end{bmatrix}&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}\frac{1}{\lambda}\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\&+R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\end{align*}\tag{4}</script><p>为了推导的方便定义如下公式：</p><script type="math/tex; mode=display">\begin{align*}f_{c_i}&=\frac{1}{\lambda}\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\f_{b_i}&=R_{bc}f_{c_i}+p_{bc}\\f_w&=R_{wb_i}f_{b_i}+p_{wb_i}\\f_{b_j}&=R^T_{wb_j}(f_{w}-p_{bc})\\\end{align*}\tag{5}</script><p>雅可比矩阵 为视觉误差对两个时刻的状态量，外参以及逆深度求导：</p><script type="math/tex; mode=display">J=\begin{bmatrix}\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_ib_i^\prime}\\ \delta\theta_{b_ib_i^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_jb_j^\prime}\\ \delta\theta_{b_jb_j^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{cc^\prime}\\ \delta\theta_{cc^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\delta\lambda } \end{bmatrix}\tag{6}</script><p>根据链式法则， Jacobian 的计算可以分两步走:</p><ul><li>第一步误差对 $f_{c_j}$ 求导：  </li></ul><script type="math/tex; mode=display">\frac{\partial r_c}{\partial f_{c_j} }=\begin{bmatrix}\frac{1}{Z_{c_j} }&0&\frac{X_{c_j}}{Z_{c_j}^2 }\\0&\frac{1}{Z_{c_j} }&\frac{Y_{c_j}}{Z_{c_j}^2 }\end{bmatrix}\tag{7}</script><ul><li>第二步对 $f_{c_j}$ 对各状态量求导：</li></ul><ol><li><strong>对 $i$ 时刻的状态量求导</strong></li></ol><p>① 对 $i$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_ib_i^\prime} }=R^{T}_{bc}R^{T}_{wb_j}\tag{8}</script><p>② 对 $i$ 时刻的<strong>角度</strong>增量求导</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}\left(R^{T}_{wb_j}\left( ({\color{red}R_{wb_i} }p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\end{align*}\tag{9}</script><p>上面公式和 $i$ 时刻角度相关的量并不多，下面为了简化，直接丢弃了不相关的部分 :</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }p_{bc}+(···)\\&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(R_{bc}f_{c_i}+p_{bc})+(···)\\&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}+(···)\end{align*}\tag{9}</script><p> 雅可比矩阵为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(I+[\delta\theta_{b_ib^\prime_i}]^{\land})f_{b_i}-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[\delta\theta_{b_ib^\prime_i}]^{\land}f_{b_i} }{\partial\delta\theta_{b_ib^\prime_i} }\\&=-\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} [\delta\theta_{b_ib^\prime_i}]}{\partial\delta\theta_{b_ib^\prime_i} }\\&=-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} \end{align*}\tag{10}</script><ol><li><strong>对 $j$ 时刻的状态量求导</strong></li></ol><p>① 对 $j$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_jb_j^\prime} }=-R^{T}_{bc}R^{T}_{wb_j}\tag{11}</script><p>② 对 $j$ 时刻的<strong>角度</strong>增量求导</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }R_{wb_i}R_{bc}f_{c_i}+R^{T}_{bc}\left({\color{green}R^{T}_{wb_j} }\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\\&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }\left(R_{wb_i}(R_{bc}f_{c_i}+p_{bc})+p_{wb_j}-p_{wb_j}\right)+(···)\\&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }(f_w-p_{wb_j})+(···)\\\end{align*}\tag{12}</script><p> 雅可比矩阵为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}(I-[\delta\theta_{b_ib^\prime_j}]^{\land}){\color{green}R^T_{wb_j} }(f_w-p_{wb_j})-R^{T}_{bc}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}f_{b_j} }{\partial\delta\theta_{b_ib^\prime_i} }\\&-=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[f_{b_j}]^{\land}[\delta\theta_{b_ib^\prime_j}] }{\partial\delta\theta_{b_ib^\prime_i} }\\&=-R^{T}_{bc}[f_{b_j}]^{\land}\end{align*}\tag{13}</script><ol><li><strong>对 imu 和相机之间的外参求导</strong>  </li></ol><p>① 对<strong>位移</strong>求导</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{cc^\prime} }=R^{T}_{bc}(R^{T}_{wb_j}R_{wb_i}-I_{3\times 3})\tag{14}</script><p>② 对<strong>角度</strong>增量求导，由于 $f_{c_j}$ 都和 $R_{bc}$ 有关，并且比较复杂，所以这次分两部分求导  </p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&={\color{green}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i} }+{\color{blue}R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)}\\&={\color{green}f^1_{c_j} }+{\color{blue}f^2_{c_j} }\end{align*}\tag{15}</script><p>第一部分 ${\color{green}f^1_{c_j} }$ 雅可比为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j}^1 }{\partial\delta\theta_{cc^\prime} }=&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\land}) R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(I+[\delta\theta_{cc^\prime}]^{\land}) f_{c_i}-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc} }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[\delta\theta_{cc^\prime}]^{\land}f_{c_i}-[\delta\theta_{cc^\prime}]^{\land} R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}+o^2(\theta_{cc^\prime}) }{\partial\delta\theta_{cc^\prime} }\\&\approx \underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial -R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\land}[\delta\theta_{cc^\prime}]+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\land}[\delta\theta_{cc^\prime}] ) }{\partial\delta\theta_{cc^\prime} }\\&=-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\land}+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\land}\end{align*}\tag{16}</script><p>第一部分 ${\color{blue}f^2_{c_j} }$ 雅可比为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j}^2 }{\partial\delta\theta_{cc^\prime} }&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\land} ) R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)-R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right) }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial-[\delta\theta_{cc^\prime}]^{\land} R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right) }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial-[R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)]^{\land}[\delta\theta_{cc^\prime}]  }{\partial\delta\theta_{cc^\prime} }\\&=[R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)]^{\land}\end{align*}\tag{17}</script><p>两个 Jacobian 相加就是视觉误差对外参中的角度增量的最终结果。  </p><ol><li><strong>视觉误差对特征逆深度的求导</strong>  </li></ol><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial \delta\lambda}&=\frac{\partial f_{c_j} }{\partial f_{c_i} }\frac{\partial f_{c_i} }{\partial \delta\lambda}\\&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(-\frac{1}{\lambda^2}\begin{bmatrix}u_{c_i}\\v_{c_i}\\1 \end{bmatrix})\\&=-\frac{1}{\lambda}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}\end{align*}\tag{18}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>五、预积分残差的雅克比求取</title>
    <link href="https://lukeyalvin.top/posts/b68d674.html"/>
    <id>https://lukeyalvin.top/posts/b68d674.html</id>
    <published>2022-05-10T11:38:28.000Z</published>
    <updated>2022-05-11T07:54:42.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>对于右乘雅可比，我们做如下的公式简化：</p><script type="math/tex; mode=display">\frac{\partial x_a}{\partial \delta\theta}=\underset{\delta\theta\rightarrow0}{lim}\frac{R_{ab}\exp([\delta\theta]^{\land})x_b-R_{ab}x_b}{\delta\theta}</script><p>后续简写为：</p><script type="math/tex; mode=display">\frac{\partial x_a}{\partial \delta\theta}=\frac{R_{ab}\exp([\delta\theta]^{\land})x_b}{\delta\theta}</script><h1 id="预积分残差的雅克比求取"><a href="#预积分残差的雅克比求取" class="headerlink" title="预积分残差的雅克比求取"></a>预积分残差的雅克比求取</h1><p>定义：一段时间内 IMU 构建的预积分量作为<strong>测量值</strong>，对两时刻之间的状态量进行约束，  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{e}_{B}(x_i,x_j)=\begin{bmatrix}r_p\\r_q\\r_v\\r_{ba}\\r_{bg}\end{bmatrix}_{15\times1}=\begin{bmatrix}q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-{\color{blue}\alpha_{b_ib_j} }\\2[{\color{blue}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{blue}\beta_{b_ib_j} }\\b^a_j-b^a_i\\b^g_j-b^g_i\end{bmatrix}\end{align*}\tag{1}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t\end{align*}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第二项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p><p>在求解非线性方程时，需要知道误差 $\mathbf{e}_{B}$ 对两个关键帧 $i, j$ 的状态量 $p, q, v, ba, bg$ 的雅可比。对 $i, j$ 时刻的状态量 $p, q, v$ 求导还是比较直观的，直接对误差公式进行计算就行。但是对 $i$ 时刻的 $b^a_i , b^g_i$ 求导就显得十分复杂，下面我们详细讨论。  </p><p>因为 $i$ 时刻的 bias 相关的预积分计算是通过迭代一步一步累计递推的，可以算但是太复杂。所以对于预积分量直接在 $i$ 时刻的 bias 附近用<strong>一阶泰勒展开</strong>来近似，而不用真的去迭代计算。  </p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\alpha_{b_ib_j}+J^{\alpha}_{b^a_i}\delta b^a_i+J^{\alpha}_{b^g_i}\delta b^g_i\\\beta_{b_ib_j}&=\beta_{b_ib_j}+J^{\beta}_{b^a_i}\delta b^a_i+J^{\beta}_{b^g_i}\delta b^g_i\\q_{b_ib_j}&=q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^{q}_{b^g_i}\delta b^g_i \end{bmatrix}\end{align*}\tag{2}</script><p>其中 $J^{\alpha}_{b^a_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^a_i},J^{\alpha}_{b^g_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^g_i},J^{\beta}_{b^a_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^a_i},J^{\beta}_{b^g_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^g_i},J^{q}_{b^g_i}=\frac{\partial q_{b_ib_j} }{\partial\delta b^g_i}$，表示预积分量对 $i$ 时刻的 bias 求导。</p><p>这些雅克比根据前面讨论的<strong>协方差传递公式</strong>，能一步步递推得到：  </p><script type="math/tex; mode=display">J_{k+1}=\mathbf{F}J_k\tag{3}</script><h2 id="r-v-对各状态量的雅可比"><a href="#r-v-对各状态量的雅可比" class="headerlink" title="$r_v$ 对各状态量的雅可比"></a>$r_v$ 对各状态量的雅可比</h2><p>下面我们来讨论 IMU 误差相对于两帧的 PVQ 的 雅克比:由于 $r_p$ 和 $r_v$ 的误差形式很相近，对各状态量求导的 雅克比形式也很相似，所以这里只对 $r_v$ 的推导进行详细介绍  </p><p>① 对 $i$ 时刻<strong>位移</strong>的雅可比</p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta p_{b_ib^\prime_i} }=0\tag{4}</script><p>② 对 $i$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_v}{\partial\delta \theta_{b_ib^\prime_i} }&=\frac{\partial (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2} \delta \theta_{b_ib^\prime_i}\end{bmatrix})^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial (R_{wb_i}\exp([\delta \theta_{b_ib^\prime_i}]^{\land}))^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial\exp([-\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial(I-[\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial -[\delta \theta_{b_ib^\prime_i}]^{\land}[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial -[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}[\delta \theta_{b_ib^\prime_i}]}{\partial\delta \theta_{b_ib^\prime_i} }\\&=[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}\end{align*}\tag{5}</script><p>③ 对 $i$ 时刻<strong>速度</strong>的雅可比</p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta v_i^w}=-R_{b_iw}\tag{6}</script><p>④ 对 $i$ 时刻<strong>加速度 bais</strong>的雅可比 ,注意 bias 量只和预积分 $\beta$ 有关：  </p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta b_i^a}=-\frac{\partial \beta_{b_ib_j} }{\partial\delta b_i^a}=-J^{\beta}_{b^a_i}\tag{7}</script><h2 id="r-q-对各状态量的雅可比"><a href="#r-q-对各状态量的雅可比" class="headerlink" title="$r_q$ 对各状态量的雅可比"></a>$r_q$ 对各状态量的雅可比</h2><p>① 对 $i$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial2[q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*\otimes q_{wb_j}]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial-2[(q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*\otimes q_{wb_j})^*]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial-2[q_{wb_j}^* \otimes (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})\otimes q_{b_ib_j} ]_{xyz}}{\partial \delta\theta_{b_ib^\prime_i} }\\&=-2[0\ \ I]\frac{\partial[q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=-2[0\ \ I][q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R\begin{bmatrix}0\\\frac{1}{2}I\end{bmatrix}\end{align*}\tag{8}</script><p>其中 $[·]_L$ 和 $[·]_R$ 为四元数转为左/右旋转矩阵的算子。  </p><p>② 对 $j$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=\frac{\partial2[q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}\otimes \begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}\end{bmatrix} ]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=\frac{\partial2[[q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_L\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}\end{bmatrix} ]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=2[0\ \ I][q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_L\begin{bmatrix}0\\\frac{1}{2}I\end{bmatrix}\end{align*}\tag{9}</script><p>② 对 $i$ 时刻<strong>陀螺仪偏置 $b^g_i$</strong> 的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_v}{\partial\delta b_i^g}&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial2[(q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial-2[((q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*\otimes q_{wb_i}^*\otimes q_{wb_j})^*]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial-2[q_{wb_j}^*\otimes q_{wb_i}\otimes(q_{b_ib_j} \otimes \begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})]_{xyz} }{\partial\delta b_i^g}\\&=-2[0\ \ I][q_{wb_j}^*\otimes q_{wb_i}\otimes q_{b_ib_j}]_L\begin{bmatrix}0\\\frac{1}{2}J^q_{b^g_i}\end{bmatrix}\end{align*}\tag{10}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>四、IMU误差状态传递方程的推导</title>
    <link href="https://lukeyalvin.top/posts/aaff1b40.html"/>
    <id>https://lukeyalvin.top/posts/aaff1b40.html</id>
    <published>2022-05-10T07:28:11.000Z</published>
    <updated>2022-05-11T08:06:50.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="IMU误差状态传递方程的推导"><a href="#IMU误差状态传递方程的推导" class="headerlink" title="IMU误差状态传递方程的推导"></a>IMU误差状态传递方程的推导</h1><h2 id="协方差的传播"><a href="#协方差的传播" class="headerlink" title="协方差的传播"></a>协方差的传播</h2><p>例如，已知一个变量$y=Ax,x\in \mathcal{N}(0,\Sigma_{x})$，则有$\Sigma_y=A\Sigma_xA^T$</p><script type="math/tex; mode=display">\begin{align*}\Sigma_y&=E((Ax)(Ax)^T)\\&=E(Axx^TA^T)\\&=A\Sigma_xA^T\end{align*}\tag{1}</script><p>我们知道，一个IMU数据作为测量值的噪声方差我们可以标定 （类似公式$(1)$中的已知量$x$），那么一段时间的多个IMU数据形成的IMU数据积分形式的预积分量的方差（类似公式$(1)$中的已知量$y$），就可以通过以上形式求解，关键是找出IMU  噪声与预积分量之间的<strong>线性递推关系</strong>（类似公式$(1)$中的已知量$y=Ax$）。</p><p>假设已知了<strong>相邻时刻误差的线性传递方程：</strong></p><script type="math/tex; mode=display">\eta_{ik}=\mathbf{F}_{k-1}\eta_{ik-1}+\mathbf{G}_{k-1}\mathbf{n}_{k-1}\tag{2}</script><p>比如：状态量误差为 $\eta_{ik}=[\delta\theta_{ik},\delta\mathbf{v}_{ik},\delta\mathbf{p}_{ik}]$，$\eta_{ik}$为当前时刻的误差，$\eta_{ik-1}$为上一时刻的误差；<strong>测量噪声</strong>为 $\mathbf{n}_{k}=[\mathbf{n}_{k}^a,\mathbf{n}_{k}^g]$，因此，误差的传递由两部分组成，即<strong>当前时刻的误差传递给下一时刻，当前时刻的测量噪声传递给下一时刻</strong>。</p><p>如果已知上面的误差状态传递方程，那么一段时间内IMU积分的协方差矩阵就可以轻松递推算出：</p><script type="math/tex; mode=display">\Sigma_{ik}=\mathbf{F}_{k-1}\Sigma_{ik-1}\mathbf{F}_{k-1}^T+\mathbf{G}_{k-1}\Sigma_\mathbf{n}\mathbf{G}_{k-1}^T\tag{3}</script><p>其中，$\Sigma_n$是<strong>测量噪声的协方差矩阵</strong>，方差从 $i$ 时刻开始进行递推，$\Sigma_{ii}=0$</p><h2 id="状态误差线性递推方程的推导"><a href="#状态误差线性递推方程的推导" class="headerlink" title="状态误差线性递推方程的推导"></a>状态误差线性递推方程的推导</h2><p>通常情况下，对于状态量之间的递推关系是非线性的方程，如 $x_k=f(x_{k-1},\mathbf{u}_{k-1})$，其中状态量 $x,\mathbf{u}$ 为系统的输入量。</p><p>我们可以用两种方法来推导误差传递的线性递推关系：</p><ul><li>一种是<strong>基于一阶泰勒展开</strong>的误差传递方程，主要应用于 EKF 的协方差预测。</li><li>一种是<strong>基于误差随时间变化</strong>的递推方程。</li></ul><h3 id="基于一阶泰勒展开"><a href="#基于一阶泰勒展开" class="headerlink" title="基于一阶泰勒展开"></a>基于一阶泰勒展开</h3><p>令状态量为 $x=\hat{x}+\delta x$，其中，真值为$\hat{x}$，误差为 $\delta x$，另外输入量 $\mathbf{u}$ 的噪声为 $\mathbf{n}$。</p><p>对于非线性系统  $x_k=f(x_{k-1},\mathbf{u}_{k-1})$ 进行一阶泰勒展开有：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},\mathbf{u}_{k-1})\\\hat{x}_k+\delta x_k&=f(\hat{x}_{k-1}+\delta x_{k-1},\hat{\mathbf{u} }_{k-1}+\mathbf{n}_{k-1})\\{\color{blue}\hat{x}_k}+\delta x_k&={\color{blue}f(\hat{x}_{k-1},\hat{\mathbf{u} }_{k-1})}+\mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\end{align*}\tag{4}</script><p>可以看出蓝色字体部分表示真值，他们相互抵消掉了，剩下的就是误差的线性递推关系：</p><script type="math/tex; mode=display">\delta x_k = \mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\tag{5}</script><p>其中，$\mathbf{F}$ 是状态量 $x_k$ 对状态量 $x_{k-1}$ 的雅可比矩阵， $\mathbf{G}$ 是状态量 $x_k$ 对输入量 $\mathbf{u}_{k-1}$ 的雅可比矩阵。</p><h3 id="基于误差随时间变化"><a href="#基于误差随时间变化" class="headerlink" title="基于误差随时间变化"></a>基于误差随时间变化</h3><p>如果我们能够推导状态误差随着时间变换的倒数关系，比如：</p><script type="math/tex; mode=display">\dot{\delta x}=\mathbf{A}\delta x+\mathbf{B}\mathbf{n}\tag{6}</script><p>则误差状态的递推方程为：</p><script type="math/tex; mode=display">\begin{align*}&\delta x_k = \delta x_{k-1} + \dot{\delta x_{k-1} }\Delta t\\\rightarrow&\delta x_k=(\mathbf{I}+\mathbf{A}\Delta t)\delta x_{k-1}+\mathbf{B}\Delta t \mathbf{n}_{k-1} \end{align*}\tag{7}</script><p>综合两种方法可以发现：</p><script type="math/tex; mode=display">\mathbf{F}=\mathbf{I}+\mathbf{A}\Delta t,\ \ \ \ \mathbf{G}=\mathbf{B}\Delta t\tag{8}</script><p>由于在 VIO 系统中我们已经知道了状态的导数与状态之间的旋转矩阵，如公式 $(26)$:</p><script type="math/tex; mode=display">\dot{\mathbf{v} }=Ra^b+g\tag{9}</script><p>那么我们就可以推导<strong>速度误差</strong>和<strong>状态误差</strong>之间的关系，再每一项上都加上各自的误差，既有：</p><script type="math/tex; mode=display">\begin{align*}\dot{\mathbf{v} }+\dot{\delta\mathbf{v} }&=R(\mathbf{I}+[\delta\theta]^{\land})(a^b+\delta a^b)+g+\delta g\\\dot{\delta\mathbf{v} }&=R\delta a^b+R[\delta\theta]^{\land}(a^b+\delta a^b)+\delta g\\\dot{\delta\mathbf{v} }&=R\delta a^b-R[a^b]^{\land}\delta\theta+\delta g\end{align*}\tag{10}</script><p>由此就可以以此类推，很轻易的写出整个 $\mathbf{A}$ 和 $\mathbf{B}$ ，这也是此方法的优点。 </p><h1 id="基于一阶泰勒展开的推导"><a href="#基于一阶泰勒展开的推导" class="headerlink" title="基于一阶泰勒展开的推导"></a>基于一阶泰勒展开的推导</h1><p>由上一节的公式$(17)$：IMU 预积分误差的离散形式 ，此时将噪声模型也考虑进去：</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}{\color{red}+\mathbf{n}^a_{k} }-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }{\color{red}+\mathbf{n}^a_{k+1} }-b^a_k)]\\w&=\frac{1}{2}[(w^{b_k}{\color{red}+\mathbf{n}^g_{k} }-b^g_k)+(w^{b_{k+1} }{\color{red}+\mathbf{n}^g_{k+1} }-b^g_k)]\\{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t\end{align*}\tag{11}</script><p>用前面一阶泰勒展开的推导方式，我们希望能推导出如下的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}\delta\alpha_{b_{k+1}b^{\prime}_{k+1} }\\\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\\delta\beta_{b_{k+1}b^{\prime}_{k+1} }\\\delta\mathbf{b}^a_{k+1}\\\delta\mathbf{b}^g_{k+1}\\\end{bmatrix}=\mathbf{F}\begin{bmatrix}\delta\alpha_{b_{k}b^{\prime}_{k} }\\\delta\theta_{b_{k}b^{\prime}_{k} }\\\delta\beta_{b_{k}b^{\prime}_{k} }\\\delta\mathbf{b}^a_{k}\\\delta\mathbf{b}^g_{k}\\\end{bmatrix}+\mathbf{G}\begin{bmatrix}\mathbf{n}^a_{k}\\\mathbf{n}^g_{k}\\\mathbf{n}^a_{k+1}\\\mathbf{n}^g_{k+1}\\\mathbf{n}_{\mathbf{b}^a_k}\\\mathbf{n}_{\mathbf{b}^g_k}\\\end{bmatrix}\tag{12}</script><p>$\mathbf{F},\mathbf{G}$为两个时刻间的协方差传递矩阵。</p><p>这里我们直接给出 $\mathbf{F},\mathbf{G}$ 的最终形式，后面会对部分项进行详细推导：  </p><script type="math/tex; mode=display">\mathbf{F}=\begin{bmatrix}\mathbf{I}&f_{12}&\mathbf{I}\delta t&-\frac{1}{4}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t^2&f_{15}\\0&\mathbf{I}-[\omega]^{\land}&0&0&-\mathbf{I}\delta t\\0&f_{32}&\mathbf{I}&-\frac{1}{2}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t&f_{35}\\0&0&0&\mathbf{I}&0\\0&0&0&0&\mathbf{I}\end{bmatrix}\tag{13}</script><script type="math/tex; mode=display">\mathbf{G}=\begin{bmatrix}\frac{1}{4}q_{b_ib_k}\delta t^2&g_{12}&\frac{1}{4}q_{b_ib_{k+1} }\delta t^2&g_{14}&0&0\\0&\frac{1}{2}\mathbf{I}\delta t&0&\frac{1}{2}\mathbf{I}\delta t&0&0\\\frac{1}{2}q_{b_ib_k}\delta t&g_{32}&\frac{1}{2}q_{b_ib_{k+1} }\delta t&g_{34}&0&0\\0&0&0&0&\mathbf{I}\delta t&0\\0&0&0&0&0&\mathbf{I}\delta t\end{bmatrix}\tag{14}</script><p>其中的系数如下：</p><p><img src="/images/3-2-IMU误差状态传递的推导/image-20220509150144881-16521033725157.png" alt="image-20220509150144881"></p><h2 id="雅克比矩阵-mathbf-F-的推导"><a href="#雅克比矩阵-mathbf-F-的推导" class="headerlink" title="雅克比矩阵 $\mathbf{F}$ 的推导"></a>雅克比矩阵 $\mathbf{F}$ 的推导</h2><h3 id="速度预积分量的雅可比"><a href="#速度预积分量的雅可比" class="headerlink" title="速度预积分量的雅可比"></a>速度预积分量的雅可比</h3><p>$\beta$ 对于各个状态量的雅可比矩阵推导，即 $\mathbf{F}$ 矩阵第三行。速度预积分量 $\beta$ 的递推计算形式:  </p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{15}</script><p>$f_{33}$: 对上一时刻<strong>速度预积分量</strong>的 雅可比：</p><script type="math/tex; mode=display">f_{33}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\beta_{b_{k}b^{\prime}_{k} } }=\mathbf{I}_{3\times 3}\tag{16}</script><p>$f_{32}$: 对上一时刻<strong>角度预积分量</strong>的 雅可比：</p><p>首先将公式 $(32)$写成如下形式：</p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{17}</script><p>那么，<strong>速度的预积分量对角度预积分量</strong>的 雅可比：  </p><script type="math/tex; mode=display">f_{32}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }=\frac{\partial a\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\tag{18}</script><p>其中分子可以写成：</p><script type="math/tex; mode=display">\begin{align*}a\delta t &=\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}(a^{b_k}-b^a_k)\delta t\\&+\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)\delta t\\&=\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t\\&+\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t\end{align*}\tag{19}</script><p>分别对分子的两项进行求导：</p><p>①第一项</p><script type="math/tex; mode=display">\begin{align*}&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }(I + [\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t-R_{b_ib_{k} }(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[(a^{b_{k} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}[\delta\theta_{b_kb^{\prime}_{k} }]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}\end{align*}\tag{20}</script><p>②第二项</p><script type="math/tex; mode=display">\begin{align*}&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }(I+[\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }\left[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\ [\delta\theta_{b_kb^{\prime}_{k} }\right]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }\exp([\omega\delta t]^{\land})\left[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})[\delta\theta_{b_kb^{\prime}_{k} }\right]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\&=-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\&\approx-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}(I-[\omega\delta t]^{\land})\end{align*}\tag{21}</script><p>将上面两部分综合起来就能得到  :</p><script type="math/tex; mode=display">\begin{align*}f_{32}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\frac{1}{2}\left([a^{b_{k} }-b^a_k]^{\land}\delta t+R_{b_ib_{k+1} }[a^{b_{k+1} }-b^a_k]^{\land}(I-[\omega]^{\land}\delta t)\delta t \right)\end{align*}\tag{22}</script><p>$f_{35}$: <strong>速度预积分量</strong>对 $k$ 时刻<strong>角速度 bias</strong> 的 雅可比：</p><p>递推公式如下:</p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes \begin{bmatrix}1\\{\color{red}\frac{1}{2}w\delta t}\end{bmatrix}(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{23}</script><p>只有红色公式部分和角速度 bias 有关系，因此雅克比的推导只考虑红色公式部分。  </p><script type="math/tex; mode=display">\begin{align}f_{35}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{\partial \frac{1}{2}q_{b_ib_{k} }\otimes \begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes \begin{bmatrix}1\\-\frac{1}{2}\mathbf{b}^g_k\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)\delta t-\partial \frac{1}{2}q_{b_ib_{k} }\otimes \begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes (a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }\exp([-\delta\mathbf{b}^g_k\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }(I+[-\delta\mathbf{b}^g_k\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }[-\delta\mathbf{b}^g_k\delta t]^{\land}[(a^{b_{k+1} }-b^a_k)\delta t]}{\partial\delta\mathbf{b}^g_k}\\&=-\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}[-\delta\mathbf{b}^g_k\delta t]}{\partial\delta\mathbf{b}^g_k}\\&=-\frac{1}{2}(R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)]^{\land}\delta t)(-\delta t)\end{align}\tag{24}</script><h3 id="旋转预积分量的雅可比"><a href="#旋转预积分量的雅可比" class="headerlink" title="旋转预积分量的雅可比"></a>旋转预积分量的雅可比</h3><p>旋转预积分的递推公式为：  </p><script type="math/tex; mode=display">\begin{align*}q_{b_ib_{k+1} }&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}(\frac{1}{2}(\omega^{b_k}+\omega^{b_{k+1} })-\mathbf{b}^g_k)\delta t\end{bmatrix}\end{align*}\tag{25}</script><p>$f_{22}$: 前一时刻的旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 如何影响当前的旋转误差  $\delta\theta_{b_{k+1}b^{\prime}_{k+1} }$ ？</p><p>假设两个时刻的真值为 $q_{b_ib_{k+1} },\ q_{b_ib_{k} }$，两个时间的增量真值为 $q_{b_kb_{k+1} }$。推导过程只考虑一个变量，即旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 的影响，而不考虑测量值 角速度 bias 误差影响，可以假设 $q_{b_kb_{k+1} }\approx\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}$。</p><p>另外，三元组四元数相乘有如下性质：</p><script type="math/tex; mode=display">\mathbf{q}\otimes\mathbf{p}\otimes\mathbf{q}^*=[\mathbf{q}]_L[\mathbf{q}]_R^T\mathbf{p}=\begin{bmatrix}p_w\\R\mathbf{p}_v\end{bmatrix}\tag{26}</script><p>其中 $R$是 $\mathbf{q}$ 对应的旋转矩阵，$\mathbf{q}^*$ 是 $\mathbf{q}$ 的共轭， $p_w$ 为 $\mathbf{p}$ 的实部，  $\mathbf{p}_v$ 为  $\mathbf{p}$ 的虚部。</p><p>下面开始详细推导：  </p><script type="math/tex; mode=display">\begin{align*}q_{b_ib_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}&=q_{b_ib_{k+1} }^*\otimes q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=q_{b_{k+1}b_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&\approx \begin{bmatrix}1\\-\frac{1}{2}\omega\delta t\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=\begin{bmatrix}1\\\frac{1}{2}R\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\end{align*}\tag{27}</script><p>注意：上面推导过程，也可以用李代数的右扰动   $R\exp([\delta\theta_{k+1}]^{\land})$</p><p>只考虑公式 $(27)$ 中的虚部：</p><script type="math/tex; mode=display">\begin{align*}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }&=R\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\&=\exp([-w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\\&\approx (I-[w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\end{align*}\tag{28}</script><p>那么，第 $k+1$ 时刻的旋转预积分的误差相对于第 $k$ 时刻的 雅可比为：</p><script type="math/tex; mode=display">f_{22}=\frac{\partial \delta\theta_{b_{k+1}b^{\prime}_{k+1} } }{\partial \delta\theta_{b_{k}b^{\prime}_{k} } }=I-[w\delta t]^{\land}\tag{29}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>三、预积分模型以及残差的构建</title>
    <link href="https://lukeyalvin.top/posts/285413d6.html"/>
    <id>https://lukeyalvin.top/posts/285413d6.html</id>
    <published>2022-05-09T13:22:59.000Z</published>
    <updated>2022-05-11T07:53:08.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="IMU的误差模型"><a href="#IMU的误差模型" class="headerlink" title="IMU的误差模型"></a>IMU的误差模型</h1><ul><li><strong>加速度计的误差模型</strong></li></ul><p>设导航系$G$为东北天，$g^G=(0,0,-9.81)^T$。</p><p>理论测量值：</p><script type="math/tex; mode=display">a_m^B=R_{BG}(a^G-g^G)\tag{1}</script><p>如果考虑高斯白噪声，bias，以及尺度因子(通常假设尺度因子为单位矩阵。)，则为：</p><script type="math/tex; mode=display">a_m^B=S_aR_{BG}(a^G-g^G)+n_a+b_a\tag{2}</script><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423171217806.png" alt="image-20220423171217806" style="zoom:50%;" /></p><ul><li><strong>陀螺仪的误差模型</strong></li></ul><p>考虑尺度因子，高斯白噪声，以及 bias, 陀螺仪的误差模型如下：</p><script type="math/tex; mode=display">w^b_m=S_gw^b+n_g+b_g\tag{3}</script><p>低端传感器，考虑加速度对陀螺仪的影响，即 g-灵敏度：</p><script type="math/tex; mode=display">w^b_m=S_gw^b+S_{ga}a^b+n_g+b_g\tag{4}</script><p>陀螺仪受四种噪声的影响分别如下图所示：</p><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423190440715.png" alt="image-20220423190440715" style="zoom: 50%;" /></p><h1 id="IMU模型与运动积分"><a href="#IMU模型与运动积分" class="headerlink" title="IMU模型与运动积分"></a>IMU模型与运动积分</h1><p>忽略 scale 的影响，根据imu的误差模型我们可以假设：角速度读数会在真实值的基础上受到<strong>bias和白噪声</strong>的影响，加速度除了受到<strong>bias和白噪声</strong>的影响，还会受到<strong>重力</strong>的影响。因此我们可以从IMU中得到角速度和加速度的读数，如公式$(5)(6)$的等式左边，它们都是基于IMU坐标系的。</p><script type="math/tex; mode=display">\begin{align*}\tilde{w}^b&=w^b+b_g+n_g\tag{5}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\tilde{a}^b&=q_{bw}(a^w-g^w)+b_a+n_a\tag{6}\end{align*}</script><p>上标$ g$ 表示 gyro，a 表示 acc，$^w $表示在世界坐标系 world，$^b$表示imu 机体坐标系 body。IMU 的真实值为$w, a$, 测量值为$\tilde w, \tilde a$，测量值即为IMU的读数。 </p><p>我们知道<strong>角速度$w$</strong>积分得到<strong>姿态$q$</strong>，<strong>加速度$a$</strong>积分得到<strong>速度$v$</strong>，<strong>速度$v$</strong>积分得到<strong>位移$p$</strong>。而现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型， <strong>P(ose)（位置），V(elocity)（速度），Q(uaternion) （旋转）</strong>对时间的导数可写成：</p><script type="math/tex; mode=display">\begin{align*}\dot p_{wb}&=v^w_t\\\dot v^w_t &=a^w_t\\\dot q_{wb_t} &=q_{wb_t} \otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\end{align*}\tag{7}</script><p>它描述了 IMU坐标系 的姿势和速度的演变。</p><p>第三项，四元数求导参考 <a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0">一、VIO概述以及三维刚体运动知识点回顾</a></p><p> $t + \Delta t $时刻的状态是通过积分方程$(7)$获得的：</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+\int^{t+\Delta t}_t v^w(\tau)d\tau+\iint^{t+\Delta t}_t a^w d\tau^2\\v^w(t+\Delta t)&=v^w(t)+\int^{t+\Delta t}_t a^w d\tau\\q_{wb}(t+\Delta t)&=\int^{t+\Delta t}_t q_{wb}(\tau)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(\tau)\end{bmatrix}d\tau\end{align*}\tag{8}</script><p>根据积分的性质，这里的 $\tau$ 是把 $[t,t+\Delta t]$分割的无限小部分。</p><p>假设 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2} a^w \Delta t^2\\v^w(t+\Delta t)&=v^w(t)+ a^w \Delta t\\q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(t)\Delta t\end{bmatrix}\end{align*}\tag{9}</script><p>根据公式$(5)(6)$可以将 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 写成 IMU 测量的函数，因此 $(9)$ 变为:</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t^2\\v^w(t+\Delta t)&=v^w(t)+g^w\Delta t+ q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t\\q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}(\tilde{w}^b(t)-b_g(t)-n_g(t))\Delta t\end{bmatrix}\end{align*}\tag{10}</script><p>方程 $(10)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。<strong>这样就可以得到旋转，速度，平移与 IMU 读数之间的关系，进而可以根据IMU 的读数来估计位姿。</strong></p><h1 id="IMU预积分模型"><a href="#IMU预积分模型" class="headerlink" title="IMU预积分模型"></a>IMU预积分模型</h1><h2 id="IMU-预积分"><a href="#IMU-预积分" class="headerlink" title="IMU 预积分"></a>IMU 预积分</h2><p>如图所示，相机的采样频率是明显低于 IMU 的采样频率的，相机或激光一般在几十 HZ，而 IMU 可以达到几百 HZ，而在 SLAM 中我们通常是求解每一帧图像/激光的位姿，因此需要对两帧图像/激光之间的所有IMU观测进行累加，可以得到 $i$ 帧和 $j$ 帧两个关键帧之间的单个复合的测量值，我们称之为<strong>预积分</strong>。</p><p><img src="/images/3-预积分模型以及误差递推方程的推导/image-20220507202527649-16521033725156.png" alt="image-20220507202527649"></p><p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 $(10)$，我们发现：</p><script type="math/tex; mode=display">\begin{align*}{p_{wb} }_j&={p_{wb} }_i+\sum^{j-1}_{k=i}\left[v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb_k}\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t^2\right]\\v^w_j&=v^w_i+g^w\Delta t_{ij}+ \prod^{j-1}_{k=i} q_{wb_k}(t)\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t\\q_{wb_j}&= q_{wb_i}\otimes \begin{bmatrix}0\\ \frac{1}{2}\prod^{j-1}_{k=i}(\tilde{w}^b_k-b_{gk}-n_{gk})\Delta t\end{bmatrix}\end{align*}\tag{11}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。 $(11)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(11)$ 中的积分（直观地说，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_k}、k = i,…,j-1$ 的变化，因此有必要重新评估 $(11)$ 中的求和和乘积。</p><blockquote><p>这里没有找到离散形势下使用四元数的预积分推导相关资料，而在高博等人的《从零开始手写VIO》课程中，用的是如下连续形式进行推导的，事实上，我认为 $(12)$ 中的连续形式中在递推 $p_{wb_j}$的时候，对速度没有积分是不对的，此处暂且留疑点。</p></blockquote><p>同样的，连续形式下，可以得到:</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t+\iint_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t^2\\v^w_j&=v^w_i+\int_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t\\q_{wb_j}&=\int_{t\in[i,j]}q_{wb_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{12}</script><p>其中，不难发现，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_t}、t \in [i,j]$ 的变化，导致对 $(12)$中的积分进行重复计算。</p><p>一个很简单的公式转换，就可以将积分模型转为预积分模型：  </p><script type="math/tex; mode=display">q_{wb_t}=q_{wb_i}\otimes q_{b_ib_t}\tag{13}</script><p>其中 $\otimes$ 表示四元数的乘法，具体可以可以参考，<a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0"><strong>四元数的乘法运算</strong></a></p><p>那么， PVQ 积分公式中的积分项则变成相对于第 $i$ 时刻的姿态，而不是相对于世界坐标系的姿态，则公式$(12)$变换为：</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+q_{wb_i}\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\v^w_j&=v^w_i-g^w\Delta t+q_{wb_i}\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{wb_j}&=q_{wb_i}\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{14}</script><p>这样的话，积分里的把相对于世界坐标系的状态量 $q_{wb_i}$ 移出去了，积分里面都是相对于第 $i$ 时刻的状态量 $q_{b_ib_t}$。</p><p>定义预积分量如下，预积分量仅仅跟 IMU 测量值有关，它将一段时间内的 IMU 数据直接积分起来就得到了<strong>预积分量</strong>：  </p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t\end{align*}\tag{15}</script><p>由公式$(14)$与$(15)$重新整理PVQ的积分公式，有：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}p_{wb_j}\\v^w_{j}\\q_{wb_j}\\b^a_j\\b^g_j\end{bmatrix}=\begin{bmatrix}p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+q_{wb_i}\alpha_{b_ib_j}\\v^w_i-g^w\Delta t+q_{wb_i}\beta_{b_ib_j}\\q_{wb_i}q_{b_ib_j}\\b^a_i\\b^g_i\end{bmatrix}\end{align*}\tag{16}</script><h2 id="IMU-预积分残差"><a href="#IMU-预积分残差" class="headerlink" title="IMU 预积分残差"></a>IMU 预积分残差</h2><p>定义：一段时间内 <strong>IMU 构建的预积分量作为测量值</strong>，对两时刻之间的状态量进行约束，  </p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}r_p\\r_v\\r_q\\r_{ba}\\r_{bg}\end{bmatrix}_{15\times1}=\begin{bmatrix}q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-{\color{red}\alpha_{b_ib_j} }\\q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{red}\beta_{b_ib_j} }\\2[{\color{red}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\b^a_j-b^a_i\\b^g_j-b^g_i\end{bmatrix}\end{align*}\tag{16}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第三项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p><h2 id="IMU-预积分残差的离散形式"><a href="#IMU-预积分残差的离散形式" class="headerlink" title="IMU 预积分残差的离散形式"></a>IMU 预积分残差的离散形式</h2><p>使用 mid-point 方法，即两个相邻时刻$ k$到$ k+1$ 的位姿是用两个时刻的测量值$ a,w $的平均值来计算。参考公式$(11)(12)$:</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\\w&=\frac{1}{2}[(w^{b_k}-b^g_k)+(w^{b_{k+1} }-b^g_k)]\\{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t\end{align*}\tag{17}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【文献阅读】On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</title>
    <link href="https://lukeyalvin.top/posts/e6b6704d.html"/>
    <id>https://lukeyalvin.top/posts/e6b6704d.html</id>
    <published>2022-05-08T13:16:58.000Z</published>
    <updated>2022-05-08T13:17:50.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry"><a href="#On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry" class="headerlink" title="On-Manifold Preintegration for Real-Time Visual-Inertial Odometry"></a>On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</h1><p>摘要：当前的视觉惯性里程计（VIO）方法能够通过非线性优化获得高度准确的状态估计。然而，随着轨迹随着时间的推移，实时优化很快变得不可行。尤其是惯性测量以高速率出现的时候，这个问题变得更加突出，因此导致优化中变量数量的快速增长。在本文中，我们<strong>通过预积分关键帧之间的惯性测量以得到单个相对运动约束</strong>。</p><p>我们的第一个贡献是一个预积分理论，它正确地解决了<strong>旋转群的流形结构</strong>。我们正式讨论生成测量模型以及旋转噪声的性质，并推导出最大后验状态估计器的表达式。我们的理论发展能够计算所有必要的雅可比矩阵，以分析形式的优化和后验偏差校正。</p><p>第二个贡献是表明预积分的 IMU 模型可以在因子图的统一框架下被整合到视觉-惯性流程中。这使得<strong>增量平滑算法</strong>的应用和<strong>视觉测量的无结构模型</strong>的使用成为可能，避免了对 3D 点的优化，进一步加速了计算。</p><p>我们在真实和模拟数据集上对我们的单目 VIO 流程进行了广泛的评估。结果证实，我们的建模工作可以实时进行准确的状态估计，优于最先进的方法。</p><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>使用相机和惯性传感器进行三维结构和运动估计已经受到机器人界的极大关注。两种传感器类型都便宜、无处不在且互补。<strong>移动相机</strong>是一种外感知传感器，它允许我们测量三维场景的外观和几何形状，直至未知的度量尺度；<strong>惯性测量单元 (IMU)</strong> 是一种本体感受传感器，可呈现单目视觉和重力可视化的度量尺度 [1]，并提供稳健且准确的帧间运动估计。<strong>视觉惯性里程计（VIO）</strong>的应用范围从无GPS环境的自动驾驶到3D重建和增强现实。</p><p>现有的关于 VIO 的文献在准确性和计算效率之间进行了权衡（第 II 节给出了详细的回顾）。一方面，<strong>滤波方法</strong>可以实现快速推断，但其准确性会因线性化误差的累积而下降。另一方面，<strong>基于非线性优化的完全平滑方法</strong>是准确的，但计算量很大。固定滞后平滑（$Fixed-lag\ Smoothing$）在精度和效率之间提供折中；但是，尚不清楚如何设置估计窗口的长度以保证给定的性能水平。</p><p>在这项工作中，我们表明可以克服这种权衡。我们设计了一个 VIO 系统，可以实现快速增量平滑并实时计算最优的最大后验 (MAP) 估计。第IV给出了我们方法的概述。</p><p>实现这一目标的第一步是发展一个新的预积分理论。在 [2] 中首次提出使用预积分 IMU 测量，其组合两个关键帧间的许多惯性测量为单个相对运动约束。我们在这项工作的基础上提出了一个预积分理论，该理论正确地<strong>解决了旋转群 $SO(3)$ 的流形结构</strong>。我们的预积分理论在第 V-VI 节中介绍。与[2]相比，我们的理论对旋转噪声提供了更正式的处理，并避免了旋转表示中的奇异性。此外，我们能够以解析形式推导出所有必要的雅可比矩阵：具体来说，我们在本文的附录中报告了残差、噪声传播和后验偏差校正的解析雅可比矩阵。</p><p>我们的第二个贡献是<strong>将 IMU 预积分理论框架化为因子图模型</strong>。这使得增量平滑算法的应用成为可能，如 iSAM2 [3]，它避免了线性化误差的累积，并提供了一种优雅的方式来权衡精度和效率。受 [4, 5] 的启发，我们还<strong>采用无结构模型进行视觉测量</strong>，允许在增量平滑期间消除大量变量（即所有 3D 点），从而进一步加速计算（第 VII 节）。与 [5] 相比，我们在增量平滑框架中使用无结构模型。这有两个主要优点：我们不需要延迟视觉测量的处理，我们可以多次重新线性化视觉测量。</p><p>为了证明我们模型的有效性，我们将提议的 IMU 预积分集成到最先进的 VIO 流程中，并在真实和模拟数据集 2（第 VIII 节）上对其进行了测试。我们的理论发展带来了切实的实际优势：本文提出的方法的实现以 100 Hz 的速率执行完全平滑，并相对于具有竞争力的最先进的过滤和优化方法实现了卓越的精度。</p><p>除了技术贡献，论文还为实践者提供了教程贡献。在第III部分和整篇论文中，我们对流形上的不确定性表示以及不确定性传播和雅可比计算的示例推导进行了简短而简洁的总结。所有方程和雅可比矩阵的完整推导——实现我们的模型所必需的——在附录中给出。</p><p>本文是我们之前工作 [6] 的扩展，包括额外的实验、对相关工作的深入讨论和全面的技术推导。新实验的结果突出了偏差估计的准确性，证明了我们方法的一致性，并提供了与全批次估计的比较。我们在 GTSAM 4.0 优化工具箱中发布了预集成 IMU 和无结构视觉因素的实现。</p><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>视觉惯性里程计的相关工作可以沿着三个主要维度进行划分。<strong>第一个维度是 在估计中涉及的相机位姿的数量。</strong>虽然完全平滑器（$full\ smoothers$）（或批量非线性最小二乘算法（$batch\ nonlinear\ least-squares\ algorithms$）估计姿势的完整历史，但固定滞后平滑器（$fixed-lag\ smoothers$）（或滑动窗口估计器（$fixed-lag\ smoothers$）考虑最新姿势的窗口，而过滤方法仅估计最新状态。固定滞后平滑器和滤波器都会<strong>边缘化</strong>旧状态并<strong>吸收</strong>高斯先验中的相应信息。</p><p><strong>第二个维度是 关于测量不确定性和高斯先验的表示</strong>：扩展卡尔曼滤波器 (EKF) 使用协方差矩阵表示不确定性；相反，信息滤波器和平滑器求助于信息矩阵（协方差的倒数）或信息矩阵的平方根 [3, 8]</p><p>最后，<strong>第三个维度 通过查看测量模型线性化的次数来区分现有方法。</strong>虽然标准 EKF（与迭代 EKF 相比）只处理一次测量，但平滑方法允许多次线性化。</p><p>虽然术语很多，但底层算法是紧密相关的。例如，可以证明<strong>迭代扩展卡尔曼滤波器方程等价于高斯牛顿算法</strong>，通常用于平滑 [9]</p><h2 id="A-滤波"><a href="#A-滤波" class="headerlink" title="A. 滤波"></a>A. 滤波</h2><p>滤波算法通过将推理过程限制在系统的最新状态来实现有效的估计。 EKF 的复杂性在估计的地标数量上呈二次增长，因此，通常会跟踪少量地标（大约 20 个）以允许实时操作 [10-12]。另一种方法是采用<strong>“无结构”方法</strong>，其中地标位置被<strong>边缘化</strong>出状态向量。这种策略的一个很好的例子是<strong>多状态约束卡尔曼滤波器</strong>（$Multi-State\ Constraint\ Kalman\ filter\ ，MSC-KF$）[5]。无结构方法需要通过<strong>随机克隆</strong>（$stochastic\ cloning$） [13] 将先前的姿势保留在状态向量中。</p><p>使用无结构方法进行过滤的一个缺点是，<strong>地标测量的处理</strong>需要延迟，直到获得地标的所有测量值 [5]。这会妨碍准确性，因为滤波器不能使用所有当前的视觉信息。<strong>边缘化</strong>也是错误的来源，因为它锁定了<strong>线性化误差</strong>和<strong>错误的异常值测量</strong>。因此，滤除虚假测量值尤为重要，因为单个异常值会不可逆转地破坏滤波器 [14]。此外，<strong>线性化误差</strong>会在估计中引入漂移并导致滤波器不一致。不一致的一个影响是<strong>估计器</strong>变得过于自信，导致非最优信息融合。通常，VIO 问题有四个不可观察的方向：<strong>全局位置</strong>和围绕重力方向（<strong>偏航</strong>，yaw）的方向 [15, 16]。在 [16] 中表明，<strong>错误估计的线性化</strong>仅导致三个不可观察的方向（全局位置）；因此，错误的线性化将偏航方向的虚假信息添加到高斯先验中，从而导致滤波器不一致。这个问题已通过<strong>首次估计雅可比方法</strong> （$first-estimates\ jacobian$）[17] 得到解决，<strong>该方法确保状态不会使用不同的线性化点进行更新</strong>——这是不一致的来源。在可观察性约束（$observability-constrained$）的 EKF (OC-EKF) 中，维持对不可观察方向的估计，这允许仅在可观察的方向上更新滤波器 [16, 18]。在 [1, 15, 19] 中给出了对 VIO 可观察性属性的全面分析。</p><h2 id="B-固定滞后平滑"><a href="#B-固定滞后平滑" class="headerlink" title="B.固定滞后平滑"></a>B.固定滞后平滑</h2><p>固定滞后平滑器（$fixed-lag\ smoothers$）估计落在给定时间窗口内的状态，同时边缘化较旧的状态[20-24]。在最大似然估计设置中，固定滞后平滑器会<strong>导致一组最近状态的优化问题</strong>。对于非线性问题，<strong>平滑方法</strong>通常比滤波更准确，因为它们会<strong>重新线性化过去的测量</strong> [25]。此外，这些方法<strong>对异常值更具弹性</strong>，可以在后验（即优化之后）丢弃，或者可以通过使用鲁棒代价函数来缓解。不利的一面是，<strong>估计窗口外的状态边缘化会导致密集的高斯先验，从而阻碍有效的推理。</strong>出于这个原因，有人提出为了<strong>稀疏性</strong>而放弃某些测量值[24]。此外，由于边缘化，固定滞后平滑器具有过滤的部分问题（一致性、线性化误差的累积）[18、22、26]。</p><h2 id="C-完全平滑"><a href="#C-完全平滑" class="headerlink" title="C. 完全平滑"></a>C. 完全平滑</h2><p>完全平滑（$Full\ Smoothing$）方法<strong>通过解决大型非线性优化问题来估计状态的整个历史</strong>（相机轨迹和 3D 地标）[27-31]。全平滑保证了最高精度；然而，随着轨迹和地图随着时间的推移而增长，实时操作很快变得不可行。因此，已经提出丢弃除选定<strong>关键帧</strong>之外的帧 [24, 32-34] 或使用<strong>跟踪和建图双重架构</strong> [20, 35] 在并行线程中运行优化。一项突破是<strong>增量平滑技术</strong>（$incremental\ smoothing\ techniques$）（iSAM [36]、iSAM2 [3]）的发展，该技术<strong>利用因子图的表达性来保持稀疏性，并仅识别和更新受新测量影响的通常较小的变量子集。</strong></p><p>尽管如此，高频率的惯性测量（通常为 $100 Hz$ 至 $1 kHz$）仍然对平滑方法构成挑战。一个简单的实现需要在每次 IMU 测量时添加一个新状态，这很快就会变得非常慢 [37]。因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。<strong>对于两帧之间的标准 IMU 集成，初始条件由第一帧的状态估计给出。</strong>因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。对于两帧之间的标准 IMU 积分，初始条件由第一帧的状态估计给出。然而，<strong>在优化的每次迭代中，状态估计都会发生变化，这需要在所有帧之间重复 IMU 积分</strong>[24]。 Lupton 和 Sukkarieh [2] 表明，<strong>通过重新参数化相对运动约束可以避免这种重复积分。这种重新参数化称为 IMU 预积分。</strong></p><p>在目前的工作中，我们以开创性工作 [2] 为基础，通过适当<strong>解决旋转群 SO(3) 的流形结构</strong>，使 IMU 预积分理论走向成熟。工作[2]采用欧拉角作为旋转的全局参数。在刚性变换的作用下，使用欧拉角并应用欧几里得空间的通常平均和平滑技术进行状态传播和协方差估计并不具有不变性[41, 42]。此外，欧拉角具有奇异性。我们的研究，另一方面，提供了一个正式的旋转测量的表示（和对应噪声），并提供了完整的最大后验估计量的推导。我们还推导出雅可比矩阵的解析表达式（优化所需），据我们所知，这些表达式以前没有在文献中报道过。在实验部分，我们表明旋转流形的正确表示会导致更高的准确性和鲁棒性，从而比原始提议 [2] 带来切实的优势。</p><h1 id="三、预备知识"><a href="#三、预备知识" class="headerlink" title="三、预备知识"></a>三、预备知识</h1><p>在本文中，我们根据 MAP 估计来制定 VIO。在我们的模型中，MAP 估计会导致非线性优化问题，该问题涉及存在于<strong>平滑流形</strong>上的量（例如，旋转、姿势）。因此，在深入研究细节之前，我们方便地回顾一些有用的几何概念。专家读者可以跳过本节。</p><p>我们将本节结构如下：第 III-A 节提供了与两个主要<strong>黎曼流形</strong>相关的有用概念：<strong>特殊正交群</strong> $SO(3)$ 和<strong>特殊欧几里得群</strong>$ SE(3)$。我们的介绍基于 [43, 44]。第 III-B 节描述了一个合适的模型来描述$ SO(3) $中的不确定旋转。第 III-C 节根据标准参考文献 [45] 回顾了流形上的优化。</p><h2 id="A-黎曼几何的概念"><a href="#A-黎曼几何的概念" class="headerlink" title="A. 黎曼几何的概念"></a>A. 黎曼几何的概念</h2><p>a) 特殊正交群：SO(3) 描述了一组 3D 旋转矩阵，正式定义为$SO(3)\doteq \{R\in\mathbb{R}^{3\times3}:R^TR=I,\det(R)=1\}.$群运算就是通常的矩阵乘法，逆运算就是矩阵转置。群 $ SO(3) $也形成一个<strong>光滑的流形</strong>。流形（恒等式）的<strong>切线空间表示</strong>为 $\mathfrak{so}(3)$，也称为<strong>李代数</strong>，与 $3\times3$ 斜对称矩阵的空间重合。我们可以使用$hat$算子在 R3 中用一个向量识别每个倾斜对称矩阵：</p><script type="math/tex; mode=display">w^{\land}=\begin{bmatrix}w_1\\w_2\\w_3\end{bmatrix}^{\land}=\begin{bmatrix}0&-w_3&w_2\\w_3&0&-w_1\\-w_2&w_1&0\end{bmatrix}\in\mathfrak{so}(3).\tag{1}</script><p>类似地，我们可以使用 $vee $算子$(\cdot)^{\lor}$ 将斜对称矩阵映射到$\mathbb{R}^3 $中的向量：对于<strong>斜对称矩阵</strong> $S= ω^{\land}$，$vee $ 算子使得 $S^{\lor}= ω$。稍后将有用的斜对称矩阵的属性是：</p><script type="math/tex; mode=display">a^{\land}b=-b^{\land}a,\forall a,b\in\mathbb{R}^3.\tag{2}</script><p><strong>指数映射</strong>（恒等式）$ \exp : \mathfrak{so}(3)\rightarrow SO(3)$将李代数的一个元素与旋转相关联，并与标准矩阵指数（罗德里格斯公式）一致：</p><script type="math/tex; mode=display">\exp(\phi)^{\land}=I+\frac{\sin(\parallel\phi\parallel)}{\parallel\phi\parallel}\phi^{\land}+\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel}(\phi^{\land})^2.\tag{3}</script><p>我们稍后将使用的指数映射的一阶近似是：</p><script type="math/tex; mode=display">\exp(\phi)^{\land}\approx I+\phi^{\land}.\tag{4}</script><p><strong>对数映射</strong>（恒等式）将 $SO(3)$ 中的矩阵 $R\ne I $与斜对称矩阵相关联：</p><script type="math/tex; mode=display">\log(R)=\frac{\varphi\cdot(R-R^T)}{2\sin(\varphi)},\varphi=\cos^{-1}(\frac{\tr(R)-1}{2}).\tag{5}</script><p>注意$ \log(R)^{\lor}= a\varphi$，其中 $a $和 $\varphi $分别是 $R$ 的旋转轴和旋转角度。如果 $R = I$，则 $\varphi= 0 $，并且 $a$ 是不确定的，因此可以任意选择。</p><p>如果限制在一个开放的球内$\parallel\phi\parallel&lt;\pi$，<strong>指数映射</strong>是<strong>双射</strong>，对应的逆是<strong>对数映射</strong>。然而，如果我们不限制定义域，指数映射就会变成<strong>满射</strong>的，因为每个向量$ \phi= (\varphi + 2k\pi)a, k \in \mathbb{Z}$ 将是 $R$ 的一个可容许对数。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507100016617.png" alt="image-20220507100016617"></p><p>为了符号方便，我们采用指数和对数图的“矢量化”版本：</p><script type="math/tex; mode=display">\begin{align*}Exp&:\ \mathbb{R}^3\rightarrow SO(3)\ ;\ \phi\mapsto \exp(\phi^{\land})\\Log&:\ SO(3)\rightarrow \mathbb{R}^3\ ;\ R\mapsto \log(R)^{\lor}\end{align*}\tag{6}</script><p>它直接对向量进行操作，而不是对$ \mathfrak{so}(3) $中的斜对称矩阵进行操作。</p><p>稍后，我们将使用以下一阶近似：</p><script type="math/tex; mode=display">Exp(\phi+\delta\phi)\approx Exp(\phi)\ Exp(J_r(\phi)\delta\phi).\tag{7}</script><p>$J_r(\phi)$是$SO(3)$ [43, p.40] 的右雅可比行列式，并将切线空间中的加法增量与右侧应用的乘法增量相关联（图 1）：</p><script type="math/tex; mode=display">J_r(\phi)=I-\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel^2}\phi^{\land}+\frac{\parallel\phi\parallel-\sin(\parallel\phi\parallel)}{\parallel\phi^3\parallel}(\phi^{\land})^2.\tag{8}</script><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507102404953.png" alt="image-20220507102404953" style="zoom: 50%;" /></p><blockquote><p>图 1：右雅可比$ J_r $将切线空间中的加性微扰 $\delta\phi$ 与流形$ SO(3)$ 上的乘性微扰联系起来，如方程。 (7)。</p></blockquote><p>类似的一阶近似适用于对数：</p><script type="math/tex; mode=display">Log(Exp(\phi)\ Exp(\delta\phi))\approx\phi+J_r^{-1}(\phi)\delta\phi.\tag{9}</script><p>右雅可比行列式的倒数是:</p><script type="math/tex; mode=display">\begin{align*}J_r^{-1}=I+\frac{1}{2}\phi^{\land}+\left(\frac{1}{\parallel\phi\parallel^2}+\frac{1+\cos(\parallel\phi\parallel)}{2\parallel\phi\parallel\sin(\parallel\phi\parallel)}\right)(\phi^{\land})^2,\end{align*}</script><p>当$\parallel\phi\parallel= 0$ 时，右雅可比 $J_r(\phi)$ 及其逆$J_r^{-1}(\phi)$简化为单位矩阵。</p><p>指数映射的另一个有用属性是：</p><script type="math/tex; mode=display">\begin{align*}&R \ Exp(\phi)R^T=\exp(R\phi^{\land}R^T)=Exp(R\phi)\tag{10} \\ &\Leftrightarrow Exp(\phi)R=RExp(R^T\phi)\tag{11}\end{align*}</script><p>b) 特殊欧几里得群：$SE(3)$ 描述了 $3D$ 中刚体运动的群，是 $SO(3)$ 和 $\mathbb{R}^3 $的半直积，定义为 $SE(3) \doteq \{(R, p ) : R \in SO(3), p \in\mathbb{R}^3\}$。给定 $T_1, T_2 ∈ SE(3)$，组运算为$ T_1 \cdot T_2 = (R_1R_2 , p_1 + R_1p_2)$，逆运算为$ T_1^{-1} = (R^T_1 , −R^T_1 p_1)$。 $SE(3)$的指数映射和对数映射在 [44] 中定义。但是，本文不需要这些，原因将在第 III-C 节中明确说明。</p><h2 id="B-SO-3-中的不确定性描述"><a href="#B-SO-3-中的不确定性描述" class="headerlink" title="B. SO(3) 中的不确定性描述"></a>B. SO(3) 中的不确定性描述</h2><p>$SO(3)$中不确定性的自然定义是定义切线空间中的分布，然后通过指数映射$(6)$[44, 46, 47] 将其映射到$ SO(3)$：</p><script type="math/tex; mode=display">\tilde{R}=R\ Exp(\epsilon),\epsilon \sim\mathcal{N}(0,\Sigma),\tag{12}</script><p>其中 $R$是给定的无噪声旋转（平均值）并且$\epsilon$是一个小的正态分布扰动，均值为零，协方差为$\Sigma$。</p><p>为了获得 $R$分布的显式表达式，我们从$\mathbb{R}^3$中高斯分布的积分开始：</p><script type="math/tex; mode=display">\int_{\mathbb{R}^3}p(\epsilon)d\epsilon=\int_{\mathbb{R}^3}\alpha e^{-\frac{1}{2}\parallel\epsilon\parallel^2_{\Sigma} }d\epsilon=1,\tag{13}</script><p>其中$ \alpha= 1/\sqrt{(2\pi)^3 \det(\Sigma)} $， $\parallel\epsilon\parallel^2_{\Sigma}\doteq\epsilon^T\Sigma^{-1}\epsilon$是具有协方差 $\Sigma$ 的平方<strong>马氏距离</strong>。然后，应用坐标的变化$\epsilon = Log(R^{−1}\tilde{R})$ （当$ \parallel\epsilon\parallel&lt;\pi$ 时，这是 $(12)$ 的倒数），积分 $(13)$ 变为：</p><script type="math/tex; mode=display">\int_{SO(3)}\beta(\tilde{R})e^{-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma}}d\tilde{R}=1,\tag{14}</script><p>其中 $\beta(\tilde{R})$是归一化因子。归一化因子的形式为 $\beta(\tilde{R})= α/|\det\left(\mathcal{J} (\tilde{R})\right)|$，其中$ \mathcal{J} (\tilde{R}) \doteq J_r( Log(R^{-1}\tilde{R})) $，并且$ J_r(·)$ 是右雅可比行列式 $(8)$；$\mathcal{J} (\tilde{R})$ 是变量变化的副产品，推导参见 [46]。</p><p>根据$ (14) $的论点，我们可以直接读取 $SO(3)$ 中的“高斯”分布：</p><script type="math/tex; mode=display">p(\tilde{R})=\beta(\tilde{R})e^{-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma} }.\tag{15}</script><p>对于小的协方差，我们可以逼近$ β\simeqα$，因为当接$\tilde{R}$近 $R$ 时，$J_r( Log(R^{-1}\tilde{R}))$ 可以很好地由单位矩阵逼近。请注意，$(14)$ 已经假设协方差 $\Sigma$相对较小，因为它“剪裁”了半径为 $\pi$的开放球之外的概率尾部（这是由于重新参数化$\epsilon = Log(R^{−1}\tilde{R})$，将 $\epsilon $限制为 $\parallel\epsilon\parallel &lt; \pi$）。将$ β$ 近似为一个常数，给定一个如$(15)$中分布的测量值$\tilde{R}$，旋转 $R$ 的负对数似然是：</p><script type="math/tex; mode=display">\mathcal{L}(R)=\frac{1}{2}\parallel Log(R^{−1}\tilde{R}) \parallel^2_{\Sigma}+const=\frac{1}{2}\parallel Log(\tilde{R}^{−1}R) \parallel^2_{\Sigma}+const.\tag{16}</script><p>几何上可以解释为由逆不确定性$Σ^{-1}$加权的$\tilde{R}$和$R$之间的平方角（$SO(3)$中的测地线距离）。</p><h2 id="C-流形上的高斯-牛顿法"><a href="#C-流形上的高斯-牛顿法" class="headerlink" title="C. 流形上的高斯-牛顿法"></a>C. 流形上的高斯-牛顿法</h2><p>欧几里得空间中的标准高斯-牛顿方法通过反复优化（通常为非凸的）目标函数的二次近似来工作。求解二次近似简化为求解一组线性方程（正规方程），并且这个局部近似的解用于更新当前估计。在这里，我们回顾一下如何将这种方法扩展到（无约束的）优化问题，其变量属于某个流形 $\mathcal{M}$。让我们考虑以下优化问题：</p><p>让我们考虑以下优化问题：</p><script type="math/tex; mode=display">\underset{x\in\mathcal{M} }{\min}f(x),\tag{17}</script><p>其中变量 $x$ 属于流形$\mathcal{M}$；为简单起见，我们在 $(17)$ 中考虑单个变量，而描述很容易推广到多个变量。</p><p>与欧几里得情况相反，不能直接将 $(17) $近似为 $x$ 的二次函数。这是由于两个主要原因。首先，直接在 $x$上工作会导致问题的过度参数化（例如，我们对具有 $9$ 个元素的旋转矩阵进行参数化，而 $3D$ 旋转完全由 $\mathbb{R}^3$中的向量定义），这会使正规方程不确定，其次，所得近似的解一般不属于 $\mathcal{M}$。</p><p>流形优化的标准方法 [45, 48] 包括定义<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$，它是切线空间（在$ x$ 处）的元素 $\delta x$ 和 $x \in\mathcal{M} $的邻域之间的<strong>双射映射</strong>。使用回缩（$retraction$），我们可以将我们的问题重新参数化如下：</p><script type="math/tex; mode=display">\underset{x\in\mathcal{M} }{\min}f(x)  \Longrightarrow \underset{\delta x\in\mathbb{R}^n }{\min}f(\mathcal{R}_x(\delta x)).\tag{18}</script><p>重新参数化通常称为<strong>提升</strong>（$lifting$） [45]。粗略地说，我们在当前估计定义的切空间中工作，该空间在局部表现为欧几里得空间。使用<strong>回缩</strong>（$retraction$）允许在合适维度的欧几里德空间上构建优化问题（例如，当我们在 $SO(3) $中工作时，$\delta x ∈ \mathbb{R}^3$）。</p><p>我们现在可以将标准优化技术应用于 $(18) $右侧的问题。在 Gauss-Newton 框架中，我们将当前估计的成本平方。然后我们求解二次逼近得到一个向量$\delta x^{\star}$在切线空间。最后，流形上的当前猜测被更新为:</p><script type="math/tex; mode=display">\hat{x}\leftarrow \mathcal{R}_{\hat{x} }(\delta x^{\star}).\tag{19}</script><p>这种“lift-solve-retract”方案可以推广到任何信任区域方法[45]。此外，它提供了错误状态模型的基础和统一概括，该模型通常用于航空航天文献中的过滤[49]，最近在机器人技术中用于优化[23, 34]。</p><p>我们通过讨论<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$的选择来结束本节。一个可能的<strong>回缩</strong>（$retraction$）是指数映射。众所周知，在计算上，这可能不是最方便的选择，参见 [50]。</p><p>这项工作中，我们对 $SO(3)$ 使用以下<strong>回缩</strong>（$retraction$），</p><script type="math/tex; mode=display">\mathcal{R}_R(\phi)=R\ Exp(\delta\phi),\ \ \delta\phi\in\mathbb{R}^3,\tag{20}</script><p>对于$SE(3)$，我们使用$ T \doteq(R, p) $处的<strong>回缩</strong>（$retraction$）：</p><script type="math/tex; mode=display">\mathcal{R}_T(\delta\phi,\delta p)=(R\ Exp(\delta\phi),p+R\delta p),\ \ [\delta\phi\ \delta p]\in\mathbb{R}^6,\tag{21}</script><p>这就解释了为什么在第 III-A 节中我们只定义了 $SO(3)$ 的指数映射：通过这种<strong>回缩</strong>（$retraction$）选择，我们永远不需要计算 SE(3) 的指数映射。</p><h1 id="四、最大后验视觉惯性状态估计"><a href="#四、最大后验视觉惯性状态估计" class="headerlink" title="四、最大后验视觉惯性状态估计"></a>四、最大后验视觉惯性状态估计</h1><p>我们考虑一个VIO问题，其中我们想跟踪一个<strong>感知系统</strong>（$sensing\ system$）（例如，一个自主机器人，一个UAV，或者一个手持设备）的状态，其装备一个IMU和一个单目相机。我们假设IMU坐标系“B”和我们想要跟踪的身体坐标系重合，相机和IMU之间的变换是固定的，并且通过之前的标定已经知道（见图2）。此外，我们假设一个前端提供在未知位置的3D路标的图片测量。前端还选择一组图片，称为<strong>关键帧</strong>[32]，我们想计算它的位姿估计。第7节-B1讨论了应用，包括我们实验的前端选择。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507153228526.png" alt="image-20220507153228526" style="zoom:50%;" /></p><blockquote><p>图 2：$T_{WB}\doteq  (R_{WB}, _\mathrm{W}\mathbf{p})$ 是Body坐标系相对于世界坐标系 $W$的位姿。我们假设Body坐标与 IMU 坐标系重合。 $T_{BC}$ 是相机在Body坐标中的位姿，由先验标定已知。</p></blockquote><h2 id="A-状态"><a href="#A-状态" class="headerlink" title="A. 状态"></a>A. 状态</h2><p>系统在时间 $i $的状态由 IMU 方向、位置、速度和偏差描述：</p><script type="math/tex; mode=display">\mathrm{x}_i\doteq    [R_i,\mathbf{p}_i,\mathbf{v}_i,\mathbf{b}_i].\tag{22}</script><p>姿态 $(R_i,\mathbf{p}_i)$属于$ SE(3)$，而速度存在于向量空间中，即 $\mathbf{v}_i \in \mathbb{R}^3$。 IMU 偏差可以写为 $\mathbf{b}_i = [\mathbf{b}_i^g\ \ \mathbf{b}_i^a] \in \mathbb{R}^6$，其中 $\mathbf{b}_i^g\ , \mathbf{b}_i^a\in \mathbb{R}^3 $分别是陀螺仪和加速度计偏差。</p><p>令 $\mathcal{K}_k$ 表示直到时间 $k$ 的所有关键帧的集合。在我们的方法中，我们估计所有关键帧的状态：</p><script type="math/tex; mode=display">\mathcal{X}_k\doteq    \{\mathrm{x}_i\}_{i\in\mathcal{K_k} }.\tag{23}</script><p>在我们的实现中，我们采用了<strong>无结构</strong>的方法（参见第 VII 节），因此 3D 地标不是要估计的变量。但是，提出的方法可以推广到一般方法来估计路标和相机内参以及外参。</p><h2 id="B-测量"><a href="#B-测量" class="headerlink" title="B. 测量"></a>B. 测量</h2><p>我们估计问题的<strong>输入是来自相机和 IMU 的测量值</strong>。我们用 $\mathcal{C}_i$表示关键帧$i$处的图像测量值。在时间 $i$，相机可以观察到多个地标 $l$，因此 $\mathcal{C}_i$包含多个图像测量值 $\mathrm{z}_{il}$。我们稍微滥用符号，我们记 $ l \in \mathcal{C}_i$ 为在 $i$ 时刻看到地标 $l$ 。</p><p>我们用 $\mathcal{I}_{ij}$ 表示在两个连续关键帧 $i$ 和 $j$ 之间获得的<strong>一组 IMU 测量值</strong>。根据 IMU 测量速率和所选关键帧的频率，每个集合 $\mathcal{I}_{ij}$ 可以包含从少量到数百个 IMU 测量值。到时间 $k$ 收集的测量值集是:</p><script type="math/tex; mode=display">\mathcal{Z}_k\doteq\{\mathcal{C}_i,\mathcal{I}_{ij}\}_{(i,j)\in\mathcal{K}_k}.\tag{24}</script><h2 id="C-因子图和-MAP-估计"><a href="#C-因子图和-MAP-估计" class="headerlink" title="C. 因子图和 MAP 估计"></a>C. 因子图和 MAP 估计</h2><p>给定可用的视觉和惯性测量 $\mathcal{Z}_k$ 和先验 $p(\mathcal{X}_0)$，变量 $\mathcal{X}_k$ 的后验概率为：</p><script type="math/tex; mode=display">\begin{align*}p(\mathcal{X}_k|\mathcal{Z}_k)&\propto p(\mathcal{X}_0)\ p(\mathcal{X}_k|\mathcal{Z}_k)\overset{(a)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{C}_i,\mathcal{I}_{ij}|\mathcal{X}_k)\\&\overset{(b)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{I}_{ij}|\mathrm{x}_i,\mathrm{x}_j)\prod_{i\in\mathcal{K}_k}\prod_{l\in\mathcal{C}_i}p(\mathrm{z}_{il}|\mathrm{x}_i)\end{align*}\tag{25}</script><p>分解 $(a)$ 和 $(b)$ 遵循测量之间的标准独立假设。此外，马尔可夫属性应用于$(b)$（例如，时间 $i$ 的图像测量仅取决于时间 $i$ 的状态）。</p><p>由于测量值 $\mathcal{Z}_k$ 是已知的，我们可以自由地将它们作为变量消除，并将它们视为<strong>实际未知数的联合概率因子</strong>的参数。这自然会导致众所周知的因子图表示，这是一类可用于表示这种因子密度的<strong>二分图模型</strong> [51, 52]。图 3 给出了 VIO 问题背后的因子图的连通性示意图（无结构视觉因子的连通性将在第 VII 节中阐明）。<strong>因子图</strong>由<strong>未知数节点</strong>和定义在其上的<strong>概率因子节点</strong>组成，<strong>图结构表示每个因子涉及哪些未知数</strong>。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507162306950.png" alt="image-20220507162306950"></p><blockquote><p>图 3：左：VIO 中的视觉和惯性测量。右图：因子图，其中几个 IMU 测量值汇总在单个预积分 IMU 因子中，无结构视觉因子约束关键帧观察相同的地标。</p></blockquote><p>MAP 估计 $\mathcal{X}_k^{\star}$ 对应于 $(25)$ 的最大值，或者等效地，负对数后验的最小值。在零均值高斯噪声的假设下，<strong>负对数后验</strong>可以写为<strong>残差平方和</strong>：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}_k^{\star}&\doteq\arg\underset{\mathcal{X}_k}{\min}-\log_ep(\mathcal{X}_k|\mathcal{Z}_k)\\&=\arg\underset{\mathcal{X}_k}{\min}\parallel r_0 \parallel^2_{\Sigma_0}+\sum_{(i,j)\in\mathcal{K}_k}\parallel r_{\mathcal{I}_{ij} } \parallel^2_{\Sigma_{ij} }+\sum_{i\in\mathcal{K}_k}\sum_{j\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\end{align*}\tag{26}</script><p>其中 $r_0,r_{\mathcal{I}_{ij} },r_{\mathcal{C}_{il} }$ 是与测量相关的<strong>残差</strong>，而 $\Sigma_0,\Sigma_{ij} $和 $\Sigma_{\mathcal{C} }$ 是相应的<strong>协方差矩阵</strong>。粗略地说，残差是 $\mathcal{X}_k$ 的函数，其在给定状态 $\mathcal{X}_k$ 和先验的前提下，量化测量值和预测值的差。以下部分的目标是提供残差和协方差的表达式。</p><h1 id="五、IMU模型与运动积分"><a href="#五、IMU模型与运动积分" class="headerlink" title="五、IMU模型与运动积分"></a>五、IMU模型与运动积分</h1><p>IMU 通常包括一个 3 轴加速度计和一个 3 轴陀螺仪，，并允许我们来测量传感器相对一个惯性坐标系的旋转速度和加速度。测量值，即 $_B\tilde{a}(t)$ 和 $_B\tilde{w}_{WB}(t)$，受加性白噪声 $\eta$ 和缓慢变化的传感器偏差 $\mathbf{b}$ 的影响：</p><script type="math/tex; mode=display">\begin{align*}_\mathrm{B}\tilde{\omega}_{\mathrm{WB} }(t)&= \ _\mathrm{B}\omega_{\mathrm{WB} }(t)+\mathbf{b}^g(t)+\mathbf{\eta}^g(t)\tag{27}\\_\mathrm{B}\tilde{a}(t)&=R^T_{\mathrm{WB} }(t)(\ _\mathrm{W}\mathbf{a}(t)-\ _\mathrm{W}\mathbf{g})+\mathbf{b}^a(t)+\mathbf{\eta}^a(t)\tag{28}\end{align*}</script><p>在我们的符号中，前缀 $\mathrm{B}$ 表示相应的量在坐标系中 $\mathrm{B}$ 表示（参见图 2）。 IMU 的位姿由变换 $\{R_\mathrm{WB},\ _\mathrm{W}p\}$ 描述，该变换将传感器坐标系 $\mathrm{B}$ 中的一个点映射到 $\mathrm{W}$ 。向量 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)\in \mathbb{R}^3$ 是坐标系 $\mathrm{B}$ 中表示的 $\mathrm{B}$ 相对于 $\mathrm{W}$ 的<strong>瞬时角速度</strong>，而$\ _\mathrm{W}\mathbf{a}(t)\in \mathbb{R}^3$是传感器的<strong>加速度</strong>； $\ _\mathrm{W}\mathbf{g}$ 是世界坐标中的<strong>重力加速度</strong>。我们忽略了地球自转的影响，这相当于假设 $\mathrm{W}$ 是一个惯性系。</p><p>现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型 [49, 53]：</p><script type="math/tex; mode=display">\begin{align*}\dot{R}_\mathrm{WB}&={R}_\mathrm{WB}\ _B{\omega}^{\land}_\mathrm{WB}\\_\mathrm{W}\dot{\mathbf{v} }&=\ _\mathrm{W}\mathbf{a}\\_\mathrm{W}\dot{\mathbf{p} }&=\ _\mathrm{W}\mathbf{v}\end{align*}\tag{29}</script><p>它描述了 $\mathrm{B}$ 的姿势和速度的演变。</p><p> $t + \Delta t $时刻的状态是通过积分方程$(29)$获得的：</p><script type="math/tex; mode=display">\begin{align*}{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\int^{t + \Delta t }_t\ _B{\omega}_\mathrm{WB}(\tau)d\tau\right) \\_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+ \int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau\\_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{v}(\tau)d\tau+\iint^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau^2\end{align*}</script><p>假设 $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p><script type="math/tex; mode=display">\begin{align*}{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\ _B{\omega}_\mathrm{WB}(t)\Delta t\right) \\_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+\ _\mathrm{W}\mathbf{a}(t)\Delta t\\_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\  _\mathrm{W}\mathbf{v}(t)\Delta t+\frac{1}{2}\  _\mathrm{W}\mathbf{a}(t)\Delta t^2\end{align*}\tag{30}</script><p>使用方程式。 (27)–(28)，我们可以将  $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$  写为 IMU 测量的函数，因此 (30) 变为:</p><script type="math/tex; mode=display">\begin{align*}{R}(t + \Delta t )&={R}(t)Exp\left(\ (\tilde{\omega}(t)-\mathbf{b}^g(t)-\mathbf{\eta}^{gd}(t))\Delta t\right) \\\mathbf{v}(t + \Delta t)&=\ \mathbf{v}(t)+\mathbf{g}\Delta t+\ R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t\\\mathbf{p}(t + \Delta t)&=\ \mathbf{p}(t)+\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t^2\end{align*}\tag{31}</script><p>为了便于阅读，我们删除了坐标系下标（从现在开始，符号应该是明确的）。速度和位置的这种数值积分假定两个测量之间 $R(t)$是常数，对于具有非零旋转速率的测量，这不是微分方程 $(29)$ 的精确解。在实践中，使用高速IMU 可以减轻这种近似的影响。我们采用 $(31)$ 的积分方案，<strong>因为它简单，且对于建模和不确定性传播是经得起检验的。</strong>虽然我们表明这种积分方案在实践中表现非常好，但我们注意到对于较慢的 IMU 测量速率，可以考虑使用高阶数值积分方法 [54-57]。</p><p>离散时间噪声 $\eta^{gd}$ 的协方差是采样率的函数，并且通过 $Cov(\eta^{gd}(t)) = \frac{1}{\Delta t}Cov(\eta^{g}(t))$ 与连续时间频谱噪声 $\eta^{g}$ 相关。同样的关系也适用于 $\eta^{ad}$（参见 [58, 附录]）。</p><h1 id="六、-流形上的IMU预积分"><a href="#六、-流形上的IMU预积分" class="headerlink" title="六、 流形上的IMU预积分"></a>六、 流形上的IMU预积分</h1><p>虽然等式 $(31)$  可以很容易地被视为因子图中的概率约束，它需要在因子图中以高速率包含状态。直观地说，方程。 $(31)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。因此，我们必须在每次新的 IMU 测量时在估计中添加新状态 [37]。</p><p>在这里，我们展示了在时间 $k = i$ 和 $k = j$（见图 4）的两个关键帧之间的所有测量值可以总结为单个复合测量值，称为预积分 IMU 测量值，它限制了连续关键帧之间的运动。这个概念最初是在 [2] 中使用欧拉角提出的，我们通过开发一种适用于流形 $SO(3)$ 上的预积分的理论来扩展它。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507202527649.png" alt="image-20220507202527649"></p><blockquote><p>图 4：IMU 和相机的不同速率。</p></blockquote><p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 (31)，我们发现：</p><script type="math/tex; mode=display">\begin{align*}{R}_j&={R}_i\prod^{j-1}_{k=i} Exp\left( (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)\Delta t\right) \\\mathbf{v}_j&=\ \mathbf{v}_i+\mathbf{g}\Delta t_{ij}+\ \prod^{j-1}_{k=i}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\\mathbf{p}_j&=\mathbf{p}_i+\sum^{j-1}_{k=i}\left[\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] \end{align*}\tag{32}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。虽然等式。 $(32)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(32)$ 中的积分 [24]（直观地说，旋转 $R_i$ 的变化，意味着所有未来旋转 $R_k、k = i,…,j-1$ 的变化，因此有必要重新评估 $(32)$ 中的求和和乘积。</p><p>我们希望避免在时间 $t_i$ 的线性化点发生变化时重新计算上述积分。因此，我们遵循 [2] 并定义以下相对运动增量，这些增量与 $t_i$ 处的位姿和速度无关:</p><script type="math/tex; mode=display">\begin{align*}\Delta{R}_{ij}&\doteq{R}^T_iR_j\prod^{j-1}_{k=i} Exp\left( (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)\Delta t\right) \\\Delta\mathbf{v}_{ij}&\doteq{R}^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})\ = \sum^{j-1}_{k=i}\Delta R_{ij}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\\Delta\mathbf{p}_{ij}&\doteq{R}^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\sum^{j-1}_{k=i}\mathbf{g}\Delta t^2)\\&=\sum^{j-1}_{k=i}\left[\  \mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta R_{ik}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] \end{align*}\tag{33}</script><p>其中 $\Delta{R}_{ik}\doteq R^T_i R_k $ 和 $\Delta\mathbf{v}_{ik} \doteq R^T_i (\mathbf{v}_{k}−\mathbf{v}_{i}−\mathbf{g}\Delta t_{ik})$。我们强调，与“delta”旋转 $\Delta{R}_{ij}$ 相比， $\Delta\mathbf{v}_{ij}$  和 $\Delta\mathbf{p}_{ij}$都不对应于速度和位置的真实物理变化，而是以一种方式定义的，使得 $(33)$ 的右侧独立于时间 $i$ 的状态以及引力效应。事实上，我们将能够直接从两个关键帧之间的惯性测量中计算 $(33)$ 的右侧。</p><p>不幸的是，$(33)$ 中的求和和乘积仍然是偏差估计的函数。我们分两步解决这个问题。在第 VI-A 节中，我们假设$\mathbf{b}_{i}$ 是已知的；然后，在第 VI-C 节中，我们展示了如何在偏差估计发生变化时避免重复积分。</p><p>在本文的其余部分，我们假设两个关键帧之间的偏差保持不变：</p><script type="math/tex; mode=display">\mathbf{b}^g_{i}=\mathbf{b}^g_{i+1}=···=\mathbf{b}^g_{j-1},\ \ \ \ \mathbf{b}^a_{i}=\mathbf{b}^a_{i+1}=···=\mathbf{b}^a_{j-1}.\tag{34}</script><h2 id="A-预积分-IMU-测量"><a href="#A-预积分-IMU-测量" class="headerlink" title="A. 预积分 IMU 测量"></a>A. 预积分 IMU 测量</h2><p>等式 $(33)$ 将关键帧 $i$ 和 $j$ 的状态（左侧）与测量值（右侧）相关联。从这个意义上说，它已经可以理解为一种测量模型。不幸的是，它对测量噪声有相当复杂的依赖性，这使得 MAP 估计的直接应用变得复杂。直观地说，MAP 估计器需要清楚地定义测量的密度（及其对数似然）。在本节中，我们修改 $(33)$  以便更容易推导测量对数似然。在实践中，我们在 $(33)$ 中隔离了单个惯性测量的噪声项。如上所述，在本节中，假设时间 $t_i$ 的偏差是已知的。</p><p>让我们从 $(33)$ 中的旋转增量 $\Delta{R}_{ij}$ 开始。我们使用一阶近似 $(7)$（旋转噪声“小”）并重新排列术语，通过使用关系$(11)$将噪声“移动”到末尾：</p><script type="math/tex; mode=display">\begin{align*}\Delta{R}_{ij} &\overset{eq.(7)}{\simeq}\prod^{j-1}_{k=i}\left[Exp((\tilde{\omega}_k-\mathbf{b}^g_i)\Delta t)Exp(-J^k_r\eta^{gd}_k\Delta t)\right]\\&\overset{eq.(11)}{\simeq}\Delta{\tilde R}_{ij}\prod^{j-1}_{k=i}Exp(-\Delta \tilde R^T_{k+1 j} J^k_r \eta^{gd}_k \Delta t)\\&\doteq    \Delta{\tilde R}_{ij}Exp(-\delta \phi_{ij})    \end{align*}\tag{35}</script><p>其中，$J^k_r \doteq J^k_r(( \tilde\omega_k − b^g_i )Δt)$。在 $(35)$ 的最后一行，我们定义了预积分旋转测量 $\Delta{\tilde R}_{ij} \doteq \prod^{j−1}_{k=i} Exp (( \tilde\omega_k − b^g_i) Δt)$，及其噪声 $\delta\phi_{ij}$，将在下一节中分析。</p><p>将 $(35)$ 代回 $(33)$ 中 $\Delta\mathbf{v}_{ij}$ 的表达式，使用 $Exp(-\delta \phi_{ij})    $ 的一阶近似 $(4)$，并去掉高阶噪声项，我们得到：</p><script type="math/tex; mode=display">\begin{align*}\Delta\mathbf{v}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t -\Delta{\tilde R}_{ik}\eta^{gd}_k\Delta t\\&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{v} }_{ij}+\sum^{j-1}_{k=i}\left[\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t - \Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t\right]\\&\doteq    \Delta\tilde{\mathbf{v} }_{ij}-\delta\mathbf{v}_{ij}\end{align*}\tag{36}</script><p>其中，我们定义了预积分速度测量 $\Delta\tilde{\mathbf{v} }_{ij}\doteq\sum^{j-1}_{k=i}<br>\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\Delta t $及其噪声 $\delta\mathbf{v}_{ij}$。</p><p>类似地，将$(35)$ 和$(36)$ 代入$(33)$ 中的 $\Delta\mathbf{p}_{ij}$ 表达式，并使用一阶近似 $(4)$，我们得到：</p><script type="math/tex; mode=display">\begin{align*}\Delta\mathbf{p}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\left[(\Delta\tilde{\mathbf{v} }_{ik}-\delta\mathbf{v}_{ik})\Delta t+\frac{1}{2}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t^2 -\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\\&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{p} }_{ij}+\sum^{j-1}_{k=i}\left[-\delta\mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t^2 - \frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2\right]\\&\doteq    \Delta\tilde{\mathbf{p} }_{ij}-\delta\mathbf{p}_{ij}\end{align*}\tag{37}</script><p>其中我们定义了预集成的位置测量 $\Delta\tilde{\mathbf{p} }_{ij}$ 及其噪声 $\delta\mathbf{p}_{ij}$。</p><p>将表达式 $(35), (36), (37)$ 代入$ (33)$ 中 $\Delta{R}_{ij}, \Delta\mathbf{v}_{ij}, \Delta\mathbf{p}_{ij}$ 的原始定义，我们最终得到了我们的<strong>预积分测量模型</strong>（记住 $Exp(-\delta\phi_{ij})^T = Exp(\delta\phi_{ij})$):</p><script type="math/tex; mode=display">\begin{align*}\Delta{\tilde R}_{ij}&=R^T_iR_j\mathrm{Exp}(\delta\phi_{ij})\\R^T_i\Delta\tilde{\mathbf{v} }_{ij}&=R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})+\delta\mathbf{v}_{ij}\\\Delta\tilde{\mathbf{p} }_{ij}&=R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)+\delta\mathbf{p}_{ij}\end{align*}\tag{38}</script><p>其中我们的复合测量被写为（待估计）状态“加上”随机噪声的函数，由随机向量 $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 描述。</p><p>为了总结本节的内容，我们将 $(33)$ 的测量模型重新写为 $(38)$。$(38)$ 的优势在于，对于一个合适的噪声分布，它直接定义了对数似然。例如，具有零均值加性高斯噪声（ $(38)$的最后两行）测量的（负）对数是一个二次函数。类似地，如果 $\delta\phi_{ij}$  是零均值高斯噪声，我们计算与 $\Delta\tilde R_{ij}$ 相关的（负）对数似然。噪声项的性质将在下一节中讨论。</p><h2 id="B-噪声传播"><a href="#B-噪声传播" class="headerlink" title="B. 噪声传播"></a>B. 噪声传播</h2><p>在本节中，我们推导出噪声向量  $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 的统计量。虽然我们已经观察到将噪声向量近似为零均值正态分布是很方便的，但准确地建模噪声协方差是至关重要的。实际上，噪声协方差对 MAP 估计器有很大的影响（逆噪声协方差用于对优化中的项进行加权 $(26)$）。因此，在本节中，我们提供了预积分测量的协方差 $\Sigma_{ij}$ 的推导：</p><script type="math/tex; mode=display">\eta^{\Delta}_{ij}\doteq[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T\sim\mathcal{N}(0_{9\times1},\Sigma_{ij})\tag{39}</script><p>我们首先考虑预积分的旋转噪声 $\delta\phi_{ij}$。回想一下 $(35)$</p><script type="math/tex; mode=display">\mathrm{Exp}(-\delta\phi_{ij})\doteq\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\tag{40}</script><p>取两边的对数并改变符号，我们得到：</p><script type="math/tex; mode=display">\delta\phi_{ij}=-\mathrm{Log}\left(\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\right)\tag{41}</script><p>一阶近似 $(9)$ 的重复应用（回想一下，$\eta^{gd}_k$ 和 $\delta\phi_{ij}$ 都是小的旋转噪声，因此右雅可比矩阵接近恒等式）产生：</p><script type="math/tex; mode=display">\delta\phi_{ij}\simeq\sum^{j-1}_{k=1}\Delta\tilde R^T_{K+1j}J^k_r\eta^{gd}_k\Delta t\tag{42}</script><p>保留到一阶，噪声  $\delta\phi_{ij}$ 是零均值和高斯的，因为它是零均值噪声项 $\eta^{gd}_k$ 的线性组合。这是可取的，因为它使旋转测量模型 $(38)$ 完全符合形式 $(12)$。</p><script type="math/tex; mode=display">\begin{align*}\delta \mathbf{v}_{ij}&\simeq \sum^{j-1}_{k=i}\left[-\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t +\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t\right]\\\delta\mathbf{p}_{ij} &\simeq\sum^{j-1}_{k=i}\left[\delta\mathbf{v}_{ik}\Delta t-\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t ^2 +\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\end{align*}\tag{43}</script><p>其中关系到一阶都是正确的。</p><p>方程。 $(42)-(43)$ 将预积分噪声 $\eta^{\Delta}_{ij}$ 表示为 IMU 测量噪声 $\eta^d_k \doteq [\eta^{gd}_k , \eta^{ad}_k ], k = 1, . . .,j − 1$, 的线性函数。因此，根据 $\eta^{d}_{k}$  的协方差知识（在 IMU 规范中给出），我们可以通过简单的线性传播计算 $\eta^{\Delta}_{ij}$ 的协方差，即 $\Sigma_{ij}$。</p><p>在附录 IX-A 中，我们提供了一种更巧妙的方法来计算$\Sigma_{ij}$。特别是，我们展示了 $\Sigma_{ij}$ 可以方便地以迭代形式计算：当一个新的 IMU 测量到达时，我们只更新 $\Sigma_{ij}$，而不是从头开始重新计算。迭代计算导致更简单的表达式并且更适合在线推理。</p><h2 id="C-组合偏差更新"><a href="#C-组合偏差更新" class="headerlink" title="C. 组合偏差更新"></a>C. 组合偏差更新</h2><p>在上一节中，我们假设在 $k = i$ 和 $k = j$ 之间的预积分期间使用的偏差 $\{\overline{b}^a_i , \overline{b}^g_i\}$ 是正确的并且不会改变。然而，更有可能的是，偏差估计在优化过程中会发生少量 $\delta\mathbf{b}$ 的变化。一种解决方案是在偏差发生变化时重新计算 delta 测量值；但是，这在计算上是昂贵的。相反，给定偏差更新 $\mathbf{b}\gets \mathbf{b} + \delta\mathbf{b}$，我们可以使用一阶展开更新 delta 测量：</p><script type="math/tex; mode=display">\begin{align*}\Delta\tilde{R}_{ij}(\mathbf{b}^g_i)&\simeq\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)\\\Delta\tilde{\mathbf{v} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\\\Delta\tilde{\mathbf{p} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\end{align*}\tag{44}</script><p>这类似于 [2] 中的偏差校正，但直接在 $SO(3)$ 上运行。雅可比矩阵 $\{ \frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g} , \frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g} , . . .\}$（在  $\overline{\mathbf{b} }_i$ 计算，积分时的偏差估计）描述了测量值如何由于偏差估计的变化而变化。雅可比矩阵保持不变，并且可以在预积分期间预先计算。雅可比矩阵的推导与我们在第 VI-A 节中用于将测量值表示为大值加上小扰动的推导非常相似，并在附录 IX-B 中给出。</p><h2 id="D-预积分IMU因子"><a href="#D-预积分IMU因子" class="headerlink" title="D. 预积分IMU因子"></a>D. 预积分IMU因子</h2><p>给定 $(38)$ 中的预积分测量模型，并且由于测量噪声是零均值和高斯（协方差 $\Sigma_{ij}$）直到一阶 $(39)$，现在很容易写出残差 $r_{\mathcal{I}_{ij} }\doteq [r^T_{\Delta R_{ij} }, r^T_{\Delta \mathbf{v}_{ij} },r^T_{\Delta \mathbf{p}_{ij} }]^T \in \mathbb{R}^9$, 其中:</p><script type="math/tex; mode=display">\begin{align*}r_{\Delta R_{ij} }&\doteq \mathrm{Log}\left(\left(\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)\right)^TR^T_iR_j\right)\\r_{\Delta \mathbf{v}_{ij} }&\doteq R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})-\left[\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a\right]\\r_{\Delta \mathbf{p}_{ij} }&\doteq R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)-\left[\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a\right]\\\end{align*}\tag{45}</script><p>其中我们还包括了方程的偏差更新 $(44)$。</p><p>根据“lift-solve-retract”方法（第 III-C 节），在每次 Gauss-Newton 迭代中，我们需要使用<strong>回缩($retraction$)</strong> $(21)$重新参数化 $(45)$。然后，“解决”步骤需要围绕当前估计线性化结果成本。出于线性化的目的，计算残差的雅可比行列式分析表达式很方便，我们在附录 IX-C 中推导出了该表达式。</p><h2 id="E-偏置模型"><a href="#E-偏置模型" class="headerlink" title="E. 偏置模型"></a>E. 偏置模型</h2><p>在介绍 IMU 模型 $(27)$ 时，我们说偏差是缓慢随时间变化的量。因此，我们用“布朗运动”对它们进行建模，即综合白噪声：</p><script type="math/tex; mode=display">\dot{b}^g(t)=\eta^{bg}, \ \ \ \ \dot{b}^a(t)=\eta^{ba}\tag{46}</script><p>在两个连续关键帧 $i$ 和 $j$ 之间的时间间隔 $[t_i, t_j]$ 上对 $(46)$ 进行积分，我们得到：</p><script type="math/tex; mode=display">\mathbf{b}^g_j(t)=\mathbf{b}^g_i+\eta^{bgd}, \ \ \ \ \ \mathbf{b}^a_j(t)=\mathbf{b}^a_i+\eta^{bad}\tag{47}</script><p>其中，如前所述，我们使用简写 $\mathbf{b}^g_j\doteq \mathbf{b}^g(t_i)$，我们定义离散噪声 $\eta^{bgd}$ 和 $\eta^{bad}$，它们的均值和协方差为零 $\Sigma^{bgd}\doteq \Delta t_{ij} Cov(\eta^{bg})$ 和 $\Sigma^{bad}\doteq \Delta t_{ij} Cov(\eta^{ba})$，分别（参见[58，附录]）。</p><p>模型 $(47)$ 可以很容易地包含在我们的因子图中，作为 $(26)$ 中所有连续关键帧的进一步附加项：</p><script type="math/tex; mode=display">\parallel r_{b_{ij} } \parallel^2 \doteq\parallel \mathbf{b}^g_j- \mathbf{b}^g_i \parallel^2_{\Sigma_{bgd} }+\parallel \mathbf{b}^a_j- \mathbf{b}^a_i \parallel^2_{\Sigma_{bad} }\tag{48}</script><h1 id="七、无结构视觉因子"><a href="#七、无结构视觉因子" class="headerlink" title="七、无结构视觉因子"></a>七、无结构视觉因子</h1><p>在本节中，我们将介绍我们用于视觉测量的无结构模型。我们方法的关键特征是地标的线性消除。请注意，在每次 Gauss-Newton 迭代中都会重复消除，因此我们仍然可以保证获得最佳 MAP 估计。</p><p>视觉测量通过如下求和贡献到代价函数 $(26)$ 中:</p><script type="math/tex; mode=display">\sum_{i\in\mathcal{K}_k}\sum_{l\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2=\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\tag{49}</script><p>其中，在右侧，我们将其重写为每个地标 $l = 1 ,. . , L$, 的贡献的总和。在 (49) 中，$\mathcal{X}(l)$ 表示看到 $l$ 的关键帧的子集。</p><p>单个图像测量 $\mathbf{z}_{il}$ 的残差的一个相当标准的模型是重投影误差：</p><script type="math/tex; mode=display">r_{\mathcal{c}_{il} }=\mathbf{z}_{il}-\pi(R_i,\mathbf{p}_{i},ρ_l)\tag{50}</script><p>其中 $ρ_l \in \mathbb{R}^3$ 表示第 $l$ 个地标的位置，$π(·)$ 是标准透视投影，它也编码了（已知的）IMU 相机变换 $T_{BC}$。</p><p>直接使用 $(50)$ 将需要包括地标位置 $ρ_l, l = 1, 。 . . , L$ 在优化中，这对计算产生负面影响。因此，在下文中，我们采用了一种无结构的方法，避免对地标进行优化，从而确保检索 MAP 估计</p><p>正如在第 III-C 节中回顾的那样，在每次 GN 迭代中，我们使用<strong>回缩($retraction$)</strong> $(21)$来提升成本函数。对于视觉因素，这意味着原始残差 $(49)$ 变为：</p><script type="math/tex; mode=display">\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel \mathbf{z}_{il}-\check{\pi}(\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l)\parallel^2_{\Sigma_{\mathcal{C} } }\tag{51}</script><p>其中 $\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l$ 是欧几里得修正，$\check{\pi}(·)$ 是提升的成本函数。 GN 方法中的“求解”步骤基于残差的线性化：</p><script type="math/tex; mode=display">\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel \mathbf{F}_{il}\delta\mathbf{T}_{i}+\mathbf{E}_{il}\delta ρ_l-\mathbf{b}_{il}\parallel^2\tag{52}</script><p>其中 $\delta \mathbf{T}_i \doteq [\delta\phi_i,\delta\mathbf{p}_i]^T$; 雅可比矩阵 $\mathbf{F}_{il},\mathbf{E}_{il}$ 和向量 $\mathbf{b}_{il}$（均由 $\Sigma^{1/2}_{\mathcal{C}}$ 归一化）来自线性化。向量$\mathbf{b}_{il}$是线性化点处的残差。将 $(52)$ 中的第二个和写成矩阵形式，我们得到：</p><script type="math/tex; mode=display">\sum^L_{l=1}\parallel \mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}\parallel^2\tag{53}</script><p>其中，对于所有 $i \in \mathcal{X}(l)，\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 分别通过堆叠 $\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 获得。</p><p>由于地标 $l$ 出现在总和 $(53)$ 的单个项中，因此对于任何给定的姿态扰动 $\delta\mathbf{T}_{\mathcal{X}(l)}$ 选择，最小化代价函数 $\parallel<br>\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}<br>\parallel^2$ 的地标扰动 $\deltaρ_l$ 是：</p><script type="math/tex; mode=display">\deltaρ_l=-(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\tag{54}</script><p>将 $(54)$ 代回 $(53)$ 我们可以从优化问题中消除变量 $\deltaρ_l$ ：</p><script type="math/tex; mode=display">\sum^L_{l=1}\parallel (\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T)(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\parallel^2\tag{55}</script><p>其中 $\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T$ 是 $\mathbf{E}_{l}$的正交投影。在附录 IX-D 中，我们展示了可以进一步操纵成本 $(55)$，从而实现更有效的实施。</p><p>这种方法在BA文献中被称为 Schur 补码技巧($Schur\ complement\ trick$)，其中一种标准做法是通过反向替换来更新 $ρ_l$ 的线性化点 [61]。相反，我们使用快速线性三角测量从姿势的线性化点获得更新的地标位置。使用这种方法，我们将涉及姿势和地标的大量因子 $(51)$ 减少为仅涉及姿势的较小 $L$ 因子集 $(55)$。特别是，与界标 $l$ 对应的因子仅涉及观察 $l$ 的状态 $\mathcal{X}(l)$，创建图 3 的连接模式。MSCKF [5] 中也使用相同的方法来避免在状态向量中包含界标.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>外积、内积、张量积、Kronecker积</title>
    <link href="https://lukeyalvin.top/posts/bdcf3114.html"/>
    <id>https://lukeyalvin.top/posts/bdcf3114.html</id>
    <published>2022-05-08T13:08:37.000Z</published>
    <updated>2022-05-08T13:26:11.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h1><p>内积又称为点积，有两种定义方式，一种是代数方式，一种是集合方式。</p><ul><li><strong>代数定义</strong></li></ul><p>两个向量$\vec{a}=[a_1,a_2,···,a_n]$和$\vec{b}=[b_1,b_2,···,b_n]$的点积定义为：</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b}=\sum^{n}_{i=1}a_ib_i=a_1b_1+a_2b_2+···+a_nb_n\tag{1}</script><p>点积也可以写成$\vec{a}\vec{b}^T$</p><ul><li><strong>几何定义</strong></li></ul><p>在欧几里得空间中，点积可以直观地定义为:</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\cos\theta\tag{2}</script><p>其中，$|\vec{x}|$表示$\vec{x}$的模长，$\theta$表示两个向量之间的夹角。</p><h1 id="叉积（Cross-product）"><a href="#叉积（Cross-product）" class="headerlink" title="叉积（Cross product）"></a>叉积（Cross product）</h1><ul><li><strong>定义</strong></li></ul><p>叉积又称为向量积（有时候也说是外积，这里为了区分，就不这么说，因为你会发现好多外积），是对三维空间中的两个向量的二元运算，使用符号$\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量$a$和$b$，它们的外积写作 $a\times b$，是 $ a $和$b$所在平面的法线向量，与$ a $和$b$都垂直。</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506153837169.png" alt="image-20220506153837169" style="zoom: 25%;" /></p><p>两个向量$a$和$b$的叉积仅在三维空间有定义，写作 $a\times b$，叉积也可以定义为：</p><script type="math/tex; mode=display">a\times b=\parallel a \parallel \parallel b\parallel \sin(\theta)n\tag{3}</script><p>其中$\theta$表示$a$和$b$在它们所定义的平面上的夹角，$\parallel a \parallel$和$\parallel b \parallel$表示向量$a$和$b$的模长，而$n$则是一个与$a$和$b$所构成的平面的垂直的单位向量，方向由右手定则决定。</p><ul><li><strong>矩阵表示</strong></li></ul><p>叉积也可以定义为：</p><script type="math/tex; mode=display">a\times b=\left|\begin{matrix}i&j&k\\a_1&a_2&a_3\\b_1&b_2&b_3\end{matrix}\right|=\begin{bmatrix}a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1\end{bmatrix}=\begin{bmatrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\end{bmatrix}b\triangleq a^{\land}b\tag{4}</script><p>这里引入符号$^{\land}$，成为反对称符号，这样就可以把外积$a\times b$写成了矩阵与向量的乘法$a^{\land}b$，把它变成可线性运算。在《视觉SLAM十四讲》中也有提及。</p><h1 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h1><p>在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的:最一般的双线性运算。在某些上下文中也叫做外积。</p><script type="math/tex; mode=display">b\otimes a \rightarrow \begin{bmatrix}b_1\\b_2\\b_3\\b_4\end{bmatrix}_{4\times 1}\begin{bmatrix}a_1&a_2&a_3\end{bmatrix}_{1\times 3}=\begin{bmatrix}a_1b_1&a_2b_1&a_3b_1\\a_1b_2&a_2b_2&a_3b_2\\a_1b_3&a_2b_3&a_3b_3\\a_1b_4&a_2b_4&a_3b_4\\\end{bmatrix}_{4\times 3}\tag{5}</script><p>对于张量积之后的秩：</p><script type="math/tex; mode=display">rank(V\otimes U)=rank(V)+rank(U)\tag{6}</script><h1 id="Kronecker积"><a href="#Kronecker积" class="headerlink" title="Kronecker积"></a>Kronecker积</h1><p>数学上，克罗内克积（英语：Kronecker product）是两个任意大小的矩阵间的运算，表示为⊗。克罗内克积是外积从向量到矩阵的推广，也是张量积在标准基下的矩阵表示。</p><p>如果$A$是一个$m\times n$的矩阵，$B$是一个$p\times q$的矩阵，克罗内克积为$A\otimes B$则是一个$mp\times nq$的矩阵：</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162341626.png" alt="image-20220506162341626" style="zoom: 20%;" /></p><p>更具体的表示为：</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162438902.png" alt="image-20220506162438902" style="zoom:40%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学基础" scheme="https://lukeyalvin.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="内积与外积" scheme="https://lukeyalvin.top/tags/%E5%86%85%E7%A7%AF%E4%B8%8E%E5%A4%96%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>相机模型简要分析</title>
    <link href="https://lukeyalvin.top/posts/ddbf64.html"/>
    <id>https://lukeyalvin.top/posts/ddbf64.html</id>
    <published>2022-05-08T13:06:11.000Z</published>
    <updated>2022-05-08T13:08:07.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="相机成像模型"><a href="#相机成像模型" class="headerlink" title="相机成像模型"></a>相机成像模型</h1><p>相机模型基于小孔成像：</p><p><img src="/images/相机模型简要分析/image-20220505170737171.png" alt="image-20220505170737171" style="zoom: 67%;" /></p><p>这里出现了几个坐标系：</p><ul><li>世界坐标系$\{W\}$，在世界坐标系下，特征点$P$在世界坐标系下的坐标为$P_w=(X_w,Y_w,Z_w)$</li><li><p>相机坐标系$\{C\}$，对相机来说，也有一个相机坐标系，也可以称之为机器人本体坐标系，因为相机属于机器人，特征点$P$在相机坐标系下的坐标为$P_c=(X_c,Y_c,Z_c)$</p></li><li><p>像素平面坐标系$\{P^{\prime}\}$，这个是通过相机内部得到的投影平面坐标系，它是一个二维的平面，特征点$P$在像素平面坐标系下的坐标为$P^{\prime}=(X^{\prime},Y^{\prime})$，</p></li><li><p>像素坐标系$\{P_{uv}\}$，像素坐标系是素平面坐标系$\{P^{\prime}\}$经过缩放和平移得到的，后面介绍。</p></li></ul><p>那么我们需要明白这几个坐标系之间的关系：</p><p><img src="/images/相机模型简要分析/image-20220505171918452.png" alt="image-20220505171918452"></p><h2 id="世界坐标系——相机坐标系"><a href="#世界坐标系——相机坐标系" class="headerlink" title="世界坐标系——相机坐标系"></a>世界坐标系——相机坐标系</h2><p>这个很简单，两者就相差一个刚体变换，这变换矩阵为$T_{cw}$，则对于特征点$P$来说，就有：</p><script type="math/tex; mode=display">P_{c}=(T_{cw}P_{w})_{(1:3)}=(T_{cw}\begin{bmatrix}X_{w}\\Y_{w}\\Z_{w}\end{bmatrix})_{(1:3)}\tag{1}</script><p>这里$(T_{cw})_{(1:3)}$指的是纯旋转的情况下，考虑他的前三项。</p><h2 id="相机坐标系——像平面坐标系"><a href="#相机坐标系——像平面坐标系" class="headerlink" title="相机坐标系——像平面坐标系"></a>相机坐标系——像平面坐标系</h2><p><img src="/images/相机模型简要分析/image-20220505172602891.png" alt="image-20220505172602891"></p><p>如图所示，展示相机内部投影的过程，</p><script type="math/tex; mode=display">\begin{align*}X^{\prime}=f\frac{X_c}{Z_c}\\Y^{\prime}=f\frac{Y_c}{Z_c}\end{align*}\tag{2}</script><h2 id="像平面坐标系——像素坐标系"><a href="#像平面坐标系——像素坐标系" class="headerlink" title="像平面坐标系——像素坐标系"></a>像平面坐标系——像素坐标系</h2><p>像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。我们设像素坐标在$u$ 轴上缩放了 $\alpha$倍，在 $v$上缩放了 $\beta$ 倍。同时，原点平移了$ [c_x,c_y]^T$。那么， $P^′$ 的坐标与像素坐标 $[u,v]^T $的关系为：  </p><script type="math/tex; mode=display">\left\{\begin{array}{L}u=\alpha X^{\prime}+c_x\\v=\alpha Y^{\prime}+c_y\end{array}\right.\\tag{3}</script><p>将$(2)$带入$(3)$:</p><script type="math/tex; mode=display">\left\{\begin{array}{L}u=f_x \frac{X_c}{Z_c}+c_x\\v=f_y \frac{Y_c}{Z_c}+c_y\end{array}\right.\\tag{3}</script><p>其中$f_x= \alpha f$，$f_y= \beta f$，$f$ 的单位为米， $\alpha,\beta$ 的单位为像素每米，所以 $f_x,f_y $的单位为像素 。</p><h2 id="相机坐标系——像素坐标系"><a href="#相机坐标系——像素坐标系" class="headerlink" title="相机坐标系——像素坐标系"></a>相机坐标系——像素坐标系</h2><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}\triangleq \lambda KP_c\tag{4}</script><p>其中，$\lambda$称为逆深度，$K$表示相机的内参。</p><ul><li>采用逆深度的方式，表达一个点的坐标$(x,y,z)$变成成了$1/λ * [u,v,1]^T$，将$3$个优化变量，变成了一个优化变量（$u,v$为归一化相机坐标系下的三维点的坐标，通过观测数据是可知的），所以优化变量少。</li><li>同时，对于深度很大的点，在数值上很大，采用逆深度的方式，倒一下，数值上变小了，有利于优化过程中数值的稳定性，不会因为很远的点（深度值很大）导致一次优化过程中出现较大的误差函数的变换，因此再远的点（如天空中的点）也能表达了，所以能表达非常远的点。</li><li>将深度值倒数一下，变成小数，跟接近高斯分布的函数表达形式，方便优化。</li></ul><p><strong>归一化坐标</strong></p><p>另外我们引入归一化坐标的概念，它位于相机前方 $z = 1$ 处的平面上。该平面称为<strong>归一化平面</strong>。  比如对$P_c$进行归一化处理得到$\overline{P}$</p><script type="math/tex; mode=display">\overline{P}=\frac{1}{Z_c}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\tag{5}</script><p>因此，可以得到像素坐标与归一化坐标之间的关系为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}\triangleq  K\overline{P}\tag{6}</script><p>可以发现相机归一化坐标$\overline{P}$经过相机内参就可以得到像素坐标，所以我们可以把像素坐标$[u,v]^T$ ，看成对归一化平面上的点进行量化测量的结果。  </p><h2 id="相机坐标系——世界坐标系"><a href="#相机坐标系——世界坐标系" class="headerlink" title="相机坐标系——世界坐标系"></a>相机坐标系——世界坐标系</h2><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}(R_{cw}P_w+t)\triangleq \lambda KT_{cw}P_w\tag{7}</script><h1 id="VO重投影误差"><a href="#VO重投影误差" class="headerlink" title="VO重投影误差"></a>VO重投影误差</h1><p>重投影误差如图示，我们通过特征匹配可知，观测值$p_1$和$p_2$是同一个空间点$P$的投影，而实际上我们利用帧间的位姿估计，可以通过观测值$p_1$求得对应的匹配$\hat{p}_2$，理论上，我们的计算值$\hat{p}_2$与观测值$p_1$应该是重合的，但是，由于我们估计的帧间位姿并不是准确的，因此就会出现误差$e$，我们称之为重投影误差。</p><p><img src="/images/相机模型简要分析/image-20220505202300998.png" alt="image-20220505202300998" style="zoom:50%;" /></p><p>按照之前的基础知识，可以推导：</p><script type="math/tex; mode=display">s_iu_i=K\exp(\xi^{\land})P_i\tag{8}</script><p>其中，$u_i=[u_i,v_i]^T$表示特征点$P$的投影坐标，$s_i$表示深度，$K$表示相机内参，$\exp(\xi^{\land})$则是变换$T_{cw}$的李代数形式，这里的$P_i$是特征点的世界坐标。这里类似于公式$(7)$。</p><p>通过重投影误差的定义可知，我们的目的在于不断优化变量$\xi$，从而得到一个最优的$\xi$使得$e$的值达到最小，因此构建最小二乘：</p><script type="math/tex; mode=display">\xi^*=\arg\underset{\xi}{\min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1}{s_i}K\exp(\xi^{\land})P_i\parallel^2_2\tag{9}</script><p>然后就是对其优化的内容了，这里可以参考：<a href="https://lukeyalvin.top/posts/20908.html#1-%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE">PnP_重投影误差</a></p><h1 id="VIO重投影误差"><a href="#VIO重投影误差" class="headerlink" title="VIO重投影误差"></a>VIO重投影误差</h1><p>由构建于VIO重投影误差省略了相机内参$K$，那么，我们在公式$(6)$的基础上把$K$去掉，就发现<strong>特征点在相机归一化平面的坐标就是像素坐标</strong>$[u,v]^T$，其中$[u,v]^T$是观测值，由于$T_{cw}$是估计出来的，所以等式右边是估计值，理想情况下有：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=T_{cw}\begin{bmatrix}\frac{X_w}{Z_w}\\\frac{Y_w}{Z_w}\\1\end{bmatrix}=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\triangleq  \overline{P}</script><p>而此时的重投影误差就变成了：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_c}{Z_c}-u\\\frac{Y_c}{Z_c}-v\end{bmatrix}</script><p>熟悉这个之后，我们再来学习一下VIO重投影误差。</p><p><img src="/images/相机模型简要分析/image-20220505205125811.png" alt="image-20220505205125811" style="zoom: 33%;" /></p><p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p><script type="math/tex; mode=display">\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{10}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u\\\frac{Y_{cj} }{Z_{cj} }-v\end{bmatrix}\tag{11}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="相机模型" scheme="https://lukeyalvin.top/tags/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="VO" scheme="https://lukeyalvin.top/tags/VO/"/>
    
  </entry>
  
  <entry>
    <title>状态估计模型与贝叶斯滤波</title>
    <link href="https://lukeyalvin.top/posts/b04da399.html"/>
    <id>https://lukeyalvin.top/posts/b04da399.html</id>
    <published>2022-05-04T11:29:54.032Z</published>
    <updated>2022-05-08T13:27:20.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><strong>滤波器的本质：</strong>结合预测和观测，得到“最精确”的后验值。这个精确值是相对的，因为实际中，预测和观测均是从传感器而来的，因此滤波器的作用就是结合各个传感器得到一个最好的融合结果。这就是一个数据融合的过程，关于数据融合的介绍可以参考：<a href="https://lukeyalvin.top/posts/8369.html#%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88">数据融合</a></p><p><img src="/images/滤波器基本原理/image-20220504151009319.png" alt="image-20220504151009319" style="zoom:50%;" /></p><p>1) 实际中预测往往从IMU、编码器等传感器递推而来；<br>2) 观测往往从GPS、雷达、相机等传感器而来；<br>3) 后验为融合后的结果，即定位模块的输出。</p><h1 id="状态估计模型"><a href="#状态估计模型" class="headerlink" title="状态估计模型"></a>状态估计模型</h1><p>实际状态估计任务中，待估计的后验概率密度可以表示为：</p><script type="math/tex; mode=display">p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})\tag{1}</script><p>其中：$\tilde{x}_0$表示的是状态初始值；$v_{1:k}$表示从第1时刻到第$k$时刻的输入；$y_{0:k}$表示从第0时刻到第$k$时刻的观测。</p><p>因此，滤波问题可以直观表示为，根据所有历史数据（输入、观测、初始状态），得出的最终的融合结果。历史数据之间的关系，可以用下面的图模型表示，</p><p><img src="/images/滤波器基本原理/image-20220504205031587.png" alt="image-20220504205031587" style="zoom: 33%;" /></p><p>图模型中体现了<strong>马尔可夫性</strong>，即当前状态只跟前一时刻状态相关，和其他历史时刻状态无关。数学表达该性质，</p><script type="math/tex; mode=display">\left\{\begin{aligned}运动方程：x_k&=f(x_{k-1},v_k,w_k)\\观测方程：y_k&=g(x_k,n_k)\end{aligned}\right.\tag{2}</script><h1 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h1><p>根据贝叶斯公式，$k$时刻后验概率密度可以表示为</p><script type="math/tex; mode=display">\begin{align*}p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})&=\frac{p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}{p(y_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}\\&=\eta p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\end{align*}\tag{3}</script><p>根据观测方程，$y_k$只与$x_k$相关，因此上式可以简写为：</p><script type="math/tex; mode=display">p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})=\eta p(y_k|x_k)p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\tag{4}</script><p>应用系统的马尔可夫性进一步化简公式，</p><script type="math/tex; mode=display">\begin{align*}&p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\\&=\int p(x_k,x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\&=\int p(x_k|x_{k-1}，\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\&=\int p(x_k|x_{k-1},v_{k})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\end{align*}\tag{3}</script><p>经过以上化简，最终后验概率可以写为</p><p><img src="/images/滤波器基本原理/image-20220504211503741.png" alt="image-20220504211503741" style="zoom: 50%;" /></p><p>根据以上结果，可以画出贝叶斯滤波的信息流图如下</p><p><img src="/images/滤波器基本原理/image-20220504210156815.png" alt="image-20220504210156815"></p><p>贝叶斯滤波分为很多种实现形式：</p><p><img src="/images/滤波器基本原理/image-20220504211643228.png" alt="image-20220504211643228" style="zoom: 50%;" /></p><p>实际中，粒子滤波（PF）多用于(早期的)2D激光SLAM方案中。在高斯假设前提下，用贝叶斯滤波的原始形式比较复杂，可以利用高斯的特征得到简化形式，即广义高斯滤波，后面KF、EKF、IEKF、UKF的推导均采用这种形式，只有PF例外，因为它是针对非高斯的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="滤波器" scheme="https://lukeyalvin.top/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    
    <category term="概率基础" scheme="https://lukeyalvin.top/tags/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    
    <category term="贝叶斯滤波" scheme="https://lukeyalvin.top/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>点云地图的建立、畸变补偿和定位</title>
    <link href="https://lukeyalvin.top/posts/f737dac5.html"/>
    <id>https://lukeyalvin.top/posts/f737dac5.html</id>
    <published>2022-05-03T10:44:59.183Z</published>
    <updated>2022-05-04T01:30:50.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>点云地图的建立</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="建图流程"><a href="#建图流程" class="headerlink" title="建图流程"></a>建图流程</h1><p>建图流程设计的核心原则是准确、高效地把<strong>里程计相对位姿</strong>、<strong>回环相对位姿</strong>、<strong>惯导先验位姿</strong>进行融合。</p><p><img src="/images/点云地图的建立/image-20220503190523343.png" alt="image-20220503190523343" style="zoom: 33%;" /></p><ul><li>轨迹对齐</li></ul><p>里程计的初始位姿是从激光雷达收到第一帧点云开始的，它的初始位姿就是单位阵，平移和旋转均为0；而对于惯导而言，它的旋转是以东北天坐标系为准的，因此它的初始位姿并不一定为0；因此里程计第一帧之间的位姿和惯导第一帧的位姿出现了相对旋转，这会导致里程计和先验之间出现很大的误差，所以我们求第一帧时里程计和惯导位姿之间的相对变换即可，这样就可以把里程计的轨迹拉到与惯导轨迹（一般和小车行进方向一致）一致的方向。这个过程就是<strong>轨迹对齐</strong>。</p><ul><li>回环检测</li></ul><p>这里涉及一个简单的回环检测的策略，比如如下的回环，我们检测回环不可能每一帧都进行检测，而是在一定的范围内，并且两帧之间的时间差必须大于一定的阈值，另外当某一帧被检测为闭环了，那么它相邻的一些帧则不做重复的检测，把相邻帧做“吸收化”之后，在后续段进行闭环检测。</p><p><img src="/images/点云地图的建立/image-20220503191428273.png" alt="image-20220503191428273" style="zoom: 50%;" /></p><ul><li>优化周期</li></ul><p>固定优化周期，可以在一定周期内进行优化，可以在误差累积相对较小的情况下进行优化，因为累积误差小，优化时间短，这样前端里程计构建过程中可以同步实现后端的优化，可以提高效率。</p><h1 id="畸变补偿"><a href="#畸变补偿" class="headerlink" title="畸变补偿"></a>畸变补偿</h1><ul><li><strong>产生原因：</strong></li></ul><p>由于一帧点云中的激光点是不同时刻采集的，激光点的坐标原点是采集时刻的雷达位姿，雷达在不同时刻的位姿有变化的时候，各个激光点原点不一致，拼接成一帧时，点云的形状便和实际物体形状不一致。</p><p><img src="/images/点云地图的建立/image-20220503193403250.png" alt="image-20220503193403250" style="zoom:50%;" /></p><p><img src="/images/loam论文深度解析/image-20220411193701848.png" alt="image-20220411193701848" style="zoom:33%;" /></p><ul><li><strong>补偿方法：</strong></li></ul><p>对于每一个激光点坐标做补偿，补偿量为激光点云与原点（即当时激光雷达坐标）相对于该帧起始时刻的变换。</p><h2 id="计算相对坐标"><a href="#计算相对坐标" class="headerlink" title="计算相对坐标"></a>计算相对坐标</h2><p>在匀速模型假设前提下，坐标 = 运动×时间。</p><p>假设第一帧点云的起始位姿为：</p><script type="math/tex; mode=display">T_0=\begin{bmatrix}R_0&t_0\\0&1\end{bmatrix}\tag{1}</script><p>第$i$个激光点采集时，雷达的位姿为：</p><script type="math/tex; mode=display">T_i=\begin{bmatrix}R_i&t_i\\0&1\end{bmatrix}\tag{2}</script><p>第$i$个激光点的坐标为：</p><script type="math/tex; mode=display">P_i=[p_{ix} \ p_{iy} \ p_{iz}]^T\tag{3}</script><p>则第$i$个激光点补偿畸变后的坐标应该为：</p><script type="math/tex; mode=display">\overline{P}_i=T_0^{-1}T_iP_i\tag{4}</script><p>上式可以理解为，只需要计算$0$到$i$时刻，激光雷达的相对旋转和相对平移变换即可。</p><p>实际上，雷达点云是局部坐标系下的表示，当以0时刻雷达的位姿为基准坐标系的时候，此时$T_0$为单位阵，$T_i$即为$0$到$i$时刻的相对旋转和平移。</p><p>此时有：</p><script type="math/tex; mode=display">\begin{align*}R_i&=\omega\nabla t\\t_i&=V\nabla t\end{align*}\tag{5}</script><p>即，只需要知道$0$到$i$时刻的平均角速度和平均速度即可。</p><p><strong>那么时间差如何进行求取呢？</strong></p><p>由于是顺序扫描，我们可以通过$\arctan\frac{y}{x}$来计算出该激光点相对于第一个激光点旋转过的角度$\beta$，已知雷达内部旋转$360°$用了$100ms$，那么旋转$\beta$角度所用的时间就可以计算出来了。</p><p>但是由于$\arctan\frac{y}{x}\in[-90°,90°]$的范围。而雷达的周期是$360°$，因此计算出来的$\arctan\frac{y}{x}$还需要进行角度补偿。</p><p>下面摘自：<a href="https://zhuanlan.zhihu.com/p/109379384">从零开始做自动驾驶定位(八): 点云畸变补偿</a></p><h2 id="点云数据排列方式"><a href="#点云数据排列方式" class="headerlink" title="点云数据排列方式"></a>点云数据排列方式</h2><p>做激光定位的多数都看过loam的程序，会发现在计算激光点采集时刻这一步上我们和它是有区别的，这就是这个点云排列方式导致的。</p><p>从激光雷达原理上讲，每次采集一列，边扫描边采集，所以数据应该是一列一列地存储，这样保证第一个点一定是最早时刻被采集的，最后一个点是最晚时刻被采集的，这样做有一个好处，那就是可以计算雷达真正扫描了多少度，因为它就是第一个点和最后一个点的角度差。</p><p>而在这个bag文件里，是按行存储的，也就是先索引第一根线上的点，再第二根，依次类推，直到最后一根，这样的缺点是，我们无法通过这个来计算雷达实际扫描角度了，因为第一个点不一定是时间最早的点，如果第一根线前半部分被遮挡，那么你就会得到错误的计算角度，所以这时候，像我们这样直接强制把扫描角度设置成360度是更稳妥的，缺点就是它不够精确。</p><p>这个问题的原因应该是数据的二次加工导致的，kitti先把数据存成bin文件，kitti2bag再转成bag文件，改变了原来的排列方式。一般雷达驱动中输出的数据都是按列排列的。</p><p>所以如果各位以后使用的数据是列排列的，那么时间计算上可以使用loam里的方法，会更准确。</p><h1 id="定位流程"><a href="#定位流程" class="headerlink" title="定位流程"></a>定位流程</h1><p>在地图匹配的过程中，鲁棒性和运行速度特别重要，因此实际中，基于NDT的匹配使用更为广泛。由于NDT匹配需要较准确的初始位姿，因此在定位之前需要初始化环节，给出载体的初始位姿。<br>按照难度由低到高，常见的初始化需求有这样几种：</p><p>1）已知位姿的初始化<br>2）位置已知而姿态未知的初始化<br>3）位置和姿态均未知的初始化</p><p><img src="/images/点云地图的建立/image-20220504092212456.png" alt="image-20220504092212456" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;点云地图的建立&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="建图" scheme="https://lukeyalvin.top/tags/%E5%BB%BA%E5%9B%BE/"/>
    
    <category term="畸变补偿" scheme="https://lukeyalvin.top/tags/%E7%95%B8%E5%8F%98%E8%A1%A5%E5%81%BF/"/>
    
  </entry>
  
  <entry>
    <title>后端位姿图优化</title>
    <link href="https://lukeyalvin.top/posts/aed03174.html"/>
    <id>https://lukeyalvin.top/posts/aed03174.html</id>
    <published>2022-05-02T13:26:34.855Z</published>
    <updated>2022-05-03T10:35:42.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="后端优化的基本原理"><a href="#后端优化的基本原理" class="headerlink" title="后端优化的基本原理"></a>后端优化的基本原理</h1><ul><li><strong>后端优化的目的：</strong></li></ul><p>利用回环检测结果和惯导先验位姿修正里程计误差，而回环在此提供的是两帧之间的相对位姿。</p><ul><li><strong>后端优化的方法：</strong></li></ul><p>假设马尔可夫性，简单的一阶马氏性认为，$k $时刻状态只与$ k − 1 $时刻状态有关，而与再之前的无关。如果做出这样的假设，我们就会得到以扩展卡尔曼滤波（EKF）为代表的滤波器方法。在滤波方法中，我们会从某时刻的状态估计，推导到下一个时刻。</p><p>另外一种方法是依然考虑 $k$ 时刻状态与之前所有状态的关系，此时将得到非线性优化为主体的优化框架。在视觉SLAM中非线性优化如BA与图优化、位姿图优化等。</p><ul><li><strong>总结而言，后端优化的观测主要从这三个方面：</strong></li></ul><p>①连续两帧之间的相对位姿观测（里程计）</p><p>②闭环匹配得到的相对位姿观测（闭环检测）</p><p>③组合导航提供的先验位姿估计（IMU）</p><p>①②的观测构成了<strong>基于回环的位姿修正</strong>，①③的观测构成了<strong>基于先验观测的位姿修正，</strong>当然三者也可以结合使用。三者的关系是，②③在①的基础上对位姿进行修正，这里对里程计的平滑性有一定的要求。</p><h1 id="基于回环的位姿修正"><a href="#基于回环的位姿修正" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h1><h2 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h2><p><img src="/images/后端位姿图优化/fc51f93b-322d-475b-bfa5-cae57a6750f9.jpeg" alt="回环检测是什么"></p><p>首先我们需要了解什么是回环检测，如是上图所示，对于里程计而言，它用来估计帧与帧之间的位姿估计，而这个位姿估计会因为噪声而产生漂移，（即使每一帧之间我们都进行了BA优化，但微小的漂移仍是无法避免的），由于里程计帧之间的位姿估计有很多，因此积少成多，漂移最终累积特别大，就会导致机器人在达到初始位置是，观测显示已经回到初始位置，而位姿估计却显示与初始位置相差一段距离，如上图所示。</p><p>我们通过构建位姿估计的位置和初始位置的残差项，对整个回环进行优化和修正，进而得到如下的地图。（理论而言，没有漂移的情况下，位姿估计的位置和初始位置是重合的。）</p><p><img src="/images/后端位姿图优化/32fa19ca-c057-4ccb-8075-802d0a456991.jpeg" alt="什么是回环检测"></p><p>因此，回环检测的目的就是消除累积误差。</p><h2 id="位姿图优化"><a href="#位姿图优化" class="headerlink" title="位姿图优化"></a>位姿图优化</h2><p>与之前的BA优化不同，比如我们之前学习的重投影模型，它考虑的是相邻帧之间的位姿估计，需要优化每个相机的位姿和特征点的位置，即使我们使用关键帧，对于大场景而言，特征点的观测是非常巨大的，这种计算量也是巨大的。</p><p>而位姿图优化，构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。</p><p><img src="/images/后端位姿图优化/image-20220503095925699.png" alt="image-20220503095925699" style="zoom:50%;" /></p><h2 id="基于回环的位姿修正-1"><a href="#基于回环的位姿修正-1" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h2><h3 id="构建残差"><a href="#构建残差" class="headerlink" title="构建残差"></a>构建残差</h3><p>在上文，我们找到如何构建残差项，下一步就是对残差项进行修正，那么我们就需要求得残差项对相应状态量的雅可比矩阵，从而才能知道从哪个方向修正状态量能够达到优化的目的。</p><p>位姿图优化关心的是两帧之间的观测，这两帧并不一定是相邻的两帧，比如回环检测中的两帧。设第$i$和第$j$帧之间的观测，在李群SE3上可以表示为：</p><script type="math/tex; mode=display">\Delta T_{ij}=T_i^{-1}T_j.\tag{1}</script><p>很容易理解，如果说第$i$和第$j$帧构成回环，那么$T_i^{-1}T_j=I$，也就不存在误差。</p><p>也可以用李代数表示：</p><script type="math/tex; mode=display">\Delta \xi_{ij}=\xi^{-1}_i◦\xi_j=\ln(T_i^{-1}T_j)^{\lor}.\tag{2}</script><p>构建残差：</p><script type="math/tex; mode=display">\begin{align*}e_{ij}&=\ln(\Delta T_{ij}^{-1}T_i^{-1}T_j)^{\lor}\\&=\ln(\exp((-\xi_{ij})^{\land})\exp((-\xi_i)^{\land})\exp(\xi^{\land}_j))^{\lor}\end{align*}.\tag{3}</script><p>位姿图优化的思想是通过调整状态量（即位姿），使残差项的值最小化，这就是需要用残差项求雅可比矩阵，才能使用梯度下降方法进行迭代优化。</p><h3 id="求雅可比矩阵"><a href="#求雅可比矩阵" class="headerlink" title="求雅可比矩阵"></a>求雅可比矩阵</h3><p>我们对位姿$T_i$和$T_j$分别左乘一个扰动$\Delta T=\exp(\delta\xi^{\land})$</p><script type="math/tex; mode=display">\begin{align*}\hat{e}_{ij}&=\ln \left(T_{ij}^{-1}T_i^{-1}\exp((-\delta\xi_i)^{\land})\exp(\delta\xi_j^{\land})T_j\right)^{\lor}\\&=\ln \left( T_{ij}^{-1}T_i^{-1}T_j\exp\left(  (-Ad(T_j^{-1})\delta\xi_i)^{\land}  \right)\exp\left(    (Ad(T_j^{-1})\delta\xi_j)^{\land} \right)\right)^{\lor}\\&\approx\ln \left( \exp(e_{ij})\exp\left((-Ad(T_j^{-1})\delta\xi_i)^{\land}+(Ad(T_j^{-1})\delta\xi_j)^{\land}\right)\right)^{\lor}\\&\approx e_{ij}-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\delta\xi_i+\mathcal{J}_r^{-1}Ad(T_j^{-1})\delta\xi_j\end{align*}\tag{4}</script><hr><p>这里推导过程的第一步到第二步利用了李群的伴随性质：</p><ul><li><strong>SO(3)上的伴随性质</strong></li></ul><script type="math/tex; mode=display">R\exp(p^{\land})R^T=\exp((Rp)^{\land})\\</script><ul><li><strong>SE(3)上的伴随性质</strong></li></ul><script type="math/tex; mode=display">T\exp(\xi^{\land})T^{-1}=\exp((Ad(T)\xi)^{\land})\\</script><p>其中伴随矩阵的定义如下：</p><script type="math/tex; mode=display">Ad(T)=\begin{bmatrix}R&t^{\land}R\\ 0&R\end{bmatrix}</script><p>第二步第三步使用的是BCH公式：</p><ul><li><strong>SO(3)上的BCH公式</strong></li></ul><script type="math/tex; mode=display">\ln(\exp(\phi_1^{\land})\exp(\phi_2^{\land}))\approx\left\{\begin{aligned}J_l(\phi_2)^{-1}\phi_1+\phi_2\ ,\ 当\phi_1为小量 \\J_r(\phi_1)^{-1}\phi_2+\phi_1\ ,\ 当\phi_2为小量\end{aligned}\right.</script><p>其中左乘雅可比为：</p><script type="math/tex; mode=display">J_l=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})aa^T+\frac{1-\cos\theta}{\theta}a^{\land}</script><p>所以：</p><script type="math/tex; mode=display">J_l^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})aa^T-\frac{\theta}{2}a^{\land}</script><p>右乘雅可比仅需要在左乘雅可比的基础上对自变量取负号，即：</p><script type="math/tex; mode=display">J_r(\phi)=J_l(-\phi)</script><ul><li><strong>SE(3)上的BCH公式</strong></li></ul><script type="math/tex; mode=display">\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\left\{\begin{aligned}J_l(\xi_2)^{-1}\xi_1+\xi_2\ ,\ 当\xi_1为小量 \\J_r(\xi_1)^{-1}\xi_2+\xi_1\ ,\ 当\xi_2为小量\end{aligned}\right.</script><p>其中右乘雅可比为：</p><script type="math/tex; mode=display">\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi^{\land}&\rho^{\land}\\0&\phi^{\land}\end{bmatrix}</script><p>一般情况下，若$\xi$非常小，该雅克比矩阵可以直接使用单位阵，此时：</p><script type="math/tex; mode=display">\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\ln(\exp(\xi_1^{\land}+\xi_2^{\land}))^{\lor}</script><p>这里第二步到第三步的推导用的就是这个式子。</p><hr><p>所以，残差关于$T_i$的雅可比为：</p><script type="math/tex; mode=display">A_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_i}=-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{5}</script><p>残差关于$T_j$的雅可比为：</p><script type="math/tex; mode=display">B_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_j}=\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{6}</script><p>其中：</p><script type="math/tex; mode=display">\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi_e^{\land}&\rho_e^{\land}\\0&\phi_e^{\land}\end{bmatrix}\tag{7}</script><p>为了找到梯度方向，需要对残差进行一阶泰勒展开：</p><script type="math/tex; mode=display">\begin{align*}&e_{ij}(x_i+\Delta x_i,x_j+\Delta x_j)\\=&e_{ij}(x+\Delta x)\\\approx&e_{ij}+J_{ij}\Delta x\end{align*}\tag{8}</script><p>其中$J_{ij}$即为前面推导的残差关于位姿的雅可比组成的矩阵：</p><script type="math/tex; mode=display">J_{ij}=(0···0\ A_{ij}\ 0···0 \ B_{ij} \ 0···0)</script><p>至此，我们就把非线性优化变成了一个线性化问题。</p><h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><p>位姿图优化就是把所有的观测和状态放在一起优化，在实际使用中，各个残差会被分配一个权重，也就是信息矩阵，它相当于对残差进行加权，考虑信息矩阵后，总的残差可以表示为:</p><script type="math/tex; mode=display">F(x)=\sum_{i,j\in \mathcal{C} }F_{ij}=\sum_{i,j\in \mathcal{C}} e_{ij}^T\Omega_{ij}e_{ij}\tag{9}</script><blockquote><p>权重矩阵又称为信息矩阵，它是协方差矩阵的逆，即为：$\Omega_{ij}=\Sigma_{ij}^{-1}$，因为每个残差都看作高斯分布，而每个高斯分布都可以归一化为标准的高斯分布$N(0,1)$，这种归一化操作是减去均值求平方然后除以方差。残差预期均值为0，所以不用减只需要除以方差，扩展到多维的话就变成了信息矩阵加权形式。</p></blockquote><p>所以此时的优化问题就是：</p><script type="math/tex; mode=display">x^*=\arg\underset{x}{\min}\ F(x)\tag{10}</script><p>对于每一个残差块，都有：</p><script type="math/tex; mode=display">\begin{align*}&F_{ij}(x+\Delta x)\\&=e_{ij}(x+\Delta x)^T\Omega_{ij}e_{ij}(x+\Delta x)\\&\approx e_{ij}^T\Omega_{ij}e_{ij}+2e_{ij}^T\Omega_{ij}J_{ij}\Delta x+\Delta x^TJ_{ij}^T\Omega_{ij}J_{ij}\Delta x\\&=c_{ij}+2b^T_{ij}\Delta x+\Delta x^TH_{ij}\Delta x\end{align*}\tag{11}</script><p>其中：</p><script type="math/tex; mode=display">c_{ij}=e_{ij}^T\Omega_{ij}e_{ij}</script><script type="math/tex; mode=display">H^T_{ij}=J_{ij}^T\Omega_{ij}J_{ij}=\begin{bmatrix}··· & ··· & ··· & ··· \\··· &A^T_{ij}\Omega_{ij}A_{ij}&···&A^T_{ij}\Omega_{ij}B_{ij}\\··· & ··· & ··· & ··· \\··· &B^T_{ij}\Omega_{ij}A_{ij}&···&B^T_{ij}\Omega_{ij}B_{ij}\\··· & ··· & ··· & ··· \\\end{bmatrix}</script><script type="math/tex; mode=display">b_{ij}=e_{ij}^T\Omega_{ij}J_{ij}=\begin{bmatrix} ···\\A^T_{ij}\Omega_{ij}e_{ij}\\···\\B^T_{ij}\Omega_{ij}e_{ij}\\···\end{bmatrix}</script><p>所以，要使得误差最小，只需要使得：</p><script type="math/tex; mode=display">H\Delta x = -b\tag{11}</script><p>根据修正量，修正$x$的值，即完成依次迭代：</p><script type="math/tex; mode=display">x^*=x+\Delta x\tag{12}</script><p>多次迭代，直至残差满足收敛条件时，则终止循环，完成优化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="后端优化" scheme="https://lukeyalvin.top/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    <category term="位姿图优化" scheme="https://lukeyalvin.top/tags/%E4%BD%8D%E5%A7%BF%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
