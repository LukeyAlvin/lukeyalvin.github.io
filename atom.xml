<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robot Go!</title>
  
  <subtitle>一份耕耘,一份收获</subtitle>
  <link href="http://lukeyalvin.top/atom.xml" rel="self"/>
  
  <link href="http://lukeyalvin.top/"/>
  <updated>2022-04-02T07:03:00.120Z</updated>
  <id>http://lukeyalvin.top/</id>
  
  <author>
    <name>上善若水</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>卡尔曼滤波的数学推导</title>
    <link href="http://lukeyalvin.top/2022/04/02/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
    <id>http://lukeyalvin.top/2022/04/02/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</id>
    <published>2022-04-02T06:52:57.548Z</published>
    <updated>2022-04-02T07:03:00.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>卡尔曼滤波（Kalman filter）是一种高效率的<strong>递归滤波器</strong>（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="卡尔曼滤波的数学推导"><a href="#卡尔曼滤波的数学推导" class="headerlink" title="卡尔曼滤波的数学推导"></a>卡尔曼滤波的数学推导</h1><h2 id="先验与后验估计"><a href="#先验与后验估计" class="headerlink" title="先验与后验估计"></a>先验与后验估计</h2><p>由之前的状态空间方程：</p><script type="math/tex; mode=display">\begin{align}{x_k }&=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_{k}&=Hx_{k}+v_k\end{align}</script><p>其中$w_{k-1}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$P_{(w)}\sim(0,Q)，P_{(v)}\sim(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$，推导如下：</p><script type="math/tex; mode=display">\begin{align}Q=E[ww^T]&=E\begin{bmatrix}\begin{bmatrix}w_1\\w_2\\.\\.\\w_k \end{bmatrix}\begin{bmatrix}w_1&w_2&...&w_k \end{bmatrix}\end{bmatrix}=E\begin{bmatrix}w_1^2&w_1w_2&...&w_1w_k\\w_2w_1&w_2^2&...&w_2w_k\\...&...&...&...\\w_kw_1&w_kw_1&...&w_k^2\end{bmatrix}\\&=\begin{bmatrix}Ew_1^2&Ew_1w_2&...&Ew_1w_k\\Ew_2w_1&Ew_2^2&...&Ew_2w_k\\...&...&...&...\\Ew_kw_1&Ew_kw_1&...&Ew_k^2\end{bmatrix}\end{align}</script><p>由于$w$的期望为$0$，由方差等于平方的期望减去期望的平方以及协方差公式：</p><script type="math/tex; mode=display">\begin{align}Var(X)&=E(X^2)-E^2(X)\\Cov(X,Y)&=E((X-\mu)(Y-v))\end{align}</script><p>所以此处平方的期望就等于方差：</p><script type="math/tex; mode=display">\begin{align}Var(X)&=E(X^2)\\Cov(X,Y)&=E(X·Y)\end{align}</script><p>即为：</p><script type="math/tex; mode=display">Ew_k^2=\sigma_{w_1}^2,Ew_iw_j=\sigma_i\sigma_j</script><p>所以：</p><script type="math/tex; mode=display">Q=\begin{bmatrix}Ew_1^2&Ew_1w_2&...&Ew_1w_k\\Ew_2w_1&Ew_2^2&...&Ew_2w_k\\...&...&...&...\\Ew_kw_1&Ew_kw_1&...&Ew_k^2\end{bmatrix}=\begin{bmatrix}\sigma_{w_{1} }^2&\sigma_{w_1}\sigma_{w_2}&...&\sigma_{w_1}\sigma_{w_k}\\\sigma_{w_2}\sigma_{w_1}&\sigma_{w_{2} }^2&...&\sigma_{w_2}\sigma_{w_k}\\...&...&...&...\\\sigma_{w_k}\sigma_{w_1}&\sigma_{w_k}\sigma_{w_1}&...&\sigma_{w_{k} }^2\end{bmatrix}</script><p>因此$Q$就是之前所提到的协方差矩阵，同样的，测量噪声也有协方差矩阵$R$，满足类似的条件。</p><hr><p>由于存在噪声的影响，所得到的$x_k$并不精确，我们暂且设它为$\hat{x}_k$，表示这是$x_k$的估计值；同样的$x_{k-1}$也是不准确的，设为$\hat{x}_{k-1}$，并且我们设通过下试得到的$x_k$成为先验估计，定义为$\hat{x}^-_k$；</p><p><b><span style="color:rgb(255, 0, 255);">先验估计（公式1）：</span></b></p><script type="math/tex; mode=display">\hat{x}^-_k=A\hat{x}_{k-1}+B\mu_{k-1}</script><p>由于$z_k$是测出的结果，是已知的，由$z_k=Hx_k$可知：</p><script type="math/tex; mode=display">\hat{x}_{kmea}=H^-z_k</script><p>对于上面的两个式子，$\hat{x}^-_k$是算出来的，$\hat{x}_{kmea}$是测出来的，因为收到噪声的影响，它们两个都是不准确的，因此这时候卡尔曼滤波的作用就显现出来了，如何利用两个不准确的值去得出一个相对准确的结果？这里就很容易想到之前提到的数据融合的思想。</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+G(H^-z_k-\hat{x}^-_k)，G\in[0,1]</script><p>分析式子很容易理解，当我们的测量数据很少时，$G\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多时，$G\approx1$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p><p>一般教科书上设$G=K_kH$；</p><p><b><span style="color:rgb(255, 0, 255);">后验估计（公式2）：</span></b></p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]</script><p>同样的，当我们的测量数据很少（不准确）时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多（相对准确）时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p><h2 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h2><p>因此，我们的目标变得十分明确了，如何选择一个合适的$K_k$值，使得$\hat{x}_k\rightarrow x_k$，其中$x_k$表示真实值。</p><p>此时，我们定义一个误差值$e_k$，以及一个先验误差值$e_k^-$：</p><script type="math/tex; mode=display">e_k=x_k-\hat{x}_k\\e_k^-=x_k-\hat{x}^-_k</script><p>误差也是符合高斯分布，$p(e_k)\sim(0,P)$，其中协方差矩阵$P=E[ee^T]$，与之前推导的$Q$是类似的。</p><p>因此，最终的目的就是选择一个合适的$K_k$值，使得$e_k$最小，也就是使得它的方差最小，因为方差越小，说明越接近期望值$0$，即$e_k\approx0$。而方差最小就是使得它的协方差矩阵的迹$tr(P)=\sigma^2_{e_{1} }+\sigma^2_{e_{2} }+…+\sigma^2_{e_{k} }$最小。</p><font color="#dd0000">所以，最终的目的为：寻找一个合适的$K_k$使得$tr(P)$最小！</font><hr><script type="math/tex; mode=display">\begin{align}tr(P)&=E[ee^T]\\&=E[(x_k-\hat{x}_k)(x_k-\hat{x}_k)^T]\end{align}</script><p>已知：</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k)\\z_k=Hx_k+v_k</script><p>带入上式：</p><script type="math/tex; mode=display">\begin{align}x_k-\hat{x}_k&=x_k-(\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k))\\&=x_k-\hat{x}^-_k-K_kz_k+K_kH\hat{x}^-_k\\&=x_k-\hat{x}^-_k-K_k(Hx_k+v_k)+K_kH\hat{x}^-_k\\&=x_k-\hat{x}^-_k-K_kHx_k-K_kv_k+K_kH\hat{x}^-_k\\&=(x_k-\hat{x}^-_k)-K_kH(x_k-\hat{x}^-_k)-K_kv_k\\&=(I-K_kH)(x_k-\hat{x}^-_k)-K_kv_k\\&=(I-K_kH)e_k^--K_kv_k\end{align}</script><p>所以：</p><blockquote><p>可能会用到的公式：</p><p>$(AB)^T=B^TA^T$，$(A+B)^T=A^T+B^T$</p></blockquote><script type="math/tex; mode=display">\begin{align}tr(P)&=E[ee^T]\\&=E[(x_k-\hat{x}_k)(x_k-\hat{x}_k)^T]\\&=E[[(I-K_kH)e_k^--K_kv_k][(I-K_kH)e_k^--K_kv_k]^T]\\&=E[[(I-K_kH)e_k^--K_kv_k][e_k^{-T}(I-K_kH)^T-v_k^TK_k^T]]\\&=E[(I-K_kH)e_k^-e_k^{-T}(I-K_kH)^T-(I-K_kH)e_k^-v_k^TK_k^T\\&-K_kv_ke_k^{-T}(I-K_kH)^T+K_kv_kv_k^TK_k^T]\\\end{align}</script><p>分别求每一项的期望：</p><blockquote><p>可能会用到的已知条件：</p><p>$E[e_k^-]=0,E[e_k^{-T}]=0,E[v_k^T]=0,E[v_k]=0$</p></blockquote><script type="math/tex; mode=display">\begin{align}&E[-(I-K_kH)e_k^-v_k^TK_k^T]\\&=-(I-K_kH)E[e_k^-v_k^T]K_k^T\\&=-(I-K_kH)E[e_k^-]E[v_k^T]K_k^T\\&=0\end{align}</script><p>同理可得：</p><script type="math/tex; mode=display">\begin{align}&E[-K_kv_ke_k^{-T}(I-K_kH)^T]\\&=-K_kE[v_k]E[e_k^{-T}](I-K_kH)^T\\&=0\end{align}</script><p>所以最终：</p><blockquote><p>可能会用到的定义：</p><p>已知协方差矩阵$P=E[ee^T]$，则定义$P_k^-=E[e_k^-e_k^{-T}]$</p><p>$p_{(v)}\sim(0,R)$，所以$R_k=E[v_kv^T_k]$</p></blockquote><script type="math/tex; mode=display">\begin{align}tr(P)&=E[ee^T]\\&=E[(I-K_kH)e_k^-e_k^{-T}(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\&=(I-K_kH)E[e_k^-e_k^{-T}](I-K_kH)^T+K_kE[v_kv_k^T]K_k^T\\&=(P_k^--K_kHP_k^-)(I^T-H^TK_k^T)+K_kR_kK_k^T\\&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kR_kK_k^T\\\end{align}</script><blockquote><p>由于，协方差矩阵的转置就是它本身，所以$P_k^{-T}=P_k^-$</p><p>$(P_k^-H^TK_k^T)^T=K_kHP_k^{-T}=K_kHP_k^-$，所以$tr(K_kHP_k^-)=tr(P_k^-H^TK_k^T)$</p></blockquote><p>因此：</p><script type="math/tex; mode=display">\begin{align}tr(P)&=tr(P_k^-)-tr(K_kHP_k^-)-tr(P_k^-H^TK_k^T)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kR_kK_k^T)\\&=tr(P_k^-)-2tr(K_kHP_k^-)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kR_kK_k^T)\end{align}</script><p>$tr(P)$对$K_k$求导，使得$\frac{dtr(P_k)}{dK_k}=0$：</p><blockquote><p>可能会用到的公式：</p><p>$\frac{dtr(AB)}{dA}=B^T$，$\frac{dtr(ABA^T)}{dA}=2AB$</p></blockquote><script type="math/tex; mode=display">\begin{align}\frac{dtr(P_k)}{dK_k}&=\frac{tr(P_k^-)}{dK_k}-\frac{2tr(K_kHP_k^-)}{dK_k}+\frac{tr(K_kHP_k^-H^TK_k^T))}{dK_k}+\frac{tr(K_kR_kK_k^T))}{dK_k}\\&=0-2(HP_k^-)^T+2K_kHP_k^-H^T+2K_kR_k\\&=0\end{align}</script><p>所以：</p><script type="math/tex; mode=display">\begin{align}(HP_k^-)^T&=K_k(HP_k^-H^T+R_k)\end{align}</script><p><b><span style="color:rgb(255, 0, 255);">卡尔曼增益（公式3）：</span></b></p><script type="math/tex; mode=display">\begin{align}K_k&=\frac{P_k^-H^T}{HP_k^-H^T+R_k}\end{align}</script><p>因此，结合我们之前的结论：</p><blockquote><p>当我们的测量数据很少（不准确）时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多（相对准确）时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p></blockquote><p>此处也是相同的：</p><p>$R_k$表示测量噪声，当测量噪声很大时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；</p><p>当测量噪声很小时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p><hr><h2 id="误差协方差矩阵"><a href="#误差协方差矩阵" class="headerlink" title="误差协方差矩阵"></a>误差协方差矩阵</h2><p>总结前面推导的三个公式：</p><p><font color="#dd0000"><strong>先验估计（公式1）：</strong></font></p><script type="math/tex; mode=display">\hat{x}^-_k=A\hat{x}_{k-1}+B\mu_{k-1}</script><p><font color="#dd0000"><strong>后验估计（公式2）：</strong></font></p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]</script><p><font color="#dd0000"><strong>卡尔曼增益（公式3）：</strong></font></p><script type="math/tex; mode=display">\begin{align}K_k&=\frac{P_k^-H^T}{HP_k^-H^T+R_k}\end{align}</script><p>上面的公式里只有$P_k^-$是未知的，需要推导。由于已知协方差矩阵$P=E[ee^T]$，所以定义$P_k^-=E[e_k^-e_k^{-T}]$，如何求这个误差协方差矩阵是以下篇幅讨论的重点。</p><blockquote><p>可能会用到的定义与公式：</p><p>$e_k=x_k-\hat{x}_k$，$P_k=E[ee^T]$</p><p>$e_k^-=x_k-\hat{x}^-_k$ ，$P_k^-=E[e_k^-e_k^{-T}]$</p><p>$\hat{x}^-_k=A\hat{x}_{k-1}+B\mu_{k-1}$</p><p>$x_k =Ax_{k-1}+Bu_{k-1}+w_{k-1}$</p></blockquote><p>首先推导$e_k^-=x_k-\hat{x}^-_k$:</p><script type="math/tex; mode=display">\begin{align}e_k^-&=x_k-\hat{x}^-_k\\&=Ax_{k-1}+Bu_{k-1}+w_{k-1}-A\hat{x}_{k-1}-B\mu_{k-1}\\&=A(x_{k-1}-\hat{x}_{k-1})+w_{k-1}\\&=Ae_{k-1}+w_{k-1}\end{align}</script><p>所以：</p><blockquote><p>由于$e_{k-1}=x_{k-1}-\hat{x}_{k-1}$，所以$e_{k-1}$作用的是上一时刻，而$w_k$是作用于当前时刻的，它们之间是相互独立的。$E[e_{k-1}w_{k}^T]=E[e_{k-1}]E[w_{k}^T]$，且$E[e_{k-1}]=E[w_{k}^T]=0$</p></blockquote><script type="math/tex; mode=display">\begin{align}P_k^-&=E[e_k^-e_k^{-T}]\\&=E[(Ae_{k-1}+w_{k-1})(Ae_{k-1}+w_{k-1})^T]\\&=E[(Ae_{k-1}+w_{k-1})(e_{k-1}^TA^T+w_{k-1}^T)]\\&=E[Ae_{k-1}e_{k-1}^TA^T+Ae_{k-1}w_{k-1}^T+w_{k}e_{k-1}^TA^T+w_{k-1}w_{k-1}^T]\\&=E[Ae_{k-1}e_{k-1}^TA^T]+E[Ae_{k-1}w_{k-1}^T]+E[w_{k-1}e_{k-1}^TA^T]+E[w_{k-1}w_{k-1}^T]\\&=AE[e_{k-1}e_{k-1}^T]A^T+E[w_{k-1}w_{k-1}^T]\\&=AP_{k-1}A^T+Q_{k-1}\end{align}</script><p><font color="#dd0000"><strong>误差协方差矩阵（公式4）：</strong></font></p><script type="math/tex; mode=display">\begin{align}P_k^-=AP_{k-1}A^T+Q_{k-1}\end{align}</script><p>由于每一次的误差协方差矩阵$P_k^-$，都需要上一次的$P_{k-1}$，所以每一时刻我们都需要更新一下$P_k$的值，为下一时刻使用做准备。</p><p><font color="#dd0000"><strong>更新误差协方差：（公式5）：</strong></font></p><script type="math/tex; mode=display">\begin{align}P_k&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kR_kK_k^T\\&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_k(HP_k^-H^T+R_k)K_k^T\\&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+\frac{P_k^-H^T}{HP_k^-H^T+R_k}(HP_k^-H^T+R_k)K_k^T\\&=P_k^--K_kHP_k^-\\&=(I-K_kH)P_k^-\end{align}</script><p>至此，我们可以总结一下整个卡尔曼滤波的过程：</p><div class="table-container"><table><thead><tr><th style="text-align:left">预测</th><th>校正</th></tr></thead><tbody><tr><td style="text-align:left">先验：$\hat{x}^-_k=A\hat{x}_{k-1}+B\mu_{k-1}$</td><td>卡尔曼增益：$K_k=\frac{P_k^-H^T}{HP_k^-H^T+R_k}$</td></tr><tr><td style="text-align:left">先验误差协方差：$P_k^-=AP_{k-1}A^T+Q_{k-1}$</td><td>后验估计：$\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]$</td></tr><tr><td style="text-align:left"></td><td>更新误差协方差：$P_k=(I-K_kH)P_k^-$</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;卡尔曼滤波（Kalman filter）是一种高效率的&lt;strong&gt;递归滤波器&lt;/strong&gt;（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波器的数学基础</title>
    <link href="http://lukeyalvin.top/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>http://lukeyalvin.top/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2022-04-01T01:23:32.450Z</published>
    <updated>2022-04-02T06:54:36.241Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>卡尔曼滤波（Kalman filter）是一种高效率的<strong>递归滤波器</strong>（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="卡尔曼滤波器的数学基础"><a href="#卡尔曼滤波器的数学基础" class="headerlink" title="卡尔曼滤波器的数学基础"></a>卡尔曼滤波器的数学基础</h1><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>卡尔曼滤波器(Kalman Filter)，它是一种最优化的递归的数字处理算法(Optimal Recursive Data Processing Algorithm)。</p><p><strong>为什么使用卡尔曼滤波？</strong></p><p>因为显示生活中充满了不确定性，而这些不确定性主要体现在以下几个方面：</p><ul><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量传感器存在误差</li></ul><hr><p>【例】测量硬币的例子</p><p>如图所示，不同的人去测量一个硬币的直径，一共测量$k$次，得到的测量值为$z_1,……z_k$，估计硬币的真实直径是多少？</p><p><img src="/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20220401093317316.png" alt="image-20220401093317316"></p><p><strong>取平均值</strong></p><p>设我们的平均值即对真实值的估计值(Estimate)为$\hat{x}$</p><script type="math/tex; mode=display">\begin{align}\hat{x}_k&=\frac{1}{k}(z_1+z_2+...+z_k)\\&=\frac{1}{k}(z_1+z_2+...+z_{k-1})+\frac{1}{k}z_k\\&=\frac{1}{k} \frac{k-1}{k-1}(z_1+z_2+...+z_{k-1})+\frac{1}{k}z_k\\&=\frac{k-1}{k}  \hat{x}_{k-1}+\frac{1}{k}z_k\\&=\hat{x}_{k-1}-\frac{1}{k}\hat{x}_{k-1}  +\frac{1}{k}z_k\end{align}</script><p>整理得：</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}_{k-1} +\frac{1}{k}(z_k-\hat{x}_{k-1} )</script><p>令$K_k=1/k$</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}_{k-1} +K_k(z_k-\hat{x}_{k-1} )</script><p>即为：当前的估计值=上一时刻的估计值+$K_k$(当前测量值-上一时刻的估计值)</p><p><strong>分析：</strong></p><ul><li>随着$k$的增加，$K_k$趋近于0，可以得到$\hat{x}_k=\hat{x}_{k-1}$，测量的结果$z_k$不再重要</li><li>当$k$比较小的时候，$K_k$很大，则说明测量结果是非常重要的</li><li>$K_k$就是<strong>卡尔曼增益</strong>，或叫做卡尔曼因数。</li></ul><p><strong>求解卡尔曼增益$K_k$:</strong></p><p>设估计误差：$e_{EST}$，测量误差：$e_{MEA}$</p><script type="math/tex; mode=display">K_k=\frac{ {e_{EST} }_{k-1} }{ {e_{EST} }_{k-1}+{e_{MEA} }_{k} }</script><p><strong>分析：</strong></p><ul><li>$e_{EST}&gt;&gt;e_{MEA}：$$K_k$趋近于1，则$\hat{x}_k=\hat{x}_{k-1} +z_k-\hat{x}_{k-1} =z_k$，即估计误差大相信测量值</li><li>$e_{EST}&lt;&lt;e_{MEA}：$$K_k$趋近于0，则$\hat{x}_k=\hat{x}_{k-1} $，测量误差大相信估计值</li></ul><hr><p>【例】卡尔曼滤波的应用举例：</p><ul><li><strong>一般计算卡尔曼滤波分为三步：</strong><ul><li>计算卡尔曼增益：$K_k=\frac{ {e_{EST} }_{k-1} }{ {e_{EST} }_{k-1}+{e_{MEA} }_{k} }$</li><li>计算$\hat{x}_k=\hat{x}_{k-1} +K_k(z_k-\hat{x}_{k-1} )$</li><li>更新${ e_{EST} }_{k}=(1-K_k){e_{EST} }_{k-1}$</li></ul></li></ul><p>已知物体的实际长度为$50mm$，测量误差$e_{MEA}=3mm$，估计误差$e_{MEA}=5mm$，$\hat{x}_0=40mm$，一共测量了13次，根据上面的三个步骤，我们可以计算并画出折线图。</p><p><img src="/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20220401102705574.png" alt="image-20220401102705574"></p><p><img src="/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20220401102555645.png" alt="image-20220401102555645"></p><p>很明显，经过测量次数的增加，最终的估计值是接近真实值的，这就是卡尔曼滤波递归的作用。</p><h2 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h2><p>数据融合(Data Fusion)</p><p>【例】现有两个称，已知它们称的结果都符合正态分布，现去称同一个物体，已知称$A$称得物体重量为$z_1=30g$，并且已知它的标准差为$\sigma_1=2g$；称$B$称得物体重量为$z_2=32g$，并且已知它的标准差为$\sigma_2=4g$；估计该物体的真实重量$\hat{z}_k=?$。</p><p>根据递归的思想：</p><script type="math/tex; mode=display">\hat{z}_k=z_1+K_k(z_2-z_1)，K_k\in[0,1]</script><p>为了求解最接近真实值的$\hat{z}_k$，即求解最优的$K_k$值，使得方差$Var(\hat{z}_k)$最小。</p><script type="math/tex; mode=display">\begin{align}\sigma^2_{\hat{z}_k }&=Var(z_1+K_k(z_2-z_1))\\&=Var(z_1+K_kz_2-K_kz_1)\\&=Var((1-K_k)z_1+K_kz_2)\\&=Var((1-K_k)z_1)+Var(K_kz_2)\\&=(1-K_k)^2Var(z_1)+K_k^2Var(z_2)\\&=(1-K_k)^2\sigma_1^2+K_k^2\sigma_2^2\\\end{align}</script><p>对$K_k$求导：</p><script type="math/tex; mode=display">\frac{d\sigma^2_{\hat{z}_k } }{dK_k}=0\\-2(1-K_k)\sigma_1^2+2K_k\sigma_2^2=0\\K_k=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}</script><p>已知$\sigma_1=2,\sigma_2=4$:</p><script type="math/tex; mode=display">K_k=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}=\frac{4}{4+16}=0.2</script><p>带入：</p><script type="math/tex; mode=display">\begin{align}\hat{z}_k&=z_1+K_k(z_2-z_1)\\&=30+0.2(32-20)\\&=30.4g\end{align}</script><p>对应方差：</p><script type="math/tex; mode=display">\begin{align}\sigma^2_{\hat{z}_k }&=(1-K_k)^2\sigma_1^2+K_k^2\sigma_2^2\\&=(1-0.2)^2*4+0.2^2*16\\&=3.2\\\sigma_{\hat{z}_k }&=\sqrt{3.2} \\&= 1.79\end{align}</script><p>因此，我们根据两个称的特性，根据测量值对物体的真实重量进行了预测，预测值为$30.4g$，而且它是最优解。</p><p>这个过程就是数据融合。</p><p><img src="/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/WeChat%20Image_20220401141112.jpg" alt="WeChat Image_20220401141112"></p><hr><h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>协方差矩阵(Covariance Matrix)，它可以把方差和协方差在一个矩阵中表现出来，体现了变量之间的；联动关系。</p><p>【例】</p><div class="table-container"><table><thead><tr><th style="text-align:center">球员</th><th style="text-align:center">身高x</th><th style="text-align:center">体重y</th><th style="text-align:center">年龄z</th></tr></thead><tbody><tr><td style="text-align:center">瓦尔迪</td><td style="text-align:center">179</td><td style="text-align:center">74</td><td style="text-align:center">33</td></tr><tr><td style="text-align:center">奥巴梅杨</td><td style="text-align:center">187</td><td style="text-align:center">80</td><td style="text-align:center">31</td></tr><tr><td style="text-align:center">萨拉赫</td><td style="text-align:center">175</td><td style="text-align:center">71</td><td style="text-align:center">28</td></tr><tr><td style="text-align:center"><strong>平均值</strong></td><td style="text-align:center"><strong>180.3</strong></td><td style="text-align:center"><strong>75</strong></td><td style="text-align:center"><strong>30.7</strong></td></tr></tbody></table></div><p>分别求三者的方差以及相互之间的协方差，</p><script type="math/tex; mode=display">Var(x)=\sigma_x^2=\frac{1}{n}\sum^n_{i=1}(x_i-\mu)^2=\frac{1}{n}(\sum^n_{i=1}x_i^2-n\mu^2)</script><p>方差：$\sigma_x^2=24.89, \sigma_y^2=14,\sigma_z^2=4.22$，</p><script type="math/tex; mode=display">Cov(X,Y)=E((X-\mu)(Y-v))=E(X·Y)-\mu v</script><p>协方差：$\sigma_x\sigma_y=\sigma_y\sigma_x=18.7,\sigma_x\sigma_z=\sigma_z\sigma_x=4.4,\sigma_y\sigma_z=\sigma_z\sigma_y=3.3$。所以协方差矩阵为：</p><script type="math/tex; mode=display">P=\begin{bmatrix}\sigma_x^2&\sigma_x\sigma_y&\sigma_x\sigma_z\\\sigma_y\sigma_x&\sigma_y^2&\sigma_y\sigma_z\\\sigma_z\sigma_x&\sigma_z\sigma_y&\sigma_z^2\end{bmatrix}=\begin{bmatrix}24.89&18.7&4.4\\18.7&14&3.3\\4.4&3.3&4.22\end{bmatrix}</script><p>可以看出运动员的身高与体重相关性比较大，而身高体重和年龄的相关性是比较小的，这种规律，数据越多越明显。</p><p><strong>如何使用矩阵批量计算协方差矩阵？</strong></p><p>一般需要设置一个过渡矩阵：</p><script type="math/tex; mode=display">a=\begin{bmatrix}x_1&y_1&z_1\\x_2&y_2&z_2\\x_3&y_3&z_3\end{bmatrix}-\frac{1}{3}\begin{bmatrix}1&1&1\\\1&1&1\\1&1&1\end{bmatrix}\begin{bmatrix}x_1&y_1&z_1\\x_2&y_2&z_2\\x_3&y_3&z_3\end{bmatrix}</script><p>协方差：</p><script type="math/tex; mode=display">P=\frac{1}{3}a^Ta</script><h2 id="状态空间表达式"><a href="#状态空间表达式" class="headerlink" title="状态空间表达式"></a>状态空间表达式</h2><p>【例】：有一个弹簧阻尼系统，对质量为$m$的物块施加一个力$F$，弹簧向右的位移量为$x$，已知弹簧的胡克系数为$k$，阻尼系数为$B$</p><p><img src="/2022/04/01/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20220401152419675.png" alt="image-20220401152419675"></p><p>定义输入为$u_{(t)}=F_{(t)}$，输出为$x$</p><p>由胡克定律可知，弹簧拉力$f_k$以及阻力$f_B$：</p><script type="math/tex; mode=display">f_k=kx\\f_B=B\dot{x}</script><p>根据牛顿第二定律$F=ma$：</p><script type="math/tex; mode=display">\begin{align}&m\ddot{x}=F-f_k-f_B\\&m\ddot{x}+f_B+f_k=F\\&m\ddot{x}+B\dot{x}+kx=F\end{align}</script><p>所以系统的动态方程表达式：</p><script type="math/tex; mode=display">m\ddot{x}+B\dot{x}+kx=F</script><p>使用经典控制理论可以对上式进行拉普拉斯变换，进而求得系统的传递函数：</p><script type="math/tex; mode=display">ms^2X_{(s)}+BsX_{(s)}+kX_{(s)}=F_{(s)}\\G_{(s)}=\frac{X_{(s)} }{F_{(s)} }=\frac{1}{ms^2+Bs+K}</script><p>但在现代控制理论中则更多的使用状态空间方程，状态空间方程可以看成一个集合，它包含系统的输入、系统的输出以及状态变量，最终使用一个一阶微分方程的形式表达出来。</p><p>即：</p><script type="math/tex; mode=display">m\ddot{x}+B\dot{x}+kx=u</script><p>确定两个合适的状态变量，把二阶项消除：</p><ul><li>位置：$z_1=x=x_1$</li><li>速度：$z_2=\dot{x}=x_2$</li></ul><p>由于$x_1=x，x_2=\dot{x}$，因此可以得到：$\dot{x_1}=x_2，\dot{x_2}=\ddot{x}$，利用上述方程化简：</p><script type="math/tex; mode=display">\begin{align}\dot{x_1}=x_2\\\dot{x_2}=\ddot{x}&=\frac{1}{m}\mu-\frac{B}{m}\dot{x}-\frac{k}{m}x\\&=\frac{1}{m}\mu-\frac{B}{m}x_2-\frac{k}{m}x_1\end{align}</script><p>综合上面的四个方程：</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x_1}\\\dot{x_2}\end{bmatrix}=\begin{bmatrix}0&1\\-\frac{K}{m}&-\frac{B}{m}\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\\ \frac{1}{m}\end{bmatrix}u</script><script type="math/tex; mode=display">\begin{bmatrix}z_1\\z_2\end{bmatrix}=\begin{bmatrix}1&0\\0&1\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}</script><p>进一步归纳：</p><p>连续型：</p><script type="math/tex; mode=display">\dot{X}_{(t)}=AX_{(t)}+Bu_{(t)}\\Z_{(t)}=HX_{(t)}</script><p>离散型：</p><script type="math/tex; mode=display">{X_k }=AX_{k-1}+Bu_{k}\\Z_{k}=HX_{k}</script><p>其中$k$表示采样时间单位。</p><p>由于现实中存在着不确定性，比如存在过程噪声(Process Noise)：$w_{k}$，测量噪声(Measurement Noise)：$v_k$</p><script type="math/tex; mode=display">\begin{align}{X_k }&=AX_{k-1}+Bu_{k}+w_{k}\\Z_{k}&=HX_{k}+v_k\end{align}</script><p>因此，我们的模型和测量都存在误差，导致计算值以及测量值都是不准确的，如何通过两个不确定的值去估计一个准确的值$\hat{x}_k=?$，根据数据融合的例子，我们可以使用这两个不准确的结果进行数据融合，从而得到一个比较准确的估计值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;卡尔曼滤波（Kalman filter）是一种高效率的&lt;strong&gt;递归滤波器&lt;/strong&gt;（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch9_设计前端</title>
    <link href="http://lukeyalvin.top/2022/03/30/%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%AB%AF/"/>
    <id>http://lukeyalvin.top/2022/03/30/%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%AB%AF/</id>
    <published>2022-03-30T11:33:12.913Z</published>
    <updated>2022-03-31T07:26:59.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本次实践将前几章内容结合进来，实际书写一个视觉里程计程序，由于单目相机存在初始化问题以及尺度问题，因此本实践采用的是最简单的RGB-D相机，但是使用的也只是RGB-D数据集，而非真正的RGB-D相机。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="一、搭建VO框架"><a href="#一、搭建VO框架" class="headerlink" title="一、搭建VO框架"></a>一、搭建VO框架</h1><h2 id="1-1-确定程序基本框架"><a href="#1-1-确定程序基本框架" class="headerlink" title="1.1 确定程序基本框架"></a>1.1 确定程序基本框架</h2><h3 id="项目目录框架"><a href="#项目目录框架" class="headerlink" title="项目目录框架"></a>项目目录框架</h3><p>在编写一个小规模的库时，我们通常会建立一些文件夹，把源代码、头文件、文档、测试数据、配置文件、日志等等分类存放，这样会显得很有条理。如果一个库内容很多，我们还会把代码分解各个独立的小模块，以便测试。</p><p>我们的工程目录如下：</p><ul><li><p><strong>bin：</strong>用来存放可执行的二进制文件；</p></li><li><p><strong>include/myslam：</strong> 存放 slam 模块的头文件，主要是<code>.h</code>。这种做法的理由是，当你把包含目录设到 include 时，在引用自己的头文件时，需要写<code>include ”myslam/xxx.h”</code>，这样不容易和别的库混淆。</p></li><li><p><strong>src：</strong>存放源代码文件，主要是 cpp；</p></li><li><p><strong>lib：</strong> 存放编译好的库文件；</p></li><li><p><strong>build：</strong>存放执行编译操作生成的中间文件；</p></li><li><p><strong>config：</strong> 存放配置文件；</p></li><li><p><strong>cmake_modules：</strong> 第三方库的 cmake 文件，在使用 g2o 之类的库中会用到它</p></li><li><p><strong>test：</strong> 存放测试用的文件，也是 cpp</p></li><li><strong>dataset：</strong>存放我们使用的RGB-D数据集</li><li><strong>tools：</strong>这里是对数据集操作用的python文件</li></ul><p><img src="/2022/03/30/%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%AB%AF/image-20220330203310388.png" alt="image-20220330203310388"></p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p><strong>帧：</strong>一个帧是相机采集到的图像单位。它主要包含一个图像（RGB-D 情形下是一对图像）。此外，还有特征点、位姿、内参等信息。在视觉 SLAM 中我们会谈论关键帧（Key-frame），通常的做法是把某些我们认为更重要的帧保存起来，并认为相机轨迹就可以用这些关键帧来描述。关键帧如何选择是一个很大的问题，而且基于工程经验，很少有理论上的指导。</p><p><strong>路标：</strong>路标点即图像中的特征点。当相机运动之后，我们还能估计它们的 3D 位置。通常，会把路标点放在一个地图当中，并将新来的帧与地图中的路标点进行匹配，估计相机位姿。</p><h2 id="1-2-基本类的实现"><a href="#1-2-基本类的实现" class="headerlink" title="1.2 基本类的实现"></a>1.2 基本类的实现</h2><p>刚开始的阶段。我们一共写五个类：Frame 为帧，Camera 为相机模型，MapPoint 为特征点/路标点，Map<br>管理特征点，Config 提供配置参数。</p><p><img src="/2022/03/30/%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%AB%AF/image-20220330200432411.png" alt="image-20220330200432411"></p><p>每个类对应一个头文件，一个源文件，由于许多类会引用很多头文件，所以我们不妨直接写一个头文件专门存放头文件，让所有的头文件都引这个头文件。当然，这个头文件里的内容是不断填充的，现在就以直接给出的形式呈现。</p><p><strong>WL_SLAM_VO/include/myslam/common_include.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_INCLUDE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_INCLUDE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for Eigen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Eigen::Vector2d;</span><br><span class="line"><span class="keyword">using</span> Eigen::Vector3d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for Sophus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/se3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/so3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Sophus::SE3;</span><br><span class="line"><span class="keyword">using</span> Sophus::SO3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for cv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> cv::Mat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="Camera类"><a href="#Camera类" class="headerlink" title="Camera类"></a>Camera类</h3><p>Camera 类存储相机的内参和外参，并完成相机坐标系、像素坐标系、和世界坐标系之间的坐标变换。当然，在世界坐标系中你需要一个相机的（变动的）外参，我们以参数的形式传入。</p><p><strong>WL_SLAM_VO/include/myslam/Camera.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们用命名空间 namespace myslam </span></span><br><span class="line"><span class="comment">将类定义包裹起来命名空间可以防止我们不小心定义出别的库里同名的函数，也是一种比较安全和规范的做法。*/</span> </span><br><span class="line"><span class="keyword">namespace</span> mysalm</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 把智能指针定义成 Camera 的指针类型，因此以后在传递参数时，只需用 Camera::Ptr 类型即可</span></span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Camera&gt; Ptr;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> fx_, fy_, cx_, cy_, depth_scale_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="keyword">float</span> fx,<span class="keyword">float</span> fy,<span class="keyword">float</span> cx,<span class="keyword">float</span> cy, <span class="keyword">float</span> depth_scale) : </span><br><span class="line">        <span class="built_in">fx_</span>(fx),<span class="built_in">fy_</span>(fy),<span class="built_in">cx_</span>(cx),<span class="built_in">cy_</span>(cy),<span class="built_in">depth_scale_</span>(depth_scale)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标变换</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">world2camera</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">camera2world</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">    <span class="function">Vector2d <span class="title">camera2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c)</span></span>;</span><br><span class="line">    <span class="function">Vector2d <span class="title">pixel2camera</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">pixel2world</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">const</span> SE3 &amp;T_c_w, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">world2pixel</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>智能指针：std::shared_ptr</p><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p><p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。</p></blockquote><p><strong>WL_SLAM_VO/src/camera.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line">    Camera::<span class="built_in">Camera</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::world2camera</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T_c_w * p_w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::camera2world</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T_c_w.<span class="built_in">inverse</span>() * p_c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2d <span class="title">Camera::camera2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2d</span>(</span><br><span class="line">            fx_ * <span class="built_in">p_c</span>(<span class="number">0</span>, <span class="number">0</span>) / <span class="built_in">p_c</span>(<span class="number">2</span>, <span class="number">0</span>) + cx_,  <span class="comment">// u = fx*X/Z+cx</span></span><br><span class="line">            fx_ * <span class="built_in">p_c</span>(<span class="number">1</span>, <span class="number">0</span>) / <span class="built_in">p_c</span>(<span class="number">2</span>, <span class="number">0</span>) + cy_); <span class="comment">// v = fy*Y/Z+cy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::pixel2camera</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector3d</span>(</span><br><span class="line">            (<span class="built_in">p_p</span>(<span class="number">0</span>, <span class="number">0</span>) - cx_) * depth / fx_, <span class="comment">// X = (u-cx)*Z/fx</span></span><br><span class="line">            (<span class="built_in">p_p</span>(<span class="number">1</span>, <span class="number">0</span>) - cy_) * depth / fy_, <span class="comment">// Y = (v-cy)*Z/fy</span></span><br><span class="line">            depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::pixel2world</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">const</span> SE3 &amp;T_c_w, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">camera2world</span>(<span class="built_in">pixel2camera</span>(p_p, depth), T_c_w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2d <span class="title">Camera::world2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">camera2pixel</span>(<span class="built_in">world2camera</span>(p_w, T_c_w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Frame类"><a href="#Frame类" class="headerlink" title="Frame类"></a>Frame类</h3><p>由于 Frame 类是基本数据单元，在许多地方会用到它，但现在初期设计阶段，我们还不清楚以后可能新加的内容。所以这里的 Frame 类只提供基本的数据存储和接口。如果之后有新增的内容，我们就继续往里添加。</p><p><strong>WL_SLAM_VO/include/myslam/frame.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FRAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME</span></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 提前声明MapPoint类，需要用到帧的关键点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapPoint</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Frame&gt; Ptr; <span class="comment">// 定义Frame类的智能指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> id_;                  <span class="comment">// 图像帧的id编号</span></span><br><span class="line">    <span class="keyword">double</span> time_stamp_;                 <span class="comment">// 图像帧被记录的时间戳</span></span><br><span class="line">    SE3 T_c_w_;                         <span class="comment">// 世界坐标系到相机坐标系的变换矩阵</span></span><br><span class="line">    Camera::Ptr camera_;                <span class="comment">//针孔RGB-D相机模型</span></span><br><span class="line">    Mat color_, depth_;                 <span class="comment">// 彩色图以及图像深度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frame</span>();</span><br><span class="line">    <span class="built_in">Frame</span>(<span class="keyword">long</span> id, <span class="keyword">double</span> time_stamp=<span class="number">0</span>, SE3 T_c_w=<span class="built_in">SE3</span>(), Camera::Ptr=<span class="literal">nullptr</span>,</span><br><span class="line">        Mat color = <span class="built_in">Mat</span>(),Mat depth = <span class="built_in">Mat</span>() );</span><br><span class="line">    ~<span class="built_in">Frame</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建帧</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Frame::Ptr <span class="title">creatFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 寻找给定点对应的深度 </span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findDepth</span><span class="params">(<span class="keyword">const</span> cv::KeyPoint &amp;kp)</span></span>;</span><br><span class="line">    <span class="comment">// 获取相机光心</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">getCamCenter</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 判断某个点是否在视野内</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInFrame</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;pt_world)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>WL_SLAM_VO/src/frame.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/frame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造与析构</span></span><br><span class="line">Frame::<span class="built_in">Frame</span>() : <span class="built_in">id_</span>(<span class="number">-1</span>),<span class="built_in">time_stamp_</span>(<span class="number">-1</span>),<span class="built_in">camera_</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">Frame::<span class="built_in">Frame</span> ( <span class="keyword">long</span> id, <span class="keyword">double</span> time_stamp, SE3 T_c_w, Camera::Ptr camera, Mat color, Mat depth )</span><br><span class="line">: <span class="built_in">id_</span>(id), <span class="built_in">time_stamp_</span>(time_stamp), <span class="built_in">T_c_w_</span>(T_c_w), <span class="built_in">camera_</span>(camera), <span class="built_in">color_</span>(color), <span class="built_in">depth_</span>(depth)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Frame::~<span class="built_in">Frame</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Frame</span></span><br><span class="line"><span class="function">Frame::Ptr <span class="title">Frame::creatFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> factory_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Frame::<span class="built_in">Ptr</span>( <span class="keyword">new</span> <span class="built_in">Frame</span>(factory_id++) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找给定点对应的深度</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Frame::findDepth</span><span class="params">(<span class="keyword">const</span> cv::KeyPoint &amp;kp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得像素点的坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">cvRound</span>(kp.pt.x);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">cvRound</span>(kp.pt.y);</span><br><span class="line">    <span class="comment">// 得到像素点的深度</span></span><br><span class="line">    ushort d = depth_.ptr&lt;ushort&gt;(y)[x];</span><br><span class="line">    <span class="keyword">if</span>(d != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in"><span class="keyword">double</span></span>(d)/camera_-&gt;depth_scale_;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果该像素深度为0，则选择附近的点作为参考</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            d = depth_.ptr&lt;ushort&gt;(y+dy[i])[x+dx[i]];</span><br><span class="line">            <span class="keyword">if</span>(d != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in"><span class="keyword">double</span></span>(d)/camera_-&gt;depth_scale_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取相机光心</span></span><br><span class="line"><span class="function">Vector3d <span class="title">Frame::getCamCenter</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//相机坐标系的（0,0,0）在世界坐标系下的位置</span></span><br><span class="line">    <span class="keyword">return</span> T_c_w_.<span class="built_in">inverse</span>().<span class="built_in">translation</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断某个点是否在视野内</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Frame::isInFrame</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;pt_world)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将世界坐标系下的点转换为相机坐标系</span></span><br><span class="line">    Vector3d p_cam = camera_-&gt;<span class="built_in">world2camera</span>(pt_world,T_c_w_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">p_cam</span>(<span class="number">2.0</span>)&lt;<span class="number">0</span>) <span class="comment">// Z小于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Vector2d pixel = camera_-&gt;<span class="built_in">world2pixel</span>(pt_world,T_c_w_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pixel</span>(<span class="number">0</span>,<span class="number">0</span>)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">1</span>,<span class="number">0</span>)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">0</span>,<span class="number">0</span>)&lt;color_.cols </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;color_.rows;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br></pre></td></tr></table></figure><h3 id="MapPoint-类"><a href="#MapPoint-类" class="headerlink" title="MapPoint 类"></a>MapPoint 类</h3><p><strong>WL_SLAM_VO/include/myslam/mappoint.h</strong></p><p>MapPoint 表示路标点。我们将估计它的世界坐标，并且我们会拿当前帧提取到的特征点与地图中的路标点匹配，来估计相机的运动，因此还需要存储它对应的描述子。此外，我们会记录一个点被观测到的次数和被匹配到的次数，作为评价它的好坏程度的指标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><p><strong>WL_SLAM_VO/include/myslam/map.h</strong></p><p>Map 类管理着所有的路标点，并负责添加新路标、删除不好的路标等工作。VO 的匹配过程只需要和 Map 打交道即可。当然 Map 也会有很多操作，但现阶段我们只定义主要的数据结构。</p><p><strong>WL_SLAM_VO/src/map.h</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本次实践将前几章内容结合进来，实际书写一个视觉里程计程序，由于单目相机存在初始化问题以及尺度问题，因此本实践采用的是最简单的RGB-D相机，但是使用的也只是RGB-D数据集，而非真正的RGB-D相机。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch8_RGB-D直接法实践</title>
    <link href="http://lukeyalvin.top/2022/03/29/RGB-D%E7%9B%B4%E6%8E%A5%E6%B3%95%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lukeyalvin.top/2022/03/29/RGB-D%E7%9B%B4%E6%8E%A5%E6%B3%95%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-03-29T08:19:56.968Z</published>
    <updated>2022-03-30T08:57:10.305Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>此次实践使用RGB-D相机主要是因为它省略掉了深度的恢复部分，如果使用单目相机，则需要进行深度的恢复，在之前的实践内容中，我们使用单目相机主要是采用基于特征点的深度恢复，后面会介绍相应的基于块匹配的深度恢复。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="一、直接法"><a href="#一、直接法" class="headerlink" title="一、直接法"></a>一、直接法</h1><p>直接法根据空间点$P$的来源不同，对应不同的直接法。</p><ul><li>稀疏直接法</li></ul><p>若$P$来自于稀疏关键点，我们称之为稀疏直接法。通常我们使用数百个至上千个关键点，并且像 $L-K $光流那样，假设它周围像素也是不变的。这种稀疏直接法不必计算描述子，并且只使用数百个像素，因此速度最快，但只能计算稀疏的重构。</p><ul><li>半稠密（Semi-Dense）的直接法</li></ul><p>如果像素梯度为零，整一项雅可比就为零，不会对计算运动增量有任何贡献。因此，可以考虑只使用带有梯度的像素点，舍弃像素梯度不明显的地方。</p><script type="math/tex; mode=display">J=-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><ul><li>稠密直接法</li></ul><p>稠密重构需要计算所有像素（一般几十万至几百万个），因此多数不能在现有的 CPU 上实时计算，需要 GPU 的加速。但是，如前面所讨论的，梯度不明显的点，在运动估计中不会有太大贡献，在重构时也会难以估计位置。</p><blockquote><p>稀疏到稠密重构，都可以用直接法来计算。它们的计算量是逐渐增长的。<strong>稀疏方法可以快速地求解相机位姿，而稠密方法可以建立完整地图。</strong>具体使用哪种方法，需要视机器人的应用环境而定。特别地，在低端的计算平台上，稀疏直接法可以做到非常快速的效果，适用于实时性较高且计算资源有限的场合</p></blockquote><h1 id="二、稀疏直接法"><a href="#二、稀疏直接法" class="headerlink" title="二、稀疏直接法"></a>二、稀疏直接法</h1><p>由于求解直接法最后等价于求解一个优化问题，因此我们可以使用$ g2o$ 或$ Ceres $这些优化库帮助我们求解。本节以 $g2o $为例设计实验，在使用 $g2o$之前，需要把直接法抽象成一个图优化问题。显然，直接法是由以下顶点和边组成的：</p><ul><li>优化变量</li></ul><p>优化变量为<strong>一个相机位姿</strong>，因此需要一个位姿顶点。由于我们在推导中使用了李代数，故程序中使用李代数表达的 $SE(3) $位姿顶点。可以使用“Ver-texSE3Expmap”作为相机位姿。</p><ul><li>误差项</li></ul><p>误差项为单个像素的<strong>光度误差</strong>。由于整个优化过程中 $I_1 (p_1 ) $保持不变，我们可以把它当成一个固定的预设值，然后调整相机位姿，使 $I_2 (p_2 )$ 接近这个值。于是，这种边只连接一个顶点，为一元边。由于 $g2o $中本身没有计算光度误差的边，我们需要自己定义一种新的边。</p><h2 id="2-1-构建直接法的边"><a href="#2-1-构建直接法的边" class="headerlink" title="2.1 构建直接法的边"></a>2.1 构建直接法的边</h2><p>直接法的边表示的光度误差，它是一个一元边，定义边的格式之前已经叙述，主要是对<code>virtual void computeError()</code>和<code>virtual void linearizeOplus()</code>两个函数进行重写。我们分别介绍。</p><h3 id="光度误差类的定义"><a href="#光度误差类的定义" class="headerlink" title="光度误差类的定义"></a>光度误差类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义直接法的边(光度误差的边),它是一个一元边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3ProjectDirect</span> :</span> <span class="keyword">public</span> BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="title">EdgeSE3ProjectDirect</span><span class="params">(Eigen::Vector3d point, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, cv::Mat *image)</span> : x_world_(point), fx_(fx), fy_(fy), cx_(cx), cy_(cy), image_(image)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolread</span><span class="params">(istream &amp;in)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 从参考图像中获取灰度值（双线性插值）</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Eigen::Vector3d x_world_;                 <span class="comment">// 世界坐标系中的3D点</span></span><br><span class="line">    <span class="keyword">float</span> cx_ = <span class="number">0</span>, cy_ = <span class="number">0</span>, fx_ = <span class="number">0</span>, fy_ = <span class="number">0</span>; <span class="comment">// 相机内参</span></span><br><span class="line">    cv::Mat *image_ = <span class="literal">nullptr</span>;                <span class="comment">//参考图像</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们的边继承自 <code>g2o::BaseUnaryEdge</code>。在继承时，需要在模板参数里填入测量值的维度、类型，以及连接此边的顶点，同时，我们把空间点 P 、相机内参和图像存储在该边的成员变量中。为了让 g2o 优化该边对应的误差，我们需要覆写两个虚函数：用 <code>computeError()</code>计算误差值，用<code>linearizeOplus()</code>计算雅可比。</p><h3 id="getPixelValue"><a href="#getPixelValue" class="headerlink" title="getPixelValue"></a>getPixelValue</h3><p>为了更精细地计算像素亮度，我们要对图像进行插值。我们这里采用了简单的双线性插值，也可以使用更复杂的插值方式，但计算代价可能会变高一些。</p><p>所以，相比之前的边的定义，这里多了一个函数<code>inline float getPixelValue(float x, float y);</code>，它的作用是从参考图像中获取灰度值，利用的是OpenCV中的双线性插值法，我们先书写它的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从参考图像中获取灰度值（双线性插值）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar *data = &amp;image_-&gt;data[<span class="built_in"><span class="keyword">int</span></span>(y) * image_-&gt;step + <span class="built_in"><span class="keyword">int</span></span>(x)];</span><br><span class="line">    <span class="keyword">float</span> xx = x - <span class="built_in">floor</span>(x);</span><br><span class="line">    <span class="keyword">float</span> yy = y - <span class="built_in">floor</span>(y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">float</span></span>(</span><br><span class="line">    (<span class="number">1</span> - xx) * (<span class="number">1</span> - yy) * data[<span class="number">0</span>] +</span><br><span class="line">    xx * (<span class="number">1</span> - yy) * data[image_-&gt;step] +</span><br><span class="line">    (<span class="number">1</span> - xx) * yy * data[image_-&gt;step + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释待理解……</p><h3 id="computeError"><a href="#computeError" class="headerlink" title="computeError"></a>computeError</h3><p>由前文可知，误差项为单个像素的<strong>光度误差</strong>。由于整个优化过程中 $I_1 (p_1 ) $保持不变，我们可以把它当成一个固定的预设值，然后调整相机位姿，使 $I_2 (p_2 )$ 接近这个值。<code>virtual void computeError()</code>这个函数则是使用该边连接的节点和观测值来计算误差。</p><p>程序中的误差计算里，使用了$ I_2 (p_2 ) − I_1 (p_1 )$ 的形式，因此前面的负号可以省去，只需把像素梯度乘以像素到李代数的梯度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line"><span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> VertexSE3Expmap *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    Eigen::Vector3d x_local = v-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(x_world_); <span class="comment">//.map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">    <span class="comment">// 获得像素坐标</span></span><br><span class="line">    <span class="keyword">float</span> x = x_local[<span class="number">0</span>] * fx_ / x_local[<span class="number">2</span>] + cx_; <span class="comment">// x(u) = (X * fx)/Z + cx</span></span><br><span class="line">    <span class="keyword">float</span> y = x_local[<span class="number">1</span>] * fy_ / x_local[<span class="number">2</span>] + cy_; <span class="comment">// y(v) = (Y * fy)/Z + cy</span></span><br><span class="line">    <span class="comment">// 检查该像素点是否在图像内</span></span><br><span class="line">    <span class="keyword">if</span> (x - <span class="number">4</span> &lt; <span class="number">0</span> || (x + <span class="number">4</span>) &gt; image_-&gt;cols || (y - <span class="number">4</span>) &lt; <span class="number">0</span> || (y + <span class="number">4</span>) &gt; image_-&gt;rows)</span><br><span class="line">    &#123;</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setLevel</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = <span class="built_in">getPixelValue</span>(x, y) - _measurement; <span class="comment">// 光度误差，像素的亮度误差，或者是灰度值误差</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linearizeOplus"><a href="#linearizeOplus" class="headerlink" title="linearizeOplus"></a>linearizeOplus</h3><p>这个函数主要是计算雅克比矩阵，它是可选的，如果给出了则进行解析求导，不给则进行数值求导。我们直接在直接法的推导中已经介绍了该矩阵的计算，下面是推导结论，因此直接根据公式书写代码即可。</p><p>由直接法的推导可知：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial u}{\partial \delta \xi}&=\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}=\begin{bmatrix}\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}&-\frac{f_xXY}{Z^{2}}&f_x+\frac{f_xX^2}{Z^{2}}&-\frac{f_xY}{Z}\\0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}&-f_y-\frac{f_yY^{2}}{Z^{2}}&\frac{f_yXY}{Z}&\frac{f_yX}{Z}\end{bmatrix}\end{align}</script><p>最终的约旦矩阵为：</p><script type="math/tex; mode=display">J=-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><p>由于上面的误差使用的是$ I_2 (p_2 ) − I_1 (p_1 )$ 的形式，所以：</p><script type="math/tex; mode=display">J=\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">level</span>() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _jacobianOplusXi = Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt;::<span class="built_in">Zero</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">    VertexSE3Expmap *vtx = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 将世界坐标系下的三维点的估计转换成相机坐标系下</span></span><br><span class="line">    Eigen::Vector3d xyz_trans = vtx-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(x_world_);</span><br><span class="line">    <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];          <span class="comment">// X</span></span><br><span class="line">    <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];          <span class="comment">// Y</span></span><br><span class="line">    <span class="keyword">double</span> invz = <span class="number">1.0</span> / xyz_trans[<span class="number">2</span>]; <span class="comment">// 1/Z</span></span><br><span class="line">    <span class="keyword">double</span> invz_2 = invz * invz;      <span class="comment">// 1/Z^2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> u = x * fx_ * invz + cx_; <span class="comment">// u = (X*fx)/Z+cx</span></span><br><span class="line">    <span class="keyword">float</span> v = v * fy_ * invz + cy_; <span class="comment">// v = (Y*fy)/Z+cy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先求投影方程关于变换的导数 ∂u/∂δξ</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">6</span>&gt; jacobian_uv_ksai;</span><br><span class="line">    <span class="comment">// g2o 是旋转在前，平移在后；</span></span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">0</span>) = -x * y * fx_ * invz_2;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">1</span>) = (<span class="number">1</span> + x * x * invz_2) * fx_;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">2</span>) = -fx_ * y * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">3</span>) = fx_ * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">6</span>) = -fx_ * x * invz_2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">0</span>) = -(<span class="number">1</span> + y * y * invz_2) * fy_;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">1</span>) = fy_ * x * y * invz_2;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">2</span>) = fy_ * x * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">4</span>) = fy_ * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">5</span>) = -y * invz_2 * fy_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像素的梯度 ∂I2/∂u</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; jacobian_pixel_uv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jacobian_pixel_uv</span>(<span class="number">0</span>, <span class="number">0</span>) = (<span class="built_in">getPixelValue</span>(u + <span class="number">1</span>, v) - <span class="built_in">getPixelValue</span>(u - <span class="number">1</span>, v)) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">jacobian_pixel_uv</span>(<span class="number">0</span>, <span class="number">1</span>) = (<span class="built_in">getPixelValue</span>(u, v + <span class="number">1</span>) - <span class="built_in">getPixelValue</span>(u, v - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// J矩阵 = ∂I2/∂u * ∂u/∂δξ</span></span><br><span class="line">    _jacobianOplusXi = jacobian_pixel_uv*jacobian_uv_ksai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-直接法估计相机运动"><a href="#2-2-直接法估计相机运动" class="headerlink" title="2.2 直接法估计相机运动"></a>2.2 直接法估计相机运动</h2><p>在使用直接法估计相机运动时，我们用过g2o对相机的位姿进行优化，其中的观测值为世界坐标系下的3D点坐标以及对应的灰度值，因此我们使用一个结构体<code>Measurement</code>用来存储观测值，由于需要用到相机坐标系之间的变换，所以还需要写坐标变换相关的函数。</p><h3 id="Measurement结构体"><a href="#Measurement结构体" class="headerlink" title="Measurement结构体"></a>Measurement结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Measurement</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Measurement</span>(Eigen::Vector3d p, <span class="keyword">float</span> g) : <span class="built_in">pos_world</span>(p), <span class="built_in">grayscale</span>(g) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d pos_world;</span><br><span class="line">    <span class="keyword">float</span> grayscale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="project2Dto3D"><a href="#project2Dto3D" class="headerlink" title="project2Dto3D"></a>project2Dto3D</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将像素坐标系转换为世界坐标系</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector3d <span class="title">project2Dto3D</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> zz = <span class="built_in"><span class="keyword">float</span></span>(d) / scale;</span><br><span class="line">    <span class="keyword">float</span> xx = zz * (x - cx) / fx; <span class="comment">// X = Z*(u-cx)/fx</span></span><br><span class="line">    <span class="keyword">float</span> yy = zz * (y - cy) / fy; <span class="comment">// Y = Z*(u-cy)/fy</span></span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector3d</span>(xx, yy, zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="project3Dto2D"><a href="#project3Dto2D" class="headerlink" title="project3Dto2D"></a>project3Dto2D</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将世界坐标系转换为像素坐标系</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector2d <span class="title">project3Dto2D</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> u = fx * x / z + cx; <span class="comment">// u = fx*X/Z + cx</span></span><br><span class="line">    <span class="keyword">float</span> v = fy * y / z + cy; <span class="comment">// v = fy*Y/Z + cy</span></span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector2d</span>(u, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poseEstimationDirect"><a href="#poseEstimationDirect" class="headerlink" title="poseEstimationDirect"></a>poseEstimationDirect</h3><p>这是最主要的一个函数，用直接法估计相机运动，并使用了g2o对位姿进行优化。<strong>相比于特征点法，直接法完全依靠优化来求解相机位姿。</strong></p><p>原理就是以第一个图像为参考帧，然后用直接法求解后续图像的位姿。在参考帧中，对第一张图像提取 FAST 关键点（不需要描述子），并使用直接法估计这些关键点在第二个图像中的位置，以及第二个图像的相机位姿。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用直接法估计相机运动(使用非线性BA优化)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">poseEstimationDirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Measurement&gt; &amp;measurements, <span class="comment">// 测量值：一个世界坐标系下三维点与一个灰度值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Mat *gray,                          <span class="comment">// 灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Eigen::Matrix3f &amp;K,                     <span class="comment">// 相机参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Eigen::Isometry3d &amp;Tcw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">1</span>&gt;&gt; DirectBlock;</span><br><span class="line">    <span class="comment">// 1.创建线性求解器 LinearSolverDense使用dense cholesky分解法</span></span><br><span class="line">    DirectBlock::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;DirectBlock::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.创建矩阵块求解器，用上面我们定义的线性求解器LinearSolver来初始化。</span></span><br><span class="line">    DirectBlock *solver_ptr = <span class="keyword">new</span> <span class="built_in">DirectBlock</span>(std::unique_ptr&lt;DirectBlock::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;DirectBlock&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4.创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.定义图的顶点和边</span></span><br><span class="line">    <span class="comment">// 顶点(待优化变量，这里是相机位姿)</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    <span class="comment">// 设置待优化位姿旋转(Rotation)(角轴或四元素表示)、平移(Translation)</span></span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(Tcw.<span class="built_in">rotation</span>(), Tcw.<span class="built_in">translation</span>()));</span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边(误差，这里是光影误差)</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Measurement m : measurements)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeSE3ProjectDirect *edge = <span class="keyword">new</span> <span class="built_in">EdgeSE3ProjectDirect</span>(</span><br><span class="line">            m.pos_world,</span><br><span class="line">            <span class="built_in">K</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">K</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">K</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="built_in">K</span>(<span class="number">1</span>, <span class="number">2</span>), gray);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, pose);                                      <span class="comment">// 定义顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(m.grayscale);                             <span class="comment">// 定义观测值</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>()); <span class="comment">// 定义协方差矩阵的逆</span></span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(id++);</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图中的边的个数：&quot;</span> &lt;&lt; optimizer.<span class="built_in">edges</span>().<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 6.开始优化</span></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>); <span class="comment">// 迭代次数</span></span><br><span class="line">    <span class="comment">// 优化后的相机位姿</span></span><br><span class="line">    Tcw = pose-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-主函数"><a href="#2-3-主函数" class="headerlink" title="2.3 主函数"></a>2.3 主函数</h2><p>整个主函数的顺序需要了解</p><ul><li>首先是一些判断或者一些初始化</li><li>然后我们对数据集循环操作每一张图片，但是第一张图像为参考，对后续图像和参考图像做直接法</li><li>对第一张图提取Fast关键点（不需要描述子）</li><li>使用直接法估计这些关键点在第二个图像中的位置，以及第二个图像的相机位姿</li><li>最后就是绘制这些特征点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;usage: useLK path_to_dataset&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    string path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    string assciate_file = path_to_dataset + <span class="string">&quot;/assciate.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(assciate_file)</span></span>;</span><br><span class="line">    string rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    cv::Mat color, depth, gray;</span><br><span class="line">    vector&lt;Measurement&gt; measurements;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">float</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">float</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">float</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">float</span> depth_scale = <span class="number">1000.0</span>;</span><br><span class="line">    Eigen::Matrix3f K;</span><br><span class="line">    K &lt;&lt; fx, <span class="number">0.f</span>, cx, <span class="number">0.f</span>, fy, cy, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Isometry3d Tcw = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line">    cv::Mat prev_color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们以第一个图像为参考，对后续图像和参考图像做直接法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*********** loop &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">        fin &gt;&gt; time_rgb &gt;&gt; rgb_file &gt;&gt; time_depth &gt;&gt; depth_file;</span><br><span class="line">        color = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + rgb_file);</span><br><span class="line">        depth = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + depth_file, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (color.data == <span class="literal">nullptr</span> || depth.data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环</span></span><br><span class="line">        <span class="comment">// 将BGR格式(color)转换成灰度图片(gray)</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(color, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;cv::KeyPoint&gt; keypoints;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">            <span class="comment">// 使用Fast特征点检测，讲检测后的特征点存入容器keypoints中</span></span><br><span class="line">            detector-&gt;<span class="built_in">detect</span>(color, keypoints);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉邻近边缘处的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (kp.pt.x &lt; <span class="number">20</span> || kp.pt.y &lt; <span class="number">20</span> || (kp.pt.x + <span class="number">20</span>) &gt; color.cols || (kp.pt.y + <span class="number">20</span>) &gt; color.rows)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环</span></span><br><span class="line">                <span class="comment">// d指定到depth矩阵的y行第x列个像素</span></span><br><span class="line">                ushort d = depth.ptr&lt;ushort&gt;(<span class="built_in">cvRound</span>(kp.pt.y))[<span class="built_in">cvRound</span>(kp.pt.x)];</span><br><span class="line">                <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 将像素坐标系转换为世界坐标系</span></span><br><span class="line">                Eigen::Vector3d p3p = <span class="built_in">project2Dto3D</span>(kp.pt.x, kp.pt.y, d, fx, fy, cx, cy, depth_scale);</span><br><span class="line">                <span class="comment">// grayscale指定到gray矩阵的y行第x列个像素</span></span><br><span class="line">                <span class="keyword">float</span> grayscale = <span class="built_in"><span class="keyword">float</span></span>(gray.<span class="built_in">ptr</span>(<span class="built_in">cvRound</span>(kp.pt.y))[<span class="built_in">cvRound</span>(kp.pt.x)]);</span><br><span class="line">                <span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line">                measurements.<span class="built_in">push_back</span>(<span class="built_in">Measurement</span>(p3p, grayscale));</span><br><span class="line">            &#125;</span><br><span class="line">            prev_color = color.<span class="built_in">clone</span>();</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;add total &quot;</span>&lt;&lt;measurements.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; measurements.&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.对后续图像使用直接法计算相机运动</span></span><br><span class="line">        <span class="built_in">poseEstimationDirect</span>(measurements, &amp;gray, K, Tcw);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tcw=&quot;</span> &lt;&lt; Tcw.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.绘制特征点</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">img_show</span><span class="params">(color.rows * <span class="number">2</span>, color.cols, CV_8UC3)</span></span>;</span><br><span class="line">        prev_color.<span class="built_in">copyTo</span>(<span class="built_in">img_show</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, color.cols, color.rows)));</span><br><span class="line">        color.<span class="built_in">copyTo</span>(<span class="built_in">img_show</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, color.rows, color.cols, color.rows)));</span><br><span class="line">        <span class="keyword">for</span> (Measurement m : measurements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rand</span>() &gt; RAND_MAX / <span class="number">5</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p = m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_prev = <span class="built_in">project3Dto2D</span>(<span class="built_in">p</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">p</span>(<span class="number">2</span>, <span class="number">0</span>), fx, fy, cx, cy);</span><br><span class="line">            Eigen::Vector3d p2 = Tcw * m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_now = <span class="built_in">project3Dto2D</span>(<span class="built_in">p2</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">p2</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">p2</span>(<span class="number">2</span>, <span class="number">0</span>), fx, fy, cx, cy);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span> || <span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>) &gt;= color.cols || <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span> || <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) &gt;= color.rows)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> b = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> g = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> r = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_prev</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_prev</span>(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">8</span>, cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">2</span>);</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) + color.rows), <span class="number">8</span>, cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">2</span>);</span><br><span class="line">            cv::<span class="built_in">line</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_prev</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_prev</span>(<span class="number">1</span>, <span class="number">0</span>)), cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) + color.rows), cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, img_show);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( directMethod )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块路径</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( G2O )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span> ) </span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( G2O_LIBS </span><br><span class="line">    g2o_core g2o_types_sba g2o_solver_csparse g2o_stuff g2o_csparse_extension </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( direct_sparse direct_sparse.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( direct_sparse <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;G2O_LIBS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( direct_semidense direct_semidense.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( direct_semidense <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;G2O_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">*********** loop <span class="number">0</span> ************</span><br><span class="line">add total <span class="number">1402</span> measurements.</span><br><span class="line">*********** loop <span class="number">1</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7403254.830490</span>    <span class="selector-tag">time</span>= <span class="number">0.00082488</span>        cumTime= <span class="number">0.00082488</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">60236876.490033</span>        levenbergIter= <span class="number">5</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">7403254.830490</span>    <span class="selector-tag">time</span>= <span class="number">0.00102553</span>        cumTime= <span class="number">0.00185041</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">2119396675894340747264.000000</span>  levenbergIter= <span class="number">9</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00288273</span>  <span class="number">2.64449</span>e-<span class="number">05</span> -<span class="number">0.000928174</span></span><br><span class="line"> -<span class="number">0.00288272</span>     <span class="number">0.999996</span> -<span class="number">0.000436968</span> -<span class="number">3.76331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.77045</span>e-<span class="number">05</span>   <span class="number">0.00043689</span>            <span class="number">1</span>   <span class="number">0.00103318</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">2</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7759380.788781</span>    <span class="selector-tag">time</span>= <span class="number">0.00174707</span>        cumTime= <span class="number">0.00174707</span>     </span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">9</span>     chi2= <span class="number">7758019.671470</span>    <span class="selector-tag">time</span>= <span class="number">0.000755714</span>       cumTime= <span class="number">0.00772499</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">3783063956763384479744.000000</span>  levenbergIter= <span class="number">5</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00288243</span>  <span class="number">2.77591</span>e-<span class="number">05</span> -<span class="number">0.000928009</span></span><br><span class="line"> -<span class="number">0.00288242</span>     <span class="number">0.999996</span> -<span class="number">0.000441154</span> -<span class="number">3.82145</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.90306</span>e-<span class="number">05</span>  <span class="number">0.000441072</span>            <span class="number">1</span>   <span class="number">0.00103304</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">3</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7824244.109174</span>    <span class="selector-tag">time</span>= <span class="number">0.00174816</span>        cumTime= <span class="number">0.00174816</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">6220200914927.365234</span>   levenbergIter= <span class="number">8</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">7819308.542160</span>    <span class="selector-tag">time</span>= <span class="number">0.0010889</span>         cumTime= <span class="number">0.00689116</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">3127198551927549329408.000000</span>  levenbergIter= <span class="number">7</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00289109</span>  <span class="number">2.80266</span>e-<span class="number">05</span> -<span class="number">0.000927608</span></span><br><span class="line"> -<span class="number">0.00289108</span>     <span class="number">0.999996</span> -<span class="number">0.000451442</span> -<span class="number">3.83751</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.93317</span>e-<span class="number">05</span>  <span class="number">0.000451359</span>            <span class="number">1</span>   <span class="number">0.00103126</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">4</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8430224.068489</span>    <span class="selector-tag">time</span>= <span class="number">0.0017704</span>         cumTime= <span class="number">0.0017704</span>      edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">14477120284239.218750</span>  levenbergIter= <span class="number">8</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">10</span>    chi2= <span class="number">8429345.097617</span>    <span class="selector-tag">time</span>= <span class="number">0.000582781</span>       cumTime= <span class="number">0.00791508</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">25272065502643142656.000000</span>    levenbergIter= <span class="number">4</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">5</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8454586.253220</span>    <span class="selector-tag">time</span>= <span class="number">0.00216226</span>        cumTime= <span class="number">0.00216226</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">11915390830915310583808.000000</span>         levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">6</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8159516.143149</span>    <span class="selector-tag">time</span>= <span class="number">0.00214553</span>        cumTime= <span class="number">0.00214553</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">7207697814143619825664.000000</span>  levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">7</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8203720.110076</span>    <span class="selector-tag">time</span>= <span class="number">0.0021112</span>         cumTime= <span class="number">0.0021112</span>      edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">21225209233812976828416.000000</span>         levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">8</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8054487.520687</span>    <span class="selector-tag">time</span>= <span class="number">0.00161749</span>        cumTime= <span class="number">0.00161749</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">306330210612.899292</span>    levenbergIter= <span class="number">7</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">8047353.368341</span>    <span class="selector-tag">time</span>= <span class="number">0.00105102</span>        cumTime= <span class="number">0.00563404</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">4158192944542638931968.000000</span>  levenbergIter= <span class="number">6</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00290379</span>  <span class="number">2.91578</span>e-<span class="number">05</span> -<span class="number">0.000927602</span></span><br><span class="line"> -<span class="number">0.00290378</span>     <span class="number">0.999996</span> -<span class="number">0.000470562</span> -<span class="number">4.13493</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">3.05241</span>e-<span class="number">05</span>  <span class="number">0.000470476</span>            <span class="number">1</span>   <span class="number">0.00103238</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">9</span> ************</span><br></pre></td></tr></table></figure><p><img src="/2022/03/29/RGB-D%E7%9B%B4%E6%8E%A5%E6%B3%95%E5%AE%9E%E8%B7%B5/image-20220329164608300.png" alt="image-20220329164608300"></p><h1 id="三、半稠密直接法"><a href="#三、半稠密直接法" class="headerlink" title="三、半稠密直接法"></a>三、半稠密直接法</h1><p>我们很容易就能把程序拓展成半稠密的直接法形式。对参考帧中，先提取梯度较明显的像素，然后用直接法，以这些像素为图优化边，来估计相机运动。对先前的程序做如下的修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// select the pixels with high gradiants </span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x=<span class="number">10</span>; x&lt;gray.cols<span class="number">-10</span>; x++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> y=<span class="number">10</span>; y&lt;gray.rows<span class="number">-10</span>; y++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Eigen::Vector2d <span class="title">delta</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            gray.ptr&lt;uchar&gt;(y)[x+<span class="number">1</span>] - gray.ptr&lt;uchar&gt;(y)[x<span class="number">-1</span>], </span></span></span><br><span class="line"><span class="params"><span class="function">            gray.ptr&lt;uchar&gt;(y+<span class="number">1</span>)[x] - gray.ptr&lt;uchar&gt;(y<span class="number">-1</span>)[x]</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ( delta.<span class="built_in">norm</span>() &lt; <span class="number">50</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ushort d = depth.ptr&lt;ushort&gt; (y)[x];</span><br><span class="line">            <span class="keyword">if</span> ( d==<span class="number">0</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p3d = <span class="built_in">project2Dto3D</span> ( x, y, d, fx, fy, cx, cy, depth_scale );</span><br><span class="line">            <span class="keyword">float</span> grayscale = <span class="built_in"><span class="keyword">float</span></span> ( gray.ptr&lt;uchar&gt; (y) [x] );</span><br><span class="line">            measurements.<span class="built_in">push_back</span> ( <span class="built_in">Measurement</span> ( p3d, grayscale ) );</span><br><span class="line">        &#125;</span><br><span class="line">        prev_color = color.<span class="built_in">clone</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;add total &quot;</span>&lt;&lt;measurements.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; measurements.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*********** loop <span class="number">0</span> ************</span><br><span class="line">add total <span class="number">12556</span> measurements.</span><br><span class="line">*********** loop <span class="number">1</span> ************</span><br><span class="line">图中的边的个数：<span class="number">12556</span></span><br><span class="line">.....</span><br><span class="line">iteration= <span class="number">19</span>    chi2= <span class="number">71515789.320224</span>   <span class="selector-tag">time</span>= <span class="number">0.00527771</span>        cumTime= <span class="number">0.0867877</span>      edges= <span class="number">12556</span>    schur= <span class="number">0</span>        lambda= <span class="number">4022565853557871345664.000000</span>  levenbergIter= <span class="number">4</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999999</span> -<span class="number">1.99501</span>e-<span class="number">06</span>  -<span class="number">0.00124229</span>    <span class="number">0.0166827</span></span><br><span class="line"> <span class="number">3.02563</span>e-<span class="number">06</span>            <span class="number">1</span>  <span class="number">0.000829608</span>   -<span class="number">0.0119843</span></span><br><span class="line">  <span class="number">0.00124229</span> -<span class="number">0.000829611</span>     <span class="number">0.999999</span>   -<span class="number">0.0118238</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">....</span><br><span class="line">*********** loop <span class="number">9</span> ************</span><br></pre></td></tr></table></figure><p><img src="/2022/03/29/RGB-D%E7%9B%B4%E6%8E%A5%E6%B3%95%E5%AE%9E%E8%B7%B5/alvin/Documents/lukeyalvin.github.io/Blog/source/_posts/RGB-D%E7%9B%B4%E6%8E%A5%E6%B3%95%E5%AE%9E%E8%B7%B5/image-20220330165208010.png" alt="image-20220330165208010"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;此次实践使用RGB-D相机主要是因为它省略掉了深度的恢复部分，如果使用单目相机，则需要进行深度的恢复，在之前的实践内容中，我们使用单目相机主要是采用基于特征点的深度恢复，后面会介绍相应的基于块匹配的深度恢复。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch8_直接法的推导</title>
    <link href="http://lukeyalvin.top/2022/03/29/%E7%9B%B4%E6%8E%A5%E6%B3%95%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <id>http://lukeyalvin.top/2022/03/29/%E7%9B%B4%E6%8E%A5%E6%B3%95%E7%9A%84%E6%8E%A8%E5%AF%BC/</id>
    <published>2022-03-29T07:04:31.274Z</published>
    <updated>2022-03-30T02:53:53.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>之前估计相机运动时使用对极几何、PnP 或 ICP 算法，而根据图像的像素灰度信息也可以计算相机运动，这种方法称为直接法。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>考虑某个空间点 $P$ 和两个时刻的相机。$P $的世界坐标为$ [X, Y, Z]$，它在两个相机上成像，记非齐次像素坐标为 $p_1 , p_2$ 。</p><p><img src="/2022/03/29/%E7%9B%B4%E6%8E%A5%E6%B3%95%E7%9A%84%E6%8E%A8%E5%AF%BC/image-20220329150722092.png" alt="image-20220329150722092"></p><p>我们的目标是求第一个相机到第二个相机的相对位姿变换。我们以第一个相机为参照系，设第二个相机旋转和平移为$ R, t$（对应李代数为 $\xi$）。同时，两相机的内参相同，记为 $K$。为清楚起见，我们列写完整的投影方程：</p><script type="math/tex; mode=display">\begin{align}p_1 &= \begin{bmatrix}u\\v\\1\end{bmatrix}_1=\frac{1}{Z_1}KP\\p_2&=\begin{bmatrix}u\\v\\1\end{bmatrix}_2=\frac{1}{Z_2}K(RP+t)=\frac{1}{Z_2}K(exp(\xi^{\land})P)_{1:3}\end{align}</script><p>特征点法中，由于我们通过匹配描述子，知道了 $p_1 , p_2$ 的像素位置，所以可以计算重投影的位置。但在直接法中，由于没有特征匹配，我们无从知道哪一个 $p_1 , p_2$  对应着同一个点。</p><p>直接法的思路是根据当前相机的位姿估计值，来寻找 $p_2$ 的位置。但若相机位姿不够好， $p_2$ 的外观和  $p_1$ 会有明显差别。于是，为了减小这个差别，我们优化相机的位姿，来寻找与  $p_1$更相似的 $p_2$。</p><p>这同样可以通过解一个优化问题，但此时<strong>最小化的不是重投影误差</strong>，而是<strong>光度误差（Photometric Error）</strong>，也就是 $P $的两个像的亮度误差：</p><script type="math/tex; mode=display">e = I_1 (p_1 ) − I_2 (p_2 )</script><p>这里 e 是一个标量，同样的，优化目标为该误差的二范数，暂时取不加权的形式，为：</p><script type="math/tex; mode=display">\underset{\xi}{min}J(\xi)=\parallel e\parallel^2</script><p>由灰度不变假设，对于$N$个空间点$P_i$，整个相机的位姿估计问题变为：</p><script type="math/tex; mode=display">\underset{\xi}{min}J(\xi)=\sum^N_{i=1}e_i^Te_i\\e_i=I_1(p_1,i)-I_2(p_2,i)</script><p>这里的优化变量是相机位姿 $\xi$，为了求解这个优化问题，我们关心误差 $e$ 是如何随着相机位姿 $\xi$ 变化的，需要分析它们的导数关系。因此，使用李代数上的扰动模型。我们给 $exp(\xi) $左乘一个小扰动$ exp(\delta \xi)$:</p><script type="math/tex; mode=display">\begin{align}e(\xi⊕\delta \xi)&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}K exp(\delta \xi^{\land})exp(\xi^{\land})P)\\&\approx I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}K (1+\delta \xi^{\land})exp(\xi^{\land})P)\\&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+\frac{1}{Z_2}K \delta \xi^{\land}exp(\xi^{\land})P)\\\end{align}</script><p>记：</p><script type="math/tex; mode=display">\begin{align}q&=\delta \xi^{\land}exp(\xi^{\land})P\\u&=\frac{1}{Z_2}Kq\end{align}</script><p>$q $为$ P $在扰动之后，位于第二个相机坐标系下的坐标，而 $u $为它的像素坐标</p><p>由一阶泰勒展开可知：</p><script type="math/tex; mode=display">I(x+dx)\approx \frac{\partial I}{\partial x}dx\\I(x+\delta \xi)\approx \frac{\partial I}{\partial \delta \xi}{\delta \xi}</script><p>所以，同样的进行一阶泰勒展开：</p><script type="math/tex; mode=display">\begin{align}e(\xi⊕\delta \xi)&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+\frac{1}{Z_2}K \delta \xi^{\land}exp(\xi^{\land})P)\\&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+u)\\&\approx I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P)-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}\delta \xi\\&=e(\xi)-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}\delta \xi\end{align}</script><p>一阶导数由于链式法则分成了三项，分别计算这三部分：</p><p>$\partial I_2 / \partial u$为$ u $处的像素梯度；</p><p>$∂u/∂q $为投影方程关于相机坐标系下的三维点的导数，$q $为$ P $在扰动之后，位于第二个相机坐标系下的坐标，$u $为它的像素坐标，记为$q = [X, Y, Z]^T$</p><script type="math/tex; mode=display">\frac{\partial u}{\partial q}=-\begin{bmatrix}\frac{\partial u}{\partial X}&\frac{\partial u}{\partial Y}&\frac{\partial u}{\partial Z}            \\ \frac{\partial v}{\partial X}&\frac{\partial v}{\partial Y}&\frac{\partial v}{\partial Z}\end{bmatrix}=-\begin{bmatrix}\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}\\0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}\end{bmatrix}</script><p>$∂q/∂δξ $为变换后的三维点对变换的导数，由于$q$为变换后的三维点，设变换前的三维点为$q_0$</p><script type="math/tex; mode=display">\begin{align}\frac{\partial q}{\partial \delta \xi}&=\frac{\partial(Tq_0)}{\partial \delta \xi} \\ &=\underset{\delta \xi \rightarrow0}{lim}\frac{exp(\delta \xi ^{\land})exp(\xi ^{\land})q_0-exp(\xi ^{\land})q_0}{\delta \xi}\\&\approx\underset{\delta \xi \rightarrow0}{lim}\frac{(I+\delta \xi ^{\land})exp(\xi ^{\land})q_0-exp(\xi ^{\land})q_0}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\delta \xi ^{\land}exp(\xi ^{\land})q_0}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\begin{bmatrix}\delta \phi^{\land}&\delta \rho \\0^T&0\end{bmatrix}\begin{bmatrix}Rq_0+t \\1\end{bmatrix}}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\begin{bmatrix}\delta \phi^{\land}(Rq_0+t)+\delta \rho  \\0\end{bmatrix}}{\delta \xi}\\&=\begin{bmatrix}I &-(Rq_0+t)^{\land}\\0^{T}&0^{T}\end{bmatrix}\\&=\begin{bmatrix}I &-q^{\land}\\0^{T}&0^{T}\end{bmatrix}\\&=(Tq)^⊙\end{align}</script><p>后两项只与三维点 q 有关，而与图像无关，我们经常把它合并在一起：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial u}{\partial \delta \xi}&=\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}=-\begin{bmatrix}\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}&-\frac{f_xXY}{Z^{2}}&f_x+\frac{f_xX^2}{Z^{2}}&-\frac{f_xY}{Z}\\0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}&-f_y-\frac{f_yY^{2}}{Z^{2}}&\frac{f_yXY}{Z}&\frac{f_yX}{Z}\end{bmatrix}\end{align}</script><p>推导了误差相对于李代数的雅可比矩阵：</p><script type="math/tex; mode=display">J=-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><p>对于 $N $个点的问题，我们可以用这种方法计算优化问题的雅可比，然后使用$ G-N$或$L-M$ 计算增量，迭代求解。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;之前估计相机运动时使用对极几何、PnP 或 ICP 算法，而根据图像的像素灰度信息也可以计算相机运动，这种方法称为直接法。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch8_使用LK光流法</title>
    <link href="http://lukeyalvin.top/2022/03/29/%E4%BD%BF%E7%94%A8LK%E5%85%89%E6%B5%81%E6%B3%95/"/>
    <id>http://lukeyalvin.top/2022/03/29/%E4%BD%BF%E7%94%A8LK%E5%85%89%E6%B5%81%E6%B3%95/</id>
    <published>2022-03-29T02:32:32.151Z</published>
    <updated>2022-03-30T02:12:24.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>光流是一种描述像素随着时间，在图像之间运动的方法。随着时间的经过，同一个像素会在图像中运动，而我们希望追踪它的运动过程。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。稀疏光流以$ Lucas-Kanade$ 光流为代表，并可以在 SLAM 中用于跟踪特征点位置。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/2022/03/29/%E4%BD%BF%E7%94%A8LK%E5%85%89%E6%B5%81%E6%B3%95/image-20220329104428515.png" alt="image-20220329104428515"></p><h1 id="LK光流法原理"><a href="#LK光流法原理" class="headerlink" title="LK光流法原理"></a>LK光流法原理</h1><p>在$ LK $光流中，我们认为来自相机的图像是随时间变化的。图像可以看作时间的函数：$I(t)$。那么，一个在$ t $时刻，位于$ (x, y)$ 处的像素，它的灰度可以写成</p><script type="math/tex; mode=display">I(x, y, t).</script><p>灰度不变假设：</p><script type="math/tex; mode=display">I(x+d_x,y+d_y,t+d_t)=I(x, y, t)</script><p>对左边进行泰勒展开，保留一阶项，得：</p><script type="math/tex; mode=display">I (x + dx, y + dy, t + dt) \approx I (x, y, t)+\frac{\partial I}{\partial x}d_x+\frac{\partial I}{\partial y}d_y+\frac{\partial I}{\partial t}d_t</script><p>假设了灰度不变:</p><script type="math/tex; mode=display">\frac{\partial I}{\partial x}d_x+\frac{\partial I}{\partial y}d_y+\frac{\partial I}{\partial t}d_t=0</script><p>两边除以 $dt$:</p><script type="math/tex; mode=display">\frac{\partial I}{\partial x}\frac{d_x}{d_t}+\frac{\partial I}{\partial y}\frac{d_y}{d_t}=-\frac{\partial I}{\partial t}</script><p>其中: $dx/dt $为像素在 $x $轴上运动速度，记为$u$， $dy/dt $为像素在 $y$轴上运动速度，记为$v$</p><p>$\partial I/\partial x$为图像在该点处 $x$ 方向的梯度，记为$I_x$，$\partial I/\partial y$为图像在该点处 $y$ 方向的梯度，记为$I_y$</p><p>图像灰度对时间的变化量记为 $I_t$</p><script type="math/tex; mode=display">\begin{bmatrix}I_x & I_y\end{bmatrix}\begin{bmatrix}u \\ v\end{bmatrix}= - I_t</script><p>我们想计算的是像素的运动$ u, v$，但是该式是带有两个变量的一次方程，仅凭它无法计算出$ u, v$。因此，必须引入额外的约束来计算$ u, v$。在$ LK $光流中，我们假设某一个窗口内的像素具有相同的运动。</p><p>考虑一个大小为 $w × w$ 大小的窗口，它含有 $w^2 $数量的像素。由于该窗口内像素具有同样的运动，因此我们共有 $w^2 $个方程：</p><script type="math/tex; mode=display">\begin{bmatrix}I_x & I_y\end{bmatrix}_k\begin{bmatrix}u \\ v\end{bmatrix}= - I_{tk},k=1,....,w^2</script><p>即为：</p><script type="math/tex; mode=display">A = \begin{bmatrix}\begin{bmatrix}I_x & I_y\end{bmatrix}_1\\.\\.\\\begin{bmatrix}I_x & I_y\end{bmatrix}_k\end{bmatrix},b=\begin{bmatrix}I_{t1} \\.\\.\\I_{tk} \end{bmatrix}</script><p>于是整个方程为：</p><script type="math/tex; mode=display">A\begin{bmatrix}u\\u\end{bmatrix}=-b</script><p>这是一个关于 u, v 的超定线性方程，传统解法是求最小二乘解。最小二乘在很多时候都用到过：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\u\end{bmatrix}^*=-(A^TA)^{-1}A^Tb</script><p>这样就得到了像素在图像间的运动速度 $u, v$</p><h1 id="使用LK光流法"><a href="#使用LK光流法" class="headerlink" title="使用LK光流法"></a>使用LK光流法</h1><h2 id="光流追踪的原理"><a href="#光流追踪的原理" class="headerlink" title="光流追踪的原理"></a>光流追踪的原理</h2><ul><li><p>cv2.FastFeatureDetector()：Fast角点检测器确定要追踪的特征点</p></li><li><p>cv2.calcOpticalFlowPyrLK()： 追踪视频中的稀疏特征点</p></li><li><p>cv2.calcOpticalFlowFarneback()： 追踪视频中的密集特征点</p></li></ul><p>取第一帧，检测其中的一些 Fast角点，使用 Lucas-Kanade 光流迭代跟踪这些点。对于函数 cv2.calcOpticalFlowPyrLK() 传递前一帧、前一个点和下一帧。它返回下一个点以及一些状态编号，如果找到下一个点，则值为 1，否则为零。然后在下一步中迭代地将这些下一个点作为前一个点传递。</p><h2 id="光流的两种方法"><a href="#光流的两种方法" class="headerlink" title="光流的两种方法"></a>光流的两种方法</h2><p>OpenCV提供了俩种算法计算光流，分别通过：cv2.calcOpticalFlowPyrLK()、cv2.calcOpticalFlowFarneback实现；</p><ul><li>稀疏光流： 通过 Lucas-Kanade 方法计算稀疏特征集的光流（使用 角点检测算法检测到的角点）。</li></ul><p>参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::calcOpticalFlowPyrLK</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray prevImg, <span class="comment">//上一帧单通道灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray nextImg, <span class="comment">//下一帧单通道灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray prevPts, <span class="comment">//像素点上一帧二维坐标pts</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputOutputArray nextPts,<span class="comment">//像素点下一帧二维坐标pts</span></span></span></span><br><span class="line"><span class="params"><span class="function">        OutputArray status,<span class="comment">// 输出状态向量,（无符号字符）;如果找到相应特征的流，则向量的每个元素设置为1，否则设置为0。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        OutputArray err, <span class="comment">//输出错误的矢量;如果未找到流，则未定义错误（使用status参数查找此类情况）。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        Size winSize = Size(<span class="number">21</span>, <span class="number">21</span>),<span class="comment">//每个金字塔等级的搜索窗口的winSize大小。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> maxLevel = <span class="number">3</span>,<span class="comment">// 基于0的最大金字塔等级数;如果设置为0，则不使用金字塔（单级），如果设置为1，则使用两个级别，依此类推;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, <span class="number">30</span>, <span class="number">0.01</span>),<span class="comment">//参数，指定迭代搜索算法的终止条件</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">double</span> minEigThreshold = <span class="number">1e-4</span> <span class="comment">//算法计算光流方程的2x2正常矩阵的最小特征值，除以窗口中的像素数;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><ul><li>密集光流： 通过 Gunner Farneback 来寻找密集光流。它计算帧中所有点的光流。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在使用数据之前，需要根据采集时间，对数据进行一次时间上的对齐，以便对彩色图和深度图进行配对。TUM 提供了一个 python 脚本“asso-ciate.py”帮我们完成这件事。请把此文件放到数据集目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python associate.py rgb.txt depth.txt &gt; associate.txt</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入数据集所在的路径！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    string associate_file = path_to_dataset + <span class="string">&quot;/associate.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(associate_file)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;associate.txt文件不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    list&lt;cv::Point2f&gt; keypoints; <span class="comment">// 因为要删除跟踪失败的点，使用list</span></span><br><span class="line">    cv::Mat color, depth, last_color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        fin &gt;&gt; time_rgb &gt;&gt; rgb_file &gt;&gt; time_depth &gt;&gt; depth_file;</span><br><span class="line">        color = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + rgb_file);       <span class="comment">// 读入彩色图</span></span><br><span class="line">        depth = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + depth_file, <span class="number">-1</span>); <span class="comment">// 读入深度图</span></span><br><span class="line">        <span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;cv::KeyPoint&gt; kps;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">            detector-&gt;<span class="built_in">detect</span>(color, kps); <span class="comment">// 提取FAST特征点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> kp : kps)           <span class="comment">// 把提取的特征点存入list</span></span><br><span class="line">                keypoints.<span class="built_in">push_back</span>(kp.pt);</span><br><span class="line">            last_color = color;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.对其他帧使用LK跟踪特征点</span></span><br><span class="line">        <span class="keyword">if</span> (color.data == <span class="literal">nullptr</span> &amp;&amp; depth.data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;cv::Point2f&gt; next_keypoints;</span><br><span class="line">        vector&lt;cv::Point2f&gt; prev_keypoints;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">            prev_keypoints.<span class="built_in">push_back</span>(kp); <span class="comment">// 讲list中的数据赋给prev_keypoints</span></span><br><span class="line">        vector&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; status;</span><br><span class="line">        vector&lt;<span class="keyword">float</span>&gt; error;</span><br><span class="line"></span><br><span class="line">        chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">calcOpticalFlowPyrLK</span>(last_color, color, prev_keypoints, next_keypoints, status, error);</span><br><span class="line"></span><br><span class="line">        chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LK Flow use time：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把跟丢的点删掉</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = keypoints.<span class="built_in">begin</span>(); iter != keypoints.<span class="built_in">end</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (status[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iter = keypoints.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *iter = next_keypoints[i];</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;跟踪到的点个数为： &quot;</span> &lt;&lt; keypoints.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (keypoints.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;all keypoints are lost.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出 keypoints</span></span><br><span class="line">        cv::Mat img_show = color.<span class="built_in">clone</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, kp, <span class="number">10</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">240</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;corners&quot;</span>, img_show);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">        last_color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为要删除跟踪失败的点，使用list,原因如下：</p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p>list的优点：</p><blockquote><p>采用动态存储分配，不会造成内存浪费和溢出<br>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</p></blockquote></blockquote><p>打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LK Flow use time：0.0157339 seconds.</span><br><span class="line">跟踪到的点个数为： 1749</span><br><span class="line">LK Flow use time：0.0144717 seconds.</span><br><span class="line">跟踪到的点个数为： 1742</span><br><span class="line">LK Flow use time：0.0186928 seconds.</span><br><span class="line">跟踪到的点个数为： 1703</span><br><span class="line">LK Flow use time：0.0153624 seconds.</span><br><span class="line">跟踪到的点个数为： 1676</span><br><span class="line">LK Flow use time：0.019426 seconds.</span><br><span class="line">跟踪到的点个数为： 1664</span><br><span class="line">LK Flow use time：0.0140176 seconds.</span><br><span class="line">跟踪到的点个数为： 1656</span><br><span class="line">LK Flow use time：0.0187153 seconds.</span><br><span class="line">跟踪到的点个数为： 1641</span><br><span class="line">LK Flow use time：0.0187284 seconds.</span><br><span class="line">跟踪到的点个数为： 1634</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( useLK )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++11 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( useLK useLK.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( useLK <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/03/29/%E4%BD%BF%E7%94%A8LK%E5%85%89%E6%B5%81%E6%B3%95/image-20220329144916230.png" alt="image-20220329144916230"></p><p>LK 光流跟踪能够直接得到特征点的对应关系。这个对应关系就像是描述子的匹配，但实际上我们大多数时候只会碰到特征点跟丢的情况，而不太会遇到误匹配，这应该是光流相对于描述子的一点优势。但是，匹配描述子的方法在相机运动较大时仍能成功，而光流必须要求相机运动是微小的。从这方面来说，光流的鲁棒性比描述子差一些。</p><p>光流法参考：</p><ul><li><a href="https://www.shouxicto.com/article/1871.html">OpenCV中的光流及视频特征点追踪</a></li><li><a href="https://docs.opencv.org/3.4.6/dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323"> calcOpticalFlowPyrLK()</a></li><li><a href="https://docs.opencv.org/3.4.6/dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af">calcOpticalFlowFarneback()</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;光流是一种描述像素随着时间，在图像之间运动的方法。随着时间的经过，同一个像素会在图像中运动，而我们希望追踪它的运动过程。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。稀疏光流以$ Lucas-Kanade$ 光流为代表，并可以在 SLAM 中用于跟踪特征点位置。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>g2o的结构以及BA节点与边的定义</title>
    <link href="http://lukeyalvin.top/2022/03/28/g2o%E4%B8%AD%E5%85%B3%E4%BA%8EBA%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9/"/>
    <id>http://lukeyalvin.top/2022/03/28/g2o%E4%B8%AD%E5%85%B3%E4%BA%8EBA%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9/</id>
    <published>2022-03-28T03:38:08.097Z</published>
    <updated>2022-03-31T08:39:24.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。在<code>g2o/types/sba/types_six_dof_expmap.h</code>中则提供了李代数表达的节点和边。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="g2o的结构"><a href="#g2o的结构" class="headerlink" title="g2o的结构"></a>g2o的结构</h1><blockquote><p>参考博客：<a href="https://www.cnblogs.com/gaoxiang12/p/5304272.html">深入理解图优化与g2o：g2o篇</a></p></blockquote><p>源码：<a href="https://github.com/RainerKuemmerle/g2o">https://github.com/RainerKuemmerle/g2o</a></p><p><img src="/2022/03/28/g2o%E4%B8%AD%E5%85%B3%E4%BA%8EBA%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9/image-20220328125016497.png" alt="image-20220328125016497"></p><ul><li><strong>cmake_modules：</strong>给cmake用来寻找库的文件。我们用g2o时也会用它里头的东西，例如FindG2O.cmake</li><li><strong>doc：</strong>文档。包括g2o自带的说明书（难度挺大的一个说明文档）。</li><li><strong>g2o：</strong>最重要的源代码都在这里！</li><li><strong>script：</strong>在android等其他系统编译用的脚本</li></ul><p><a href="https://github.com/RainerKuemmerle/g2o/tree/master/g2o">https://github.com/RainerKuemmerle/g2o/tree/master/g2o</a></p><p><img src="/2022/03/28/g2o%E4%B8%AD%E5%85%B3%E4%BA%8EBA%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9/image-20220328125308391.png" alt="image-20220328125308391"></p><ul><li><strong>apps：</strong>一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</li><li><strong>core：</strong>核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</li><li><strong>examples：</strong>一些例程，可以参照着这里的东西来写。不过注释不太多。</li><li><strong>solvers：</strong>求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</li><li><strong>stuff：</strong>对用户来讲可有可无的一些工具函数。</li><li><strong>types：</strong>各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</li></ul><p><strong>就经验而言，solvers给人的感觉是大同小异，而 types 的选取，则是 g2o 用户主要关心的内容。然后 core 下面的内容，我们要争取弄的比较熟悉，才能确保使用中出现错误可以正确地应对。</strong></p><p>g2o最基本的类结构：</p><p><img src="/2022/03/28/g2o%E4%B8%AD%E5%85%B3%E4%BA%8EBA%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9/606958-20160321233900042-681579456.png" alt="img"></p><p>　先看上半部分。SparseOptimizer 是我们最终要维护的东东。它是一个Optimizable Graph，从而也是一个Hyper Graph。一个 SparseOptimizer 含有很多个顶点 （都继承自 Base Vertex）和很多个边（继承自 BaseUnaryEdge, BaseBinaryEdge或BaseMultiEdge）。这些 Base Vertex 和 Base Edge 都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 SparseOptimizer.addVertex 和 SparseOptimizer.addEdge 向一个图中添加顶点和边，最后调用 SparseOptimizer.optimize 完成优化。</p><p>　　在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 SparseOptimizer 拥有一个 Optimization Algorithm，继承自Gauss-Newton, Levernberg-Marquardt, Powell’s dogleg 三者之一（我们常用的是GN或LM）。同时，这个 Optimization Algorithm 拥有一个Solver，它含有两个部分。一个是 SparseBlockMatrix ，用于计算稀疏的雅可比和海塞； 一个是用于计算迭代过程中最关键的一步</p><script type="math/tex; mode=display">HΔx=−b</script><p>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p><p><strong>综上所述，在g2o中选择优化方法一共需要三个步骤：</strong></p><ol><li>创建一个线性求解器LinearSolver。从 PCG, CSparse, Choldmod中选，实际则来自 g2o/solvers 文件夹中定义的内容。</li><li>创建BlockSolver，并用上面定义的线性求解器初始化。</li><li>创建总求解器solver，并从GN/LM/DogLeg 中选一个作为迭代策略，再用上述块求解器BlockSolver初始化。</li><li>创建图优化的核心：稀疏优化器（SparseOptimizer）。</li><li>定义图的顶点和边，并添加到SparseOptimizer中。</li><li>设置优化参数，开始执行优化。</li></ol><h1 id="g2o中定义的顶点和边"><a href="#g2o中定义的顶点和边" class="headerlink" title="g2o中定义的顶点和边"></a>g2o中定义的顶点和边</h1><p>$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。<code>g2o/types/sba/types_six_dof_expmap.h</code>中则提供了李代数表达的节点和边。</p><p>因为在不同的应用场景（二维空间，三维空间），有不同的待优化变量（位姿，空间点），还涉及不同的优化类型（李代数位姿、李群位姿），g2o本身内部定义了一些常用的顶点类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VertexSE2 : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, SE2&gt;  <span class="comment">//2D位姿顶点, (x,y,theta)</span></span><br><span class="line">VertexSE3 : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, Isometry3&gt;  <span class="comment">//6d vector (x,y,z,qx,qy,qz) 请注意，我们省略了四元数的 w 部分</span></span><br><span class="line">VertexPointXY : <span class="keyword">public</span> BaseVertex&lt;<span class="number">2</span>, Vector2&gt;</span><br><span class="line">VertexPointXYZ : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt;</span><br><span class="line">VertexSBAPointXYZ : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt;</span><br><span class="line"></span><br><span class="line">VertexSE3Expmap : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SE3Quat&gt;</span><br><span class="line">VertexCam : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SBACam&gt;</span><br><span class="line">VertexSim3Expmap : <span class="keyword">public</span> BaseVertex&lt;<span class="number">7</span>, Sim3&gt;</span><br></pre></td></tr></table></figure><h2 id="顶点Vertex"><a href="#顶点Vertex" class="headerlink" title="顶点Vertex"></a>顶点Vertex</h2><p>g2o中顶点为<strong>待优化变量</strong>，边为<strong>误差项</strong>，综合之前所提到的非线性优化的应用：</p><ul><li><p>求解$PnP$</p><ul><li>待优化的变量是：相机的位姿以及所有的特征点的空间位置$P$</li><li>误差项：重投影误差 $ξ^{*}=arg \underset{ξ}{min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1} {s_i}Kexp(ξ^{\land})P_i\parallel^2_2$</li></ul></li><li><p>求解$ICP$</p><ul><li>待优化的变量是：相机的位姿以及所有的特征点的空间位置$P$</li><li>误差项：重投影误差$\underset{\xi}{min}=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - exp(\xi^{\land})p^{\prime}_i) \parallel^2_2$</li></ul></li></ul><h3 id="VertexSE3Expmap"><a href="#VertexSE3Expmap" class="headerlink" title="VertexSE3Expmap"></a><code>VertexSE3Expmap</code></h3><p>VertexSE3Expmap(李代数位姿)</p><p>继承于<code>BaseVertex</code>这个模板类<br>需要设置的模板参数：</p><ul><li>参数<code>6</code> ：表示它内部存储的优化变量维度。可以看到这是一个 6 维的李代数。，前三维表示旋转，后三维表示平移</li><li>参数<code>SE3Quat</code> ：表示优化变量的类型。这里使用了 g2o 定义的相机位姿： SE3Quat。这个类内部使用了四元数加位移向量来存储位姿，但同时也支持李代数上的运算，例如对数映射（log 函数）和李代数上增量（update 函数）等操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SBA_API</span> <span class="title">VertexSE3Expmap</span> :</span> <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SE3Quat&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">        <span class="title">VertexSE3Expmap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 顶点重置函数，设定被优化变量的原始值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate = <span class="built_in">SE3Quat</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector6&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">          <span class="built_in">setEstimate</span>(SE3Quat::<span class="built_in">exp</span>(update) * <span class="built_in">estimate</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>使用时需要设置的参数，可以参考之前使用$PnP$优化第二个相机的位姿的时设置的参数内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">Eigen::Matrix3d R_mat;</span><br><span class="line">R_mat &lt;&lt; </span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 设置Id号</span></span><br><span class="line">pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>( <span class="comment">// 设置待优化位姿R,t</span></span><br><span class="line">    R_mat,</span><br><span class="line">    Eigen::<span class="built_in">Vector3d</span>(t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))、</span><br><span class="line">));</span><br><span class="line">optimizer.<span class="built_in">addVertex</span>(pose); <span class="comment">// 向一个图中添加顶点</span></span><br></pre></td></tr></table></figure><h3 id="VertexPointXYZ"><a href="#VertexPointXYZ" class="headerlink" title="VertexPointXYZ"></a><code>VertexPointXYZ</code></h3><p>VertexPointXYZ(空间点位置)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SLAM3D_API</span> <span class="title">VertexPointXYZ</span> :</span> <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="built_in">VertexPointXYZ</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// 顶点重置函数，设定被优化变量的原始值。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123; _estimate.<span class="built_in">fill</span>(<span class="number">0.</span>); &#125;</span><br><span class="line"><span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span> </span>&#123;</span><br><span class="line">        <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector3&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">        _estimate += update;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><p>使用时需要设置的参数，可以参考之前使用$PnP$优化所有特征点的空间位置P时，设置的参数内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化所有特征点的空间位置 P</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Point3f p : points_3d)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::VertexPointXYZ *point = <span class="keyword">new</span> g2o::<span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">    point-&gt;<span class="built_in">setId</span>(index++); <span class="comment">// 设置Id号</span></span><br><span class="line">    point-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z));<span class="comment">// 设置待优化空间点3D位置XYZ</span></span><br><span class="line">    point-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>); <span class="comment">// 是否边缘化（以便稀疏化求解）g2o中必须设置 marg 参见第十讲内容</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(point); <span class="comment">// 向一个图中添加顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="边Edge"><a href="#边Edge" class="headerlink" title="边Edge"></a>边Edge</h2><p>BaseUnaryEdge，BaseBinaryEdge，BaseMultiEdge 分别表示一元边，两元边，多元边。一元边可以理解为一条边只连接一个顶点，两元边理解为一条边连接两个顶点，也就是我们常见的边啦，多元边理解为一条边可以连接多个（3个以上）顶点</p><p><img src="/2022/03/28/g2o%E4%B8%AD%E5%85%B3%E4%BA%8EBA%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9/5c7df32d30e9d.png" alt></p><h3 id="EdgeProjectXYZ2UV"><a href="#EdgeProjectXYZ2UV" class="headerlink" title="EdgeProjectXYZ2UV"></a>EdgeProjectXYZ2UV</h3><p>EdgeProjectXYZ2UV(重投影误差)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SBA_API</span> <span class="title">EdgeProjectXYZ2UV</span> :</span> <span class="keyword">public</span> BaseBinaryEdge&lt;<span class="number">2</span>, Vector2, VertexPointXYZ, VertexSE3Expmap&gt; </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">//1. 默认初始化</span></span><br><span class="line">    <span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//2. 计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>; <span class="comment">// 使用当前顶点的值计算的测量值与真实的测量值之间的误差</span></span><br><span class="line">    <span class="comment">//3. 线性增量函数，也就是雅克比矩阵J的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>; <span class="comment">// 在当前顶点的值下，该误差对优化变量的偏导数，也就是我们说的Jacobian</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//相机参数</span></span><br><span class="line">  CameraParameters* _cam;  <span class="comment">// TODO make protected member?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是个二元边。第1个参数2是说观测值是2维的，也就是图像像素坐标x,y的差值，即$ z − h(ξ, P )$，对应观测值的类型是Vector2D，两个顶点也就是优化变量分别是三维点 VertexPointXYZ，和李群位姿VertexSE3Expmap</p><h4 id="computeError"><a href="#computeError" class="headerlink" title="computeError()"></a>computeError()</h4><p>对应的<code>computeError()</code>的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeProjectXYZ2UV::computeError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> VertexSE3Expmap* v1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap*&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> VertexPointXYZ* v2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPointXYZ*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> CameraParameters* cam =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CameraParameters*&gt;(<span class="built_in">parameter</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 误差 = 观测 - 投影</span></span><br><span class="line">  _error = <span class="built_in">measurement</span>() - cam-&gt;<span class="built_in">cam_map</span>(v1-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(v2-&gt;<span class="built_in">estimate</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>_vertices[0]</code>对应的是 VertexPointXYZ 类型的顶点，也就是三维点，<code>_vertices[1]</code>对应的是VertexSE3Expmap 类型的顶点，也就是位姿pose。因此前面 1 对应的就应该是 pose，0对应的应该就是三维点。</p><p>cam_map 函数功能是把相机坐标系下三维点（输入）用内参转换为图像坐标（输出），具体代码如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector2 <span class="title">CameraParameters::cam_map</span><span class="params">(<span class="keyword">const</span> Vector3 &amp;trans_xyz)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector2 proj = <span class="built_in">project</span>(trans_xyz);</span><br><span class="line">    Vector2 res;</span><br><span class="line">    res[<span class="number">0</span>] = proj[<span class="number">0</span>] * focal_length + principle_point[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = proj[<span class="number">1</span>] * focal_length + principle_point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.map的功能是把世界坐标系下三维点变换到相机坐标系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3 <span class="title">map</span><span class="params">(<span class="keyword">const</span> Vector3&amp; xyz)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _r * xyz + <span class="keyword">_t</span>; &#125;</span><br></pre></td></tr></table></figure><p>因此下面这个代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(v2-&gt;<span class="built_in">estimate</span>())</span><br></pre></td></tr></table></figure><p>就是用V1估计的pose把V2代表的三维点，变换到相机坐标系下。</p><h4 id="linearizeOplus"><a href="#linearizeOplus" class="headerlink" title="linearizeOplus()"></a>linearizeOplus()</h4><p>对应的<code>linearizeOplus()</code>的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeProjectXYZ2UV::linearizeOplus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VertexSE3Expmap* vj = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap*&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">  <span class="function">SE3Quat <span class="title">T</span><span class="params">(vj-&gt;estimate())</span></span>;</span><br><span class="line">  VertexPointXYZ* vi = <span class="keyword">static_cast</span>&lt;VertexPointXYZ*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">  Vector3 xyz = vi-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">  Vector3 xyz_trans = T.<span class="built_in">map</span>(xyz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">number_t</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">number_t</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">number_t</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">number_t</span> z_2 = z * z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> CameraParameters* cam =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CameraParameters*&gt;(<span class="built_in">parameter</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  Eigen::Matrix&lt;<span class="keyword">number_t</span>, <span class="number">2</span>, <span class="number">3</span>, Eigen::ColMajor&gt; tmp;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">0</span>) = cam-&gt;focal_length;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">2</span>) = -x / z * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">1</span>) = cam-&gt;focal_length;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">2</span>) = -y / z * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXi = <span class="number">-1.</span> / z * tmp * T.<span class="built_in">rotation</span>().<span class="built_in">toRotationMatrix</span>();</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">0</span>) = x * y / z_2 * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">1</span>) = -(<span class="number">1</span> + (x * x / z_2)) * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">2</span>) = y / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">3</span>) = <span class="number">-1.</span> / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">5</span>) = x / z_2 * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">0</span>) = (<span class="number">1</span> + y * y / z_2) * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">1</span>) = -x * y / z_2 * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">2</span>) = -x / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">-1.</span> / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">5</span>) = y / z_2 * cam-&gt;focal_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量<code>_jacobianOplusXi</code>是<strong>误差到空间点的导数</strong>，<code>_jacobianOplusXj</code>是误<strong>差到相机位姿的导数</strong>，以李代数的左乘扰动表达。稍有差别的是，g2o 的相机里用 $f$ 统一描述 $f_x , f_y$ ，并且李代数定义顺序不同（g2o 是旋转在前，平移在后；我们是平移在前，旋转在后），所以矩阵前三列和后三列与我们的定义是颠倒的。此外都是一致的。</p><p>李代数定义的$J$：（）</p><script type="math/tex; mode=display">\begin{align}\frac{\partial e}{\partial \delta \xi}&=\frac{\partial e}{\partial P^′}\frac{\partial P^′}{\partial \delta \xi}\\&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&-\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\&=J\end{align}</script><p>而g2o中的$J$定义的方式如下：（旋转在前，平移在后）</p><script type="math/tex; mode=display">-\begin{bmatrix}-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}&\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&-\frac{f_yX^′}{Z^{′}}&0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}</script><p>值得一提的是，我们亦可自己实现相机位姿节点，并使用<code>Sophus::SE3</code>来表达位姿，提供类似的求导过程。然而，既然 g2o 已经提供了这样的类，在没有额外要求的情况下，自己重新实现就没有必要了。</p><p>使用时需要设置的参数，以$PnP$中重投影误差为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.设置边(每个 3D 点在第二个相机中的投影)</span></span><br><span class="line">index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Point2f p : points_2d)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> g2o::<span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">    edge-&gt;<span class="built_in">setId</span>(index); <span class="comment">//定义边的编号（决定了在H矩阵中的位置）</span></span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexPointXYZ *&gt;(optimizer.<span class="built_in">vertex</span>(index)));</span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose); <span class="comment">// 定义顶点</span></span><br><span class="line">    edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y)); <span class="comment">// 定义观测值</span></span><br><span class="line">    edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>()) ; <span class="comment">// 定义协方差矩阵的逆</span></span><br><span class="line">    optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义顶点类型"><a href="#自定义顶点类型" class="headerlink" title="自定义顶点类型"></a>自定义顶点类型</h1><p>一般情况下，如果我们需要用的顶点已经提供，则直接使用即可，但是有时候我们需要的顶点类型这里面没有，就得自己定义了。重新定义顶点一般需要考虑重写如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点重置函数，设定被优化变量的原始值。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update)</span></span>;</span><br><span class="line"><span class="comment">// 读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下就可以</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p><code>virtual void setToOriginImpl();</code>顶点重置函数，设定被优化变量的原始值。</p><p><code>virtual void oplusImpl(const number_t* update);</code>顶点更新函数。主要用于优化过程中增量△x的计算。我们根据增量方程计算出增量之后，就是通过这个函数对估计值进行调整的。</p><p>自定义顶点的格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myVertex</span>:</span> <span class="keyword">public</span> g2::BaseVertex&lt;Dim, Type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">myVertex</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    _estimate = <span class="built_in">Type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* update)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    _estimate += <span class="comment">/*update*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义边的类型"><a href="#自定义边的类型" class="headerlink" title="自定义边的类型"></a>自定义边的类型</h1><p>在使用BA求解ICP的实践中,使用的是3D-3D的边,由于g2o本身没有提供3D-3D的边,因此需自定义一个3D-3D的边:</p><p>自定义边格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;n,Dim, Type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">myEdge</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以构建3D-3D的边为例:</p><p>主要考虑两个函数的实现</p><ul><li><p><code>virtual void computeError()</code></p><p> 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，这个函数则是使用该边连接的节点和观测值来计算误差</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// measurement is p, point is p&#x27;</span></span><br><span class="line">    _error = _measurement - pose-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(_point); <span class="comment">//.map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里误差的定义方式,是考虑相邻两帧图像之间的重投影误差,比如我们通过特征点匹配,确定了两个匹配好的特征点,$p_i$和$p_i^{\prime}$他们的关系为:</p><script type="math/tex; mode=display">p_i = Rp_i^{\prime}+t</script><p>由于一些噪声,我们发现依据所求得的相机位姿$R,t$并没有达到理想的准确度,即$Rp_i^{\prime}+t \neq p_i$,他们的差值我们就定义为误差项:</p><script type="math/tex; mode=display">e_i = p_i - (Rp_i^{\prime}+t)</script><p>因此,我们把估计的$p_i^{\prime}$的世界坐标系下三维点转换成相机坐标系,并与$p_i$做差</p><ul><li><code>virtual void linearizeOplus()</code></li></ul><p>计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导,但是就优化效率而言,前者计算速度是更快的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">        g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">g2o::SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;          <span class="comment">// 顶点的当前估计</span></span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point); <span class="comment">// .map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_jacobianOplusXi是误差关于世界坐标系下坐标点的偏导</span></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前代码待理解……</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。在&lt;code&gt;g2o/types/sba/types_six_dof_expmap.h&lt;/code&gt;中则提供了李代数表达的节点和边。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch7_求解ICP并使用BA优化</title>
    <link href="http://lukeyalvin.top/2022/03/26/%E6%B1%82%E8%A7%A3ICP%E5%B9%B6%E4%BD%BF%E7%94%A8BA%E4%BC%98%E5%8C%96/"/>
    <id>http://lukeyalvin.top/2022/03/26/%E6%B1%82%E8%A7%A3ICP%E5%B9%B6%E4%BD%BF%E7%94%A8BA%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-26T08:31:15.472Z</published>
    <updated>2022-03-30T02:03:37.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>$ICP:$迭代最近点$（Iterative Closest Point）$求解。读者应该注意到，$3D-3D $位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组 $3D $点之间的变换时，和相机并没有关系。因此，在激光 $SLAM $中也会碰到 $ICP$，不过由于激光数据特征不够丰富，我们无从知道两个点集之间的匹配关系，只能认为距离最近的两个点为同一个，所以这个方法称为迭代最近点。而在视觉中，特征点为我们提供了较好的匹配关系，所以整个问题就变得更简单了。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>和 $PnP$ 类似，$ICP $的求解也分为两种方式：利用线性代数的求解（主要是$ SVD$），以及利用非线性优化方式的求解（类似于 $Bundle Adjustment$）。</p><h1 id="求解ICP"><a href="#求解ICP" class="headerlink" title="求解ICP"></a>求解ICP</h1><h2 id="SVD方法"><a href="#SVD方法" class="headerlink" title="SVD方法"></a>SVD方法</h2><h3 id="构建最小二乘"><a href="#构建最小二乘" class="headerlink" title="构建最小二乘"></a>构建最小二乘</h3><p>假设我们有一组配对好的 3D 点（比如我们对两个 RGB-D 图像进行了匹配）：</p><script type="math/tex; mode=display">P = {p_1 , . . . , p_n } \\ P^′= {p^′_1 , . . . , p^′_n }</script><p>现在，想要找一个欧氏变换 $R, t，$使得：</p><script type="math/tex; mode=display">∀i, p_i = Rp^′_i + t.</script><p>定义第 $i$对点的误差项：</p><script type="math/tex; mode=display">e_i=p_i - (Rp^′_i + t).</script><p>构建最小二乘问题:</p><script type="math/tex; mode=display">\underset{R,t}{min}J=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^′_i + t)) \parallel^2_2</script><h3 id="求解最小二乘"><a href="#求解最小二乘" class="headerlink" title="求解最小二乘"></a>求解最小二乘</h3><p>首先，定义两组点的质心(注意质心是没有下标)：</p><script type="math/tex; mode=display">p=\frac{1}{n}\sum^n_{i=1}(p_i)，p^{\prime}=\frac{1}{n}\sum^n_{i=1}(p^{\prime}_i)</script><p>在误差函数中，我们作如下的处理：</p><script type="math/tex; mode=display">\begin{align}\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^{\prime}_i + t)) \parallel^2&=\frac{1}{2}\sum^n_{i=1}\parallel p_i - Rp^{\prime}_i - t-p+Rp^{\prime}+p-Rp^{\prime} \parallel^2\\&= \frac{1}{2}\sum^n_{i=1}\parallel (p_i -p- R(p^{\prime}_i-p^{\prime}) )+(p- Rp^{\prime}+t) \parallel^2\\&= \frac{1}{2}\sum^n_{i=1}(\parallel p_i -p- R(p^{\prime}_i-p^{\prime}) \parallel^2+\parallel p- Rp^{\prime}+t\parallel^2\\&+2(p_i -p-R(p^{\prime}_i-p^{\prime})^T(p-Rp^{\prime}-t))\end{align}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align}p_i-p-R(p^{\prime}_i-p^{\prime})&=(Rp^{\prime}_i+t)-(Rp^{\prime}+t)-R(p^{\prime}_i-p^{\prime})\\&=Rp^{\prime}_i+t-Rp^{\prime}-t-Rp^{\prime}_i+Rp^{\prime}\\&=0\end{align}</script><p>所以：</p><script type="math/tex; mode=display">\begin{align}\underset{R,t}{min}J&=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^′_i + t)) \parallel^2\\&=\frac{1}{2}\sum^n_{i=1}\parallel p_i -p- R(p^{\prime}_i-p^{\prime}) \parallel^2+\parallel p- Rp^{\prime}+t\parallel^2\end{align}</script><p>仔细观察左右两项，我们发现左边只和旋转矩阵 R 相关，而右边既有 R 也有 t，但只和质心相关。只要我们获得了 R，令第二项为零就能得到 t。于是，ICP 可以分为以下三个步骤求解：</p><p>1.计算两组点的质心位置 $p$, $p^{\prime}$，然后计算每个点的去质心坐标：</p><script type="math/tex; mode=display">q_i = p_i − p,\\q_i^{\prime} = p_i^{\prime} − p^{\prime}  .</script><p>2.根据以下优化问题计算旋转矩阵：</p><script type="math/tex; mode=display">R^{*}=arg\underset{R}{min}\frac{1}{2}\sum^n_{i=1}\parallel q_i - Rq_i^{\prime} \parallel^2</script><p>3.根据第二步的 $R$，计算 $t$：</p><script type="math/tex; mode=display">t^∗ = p − Rp^{\prime} .</script><p>计算$R$：</p><script type="math/tex; mode=display">\frac{1}{2}\sum^n_{i=1}\parallel q_i - Rq_i^{\prime} \parallel^2=\frac{1}{2}\sum^n_{i=1}q_i^{T}q_i+q_i^{\prime T}R^TRq_i^{\prime}-2q^T_iRq_i^{\prime}</script><p>第一项和$ R$ 无关，第二项由于 $R^T R = I$，亦与 $R $无关。因此，实际上优化目标函数变为：</p><script type="math/tex; mode=display">\sum^n_{i=1}-q_i^{T}Rq_i^{\prime}=\sum^n_{i=1}-tr(Rq_i^{\prime}q_i^{T})=-tr(R\sum^n_{i=1}q_i^{\prime}q_i^{T})</script><p>定义：</p><script type="math/tex; mode=display">W=\sum^n_{i=1}q_i^{\prime}q_i^{T}</script><p>$W $是一个$ 3 × 3 $的矩阵，对$ W$ 进行 $SVD$ 分解，得：</p><script type="math/tex; mode=display">W = UΣV^T</script><p>$Σ $为奇异值组成的对角矩阵，对角线元素从大到小排列，而 $U $和$ V$ 为正交矩阵。当 $W$ 满秩时，$R$ 为：</p><script type="math/tex; mode=display">R = UV^T</script><p>解得 $R$后,按照$t^∗ = p − Rp^{\prime} .$求解 t 即可</p><h2 id="非线性优化方法"><a href="#非线性优化方法" class="headerlink" title="非线性优化方法"></a>非线性优化方法</h2><p>求解$ ICP$ 的另一种方式是使用非线性优化，以迭代的方式去找最优值。该方法和我们前面讲述的 $PnP $非常相似。以李代数表达位姿时，目标函数可以写成：</p><script type="math/tex; mode=display">\underset{\xi}{min}=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - exp(\xi^{\land})p^{\prime}_i) \parallel^2_2</script><p>单个误差项关于位姿导数已经在前面推导过了，使用李代数扰动模型即可:</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \delta \xi}=-(exp(\xi^{\land}p^{\prime}_i))^{⊙}</script><p>用非线性优化来计算$ ICP$不仅考虑相机的位姿，同时会优化 $3D$点的空间位置。对我们来说，RGB-D 相机每次可以观测到路标点的三维位置，从而产生一个$ 3D$ 观测数据。不过，由于$ g2o/sba$ 中没有提供 $3D$ 到 $3D$ 的边，而我们又想使用$ g2o/sba $中李代数实现的位姿节点，所以最好的方式是自定义一种这样的边，并向$ g2o$ 提供解析求导方式。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="1-特征点匹配"><a href="#1-特征点匹配" class="headerlink" title="1. 特征点匹配"></a>1. 特征点匹配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.特征点匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line"></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; match;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, match);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; max_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_dist: &quot;</span> &lt;&lt; max_dist &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_dist: &quot;</span> &lt;&lt; min_dist &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-建立3D点"><a href="#2-建立3D点" class="headerlink" title="2.建立3D点"></a>2.建立3D点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_3d_points</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;depth_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;depth_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;K,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;DMatch&gt; matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3f&gt; &amp;pts2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//提取特征点的深度值：</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取得匹配点的深度，queryIdx(表示匹配点的索引)查询描述子索引，pt关键点的坐标 (y行地址)[x列地址]</span></span><br><span class="line">        ushort d1 = depth_1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)];</span><br><span class="line">        ushort d2 = depth_2.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_2[m.trainIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_2[m.trainIdx].pt.x)];</span><br><span class="line">        <span class="keyword">if</span> (d1 == <span class="number">0</span> || d2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K);<span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">        Point2d p2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);<span class="comment">// p2:(X/Z,Y/Z,1)</span></span><br><span class="line">        <span class="keyword">float</span> dd1 = <span class="built_in"><span class="keyword">float</span></span>(d1) / <span class="number">5000.0</span>;</span><br><span class="line">        <span class="keyword">float</span> dd2 = <span class="built_in"><span class="keyword">float</span></span>(d2) / <span class="number">5000.0</span>;</span><br><span class="line">        <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">        pts1.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd1, p1.y * dd1, dd1));<span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">        pts2.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p2.x * dd2, p2.y * dd2, dd2));<span class="comment">// (X,Y,Z)第二帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3d-3d pairs: &quot;</span> &lt;&lt; pts1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-SVD求解ICP"><a href="#3-SVD求解ICP" class="headerlink" title="3.SVD求解ICP"></a>3.SVD求解ICP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.SVD求解ICP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_3d3d</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3f p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = pts1.<span class="built_in">size</span>(); <span class="comment">// N = 72;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 += pts1[i]; <span class="comment">// p1 为pts1坐标各维之和</span></span><br><span class="line">        p2 += pts2[i]; <span class="comment">// p2 为pts2坐标各维之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">Point3f</span>(<span class="built_in">Vec3f</span>(p1) / N); <span class="comment">// 取平均得到质心p1</span></span><br><span class="line">    p2 = <span class="built_in">Point3f</span>(<span class="built_in">Vec3f</span>(p2) / N); <span class="comment">// 取平均得到质心p2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Point3f&gt; <span class="title">q1</span><span class="params">(N)</span>, <span class="title">q2</span><span class="params">(N)</span></span>; <span class="comment">// remove the center</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1[i] = pts1[i] - p1; <span class="comment">// 计算每个点的去质心坐标q1</span></span><br><span class="line">        q2[i] = pts2[i] - p2; <span class="comment">// 计算每个点的去质心坐标q2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// compute q1*q2^T</span></span><br><span class="line">    Eigen::Matrix3d W = Eigen::Matrix3d::<span class="built_in">Zero</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// w = sum(q1*q2^T)</span></span><br><span class="line">        W += Eigen::<span class="built_in">Vector3d</span>(q1[i].x, q1[i].y, q1[i].z) * Eigen::<span class="built_in">Vector3d</span>(q2[i].x, q2[i].y, q2[i].z).<span class="built_in">transpose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;W=&quot;</span> &lt;&lt; W &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 对W进行SVD分解</span></span><br><span class="line">    <span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; <span class="title">svd</span><span class="params">(W, Eigen::ComputeFullU | Eigen::ComputeFullV)</span></span>;</span><br><span class="line">    Eigen::Matrix3d U = svd.<span class="built_in">matrixU</span>(); <span class="comment">// 正交矩阵U</span></span><br><span class="line">    Eigen::Matrix3d V = svd.<span class="built_in">matrixV</span>(); <span class="comment">// 正交矩阵V</span></span><br><span class="line">    <span class="keyword">if</span> (U.<span class="built_in">determinant</span>() * V.<span class="built_in">determinant</span>() &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">U</span>(x, <span class="number">2</span>) *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U=&quot;</span> &lt;&lt; U &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V=&quot;</span> &lt;&lt; V &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3d R_ = U * (V.<span class="built_in">transpose</span>());</span><br><span class="line">    Eigen::Vector3d t_ = Eigen::<span class="built_in">Vector3d</span>(p1.x, p1.y, p1.z) - R_ * Eigen::<span class="built_in">Vector3d</span>(p2.x, p2.y, p2.z);</span><br><span class="line"></span><br><span class="line">    R = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    t = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; <span class="built_in">t_</span> ( <span class="number">0</span>,<span class="number">0</span> ), <span class="built_in">t_</span> ( <span class="number">1</span>,<span class="number">0</span> ), <span class="built_in">t_</span> ( <span class="number">2</span>,<span class="number">0</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-BA优化"><a href="#4-BA优化" class="headerlink" title="4.BA优化"></a>4.BA优化</h2><h3 id="自定义3D-3D的边"><a href="#自定义3D-3D的边" class="headerlink" title="自定义3D-3D的边"></a>自定义3D-3D的边</h3><p>由于 g2o/sba 中没有提供 3D 到 3D 的边，而我们又想使用 g2o/sba 中李代数实现的位姿节点，所以最好的方式是自定义一种这样的边，并向 g2o 提供解析求导方式。</p><p> $J$矩阵:</p><script type="math/tex; mode=display">\begin{bmatrix}0     &-z &y     &-1 &0     &0 \\z     &0     &-x &0     &-1 &0 \\-y     &x  &0     &0     &0     &-1\end{bmatrix}</script><p>自定义 3D 到 3D 的边：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjectXYZRGBDPoseOnly</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">3</span>, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(<span class="keyword">const</span> Eigen::Vector3d &amp;point) : _point(point) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// measurement is p, point is p&#x27;</span></span><br><span class="line">        _error = _measurement - pose-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(_point); <span class="comment">// 重投影误差</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">        g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">g2o::SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;</span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point); <span class="comment">// .map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_jacobianOplusXi是误差关于世界坐标系下坐标点的偏导</span></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BA优化"><a href="#BA优化" class="headerlink" title="BA优化"></a>BA优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.BA优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为6(即为se3李代数的维数，前三维为平移，后三维为旋转)</span></span><br><span class="line">    <span class="comment">// 误差值维度为3(每个3D点在第二个相机中的投影)</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器:使用eigen中sparse Cholesky 求解</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverEigen&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 梯度下降方法，GN(高斯牛顿)418133364</span></span><br><span class="line">    g2o::OptimizationAlgorithmGaussNewton *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用GN(高斯牛顿)方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.构建顶点</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>(); <span class="comment">// 相机位姿</span></span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(Eigen::Matrix3d::<span class="built_in">Identity</span>(), Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.构建边</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    vector&lt;EdgeProjectXYZRGBDPoseOnly*&gt; edges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeProjectXYZRGBDPoseOnly *edge = <span class="keyword">new</span> <span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(Eigen::<span class="built_in">Vector3d</span>(pts2[i].x,pts2[i].y,pts2[i].z));</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;(pose));</span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector3d</span>(pts1[i].x,pts1[i].y,pts1[i].z));</span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix3d::<span class="built_in">Identity</span>()*<span class="number">1e4</span>);</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">        index++;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 开始优化</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2-t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;优化用时: &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;优化后的T: \n: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Eigen::<span class="built_in">Isometry3d</span>(pose-&gt;<span class="built_in">estimate</span>()).<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;提供彩色图与深度图：img1 img2 depth1 depth2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.特征点匹配</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;组特征匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.建立3D点</span></span><br><span class="line">    Mat depth_1 = <span class="built_in">imread</span>(argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    Mat depth_2 = <span class="built_in">imread</span>(argv[<span class="number">4</span>], CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point3f&gt; pts1, pts2;</span><br><span class="line">    <span class="built_in">build_3d_points</span>(depth_1, depth_2, K, keypoints_1, keypoints_2, matches, pts1, pts2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.SVD求解ICP</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_3d3d</span>(pts1, pts2, R, t);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共有&quot;</span> &lt;&lt; pts1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;对3D-3D&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ICP分解结果为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R: \n&quot;</span></span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: \n&quot;</span></span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 由于前面的推导是按照pi= Rp′i+t进行的，这里的R,t, </span></span><br><span class="line">    <span class="comment">// 是第二帧到第一帧的变换，与前面PnP部分是相反的。</span></span><br><span class="line">    <span class="comment">// 所以在输出结果中，我们同时打印了逆变换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R_inv: \n &quot;</span> &lt;&lt; R.<span class="built_in">t</span>() &lt;&lt; endl; <span class="comment">// 求逆</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t_inv: \n &quot;</span> &lt;&lt; -R.<span class="built_in">t</span>() * t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.BA优化</span></span><br><span class="line">    <span class="built_in">bundleAdjustment</span>(pts1, pts2, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLsits.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_3d3d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用g2o</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( CSparse REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CSPARSE_INCLUDE_DIR&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_3d3d pose_estimation_3d3d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_3d3d </span><br><span class="line">   <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">   g2o_core g2o_stuff g2o_types_sba g2o_csparse_extension </span><br><span class="line">   <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">max_dist: 94</span><br><span class="line">min_dist: 4</span><br><span class="line">一共找到79组特征匹配</span><br><span class="line">3d-3d pairs: 72</span><br><span class="line">W=  10.871 -1.01948  2.54771</span><br><span class="line">-2.16033  3.85307 -5.77742</span><br><span class="line"> 3.94738 -5.79979  9.62203</span><br><span class="line">U=  0.558087  -0.829399 -0.0252034</span><br><span class="line"> -0.428009  -0.313755   0.847565</span><br><span class="line">  0.710878   0.462228   0.530093</span><br><span class="line">V=  0.617887  -0.784771 -0.0484806</span><br><span class="line"> -0.399894  -0.366747   0.839989</span><br><span class="line">  0.676979   0.499631   0.540434</span><br><span class="line">一共有72对3D-3DICP分解结果为：</span><br><span class="line">R: </span><br><span class="line">[0.9969452349468715, 0.05983347698056557, -0.05020113095482046;</span><br><span class="line"> -0.05932607657705309, 0.9981719679735133, 0.01153858699565957;</span><br><span class="line"> 0.05079975545906246, -0.008525103184062521, 0.9986724725659557]</span><br><span class="line">t: </span><br><span class="line">[0.144159841091821;</span><br><span class="line"> -0.06667849443812729;</span><br><span class="line"> -0.03009747273569774]</span><br><span class="line">R_inv: </span><br><span class="line"> [0.9969452349468715, -0.05932607657705309, 0.05079975545906246;</span><br><span class="line"> 0.05983347698056557, 0.9981719679735133, -0.008525103184062521;</span><br><span class="line"> -0.05020113095482046, 0.01153858699565957, 0.9986724725659557]</span><br><span class="line">t_inv: </span><br><span class="line"> [-0.1461462958593589;</span><br><span class="line"> 0.05767443542067568;</span><br><span class="line"> 0.03806388018483625]</span><br><span class="line">iteration= 0     chi2= 18161.146626      time= 4.6935e-05        cumTime= 4.6935e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 1     chi2= 18155.141919      time= 9.614e-06         cumTime= 5.6549e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 2     chi2= 18155.140765      time= 9.938e-06         cumTime= 6.6487e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 3     chi2= 18155.140764      time= 9.516e-06         cumTime= 7.6003e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 4     chi2= 18155.140764      time= 8.688e-06         cumTime= 8.4691e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 5     chi2= 18155.140764      time= 8.358e-06         cumTime= 9.3049e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 6     chi2= 18155.140764      time= 1.0723e-05        cumTime= 0.000103772    edges= 72       schur= 0</span><br><span class="line">iteration= 7     chi2= 18155.140764      time= 1.1911e-05        cumTime= 0.000115683    edges= 72       schur= 0</span><br><span class="line">iteration= 8     chi2= 18155.140764      time= 1.3427e-05        cumTime= 0.00012911     edges= 72       schur= 0</span><br><span class="line">iteration= 9     chi2= 18155.140764      time= 1.207e-05         cumTime= 0.00014118     edges= 72       schur= 0</span><br><span class="line">优化用时: 0.000604832ms</span><br><span class="line">优化后的T: </span><br><span class="line">: </span><br><span class="line">  0.996945  0.0598335 -0.0502011    0.14416</span><br><span class="line">-0.0593261   0.998172  0.0115386 -0.0666785</span><br><span class="line"> 0.0507998 -0.0085251   0.998672 -0.0300979</span><br><span class="line">         0          0          0          1</span><br></pre></td></tr></table></figure><p>不使用解析求导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">优化用时: 0.00123263ms</span><br><span class="line">优化后的T: </span><br><span class="line">: </span><br><span class="line">   0.996945   0.0598335  -0.0502011     0.14416</span><br><span class="line"> -0.0593261    0.998172   0.0115386  -0.0666785</span><br><span class="line">  0.0507998 -0.00852509    0.998672  -0.0300979</span><br><span class="line">          0           0           0           1</span><br></pre></td></tr></table></figure><p><strong>不难发现,使用解析求导(即给出函数<code>virtual void linearizeOplus()</code>),比使用数值求导(即不提供该函数)要快的多.</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;$ICP:$迭代最近点$（Iterative Closest Point）$求解。读者应该注意到，$3D-3D $位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组 $3D $点之间的变换时，和相机并没有关系。因此，在激光 $SLAM $中也会碰到 $ICP$，不过由于激光数据特征不够丰富，我们无从知道两个点集之间的匹配关系，只能认为距离最近的两个点为同一个，所以这个方法称为迭代最近点。而在视觉中，特征点为我们提供了较好的匹配关系，所以整个问题就变得更简单了。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch7_求解PnP并使用BA优化</title>
    <link href="http://lukeyalvin.top/2022/03/25/%E6%B1%82%E8%A7%A3PnP%E5%B9%B6%E4%BD%BF%E7%94%A8BA%E4%BC%98%E5%8C%96/"/>
    <id>http://lukeyalvin.top/2022/03/25/%E6%B1%82%E8%A7%A3PnP%E5%B9%B6%E4%BD%BF%E7%94%A8BA%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-25T13:27:39.995Z</published>
    <updated>2022-03-30T02:53:23.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>$PnP（Perspective-n-Point）$是求解 $3D $到$ 2D $点对运动的方法。它描述了当我们知道$n $个$ 3D$ 空间点以及它们的投影位置时，如何估计相机所在的位姿。如果两张图像中，其中一张特征点的 $3D$ 位置已知，那么最少只需三个点对（需要至少一个额外点验证结果）就可以估计相机运动。特征点的$ 3D $位置可以由三角化，或者由 $RGB-D$ 相机的深度图确定。因此，在双目或$ RGB-D$ 的视觉里程计中，我们可以直接使用$ PnP$ 估计相机运动。而在单目视觉里程计中，必须先进行初始化，然后才能使用 $PnP$。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="PnP中的BA问题"><a href="#PnP中的BA问题" class="headerlink" title="PnP中的BA问题"></a>PnP中的BA问题</h1><p>我们可以把 $PnP $问题构建成一个定义于李代数上的非线性最小二乘问题。前面说的线性方法，往往是<strong>先求相</strong><br><strong>机位姿，再求空间点位置</strong>，而非线性优化则是把它们都看成优化变量，放在一起优化。这是一种非常通用的求解方式，我们可以用它对$ PnP $或$ ICP $给出的结果进行优化。</p><h2 id="1-重投影误差"><a href="#1-重投影误差" class="headerlink" title="1.重投影误差"></a>1.重投影误差</h2><p>在 $PnP $中，这个$ Bundle Adjustment $问题，是一个最小化重投影误差（Reprojection error）的问题。</p><p><img src="/2022/03/25/%E6%B1%82%E8%A7%A3PnP%E5%B9%B6%E4%BD%BF%E7%94%A8BA%E4%BC%98%E5%8C%96/image-20220329214556296.png" alt="image-20220329214556296"></p><p>该问题的误差项，是将像素坐标（观测到的投影位置）与 3D 点按照当前估计的位姿进行投影得到的位置相比较得到的误差，所以称之为重投影误差。如图，我们通过特征匹配，知道了 $p_1$和 $p_2$是同一个空间点$P$ 的投影，但是我们不知道相机的位姿。在初始值中，$P $的投影$\hat{p_2}$与实际的$ p_2$之间有一定的距离。于是我们调整相机的位姿，使得这个距离变小。不过，由于这个调整需要考虑很多个点，所以最后每个点的误差通常都不会精确为零。</p><p>考虑 $n$ 个三维空间点 $P $和它们的投影$ p$，我们希望计算相机的位姿 $R, t，$它的李代数表示为 $ξ$。假设某空间点坐标为$ P_i = [X_i , Y_i , Z_i ]^{T} $，其投影的像素坐标为 $u_i = [u_i , v_i ]^{T} $。<br>像素位置与空间点位置的关系如下：</p><script type="math/tex; mode=display">s_i\left[\begin{matrix}u_i\\v_i\\1\end{matrix}\right]=Kexp(ξ^{\land})\left[\begin{matrix}X_i\\Y_i\\Z_i\\1\end{matrix}\right]</script><p>写成矩阵形式：</p><script type="math/tex; mode=display">s_iu_i=Kexp(ξ^{\land})P_i</script><p>由于相机位姿未知以及观测点的噪声，该等式存在一个误差，把误差求和，构建最小二乘问题，然后寻找最好的相机位姿，使它最小化:</p><script type="math/tex; mode=display">ξ^{*}=arg \underset{ξ}{min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1} {s_i}Kexp(ξ^{\land})P_i\parallel^2_2</script><p>求每个误差项关于优化变量的导数，也就是线性化：</p><script type="math/tex; mode=display">e(x+\Delta x)\approx e(x)+J\Delta x</script><p>$e $为像素坐标误差（2 维），$x$ 为相机位姿（6 维）时，$J$ 将是一个 2 × 6 的矩阵。</p><h2 id="2-优化位姿"><a href="#2-优化位姿" class="headerlink" title="2.优化位姿"></a>2.优化位姿</h2><p>记变换到相机坐标系下的空间点坐标为 $P^′$:</p><script type="math/tex; mode=display">s\left[\begin{matrix}u\\v\\1\end{matrix}\right]=\left[\begin{matrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{matrix}\right]\left[\begin{matrix}X^{′}\\Y^{′}\\Z^{′}\end{matrix}\right]</script><p>利用第 3 行消去 $s$（实际上就是$ P^{′ }$的距离），得：</p><script type="math/tex; mode=display">u=f_x\frac{X^′}{Z^′}+c_x\\v=f_y\frac{Y^′}{Z^′}+c_y</script><p>对 $ξ^{\land} $左乘扰动量$ δξ$，然后考虑 $e$ 的变化关于扰动量的导数。利用链式法则:</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \delta \xi}=\underset{\delta \xi \rightarrow0}{lim}\frac{e(\delta \xi⊕\xi)}{\delta \xi}=\frac{\partial e}{\partial P^′}\frac{\partial P^′}{\partial \delta \xi}</script><p>其中：$\frac{\partial e}{\partial P^′}$</p><script type="math/tex; mode=display">\frac{\partial e}{\partial P^′}=-\begin{bmatrix}\frac{\partial u}{\partial X^′}&\frac{\partial u}{\partial Y^′}&\frac{\partial u}{\partial Z^′}            \\ \frac{\partial v}{\partial X^′}&\frac{\partial v}{\partial Y^′}&\frac{\partial v}{\partial Z^′}\end{bmatrix}=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}</script><p>$\frac{\partial P^′}{\partial \delta \xi}$为变换后的点关于李代数的导数：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial P^′}{\partial \delta \xi}&=\frac{\partial(TP)}{\partial \delta \xi} \\ &=\underset{\delta \xi \rightarrow0}{lim}\frac{exp(\delta \xi ^{\land})exp(\xi ^{\land})p-exp(\xi ^{\land})p}{\delta \xi}\\&\approx\underset{\delta \xi \rightarrow0}{lim}\frac{(I+\delta \xi ^{\land})exp(\xi ^{\land})p-exp(\xi ^{\land})p}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\delta \xi ^{\land}exp(\xi ^{\land})p}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\begin{bmatrix}\delta \phi^{\land}&\delta \rho \\0^T&0\end{bmatrix}\begin{bmatrix}Rp+t \\1\end{bmatrix}}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\begin{bmatrix}\delta \phi^{\land}(Rp+t)+\delta \rho  \\0\end{bmatrix}}{\delta \xi}\\&=\begin{bmatrix}I &-(RP+t)^{\land}\\0^{T}&0^{T}\end{bmatrix}\\&=\begin{bmatrix}I &-P^{′\land}\\0^{T}&0^{T}\end{bmatrix}\\&=(TP)^⊙\end{align}</script><p>两项相乘：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial e}{\partial \delta \xi}&=\frac{\partial e}{\partial P^′}\frac{\partial P^′}{\partial \delta \xi}\\&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\&=J\end{align}</script><p>这个雅可比矩阵描述了重投影误差关于相机位姿李代数的一阶变化关系，</p><h2 id="3-优化空间点位置"><a href="#3-优化空间点位置" class="headerlink" title="3.优化空间点位置"></a>3.优化空间点位置</h2><p>讨论 $e$关于空间点 $P $的导数</p><script type="math/tex; mode=display">\frac{\partial e}{\partial P}=\frac{\partial e}{\partial P^′}\frac{\partial P^′}{\partial P}</script><p>由于：</p><script type="math/tex; mode=display">\begin{align}P^′&=exp(\xi ^{\land})P=RP+t\\\frac{\partial P^′}{\partial P}&=R\end{align}</script><p>所以：</p><script type="math/tex; mode=display">\frac{\partial e}{\partial P}=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}R</script><p><strong>我们推导了观测相机方程关于相机位姿与特征点的两个导数矩阵。它们十分重要，能够在优化过程中提供重要的梯度方向，指导优化的迭代。</strong></p><h1 id="求解PnP"><a href="#求解PnP" class="headerlink" title="求解PnP"></a>求解PnP</h1><p>$PnP $问题有很多种求解方法，例如用三对点估计位姿的 $P3P$，直接线性变换$(DLT)$，$EPnP(Efficient PnP)$，$UPnP$等等。此外，还能用非线性优化的方式，构建最小二乘问题并迭代求解，也就是万金油式的$ Bundle Adjustment$。</p><p>其中$P3P$利用了三角形相似性质，求解投影点 $a, b, c$ 在相机坐标系下的 3D 坐标，最后把问题转换成一个 3D 到 3D 的位姿估计问题($ICP$问题)。但是，$P3P$ 只利用三个点的信息。当给定的配对点多于 3 组时，难以利用更多的信息；而且，如果 3D 点或 2D 点受噪声影响，或者存在误匹配，则算法失效。</p><p>在 $SLAM$ 当中，通常的做法是先使用 $P3P/EPnP$ 等方法估计相机位姿，然后构建最小二乘优化问题对估计值进行调整$（Bundle Adjustment）$。</p><h2 id="1-特征点匹配"><a href="#1-特征点匹配" class="headerlink" title="1.特征点匹配"></a>1.特征点匹配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 特征匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; match;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, match);</span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span>(dist &lt; min_dist) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span>(dist &gt; max_dist) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_dist: &quot;</span> &lt;&lt; max_dist &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_dist: &quot;</span> &lt;&lt; min_dist &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span>*min_dist,<span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-建立3D点"><a href="#2-建立3D点" class="headerlink" title="2.建立3D点"></a>2.建立3D点</h2><p><code>queryIdx</code> 代表的特征点序列是 <code>keypoints1</code> 中的，<code>trainIdx</code>代表的特征点序列是<code>keypoints2</code>中的，此时这两张图中的特征点相互匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;queryIdx: &quot;</span> &lt;&lt; keypoints_1[m.queryIdx].pt &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;trainIdx: &quot;</span> &lt;&lt; keypoints_2[m.trainIdx].pt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两行代码返回的类型都是<code>Point2d</code>，对同一个匹配点对，总有第一帧图像的像素点坐标<code>keypoints_1[m.queryIdx].pt</code>与第二帧图像的像素点坐标<code>keypoints_2[m.trainIdx].pt</code>相对应。因此，如果匹配点对为79,则存在79对相互对应的<code>keypoints_1[m.queryIdx].pt</code>与<code>keypoints_2[m.trainIdx].pt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------第77组匹配点----------</span><br><span class="line">queryIdx: [207.825, 286.655]</span><br><span class="line">trainIdx: [186.325, 290.238]</span><br><span class="line">--------第78组匹配点----------</span><br><span class="line">queryIdx: [383.4, 326.07]</span><br><span class="line">trainIdx: [347.569, 336.819]</span><br><span class="line">--------第79组匹配点----------</span><br><span class="line">queryIdx: [351.152, 229.324]</span><br><span class="line">trainIdx: [333.236, 240.073]</span><br></pre></td></tr></table></figure><p>由于我们需要3D-2D，因此需要将一对匹配点的其中的一个转换成相机坐标系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 像素坐标系转换成相机归一化平面的投影</span></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span><span class="params">(<span class="keyword">const</span> Point2d &amp;p, <span class="keyword">const</span> Mat &amp;K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span>(</span><br><span class="line">        (p.x - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        (p.y - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">&#123;</span><br><span class="line">    ushort d = d1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)]; <span class="comment">// 获取第一帧图像匹配的每个特征点的深度</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">float</span> dd = d / <span class="number">5000.0</span>;</span><br><span class="line">    Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">    <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">    pts_3d.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd, p1.y * dd, dd));   <span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">    pts_2d.<span class="built_in">push_back</span>(keypoints_2[m.trainIdx].pt);          <span class="comment">// 第二帧图像的像素坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一对匹配点，其中一个点是第一帧图像中的像素点，我们将它的$2D$坐标<code>keypoints_1[m.queryIdx].pt</code>转换成了相机坐标系下的$3D$点，并将转换后的$3D$坐标系存入容器<code>pts_3d</code>内；另一个点是第二帧图像中的像素点，我们直接获得它的$2D$坐标<code>keypoints_2[m.trainIdx].pt</code>，并将其存入容器<code>pts_2d</code>内；</p><h2 id="3-求解PnP"><a href="#3-求解PnP" class="headerlink" title="3.求解PnP"></a>3.求解PnP</h2><p>这里使用<code>EPnP</code>方法求解<code>PnP</code>，直接调用方法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用EPnP方法求解PnP</span></span><br><span class="line">Mat r, t;</span><br><span class="line"><span class="built_in">solvePnP</span>(pts_3d, pts_2d, K, <span class="built_in">Mat</span>(), r, t, <span class="literal">false</span>, cv::SOLVEPNP_EPNP);</span><br><span class="line">Mat R;</span><br><span class="line">cv::<span class="built_in">Rodrigues</span>(r, R); <span class="comment">// r为旋转向量形式，用Rodrigues公式转换为矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;R=&quot;</span> &lt;&lt; endl</span><br><span class="line">    &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; endl</span><br><span class="line">    &lt;&lt; t &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>Parameters:</p><ul><li>objectPoints - 世界坐标系下的控制点的坐标</li><li>imagePoints - 在像素坐标系下对应的控制点的坐标</li><li>cameraMatrix - 相机的内参矩阵</li><li>distCoeffs - 相机的畸变系数</li><li>rvec - 输出的旋转向量</li><li>tvec - 输出的平移向量</li><li><p>flags - 默认使用CV_ITERATIV迭代法</p></li><li><p>SolvePnPMethod-选择方法</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SolvePnPMethod</span> &#123;</span></span><br><span class="line">    SOLVEPNP_ITERATIVE   = <span class="number">0</span>,</span><br><span class="line">    SOLVEPNP_EPNP        = <span class="number">1</span>, </span><br><span class="line">    SOLVEPNP_P3P         = <span class="number">2</span>, </span><br><span class="line">    SOLVEPNP_DLS         = <span class="number">3</span>,</span><br><span class="line">    SOLVEPNP_UPNP        = <span class="number">4</span>, </span><br><span class="line">    SOLVEPNP_AP3P        = <span class="number">5</span>, </span><br><span class="line">    SOLVEPNP_IPPE        = <span class="number">6</span>, </span><br><span class="line">    SOLVEPNP_IPPE_SQUARE = <span class="number">7</span>,                           </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CV_DOXYGEN</span></span><br><span class="line">    SOLVEPNP_MAX_COUNT </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R=</span><br><span class="line">[0.9978745555297591, -0.05102729297915373, 0.04052883908410459;</span><br><span class="line"> 0.04983267620066928, 0.9983081506312504, 0.02995898472731967;</span><br><span class="line"> -0.04198899628432293, -0.02787564805402974, 0.9987291286613218]</span><br><span class="line">t=</span><br><span class="line">[-0.1273034869580363;</span><br><span class="line"> -0.01157187487421139;</span><br><span class="line"> 0.05667408337434332]</span><br></pre></td></tr></table></figure><h2 id="4-使用BA优化"><a href="#4-使用BA优化" class="headerlink" title="4.使用BA优化"></a>4.使用BA优化</h2><p>在使用 g2o 之前，我们要把问题建模成一个最小二乘的图优化问题，节点和边的选择：</p><ol><li><p><strong>节点：</strong>第二个相机的位姿节点 $ξ ∈ se(3)$，以及所有特征点的空间位置 $P ∈ \mathbb{R}^3 $。</p></li><li><p><strong>边：</strong>每个$ 3D$ 点在第二个相机中的投影，以观测方程来描述：</p><script type="math/tex; mode=display">z_j = h(ξ, P_j ).</script></li></ol><p>由于第一个相机位姿固定为零，我们没有把它写到优化变量里，但在习题中，我希望你能够把第一个相机的位姿与观测也考虑进来。现在我们根据一组 $3D $点和第二个图像中的 $2D $投影，估计第二个相机的位姿。所以我们把第一个相机画成虚线，表明我们不希望考虑它。</p><p><img src="/2022/03/25/%E6%B1%82%E8%A7%A3PnP%E5%B9%B6%E4%BD%BF%E7%94%A8BA%E4%BC%98%E5%8C%96/image-20220326112157782.png" alt="image-20220326112157782"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用BA优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;cv::Point3f&gt; &amp;points_3d,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;cv::Point2f&gt; &amp;points_2d,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;K,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;R,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为6(即为se3李代数的维数，前三维为平移，后三维为旋转)</span></span><br><span class="line">    <span class="comment">// 误差值维度为3(每个3D点在第二个相机中的投影)</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverCSparse&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 梯度下降方法，从GN(高斯牛顿), LM（列文伯格）, DogLeg 中选</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">//设置求解器（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// 打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.设置节点</span></span><br><span class="line">    <span class="comment">// 优化第二个相机的位姿</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    Eigen::Matrix3d R_mat;</span><br><span class="line">    R_mat &lt;&lt; R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(</span><br><span class="line">        R_mat,</span><br><span class="line">        Eigen::<span class="built_in">Vector3d</span>(t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))));</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line">    <span class="comment">// 优化所有特征点的空间位置 P</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Point3f p : points_3d)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexPointXYZ *point = <span class="keyword">new</span> g2o::<span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">        point-&gt;<span class="built_in">setId</span>(index++);</span><br><span class="line">        point-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z));</span><br><span class="line">        point-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>); <span class="comment">// g2o 中必须设置 marg 参见第十讲内容</span></span><br><span class="line">        optimizer.<span class="built_in">addVertex</span>(point);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备相机参数</span></span><br><span class="line">    g2o::CameraParameters *camera = <span class="keyword">new</span> g2o::<span class="built_in">CameraParameters</span>(</span><br><span class="line">        K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), Eigen::<span class="built_in">Vector2d</span>(K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>), K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)), <span class="number">0</span>);</span><br><span class="line">    camera-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addParameter</span>(camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置边(每个 3D 点在第二个相机中的投影)</span></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Point2f p : points_2d)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> g2o::<span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexPointXYZ *&gt;(optimizer.<span class="built_in">vertex</span>(index)));</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose);</span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y));</span><br><span class="line">        edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>());</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.优化</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after optimization: \n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;T= \n&quot;</span></span><br><span class="line">         &lt;&lt; Eigen::<span class="built_in">Isometry3d</span>(pose-&gt;<span class="built_in">estimate</span>()).<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入两张彩色图以及对应的深度图：img1 img2 depth1 depth2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    <span class="comment">// 1. 特征匹配</span></span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图一找到&quot;</span> &lt;&lt; keypoints_1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个关键点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图二找到&quot;</span> &lt;&lt; keypoints_2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个关键点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;筛选后一共&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;组匹配点&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立3D点</span></span><br><span class="line">    Mat d1 = <span class="built_in">imread</span>(argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED); <span class="comment">// 深度图为16位无符号数，单通道图像</span></span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point3f&gt; pts_3d;</span><br><span class="line">    vector&lt;Point2f&gt; pts_2d;</span><br><span class="line">    <span class="comment">//提取特征点的深度值：</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取得匹配点的深度，queryIdx(表示匹配点的索引)查询描述子索引，pt关键点的坐标 (y行地址)[x列地址]</span></span><br><span class="line">        ushort d = d1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)];</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">float</span> dd = d / <span class="number">5000.0</span>;</span><br><span class="line">        Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">        <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">        pts_3d.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd, p1.y * dd, dd)); <span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">        pts_2d.<span class="built_in">push_back</span>(keypoints_2[m.trainIdx].pt);        <span class="comment">// 第二帧图像的像素坐标</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3d-2d pairs: &quot;</span> &lt;&lt; pts_3d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用EPnP方法求解PnP</span></span><br><span class="line">    Mat r, t;</span><br><span class="line">    <span class="built_in">solvePnP</span>(pts_3d, pts_2d, K, <span class="built_in">Mat</span>(), r, t, <span class="literal">false</span>, cv::SOLVEPNP_EPNP);</span><br><span class="line">    Mat R;</span><br><span class="line">    cv::<span class="built_in">Rodrigues</span>(r, R); <span class="comment">// r为旋转向量形式，用Rodrigues公式转换为矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R=&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用BA优化</span></span><br><span class="line">    <span class="built_in">bundleAdjustment</span>(pts_3d, pts_2d, K, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_3d2d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用g2o</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"><span class="comment"># find_package( OpenCV REQUIRED ) # use this if in OpenCV2 </span></span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( CSparse REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CSPARSE_INCLUDE_DIR&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_3d2d pose_estimation_3d2d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_3d2d </span><br><span class="line">   <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">   <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">   g2o_core g2o_stuff g2o_types_sba g2o_csparse_extension g2o_types_slam3d <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">max_dist: <span class="number">94</span></span><br><span class="line">min_dist: <span class="number">4</span></span><br><span class="line">图一找到<span class="number">500</span>个关键点</span><br><span class="line">图二找到<span class="number">500</span>个关键点</span><br><span class="line">筛选后一共<span class="number">79</span>组匹配点</span><br><span class="line"><span class="number">3</span>d<span class="number">-2</span>d pairs: <span class="number">75</span></span><br><span class="line">R=</span><br><span class="line">[<span class="number">0.9978745555297591</span>, <span class="number">-0.05102729297915373</span>, <span class="number">0.04052883908410459</span>;</span><br><span class="line"> <span class="number">0.04983267620066928</span>, <span class="number">0.9983081506312504</span>, <span class="number">0.02995898472731967</span>;</span><br><span class="line"> <span class="number">-0.04198899628432293</span>, <span class="number">-0.02787564805402974</span>, <span class="number">0.9987291286613218</span>]</span><br><span class="line">t=</span><br><span class="line">[<span class="number">-0.1273034869580363</span>;</span><br><span class="line"> <span class="number">-0.01157187487421139</span>;</span><br><span class="line"> <span class="number">0.05667408337434332</span>]</span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">0.003377</span>  time= <span class="number">0.000995841</span>       cumTime= <span class="number">0.000995841</span>    edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">78.129155</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">5.9011e-05</span>        cumTime= <span class="number">0.00105485</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">52.086103</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">2</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">6.0375e-05</span>        cumTime= <span class="number">0.00111523</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">34.724069</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">3</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.4488e-05</span>        cumTime= <span class="number">0.00113971</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">23.149379</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">4</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3559e-05</span>        cumTime= <span class="number">0.00116327</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">15.432920</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3493e-05</span>        cumTime= <span class="number">0.00118677</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">10.288613</span>         levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">6</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3716e-05</span>        cumTime= <span class="number">0.00121048</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">6.859075</span>  levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">7</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">2.3546e-05</span>        cumTime= <span class="number">0.00123403</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">4.572717</span>  levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">0.000000</span>  time= <span class="number">0.000333687</span>       cumTime= <span class="number">0.00156772</span>     edges= <span class="number">75</span>       schur= <span class="number">1</span>        lambda= <span class="number">1227479343.475617</span>    levenbergIter= <span class="number">7</span></span><br><span class="line">after optimization: </span><br><span class="line">T= </span><br><span class="line">  <span class="number">0.997852</span> <span class="number">-0.0508704</span>  <span class="number">0.0412729</span>  <span class="number">-0.128668</span></span><br><span class="line"> <span class="number">0.0496577</span>   <span class="number">0.998319</span>  <span class="number">0.0298962</span> <span class="number">-0.0113707</span></span><br><span class="line"><span class="number">-0.0427243</span> <span class="number">-0.0277825</span>   <span class="number">0.998701</span>  <span class="number">0.0581576</span></span><br><span class="line">         <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure><p>迭代 8轮后，$LM $发现优化目标函数接近不变，于是停止了优化。我们输出了最后得到位姿变换矩阵$ T$ ，对比之前直接做 $PnP $的结果，大约在小数点后第三位发生了一些变化。这主要是由于我们同时优化了特征点和相机位姿导致的。</p><p>$Bundle Adjustment $是一种通用的做法。它可以不限于两个图像。我们完全可以放入多个图像匹配到的位姿和空间点进行迭代优化，甚至可以把整个$ SLAM$ 过程放进来。那种做法规模较大，主要在后端使用。在前端，我们通常考虑局部相机位姿和特征点的小型 $Bundle Adjustment $问题，希望实时对它进行求解和优化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;$PnP（Perspective-n-Point）$是求解 $3D $到$ 2D $点对运动的方法。它描述了当我们知道$n $个$ 3D$ 空间点以及它们的投影位置时，如何估计相机所在的位姿。如果两张图像中，其中一张特征点的 $3D$ 位置已知，那么最少只需三个点对（需要至少一个额外点验证结果）就可以估计相机运动。特征点的$ 3D $位置可以由三角化，或者由 $RGB-D$ 相机的深度图确定。因此，在双目或$ RGB-D$ 的视觉里程计中，我们可以直接使用$ PnP$ 估计相机运动。而在单目视觉里程计中，必须先进行初始化，然后才能使用 $PnP$。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>md公式积累</title>
    <link href="http://lukeyalvin.top/2022/03/25/md%E5%85%AC%E5%BC%8F%E7%A7%AF%E7%B4%AF/"/>
    <id>http://lukeyalvin.top/2022/03/25/md%E5%85%AC%E5%BC%8F%E7%A7%AF%E7%B4%AF/</id>
    <published>2022-03-25T12:10:07.356Z</published>
    <updated>2022-04-01T12:14:39.775Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Makedown常用符号。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="矩阵："><a href="#矩阵：" class="headerlink" title="矩阵："></a>矩阵：</h1><ul><li>matrix</li></ul><script type="math/tex; mode=display">\begin{matrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{matrix}</script><ul><li>pmatrix</li></ul><script type="math/tex; mode=display">\begin{pmatrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{pmatrix}</script><ul><li>bmatrix</li></ul><script type="math/tex; mode=display">\begin{bmatrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{bmatrix}</script><ul><li>Bmatrix</li></ul><script type="math/tex; mode=display">\begin{Bmatrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{Bmatrix}</script><ul><li>vmatrix</li></ul><script type="math/tex; mode=display">\begin{vmatrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{vmatrix}</script><ul><li>Vmatrix</li></ul><script type="math/tex; mode=display">\begin{Vmatrix}f_x &0 &c_x\\0 &f_y &c_y\\0&0 &1\end{Vmatrix}</script><h1 id="约等于，三角形"><a href="#约等于，三角形" class="headerlink" title="约等于，三角形"></a>约等于，三角形</h1><script type="math/tex; mode=display">e(x+\Delta x)\approx e(x)+J\Delta x</script><h1 id="集合符号"><a href="#集合符号" class="headerlink" title="集合符号"></a>集合符号</h1><div class="table-container"><table><thead><tr><th>\in</th><th>∈</th><th>属于</th></tr></thead><tbody><tr><td>\notin</td><td>∉</td><td>不属于</td></tr><tr><td>\subset</td><td>⊂</td><td>真子集</td></tr><tr><td>\not \subset</td><td>⊄</td><td>非子集</td></tr><tr><td>\subseteq</td><td>⊆</td><td>子集</td></tr><tr><td>\supset</td><td>⊃</td><td>超集</td></tr><tr><td>\supseteq</td><td>⊇</td><td>超集</td></tr><tr><td>\cup</td><td>∪</td><td>并集</td></tr><tr><td>\cap</td><td>∩</td><td>交集</td></tr><tr><td>\mathbb{R}</td><td>R</td><td>实数集</td></tr><tr><td>\emptyset</td><td>∅</td><td>空集</td></tr></tbody></table></div><h1 id="希腊符号"><a href="#希腊符号" class="headerlink" title="希腊符号"></a>希腊符号</h1><div class="table-container"><table><thead><tr><th>\alpha</th><th>α</th></tr></thead><tbody><tr><td>\beta</td><td>β</td></tr><tr><td>\gamma</td><td>γ</td></tr><tr><td>\Gamma</td><td>Γ</td></tr><tr><td>\theta</td><td>θ</td></tr><tr><td>\Theta</td><td>Θ</td></tr><tr><td>\delta</td><td>δ</td></tr><tr><td>\Delta</td><td>Δ</td></tr><tr><td>\triangledown</td><td>▽</td></tr><tr><td>\epsilon</td><td>ϵ</td></tr><tr><td>\zeta</td><td>ζ</td></tr><tr><td>\eta</td><td>η</td></tr><tr><td>\kappa</td><td>κ</td></tr><tr><td>\lambda</td><td>λ</td></tr><tr><td>\mu</td><td>μ</td></tr><tr><td>\nu</td><td>ν</td></tr><tr><td>\xi</td><td>ξ</td></tr><tr><td>\pi</td><td>π</td></tr><tr><td>\sigma</td><td>σ</td></tr><tr><td>\tau</td><td>τ</td></tr><tr><td>\upsilon</td><td>υ</td></tr><tr><td>\phi</td><td>ϕ</td></tr><tr><td>\omega</td><td>ω</td></tr><tr><td>\rho</td><td>$\rho $</td></tr><tr><td>\mathbb{R}</td><td>$\mathbb{R}$</td></tr><tr><td>\parallel</td><td>$\parallel$</td></tr><tr><td>\prime</td><td>$\prime$</td></tr><tr><td>\neq</td><td>$ \neq$</td></tr><tr><td>\dot{x}</td><td>$\dot{x}$</td></tr><tr><td>\ddot{x}</td><td>$\ddot{x}$</td></tr></tbody></table></div><p>极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow\infty}\frac{1}{x}</script><p>浅红色文字：<font color="#dd0000">浅红色文字：</font><br><br>深红色文字：<font color="#660000">深红色文字</font><br><br>浅绿色文字：<font color="#00dd00">浅绿色文字</font><br><br>深绿色文字：<font color="#006600">深绿色文字</font><br><br>浅蓝色文字：<font color="#0000dd">浅蓝色文字</font><br><br>深蓝色文字：<font color="#000066">深蓝色文字</font><br><br>浅黄色文字：<font color="#dddd00">浅黄色文字</font><br><br>深黄色文字：<font color="#666600">深黄色文字</font><br><br>浅青色文字：<font color="#00dddd">浅青色文字</font><br><br>深青色文字：<font color="#006666">深青色文字</font><br><br>浅紫色文字：<font color="#dd00dd">浅紫色文字</font><br><br>深紫色文字：<font color="#660066">深紫色文字</font><br> </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;Makedown常用符号。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="Makedown" scheme="http://lukeyalvin.top/categories/Makedown/"/>
    
    
    <category term="Makedown" scheme="http://lukeyalvin.top/tags/Makedown/"/>
    
  </entry>
  
  <entry>
    <title>ch7_对极约束求解相机运动</title>
    <link href="http://lukeyalvin.top/2022/03/24/%E5%AF%B9%E6%9E%81%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/"/>
    <id>http://lukeyalvin.top/2022/03/24/%E5%AF%B9%E6%9E%81%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/</id>
    <published>2022-03-24T07:31:51.082Z</published>
    <updated>2022-03-29T13:49:31.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>我们从两张图像中，可以得到一对配对好的特征点。如果我们有若干对这样的匹配点，就可以通过这些二维图像点的对应关系，恢复出在两帧之间摄像机的运动。整个推导结果，使用好的匹配点得到本质矩阵$E$或者基础矩阵$F$抑或单应矩阵$H$，然后通过将他们分解成$R,t$，就可以推算相机的位姿。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/2022/03/24/%E5%AF%B9%E6%9E%81%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220325110120640.png" alt="image-20220325110120640"></p><p>设 $P$ 的空间位置为：</p><script type="math/tex; mode=display">P=[X,Y,Z]^{T}</script><p>由于像素坐标与世界坐标的关系为：</p><script type="math/tex; mode=display">Z \left(\begin{matrix}u\\ v\\ 1\end{matrix}\right)=\left(\begin{matrix}f_x &0 &c_x\\0   &f_y &c_y\\0 &0 &1\\\end{matrix}\right)\left(\begin{matrix}X\\ Y\\ Z\end{matrix}\right)=KP</script><p>两个像素点 $p_1 , p_2 $的像素位置为:</p><script type="math/tex; mode=display">s_1p_1=KP，s_2p_2=K(RP+t)</script><p>使用齐次坐标：</p><script type="math/tex; mode=display">p_1=KP，p_2=K(RP+t)</script><p>取：$x_1=K^{-1}p_1,x_2=K^{-1}p_2$,这里的$ x_1 , x_2 $是两个像素点的归一化平面上的坐标。</p><p>代入上式:</p><script type="math/tex; mode=display">x_2=Rx_1+t</script><p>两边同时左乘$t^{\land}$:</p><script type="math/tex; mode=display">t^{\land}x_2=t^{\land}Rx_1</script><p>两侧同时左乘$x_2^{T}$，由$t^{\land}x_2$表示$t$与$x_2$的外积，外积的定义说明$t^{\land}x_2$与$t$、$x_2$都是垂直的，故而：</p><script type="math/tex; mode=display">x_2^{T}t^{\land}x_2=x_2^{T}t^{\land}Rx_1=0\\x_2^{T}Ex_1=0</script><p>带入$p_1,p_2$:</p><script type="math/tex; mode=display">p_2^{T}K^{-T}t^{\land}RK^{-1}p_1=0\\p_2^{T}Fp_1=0</script><p>因此验证对极约束：</p><script type="math/tex; mode=display">x_2^{T}t^{\land}Rx_1=0</script><h1 id="对极约束求解相机运动"><a href="#对极约束求解相机运动" class="headerlink" title="对极约束求解相机运动"></a>对极约束求解相机运动</h1><h2 id="1-特征匹配"><a href="#1-特征匹配" class="headerlink" title="1.特征匹配"></a>1.特征匹配</h2><p>这一部分的实践是在<a href="https://lukeyalvin.top/2022/03/24/特征提取/#more">特征提取与匹配</a>的基础上进行的，和之前的特征匹配没有区别，只是这里把它封装成一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找特征匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;good_matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;                    <span class="comment">// 定义描述子</span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();       <span class="comment">//创建ORB特征检测器</span></span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>(); <span class="comment">//创建ORB特征描述子提取.</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, matches);</span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; max_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            good_matches.<span class="built_in">push_back</span>(matches[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mat img_goodmatch;</span></span><br><span class="line">    <span class="comment">// drawMatches(img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch);</span></span><br><span class="line">    <span class="comment">// imshow(&quot;优化后匹配点对&quot;, img_goodmatch);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-估计两张图像间运动"><a href="#2-估计两张图像间运动" class="headerlink" title="2.估计两张图像间运动"></a>2.估计两张图像间运动</h2><p>当我们确定两帧图像之间的特征点以及匹配，我们就可以根据良好的匹配点来估计相机的运动，这里也是封装成了一个函数。可以使用本质矩阵、基础矩阵抑或单应矩阵，它们都是封装好的函数，传参即可，不需要个人写实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相机位姿估计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_2d2d</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;good_matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 相机内参,TUM Freiburg2</span></span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 把匹配点转换为vector&lt;Point2f&gt;的形式</span></span><br><span class="line">    vector&lt;Point2f&gt; points1;</span><br><span class="line">    vector&lt;Point2f&gt; points2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)good_matches.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//`queryIdx` 代表的特征点序列是 `keypoints1` 中的，</span></span><br><span class="line">        <span class="comment">//`trainIdx `代表的特征点序列是` keypoints2 `中的，此时这两张图中的特征点相互匹配。</span></span><br><span class="line">        points1.<span class="built_in">push_back</span>(keypoints_1[good_matches[i].queryIdx].pt);</span><br><span class="line">        points2.<span class="built_in">push_back</span>(keypoints_2[good_matches[i].trainIdx].pt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 计算基础矩阵</span></span><br><span class="line">    Mat fundamental_matrix;</span><br><span class="line">    fundamental_matrix = <span class="built_in">findFundamentalMat</span>(points1, points2, CV_FM_8POINT); <span class="comment">// 八点法求基础矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基础矩阵F：\n&quot;</span></span><br><span class="line">         &lt;&lt; fundamental_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算本质矩阵</span></span><br><span class="line">    <span class="function">Point2d <span class="title">principal_point</span><span class="params">(<span class="number">325.1</span>, <span class="number">249.7</span>)</span></span>; <span class="comment">//相机光心(cx cy), TUM dataset标定值</span></span><br><span class="line">    <span class="keyword">double</span> focal_length = <span class="number">521</span>;             <span class="comment">//相机焦距(fx fy), TUM dataset标定值</span></span><br><span class="line">    Mat essential_matrix = <span class="built_in">findEssentialMat</span>(points1, points2, focal_length, principal_point);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本质矩阵E：\n&quot;</span></span><br><span class="line">         &lt;&lt; essential_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算单应矩阵</span></span><br><span class="line">    <span class="comment">// RANSAC表示基于RANSAC的鲁棒算法</span></span><br><span class="line">    <span class="comment">// ransacReprojThreshold将点对视为内点的最大允许重投影错误阈值（仅用于RANSAC和RHO方法）一般1-10</span></span><br><span class="line">    Mat homography_matrix = <span class="built_in">findHomography</span>(points1, points2, RANSAC, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单应矩阵H：\n&quot;</span></span><br><span class="line">         &lt;&lt; homography_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 从本质矩阵中恢复旋转和平移信息.</span></span><br><span class="line">    <span class="built_in">recoverPose</span>(essential_matrix, points1, points2, R, t, focal_length, principal_point);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R: \n&quot;</span></span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: \n&quot;</span></span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-验证对极约束"><a href="#3-验证对极约束" class="headerlink" title="3.验证对极约束"></a>3.验证对极约束</h2><p>上面可知：</p><script type="math/tex; mode=display">x_2^{T}t^{\land}Rx_1=0</script><p>首先，要知道像素坐标转相机归一化坐标的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span><span class="params">(<span class="keyword">const</span> Point2d &amp;p, <span class="keyword">const</span> Mat &amp;K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 归一化坐标Pc(X/Z,Y/Z,1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span>(</span><br><span class="line">        (p.x - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), <span class="comment">// (u-cx)/fx = X/Z</span></span><br><span class="line">        (p.y - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment">// (v-cy)/fy = Y/Z</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此可以获得两个像素点的归一化坐标$(\frac{X}{Z},\frac{Y}{Z},1)$</p><p>实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point2d pt1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// keypoints_1[m.queryIdx].pt为像素坐标，K为相机内参矩阵</span></span><br><span class="line">Mat y1 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span>);       <span class="comment">// y1=(X/Z, Y/Z, 1) 相机归一化坐标</span></span><br><span class="line">Point2d pt2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);</span><br><span class="line">Mat y2 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>获得两个像素的归一化坐标之后，使用$x_2^{T}t^{\land}Rx_1=0$，进行验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat d = y2.<span class="built_in">t</span>() * t_x * R * y1; <span class="comment">//  y2.t()表示y2的转置，t_x表示t^</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;epipolar constraint = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这仅仅是一对像素点，最终我们会发现良好的匹配点一共有79对，因此需要写一个循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************</span></span><br><span class="line"><span class="comment">* 3.验证对极约束</span></span><br><span class="line"><span class="comment">**************/</span></span><br><span class="line">Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (DMatch m : good_matches)</span><br><span class="line">&#123;</span><br><span class="line">    Point2d pt1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// keypoints_1[m.queryIdx].pt为像素坐标，K为相机内参矩阵</span></span><br><span class="line">    Mat y1 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span>);       <span class="comment">// y1=(X/Z, Y/Z, 1) 相机归一化坐标</span></span><br><span class="line">    Point2d pt2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);</span><br><span class="line">    Mat y2 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span>);</span><br><span class="line">    Mat d = y2.<span class="built_in">t</span>() * t_x * R * y1; <span class="comment">//  y2.t()表示y2的转置，t_x表示t^</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;epipolar constraint = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><p>主函数，其中调用的方法，前文已经列出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d/calib3d.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入相邻两帧的图像&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入图像</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; good_matches;</span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 1.特征匹配</span></span><br><span class="line"><span class="comment">     **************/</span></span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, good_matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到了&quot;</span> &lt;&lt; good_matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;对匹配点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 2.估计两张图像间运动</span></span><br><span class="line"><span class="comment">     **************/</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_2d2d</span>(keypoints_1, keypoints_2, good_matches, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证E=t^R*scale</span></span><br><span class="line">    Mat t_x = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, -t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2.0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">               t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), <span class="number">0</span>, -t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) - t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t^R: \n&quot;</span></span><br><span class="line">         &lt;&lt; t_x * R &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 3.验证对极约束</span></span><br><span class="line"><span class="comment">     **************/</span></span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (DMatch m : good_matches)</span><br><span class="line">    &#123;</span><br><span class="line">        Point2d pt1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K); <span class="comment">// keypoints_1[m.queryIdx].pt为像素坐标，K为相机内参矩阵</span></span><br><span class="line">        Mat y1 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span>);       <span class="comment">// y1=(X/Z, Y/Z, 1) 相机归一化坐标</span></span><br><span class="line">        Point2d pt2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);</span><br><span class="line">        Mat y2 = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">1</span>) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span>);</span><br><span class="line">        Mat d = y2.<span class="built_in">t</span>() * t_x * R * y1; <span class="comment">//  y2.t()表示y2的转置，t_x表示t^</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;epipolar constraint = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_2d2d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable( pose_estimation_2d2d pose_estimation_2d2d.cpp extra.cpp ) # use this if in OpenCV2 </span></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_2d2d pose_estimation_2d2d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_2d2d <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一共找到了79对匹配点</span><br><span class="line">基础矩阵F：</span><br><span class="line">[4.544437503937326e-06, 0.0001333855576988952, -0.01798499246457619;</span><br><span class="line"> -0.0001275657012959839, 2.266794804637672e-05, -0.01416678429258694;</span><br><span class="line"> 0.01814994639952877, 0.004146055871509035, 1]</span><br><span class="line">本质矩阵E：</span><br><span class="line">[0.01097677480088526, 0.2483720528258777, 0.03167429207291153;</span><br><span class="line"> -0.2088833206039177, 0.02908423961781584, -0.6744658838357441;</span><br><span class="line"> 0.008286777636447118, 0.6614041624098427, 0.01676523772725936]</span><br><span class="line">单应矩阵H：</span><br><span class="line">[0.9261214281175537, -0.1445322024509824, 33.26921085699328;</span><br><span class="line"> 0.04535424464910424, 0.9386696693816731, 8.570979966717406;</span><br><span class="line"> -1.006197561051869e-05, -3.008140280167741e-05, 0.9999999999999999]</span><br><span class="line">R: </span><br><span class="line">[0.9969387384754708, -0.05155574188737422, 0.05878058527591362;</span><br><span class="line"> 0.05000441581290405, 0.998368531736214, 0.02756507279306545;</span><br><span class="line"> -0.06010582439453526, -0.02454140006844053, 0.9978902793175882]</span><br><span class="line">t: </span><br><span class="line">[-0.9350802885437915;</span><br><span class="line"> -0.03514646275858852;</span><br><span class="line"> 0.3526890700495534]</span><br><span class="line">t^R: </span><br><span class="line">[-0.01552350379276751, -0.3512511256212342, -0.04479421342842761;</span><br><span class="line"> 0.2932931178326273, -0.04199386952278789, 0.9889111138164588;</span><br><span class="line"> -0.992323587628662, 0.0236673579316946, 0.942925712677014]</span><br><span class="line">epipolar constraint = [0.6796225931993222]</span><br><span class="line">epipolar constraint = [1.041980822107436]</span><br><span class="line">........</span><br><span class="line">epipolar constraint = [1.014767775015567]</span><br><span class="line">epipolar constraint = [1.257231546320262]</span><br><span class="line">epipolar constraint = [1.000924219722595]</span><br><span class="line">epipolar constraint = [0.8732996303495971]</span><br></pre></td></tr></table></figure><h1 id="使用三角测量"><a href="#使用三角测量" class="headerlink" title="使用三角测量"></a>使用三角测量</h1><p>上文的对极约束求解相机运动存在尺度不确定性：</p><blockquote><p>由于 $E$ 本身具有尺度等价性，它分解得到的$ t, R $也有一个尺度等价性。而$ R ∈ SO(3) $自身具有约束，所以我们认为 $t $具有一个尺度。换言之，在分解过程中，对$ t $乘以任意非零常数，分解都是成立的。因此，我们通常把 $t $进行归一化，让它的长度等于 1。</p></blockquote><p>这也是由于单目相机本身的缺点，在单目 SLAM 中，仅通过单张图像无法获得像素的深度信息，我们需要通过三角测量（Triangulation）（或三角化）的方法来估计地图点的深度。</p><p><img src="/2022/03/24/%E5%AF%B9%E6%9E%81%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220325110908224.png" alt="image-20220325110908224"></p><p>按照对极几何中的定义，设 $x_1 , x_2 $为两个特征点的归一化坐标，满足：</p><script type="math/tex; mode=display">\begin{align}s_1p_1&=KP,\\ s_2p_2&=K(RP+t) \end{align}</script><p>已知：</p><script type="math/tex; mode=display">\begin{align}x_1 = K^{-1}p_1 \\x_2 = K^{-1}p_2\end{align}</script><p>将$p_1,p_2$换成$x_1,x_2$:</p><script type="math/tex; mode=display">\begin{align}s_1Kx_1&=KP,\\ s_2Kx_2&=K(RP+t) \end{align}</script><p>因此，$x_1,x_2$的关系满足：</p><script type="math/tex; mode=display">s_2x_2= s_1Rx_1+t</script><p>我们已经知道了 $R, t$，想要求解的是两个特征点的深度 $s_1 , s_2$ 。当然这两个深度是可以分开求的，比方说先来看 $s_1$ 。如果我要算 $s_1 $，那么先对上式两侧左乘一个 $x^{\land}_2$</p><script type="math/tex; mode=display">s_2x^{\land}_2x_2= s_1x^{\land}_2Rx_1+x^{\land}_2t\\s_1x^{\land}_2Rx_1+x^{\land}_2t=0 \tag{i}</script><p>这是一个关于$s_1$的方程，可以求得$s_1$的值，于是，我们就得到了两个帧下的点的深度，确定了它们的空间坐标。当然，由于噪声的存在，我们估得的 $R, t$，不一定精确使式$(i)$为零，所以更常见的做法求<strong>最小二乘解</strong>,而不是零解。</p><p>同样的，三角测量是在特征匹配以及估计两张图像间的运动的基础上进行的。之前我们已经获得了良好的匹配点，并通过本质矩阵求得相机的位姿$R,t$，在此基础上进行三角测量。</p><p>三角测量的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;DMatch&gt; &amp;matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;R, <span class="keyword">const</span> Mat &amp;t,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3d&gt; &amp;points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化单位阵(参考位姿矩阵)</span></span><br><span class="line">    Mat T1 =</span><br><span class="line">        (Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; </span><br><span class="line">         <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 对极约束求出的变换矩阵</span></span><br><span class="line">    Mat T2 =</span><br><span class="line">        (Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; </span><br><span class="line">         R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">         R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">         R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    Mat K =</span><br><span class="line">        (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">         <span class="number">520.9</span>, <span class="number">0</span>,      <span class="number">325.1</span>,</span><br><span class="line">         <span class="number">0</span>,     <span class="number">521.0</span>,  <span class="number">249.7</span>,</span><br><span class="line">         <span class="number">0</span>,     <span class="number">0</span>,      <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point2f&gt; pts_1, pts_2;</span><br><span class="line">    <span class="comment">// 遍历DMatch中匹配的特征点</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将像素坐标转换至归一化成像平面</span></span><br><span class="line">        pts_1.<span class="built_in">push_back</span>( <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt,K) );</span><br><span class="line">        pts_2.<span class="built_in">push_back</span>( <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt,K) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用三角化函数</span></span><br><span class="line">    Mat pts_4d;</span><br><span class="line">    <span class="comment">//函数接受的参数是两个相机位姿和特征点在两个相机坐标系下的归一化坐标，输出三角化后的特征点的3D坐标。</span></span><br><span class="line">    <span class="comment">//输出的3D坐标是齐次坐标，共四个维度（所以变量名为pts_4d），因此需要将前三个维度除以第四个维度以得到非齐次坐标xyz</span></span><br><span class="line">    cv::<span class="built_in">triangulatePoints</span>(T1, T2, pts_1, pts_2, pts_4d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts_4d.cols; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.<span class="built_in">col</span>(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>);<span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span><span class="params">(x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        points.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入相邻两帧的图片！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入图像</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.特征提取与匹配</span></span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到了&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个良好的匹配点&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2.估计两张图像间运动</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_2d2d</span>(keypoints_1, keypoints_2, matches, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.三角化</span></span><br><span class="line">    vector&lt;Point3d&gt; points;</span><br><span class="line">    <span class="built_in">triangulation</span>(keypoints_1,keypoints_2,matches,R,t,points);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.验证三角化点与特征点的重投影关系</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matches.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------第[&quot;</span>&lt;&lt; i+<span class="number">1</span> &lt;&lt;<span class="string">&quot;]个空间点-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个图</span></span><br><span class="line">        Point2d pt1_cam = <span class="built_in">pixel2cam</span>(keypoints_1[matches[i].queryIdx].pt, K);</span><br><span class="line">        <span class="function">Point2d <span class="title">pt1_cam_3d</span><span class="params">(points[i].x / points[i].z, points[i].y / points[i].z)</span></span>; <span class="comment">// 归一化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第一帧时的像素坐标: &quot;</span> &lt;&lt; pt1_cam &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第一帧时3D投影坐标：&quot;</span> &lt;&lt; pt1_cam_3d &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;深度d:&quot;</span> &lt;&lt; points[i].z &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第二个图</span></span><br><span class="line">        Point2f pt2_cam = <span class="built_in">pixel2cam</span>(keypoints_2[matches[i].trainIdx].pt, K);</span><br><span class="line">        Mat pt2_trans = R*(Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; points[i].x, points[i].y, points[i].z) + t;</span><br><span class="line">        pt2_trans /= pt2_trans.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第二帧时的像素坐标: &quot;</span> &lt;&lt; pt2_cam &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在第二帧时3D投影坐标：&quot;</span> &lt;&lt; pt2_trans.<span class="built_in">t</span>() &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">-- Max dist : 94.000000 </span><br><span class="line">-- Min dist : 4.000000 </span><br><span class="line">一共找到了79个良好的匹配点</span><br><span class="line">基础矩阵F：</span><br><span class="line">[4.544437503937326e-06, 0.0001333855576988952, -0.01798499246457619;</span><br><span class="line"> -0.0001275657012959839, 2.266794804637672e-05, -0.01416678429258694;</span><br><span class="line"> 0.01814994639952877, 0.004146055871509035, 1]</span><br><span class="line">本质矩阵E：</span><br><span class="line">[0.01097677480088526, 0.2483720528258777, 0.03167429207291153;</span><br><span class="line"> -0.2088833206039177, 0.02908423961781584, -0.6744658838357441;</span><br><span class="line"> 0.008286777636447118, 0.6614041624098427, 0.01676523772725936]</span><br><span class="line">单应矩阵H：</span><br><span class="line">[0.9261214281175537, -0.1445322024509824, 33.26921085699328;</span><br><span class="line"> 0.04535424464910424, 0.9386696693816731, 8.570979966717406;</span><br><span class="line"> -1.006197561051869e-05, -3.008140280167741e-05, 0.9999999999999999]</span><br><span class="line">R: </span><br><span class="line">[0.9969387384754708, -0.05155574188737422, 0.05878058527591362;</span><br><span class="line"> 0.05000441581290405, 0.998368531736214, 0.02756507279306545;</span><br><span class="line"> -0.06010582439453526, -0.02454140006844053, 0.9978902793175882]</span><br><span class="line">t: </span><br><span class="line">[-0.9350802885437915;</span><br><span class="line"> -0.03514646275858852;</span><br><span class="line"> 0.3526890700495534]</span><br><span class="line">--------第[1]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.0136303, -0.302687]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.0136588, -0.302975]</span><br><span class="line">深度d:14.4036</span><br><span class="line">点在第二帧时的像素坐标: [-0.00403148, -0.270058]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.004013293769641682, -0.2697748885145957, 1]</span><br><span class="line">--------第[2]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.153772, -0.0742802]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.153809, -0.0755175]</span><br><span class="line">深度d:9.63635</span><br><span class="line">点在第二帧时的像素坐标: [-0.179497, -0.0577735]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.1795174494211173, -0.05658791842651693, 1]</span><br><span class="line">--------第[3]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.468612, 0.119578]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.46862, 0.119797]</span><br><span class="line">深度d:7.88393</span><br><span class="line">点在第二帧时的像素坐标: [-0.499328, 0.1119]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.4993080966028579, 0.1116965292982101, 1]</span><br><span class="line">--------第[4]个空间点-----------</span><br><span class="line">点在第一帧时的像素坐标: [-0.226723, 0.0735125]</span><br><span class="line">点在第一帧时3D投影坐标：[-0.226723, 0.0735073]</span><br><span class="line">深度d:8.35771</span><br><span class="line">点在第二帧时的像素坐标: [-0.268958, 0.08119]</span><br><span class="line">点在第二帧时3D投影坐标：[-0.2689579480646592, 0.0811949362011327, 1]</span><br><span class="line">.......................(略)</span><br></pre></td></tr></table></figure><p>我们打印了每个空间点在两个相机坐标系下的投影坐标与像素坐标——相当于 P 的投影位置与看到的特征点位置。由于误差的存在，它们会有一些微小的差异。可以看到，误差的量级大约在小数点后第三位。可以看到，三角化特征点的距离大约为 14～15。但由于尺度不确定性，我们并不知道这里的 15 究竟是多少米。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>在ORBSLAM中这三种方法的顺序：</p><ul><li><p>使用<strong>特征点检测和特征匹配</strong>，寻找比较好的匹配点。</p></li><li><p>由两张图像的匹配点，利用<strong>对极几何</strong>计算出$H$或者$F$矩阵，并从这两个矩阵中恢复出$R，t$</p></li><li><p>有了$R,t $就可以利用相机的位姿和两帧对应的像素坐标用<strong>三角测量</strong>计算出其对应的3D点坐标。至此，相机的位姿和对应的地图点就都有了，接下来正常跟踪即可；</p></li><li><p>跟踪丢失后，就需要回到原来机器人曾经经过的位置找匹配帧，找到的匹配帧是有其3D地图点和位姿的，用这些3D点和当前帧自己的像素坐标， PnP计算出当前帧相较于匹配帧的运动$R，t$</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_25458977/article/details/113675519">https://blog.csdn.net/qq_25458977/article/details/113675519</a></p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;我们从两张图像中，可以得到一对配对好的特征点。如果我们有若干对这样的匹配点，就可以通过这些二维图像点的对应关系，恢复出在两帧之间摄像机的运动。整个推导结果，使用好的匹配点得到本质矩阵$E$或者基础矩阵$F$抑或单应矩阵$H$，然后通过将他们分解成$R,t$，就可以推算相机的位姿。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch7_特征提取与匹配</title>
    <link href="http://lukeyalvin.top/2022/03/24/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <id>http://lukeyalvin.top/2022/03/24/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</id>
    <published>2022-03-24T06:14:22.054Z</published>
    <updated>2022-03-29T13:11:00.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>目前主流的几种图像特征在 OpenCV 开源图像库中都已经集成完毕，我们可以很方便地进行调用。下面我们来实际练习一下 OpenCV 的图像特征提取、计算和匹配的过程。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>素材：</p><p><img src="/2022/03/24/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/FE.PNG" alt="FE"></p><p>相关函数参考文档：<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/features2d/doc/features2d.html">features2d. 二维图像特征框架</a></p><p>特征匹配的步骤：</p><ul><li>初始化</li></ul><p>主要是定义特征点、描述子、特征检测方式(ORB、FAST、SIFT)等;</p><ul><li>提取ORB特征点</li></ul><p>主要根据创建的检测器检测角点位置，以及使用角点来计算描述子。</p><ul><li>匹配点对筛选</li></ul><p>对两幅图像中的BRIEF描述子进行匹配，可以使用$ Hamming$ 距离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读入参数（相机相邻两帧的图片）</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请提供相邻两帧的图片！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取图像并保存为Mat数据类型</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR); <span class="comment">//存储的是三通道的彩色图片</span></span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一步：初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2; <span class="comment">// 定义特征点</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;               <span class="comment">// 定义描述子</span></span><br><span class="line">    <span class="comment">// FeatureDetetor 是虚类，通过定义FeatureDetector的对象</span></span><br><span class="line">    <span class="comment">// 可以使用多种特征检测方法。通过 create() 函数调用</span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();       <span class="comment">//创建ORB特征检测器</span></span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>(); <span class="comment">//创建ORB特征描述子提取.</span></span><br><span class="line">    <span class="comment">//对于给定参数，创建特征描述子匹配(使用默认的构造函数).</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二步：检测 Oriented FAST 角点位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三步：根据角点位置计算 BRIEF 描述子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line"></span><br><span class="line">    Mat outimg1;</span><br><span class="line">    <span class="built_in">drawKeypoints</span>(img_1, keypoints_1, outimg1, Scalar::<span class="built_in">all</span>(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;ORB特征点&quot;</span>, outimg1); <span class="comment">// 至此，已经成功提取ORB特征点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第四步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// DMatch用于匹配特征关键点的特征描述子的类：查询特征描述子索引, 特征描述子索引, 训练图像索引, 以及不同特征描述子之间的距离.</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, matches); <span class="comment">// 给定查询集合中的每个特征描述子，寻找最佳匹配.</span></span><br><span class="line"></span><br><span class="line">    Mat img_match;</span><br><span class="line">    <span class="built_in">drawMatches</span>(img_1, keypoints_1, img_2, keypoints_2, matches, img_match);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;所有匹配点对&quot;</span>, img_match);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第五步:匹配点对筛选</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; min_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    std::vector&lt;DMatch&gt; good_matches;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            good_matches.<span class="built_in">push_back</span>(matches[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat img_goodmatch;</span><br><span class="line">    <span class="built_in">drawMatches</span>(img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;优化后匹配点对&quot;</span>, img_goodmatch);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( feature_extraction )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>( feature_extraction feature_extraction.cpp  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( feature_extraction <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><p>特征点检测</p><p><img src="/2022/03/24/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/outimg1.png" alt="outimg1"></p><p>所有匹配点对</p><p><img src="/2022/03/24/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/img_match.png" alt="img_match"></p><p>优化后匹配点对</p><p><img src="/2022/03/24/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/img_goodmatch.png" alt="img_goodmatch"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;目前主流的几种图像特征在 OpenCV 开源图像库中都已经集成完毕，我们可以很方便地进行调用。下面我们来实际练习一下 OpenCV 的图像特征提取、计算和匹配的过程。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch6_使用g2o拟合曲线</title>
    <link href="http://lukeyalvin.top/2022/03/23/%E4%BD%BF%E7%94%A8g2o%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/"/>
    <id>http://lukeyalvin.top/2022/03/23/%E4%BD%BF%E7%94%A8g2o%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/</id>
    <published>2022-03-23T08:15:57.783Z</published>
    <updated>2022-03-29T13:10:11.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>g2o（General Graphic Optimization，G2O）。它是一个基于图优化的库。图优化，是把优化问题表现成图（Graph）的一种方式。这里的图是图论意义上的图。一个图由若干个<strong>顶点（Vertex）</strong>，以及连接着这些节点的<strong>边（Edge）</strong>组成。进而，用<strong>顶点表示优化变量</strong>，用<strong>边表示误差项</strong>。最基本的图优化，是用图模型来表达一个非线性最小二乘的优化问题。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>编译与安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.2 libcholmod-dev</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> g2o</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="使用G2O的步骤："><a href="#使用G2O的步骤：" class="headerlink" title="使用G2O的步骤："></a>使用G2O的步骤：</h2><p><img src="/2022/03/23/%E4%BD%BF%E7%94%A8g2o%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/1855613-20200414153348238-1860777008.png" alt="img"></p><h3 id="1、创建线性求解器"><a href="#1、创建线性求解器" class="headerlink" title="1、创建线性求解器"></a>1、创建线性求解器</h3><p>这里的线性求解器<code>LinearSolver</code>创建的是<code>LinearSolverCSparse</code>：</p><ul><li><strong>LinearSolverCholmod ：</strong>使用sparse cholesky分解法。继承自LinearSolverCCS</li><li><strong>LinearSolverCSparse：</strong>使用CSparse法。继承自LinearSolverCCS</li><li><strong>LinearSolverDense ：</strong>使用dense cholesky分解法。继承自LinearSolver</li><li><strong>LinearSolverEigen：</strong> 依赖项只有eigen，使用eigen中sparse Cholesky 求解，因此编译好后可以方便的在其他地方使用，性能和CSparse差不多。继承自LinearSolver</li><li><strong>LinearSolverPCG ：</strong>使用preconditioned conjugate gradient 法，继承自LinearSolver</li></ul><h3 id="2、矩阵块求解器"><a href="#2、矩阵块求解器" class="headerlink" title="2、矩阵块求解器"></a>2、矩阵块求解器</h3><p>BlockSolver 内部包含 LinearSolver，用上面我们定义的线性求解器LinearSolver来初始化。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br></pre></td></tr></table></figure><h3 id="3、创建总求解器solver。"><a href="#3、创建总求解器solver。" class="headerlink" title="3、创建总求解器solver。"></a>3、创建总求解器solver。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 梯度下降方法，从GN(高斯牛顿), LM（列文伯格）, DogLeg 中选</span></span><br><span class="line">g2o::OptimizationAlgorithmGaussNewton *solver_gn = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">g2o::OptimizationAlgorithmLevenberg *solver_lm = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">g2o::OptimizationAlgorithmDogleg *solver_dog = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmDogleg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br></pre></td></tr></table></figure><h3 id="4、创建稀疏优化器"><a href="#4、创建稀疏优化器" class="headerlink" title="4、创建稀疏优化器"></a>4、创建稀疏优化器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g2o::SparseOptimizer optimizer;    <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">optimizer.<span class="built_in">setAlgorithm</span>(solver_lm); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line">optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);        <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br></pre></td></tr></table></figure><h3 id="5、定义图的顶点和边"><a href="#5、定义图的顶点和边" class="headerlink" title="5、定义图的顶点和边"></a>5、定义图的顶点和边</h3><p>定义图的顶点和边。并添加到SparseOptimizer中。</p><h4 id="顶点的定义"><a href="#顶点的定义" class="headerlink" title="顶点的定义"></a>顶点的定义</h4><p>节点的定义比较简单，只需要继承 G2O 的基础节点类型，并且给出几个关键虚函数的实现即可：</p><ul><li><code>setToOriginImpl()</code>：重置节点的实现，通常情况下各个参数置 0 即可</li><li><code>oplusImpl()</code>：更新节点方法的实现，这里由于我们使用的节点和更新量都是 <code>Eigen::Vector3d</code>，直接相加即可</li><li><code>read(std::istream &amp;in); &amp; write(std::ostream &amp;out);</code>：读盘和写盘，还没有深入了解，不过大部分时间不需要</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="comment">// 顶点重置函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span> <span class="comment">// 顶点更新函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="边的定义"><a href="#边的定义" class="headerlink" title="边的定义"></a>边的定义</h4><p>边的定义需要继承 G2O 中的一个基础边类型，并给出几个关键函数的实现：</p><ul><li><code>computeError()</code>： 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，这个函数则是使用该边连接的节点和观测值来计算误差。最后要更新变量 <code>_error</code></li><li><code>linearizeOplus()</code>：计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</li><li><code>read(std::istream &amp;in); &amp; write(std::ostream &amp;out);</code>：读盘和写盘</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型   (边为误差项)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, CurveFittingVertex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CurveFittingEdge</span>(<span class="keyword">double</span> x) : <span class="built_in">BaseUnaryEdge</span>(), _x(x) &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> _x; <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6、设置优化参数，开始执行优化"><a href="#6、设置优化参数，开始执行优化" class="headerlink" title="6、设置优化参数，开始执行优化"></a>6、设置优化参数，开始执行优化</h3><p>设置SparseOptimizer的初始化、迭代次数、保存结果等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 设置优化初始值</span></span><br><span class="line">optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);            <span class="comment">// 设置优化次数</span></span><br></pre></td></tr></table></figure><h2 id="非线性拟合案例"><a href="#非线性拟合案例" class="headerlink" title="非线性拟合案例"></a>非线性拟合案例</h2><p>假设有一条满足以下方程的曲线：</p><script type="math/tex; mode=display">y=exp(ax^2+bx+c)+w</script><p>其中$ a, b, c $为曲线的参数，$w $为高斯噪声。我们故意选择了这样一个非线性模型，以使问题不至于太简单。现在，假设我们有$ N $个关于$ x, y$ 的观测数据点，想根据这些数据点求出曲线的参数。那么，可以求解下面的最小二乘问题以估计曲线参数：</p><script type="math/tex; mode=display">\underset{a,b,c}{min}\frac{1}{2}\sum^{N}_{i=1}\parallel y_i-exp(ax^2_i+bx_i+c)\parallel^2</script><p>节点为优化变量，边为误差项：</p><p><img src="/2022/03/23/%E4%BD%BF%E7%94%A8g2o%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/image-20220326161220343.png" alt="image-20220326161220343"></p><p>在曲线拟合问题中，整个问题只有一个顶点：曲线模型的参数$ a, b, c$；而每个带噪声的数据点，构成了一个个误差项，也就是图优化的边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span>     <span class="comment">// 顶点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span> <span class="comment">// 边</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span> <span class="comment">// GN</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span>    <span class="comment">// LM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span>       <span class="comment">// DogLeg</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点，模板参数：优化变量维度和数据类型   (节点为优化变量)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="comment">// 顶点重置函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span> <span class="comment">// 顶点更新函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型   (边为误差项)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, CurveFittingVertex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CurveFittingEdge</span>(<span class="keyword">double</span> x) : <span class="built_in">BaseUnaryEdge</span>(), _x(x) &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// const不声明该类就是一个抽象类，不能进行实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> _x; <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>, c = <span class="number">1.0</span>; <span class="comment">// 真实参数值</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;                      <span class="comment">// 数据点</span></span><br><span class="line">    <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;             <span class="comment">// 噪声Sigma值</span></span><br><span class="line">    cv::RNG rng;                      <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line">    <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;        <span class="comment">// abc参数的估计值</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;生成数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(a * x * x + b * x + c) + rng.<span class="built_in">gaussian</span>(w_sigma));</span><br><span class="line">        cout &lt;&lt; x_data[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y_data[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 梯度下降方法，从GN(高斯牛顿), LM（列文伯格）, DogLeg 中选</span></span><br><span class="line">    g2o::OptimizationAlgorithmGaussNewton *solver_gn = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver_lm = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    g2o::OptimizationAlgorithmDogleg *solver_dog = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmDogleg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer;    <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver_lm); <span class="comment">//设置求解器（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);        <span class="comment">// 打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往图中增加顶点</span></span><br><span class="line">    CurveFittingVertex *v = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    v-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 设置优化初始值</span></span><br><span class="line">    v-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);                              <span class="comment">// 设置顶点ID</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(v);                   <span class="comment">// 向稀疏优化器添加顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往图中增加边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]);</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, v);           <span class="comment">// 设置连接的顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]); <span class="comment">//观测数值</span></span><br><span class="line">        <span class="comment">// 信息矩阵：协方差矩阵的逆</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge); <span class="comment">// 向稀疏优化器添加边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 开始优化：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>(); <span class="comment">// 计时工具</span></span><br><span class="line"></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 设置优化初始值</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);            <span class="comment">// 设置优化次数</span></span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;求解优化共使用了&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出优化值</span></span><br><span class="line">    Eigen::Vector3d abc_estimate = v-&gt;<span class="built_in">estimate</span>(); <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;估计模型为：&quot;</span> &lt;&lt; abc_estimate.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeList.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( g2o_curve_fitting )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用ceres库</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找G2O</span></span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV</span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( curve_fitting g2o_curve_fitting.cpp )</span><br><span class="line"><span class="comment"># 与G2O和OpenCV链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( curve_fitting </span><br><span class="line">    <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">    g2o_core g2o_stuff</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">生成数据：</span><br><span class="line"><span class="symbol">0 </span><span class="number">2.71828</span></span><br><span class="line"><span class="number">0.01</span> <span class="number">2.93161</span></span><br><span class="line"><span class="number">0.02</span> <span class="number">2.12942</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0.96</span> <span class="number">47.7941</span></span><br><span class="line"><span class="number">0.97</span> <span class="number">48.5931</span></span><br><span class="line"><span class="number">0.98</span> <span class="number">51.8487</span></span><br><span class="line"><span class="number">0.99</span> <span class="number">51.0258</span></span><br><span class="line"> 开始优化：</span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">30373.727656</span>      time= <span class="number">7.3362</span>e-<span class="number">05</span>        cumTime= <span class="number">7.3362</span>e-<span class="number">05</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">699.050482</span>      levenbergIter= <span class="number">7</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">13336.948287</span>      time= <span class="number">4.4188</span>e-<span class="number">05</span>        cumTime= <span class="number">0.00011755</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">1864.134619</span>     levenbergIter= <span class="number">3</span></span><br><span class="line">iteration= <span class="number">2</span>     chi2= <span class="number">6946.262238</span>       time= <span class="number">3.8416</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000155966</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">1242.756412</span>     levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">3</span>     chi2= <span class="number">271.023143</span>        time= <span class="number">3.6174</span>e-<span class="number">05</span>        cumTime= <span class="number">0.00019214</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">414.252137</span>      levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">4</span>     chi2= <span class="number">118.903888</span>        time= <span class="number">3.7968</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000230108</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">138.084046</span>      levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">113.568661</span>        time= <span class="number">3.7864</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000267972</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">46.028015</span>       levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">6</span>     chi2= <span class="number">107.476468</span>        time= <span class="number">3.5648</span>e-<span class="number">05</span>        cumTime= <span class="number">0.00030362</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">15.342672</span>       levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">7</span>     chi2= <span class="number">103.014521</span>        time= <span class="number">4.424</span>e-<span class="number">05</span>         cumTime= <span class="number">0.00034786</span>     edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">5.114224</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">101.988349</span>        time= <span class="number">3.7035</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000384895</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">1.704741</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">9</span>     chi2= <span class="number">101.937388</span>        time= <span class="number">3.6393</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000421288</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.568247</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">10</span>    chi2= <span class="number">101.937021</span>        time= <span class="number">3.0743</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000452031</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.378831</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">11</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.2616</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000484647</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.252554</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">12</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.1629</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000516276</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.168370</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">13</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.2006</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000548282</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.112246</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">14</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.124</span>e-<span class="number">05</span>         cumTime= <span class="number">0.000579522</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">0.074831</span>        levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">15</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">5.3317</span>e-<span class="number">05</span>        cumTime= <span class="number">0.000632839</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">13391510.122618</span>         levenbergIter= <span class="number">8</span></span><br><span class="line">iteration= <span class="number">16</span>    chi2= <span class="number">101.937020</span>        time= <span class="number">3.736</span>e-<span class="number">05</span>         cumTime= <span class="number">0.000670199</span>    edges= <span class="number">100</span>      schur= <span class="number">0</span>        lambda= <span class="number">857056647.847525</span>        levenbergIter= <span class="number">3</span></span><br><span class="line">求解优化共使用了<span class="number">0.00163436</span>秒</span><br><span class="line">估计模型为：<span class="number">0.890912</span>   <span class="number">2.1719</span> <span class="number">0.943629</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;g2o（General Graphic Optimization，G2O）。它是一个基于图优化的库。图优化，是把优化问题表现成图（Graph）的一种方式。这里的图是图论意义上的图。一个图由若干个&lt;strong&gt;顶点（Vertex）&lt;/strong&gt;，以及连接着这些节点的&lt;strong&gt;边（Edge）&lt;/strong&gt;组成。进而，用&lt;strong&gt;顶点表示优化变量&lt;/strong&gt;，用&lt;strong&gt;边表示误差项&lt;/strong&gt;。最基本的图优化，是用图模型来表达一个非线性最小二乘的优化问题。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch6_使用Ceres拟合曲线</title>
    <link href="http://lukeyalvin.top/2022/03/23/%E4%BD%BF%E7%94%A8Ceres%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/"/>
    <id>http://lukeyalvin.top/2022/03/23/%E4%BD%BF%E7%94%A8Ceres%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/</id>
    <published>2022-03-23T02:30:33.488Z</published>
    <updated>2022-03-29T13:08:51.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Ceres solver 是谷歌开发的一款用于<a href="https://so.csdn.net/so/search?q=非线性&amp;spm=1001.2101.3001.7020">非线性</a>优化的库，在谷歌的开源激光雷达 slam 项目 cartographer 中被大量使用。Ceres 官网上的文档非常详细地介绍了其具体使用方法，相比于另外一个在 slam 中被广泛使用的图优化库 G2O，ceres 的文档可谓相当丰富详细。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>下载与编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ceres-solver/ceres-solver</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev libgoogle-glog-dev libgtest-dev</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> ceres-solver</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="Ceres使用步骤："><a href="#Ceres使用步骤：" class="headerlink" title="Ceres使用步骤："></a>Ceres使用步骤：</h2><ul><li>（1）定义$Cost Function$ 模型</li></ul><p>代价函数，也就是寻优的目标式。这个部分需要使用仿函数$（functor）$这一技巧来实现，做法是定义一个$ cost function $的结构体，在结构体内重载（）运算符。</p><ul><li><p>（2）通过代价函数构建待求解的优化问题</p></li><li><p>（3）配置求解器参数并求解问题</p></li></ul><h2 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例</h2><h3 id="1-构建代价函数"><a href="#1-构建代价函数" class="headerlink" title="1.构建代价函数"></a>1.构建代价函数</h3><p>本案例中待优化的函数为：$f(x)=10-x$，我们需要寻找最优的$x$值是的函数$f(x)$最小，所以误差项为$10.0-x[0]$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一部分：构建代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(<span class="number">10.0</span>) - x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-构建寻优问题"><a href="#2-构建寻优问题" class="headerlink" title="2.构建寻优问题"></a>2.构建寻优问题</h3><p>首先，定义 Problem 类型的变量，然后将构建的代价函数添加到寻优问题中。实例化对象<code>AutoDiffCostFunction</code>将创建的代价函数结构体实例作为输入，自动生成其微分并且返回一个<code>CostFunction</code> 类型的接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二部分：构建寻优问题</span></span><br><span class="line">   Problem problem;</span><br><span class="line">   CostFunction* cost_function =</span><br><span class="line">   <span class="comment">// 使用自动求导入，第一个1是输出维度，即残差的维度，第二个1是输入维度，即待寻优参数x的维度</span></span><br><span class="line">           <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor);</span><br><span class="line">   problem.<span class="built_in">AddResidualBlock</span>(cost_function, <span class="literal">NULL</span>, &amp;x); <span class="comment">//向问题中添加误差项，本问题比较简单，添加一个就行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-配置并运行求解器"><a href="#3-配置并运行求解器" class="headerlink" title="3.配置并运行求解器"></a>3.配置并运行求解器</h3><p>为求解这个优化问题，我们需要做一些配置，需要创建一个 Option，配置一下求解器的配置，创建一个 Summary。最后调用 Solve 方法，求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三部分： 配置并运行求解器</span></span><br><span class="line">    Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;<span class="comment">//输出到cout</span></span><br><span class="line">    Solver::Summary summary;<span class="comment">//优化信息</span></span><br><span class="line">    <span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);<span class="comment">//求解</span></span><br></pre></td></tr></table></figure><h3 id="4-输出结果"><a href="#4-输出结果" class="headerlink" title="4.输出结果"></a>4.输出结果</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//输出优化的简要信息</span></span><br><span class="line">  <span class="comment">//最终结果</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;x : &quot;</span> &lt;&lt; initial_x</span><br><span class="line">            &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>输出日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  1.250000e+01    0.00e+00    5.00e+00   0.00e+00   0.00e+00  1.00e+04        0    1.41e-05    4.20e-05</span><br><span class="line">   1  1.249750e-07    1.25e+01    5.00e-04   5.00e+00   1.00e+00  3.00e+04        1    3.10e-05    1.18e-04</span><br><span class="line">   2  1.388518e-16    1.25e-07    1.67e-08   5.00e-04   1.00e+00  9.00e+04        1    3.81e-06    1.31e-04</span><br><span class="line">Ceres Solver Report: Iterations: 3, Initial cost: 1.250000e+01, Final cost: 1.388518e-16, Termination: CONVERGENCE</span><br><span class="line">x : 5 -&gt; 10</span><br></pre></td></tr></table></figure><p>整体代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ceres;</span><br><span class="line"><span class="comment">//第一部分：构建代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(<span class="number">10.0</span>) - x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻优参数x的初始值，为5</span></span><br><span class="line">    <span class="keyword">double</span> initial_x = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">double</span> x = initial_x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二部分：构建寻优问题</span></span><br><span class="line">    Problem problem;</span><br><span class="line">    CostFunction* cost_function =</span><br><span class="line">            <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor); <span class="comment">//使用自动求导</span></span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, <span class="literal">NULL</span>, &amp;x); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三部分： 配置并运行求解器</span></span><br><span class="line">    Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;<span class="comment">//输出到cout</span></span><br><span class="line">    Solver::Summary summary;<span class="comment">//优化信息</span></span><br><span class="line">    <span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);<span class="comment">//求解</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//输出优化的简要信息</span></span><br><span class="line">    <span class="comment">//最终结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x : &quot;</span> &lt;&lt; initial_x</span><br><span class="line">              &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非线性优化案例"><a href="#非线性优化案例" class="headerlink" title="非线性优化案例"></a>非线性优化案例</h2><p>使用$ Ceres $拟合曲线</p><p>假设有一条满足以下方程的曲线：</p><script type="math/tex; mode=display">y=exp(ax^2+bx+c)+w</script><p>其中$ a, b, c $为曲线的参数，$w $为高斯噪声。我们故意选择了这样一个非线性模型，以使问题不至于太简单。现在，假设我们有$ N $个关于$ x, y$ 的观测数据点，想根据这些数据点求出曲线的参数。那么，可以求解下面的最小二乘问题以估计曲线参数：</p><script type="math/tex; mode=display">\underset{a,b,c}{min}\frac{1}{2}\sum^{N}_{i=1}\parallel y_i-exp(ax^2_i+bx_i+c)\parallel^2</script><p>请注意，在这个问题中，待估计的变量是 $a, b, c$，而不是$ x$。我们写一个程序，先根据模型生成 $x, y$ 的真值，然后在真值中添加高斯分布的噪声。随后，使用 $Ceres $从带噪声的数据中拟合参数模型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一部分：构建代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CURVE_FITTING_COST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构体中的自定义构造函数，同时初始化x和y(使用构造函数初始化const值，我们必须使用初始化列表)</span></span><br><span class="line">    <span class="built_in">CURVE_FITTING_COST</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 残差的计算</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="comment">// const T* const abc模型参数，有3维</span></span><br><span class="line">    <span class="comment">// T* residual      // 残差</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *<span class="keyword">const</span> abc, T *residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(_y) - ceres::<span class="built_in">exp</span>(abc[<span class="number">0</span>]* <span class="built_in">T</span>(_x)* <span class="built_in">T</span>(_x) + abc[<span class="number">1</span>] * <span class="built_in">T</span>(_x) + abc[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> _x, _y; <span class="comment">// x,y数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>, c = <span class="number">1.0</span>; <span class="comment">// 真实参数值</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;                      <span class="comment">// 数据点</span></span><br><span class="line">    <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;             <span class="comment">// 噪声Sigma值</span></span><br><span class="line">    cv::RNG rng;                      <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line">    <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;        <span class="comment">// abc参数的估计值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建存放x，y数据的容器</span></span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="comment">// 将生成100组的数据给容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;产生数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i / <span class="number">100.0</span>; <span class="comment">// x为0-1之间的100个数</span></span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(a * x * x + b * x + c) + rng.<span class="built_in">gaussian</span>(w_sigma));</span><br><span class="line">        cout &lt;&lt; x_data[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y_data[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 第二部分：构建寻优问题</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向问题中添加误差项</span></span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(</span><br><span class="line">            <span class="comment">// 使用自动求导，模板参数：误差类型，输出维度，输入维度，维数要与前面struct中一致</span></span><br><span class="line">            <span class="comment">// 第一个1是输出维度，即残差的维度，第二个3是输入维度，即待寻优参数abc的维度</span></span><br><span class="line">            <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line">                        (<span class="keyword">new</span> <span class="built_in">CURVE_FITTING_COST</span>(x_data[i], y_data[i])),</span><br><span class="line">            <span class="literal">nullptr</span>, <span class="comment">// 核函数，这里不使用，为空</span></span><br><span class="line">            abc);    <span class="comment">// 待估计参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三部分： 配置并运行求解器</span></span><br><span class="line">    ceres::Solver::Options options;               <span class="comment">// 这里有很多配置项可以填</span></span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">// 增量方程求解方法（QR）</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;  <span class="comment">// 输出到cout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化信息</span></span><br><span class="line">    ceres::Solver::Summary summary;                                                                </span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">// 计时点t1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始优化</span></span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options,&amp;problem,&amp;summary); <span class="comment">//求解!!!!</span></span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">// 计时点t2</span></span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1); <span class="comment">// 统计用时</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总计用时：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;估计的a,b,c的值为：&quot;</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : abc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( ceres_curve_fitting )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用ceres库</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找Ceres库并添加它的头文件</span></span><br><span class="line"><span class="keyword">find_package</span>( Ceres REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;CERES_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV</span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( curve_fitting ceres_curve_fitting.cpp )</span><br><span class="line"><span class="comment"># 与Ceres和OpenCV链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( curve_fitting <span class="variable">$&#123;CERES_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">产生数据：</span><br><span class="line">0 2.71828</span><br><span class="line">0.01 2.93161</span><br><span class="line">0.02 2.12942</span><br><span class="line">0.03 2.46037</span><br><span class="line">0.04 4.18814</span><br><span class="line">0.05 2.73368</span><br><span class="line">0.06 2.42751</span><br><span class="line">0.07 3.44729</span><br><span class="line">0.08 3.72543</span><br><span class="line">0.09 2.1358</span><br><span class="line">.....</span><br><span class="line">0.96 47.7941</span><br><span class="line">0.97 48.5931</span><br><span class="line">0.98 51.8487</span><br><span class="line">0.99 51.0258</span><br><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  1.824887e+04    0.00e+00    1.38e+03   0.00e+00   0.00e+00  1.00e+04        0    1.02e-04    1.95e-04</span><br><span class="line">   1  2.748700e+39   -2.75e+39    1.38e+03   7.67e+01  -1.52e+35  5.00e+03        1    1.02e-04    3.83e-04</span><br><span class="line">   2  2.429783e+39   -2.43e+39    1.38e+03   7.62e+01  -1.35e+35  1.25e+03        1    3.91e-05    4.59e-04</span><br><span class="line">   3  1.213227e+39   -1.21e+39    1.38e+03   7.30e+01  -6.73e+34  1.56e+02        1    3.29e-05    5.27e-04</span><br><span class="line">   4  1.852387e+37   -1.85e+37    1.38e+03   5.56e+01  -1.03e+33  9.77e+00        1    3.22e-05    5.87e-04</span><br><span class="line">   5  6.714689e+31   -6.71e+31    1.38e+03   2.96e+01  -3.85e+27  3.05e-01        1    3.22e-05    6.44e-04</span><br><span class="line">   6  9.500531e+12   -9.50e+12    1.38e+03   9.50e+00  -8.39e+08  4.77e-03        1    3.10e-05    7.00e-04</span><br><span class="line">   7  1.776982e+04    4.79e+02    1.83e+03   2.58e-01   1.18e+00  1.43e-02        1    1.14e-04    8.37e-04</span><br><span class="line">   8  1.599969e+04    1.77e+03    3.45e+03   5.53e-01   1.46e+00  4.29e-02        1    8.11e-05    9.54e-04</span><br><span class="line">   9  1.060557e+04    5.39e+03    7.62e+03   7.33e-01   1.68e+00  1.29e-01        1    1.30e-04    1.11e-03</span><br><span class="line">  10  3.669783e+03    6.94e+03    9.60e+03   5.25e-01   1.39e+00  3.86e-01        1    9.61e-05    1.24e-03</span><br><span class="line">  11  5.397541e+02    3.13e+03    5.00e+03   2.66e-01   1.12e+00  1.16e+00        1    8.20e-05    1.36e-03</span><br><span class="line">  12  1.484444e+02    3.91e+02    1.22e+03   8.46e-02   1.02e+00  3.48e+00        1    8.20e-05    1.48e-03</span><br><span class="line">  13  1.216815e+02    2.68e+01    3.76e+02   4.17e-02   1.01e+00  1.04e+01        1    7.39e-05    1.58e-03</span><br><span class="line">  14  9.290109e+01    2.88e+01    2.42e+02   9.10e-02   1.01e+00  3.13e+01        1    1.57e-04    1.76e-03</span><br><span class="line">  15  6.674330e+01    2.62e+01    1.09e+02   1.33e-01   1.00e+00  9.39e+01        1    1.31e-04    1.93e-03</span><br><span class="line">  16  5.936574e+01    7.38e+00    2.14e+01   1.08e-01   9.94e-01  2.82e+02        1    1.39e-04    2.10e-03</span><br><span class="line">  17  5.653118e+01    2.83e+00    1.36e+01   1.57e-01   9.98e-01  8.45e+02        1    9.11e-05    2.25e-03</span><br><span class="line">  18  5.310764e+01    3.42e+00    8.50e+00   2.81e-01   9.89e-01  2.53e+03        1    7.58e-05    2.35e-03</span><br><span class="line">  19  5.125939e+01    1.85e+00    2.84e+00   2.98e-01   9.90e-01  7.60e+03        1    7.39e-05    2.45e-03</span><br><span class="line">  20  5.097693e+01    2.82e-01    4.34e-01   1.48e-01   9.95e-01  2.28e+04        1    7.41e-05    2.54e-03</span><br><span class="line">  21  5.096854e+01    8.39e-03    3.24e-02   2.87e-02   9.96e-01  6.84e+04        1    7.30e-05    2.64e-03</span><br><span class="line">总计用时：0.00273015</span><br><span class="line">Ceres Solver Report: Iterations: 22, Initial cost: 1.824887e+04, Final cost: 5.096854e+01, Termination: CONVERGENCE</span><br><span class="line">估计的a,b,c的值为：0.891943 2.17039 0.944142 </span><br></pre></td></tr></table></figure><p>从 Ceres 给出的优化过程中可以看到，整体误差从 18248 左右下降到了 50.9，并且梯度也是越来越小。在迭代 22 次后算法收敛，最后的估计值为：</p><script type="math/tex; mode=display">a=0.891943, b=2.17039, c=0.944142</script><p>与真实值比较接近。</p><p><img src="/2022/03/23/%E4%BD%BF%E7%94%A8Ceres%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/Ceres.PNG" alt="Ceres"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;Ceres solver 是谷歌开发的一款用于&lt;a href=&quot;https://so.csdn.net/so/search?q=非线性&amp;amp;spm=1001.2101.3001.7020&quot;&gt;非线性&lt;/a&gt;优化的库，在谷歌的开源激光雷达 slam 项目 cartographer 中被大量使用。Ceres 官网上的文档非常详细地介绍了其具体使用方法，相比于另外一个在 slam 中被广泛使用的图优化库 G2O，ceres 的文档可谓相当丰富详细。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch5_拼接点云(PCL库)</title>
    <link href="http://lukeyalvin.top/2022/03/23/%E6%8B%BC%E6%8E%A5%E7%82%B9%E4%BA%91-PCL%E5%BA%93/"/>
    <id>http://lukeyalvin.top/2022/03/23/%E6%8B%BC%E6%8E%A5%E7%82%B9%E4%BA%91-PCL%E5%BA%93/</id>
    <published>2022-03-23T02:21:23.687Z</published>
    <updated>2022-03-29T13:08:35.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>程序提供了五张 RGB-D 图像，并且知道了每个图像的内参和外参。根据 RGB-D 图像和相机内参，我们可以计算任何一个像素在相机坐标系下的位置。同时，根据相机位姿，又能计算这些像素在世界坐标系下的位置。如果把所有像素的空间坐标都求出来，相当于构建一张类似于地图的东西。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>pose.txt 文件给出了五张图像的相机位姿（以 $T_{wc} $形式）。位姿记录的形式是平移向量加旋转四元数：<br>$[x, y, z, q_x , q_y , q_z , q_w ]$,其中 $q_w $是四元数的实部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0.228993 0.00645704 0.0287837 -0.0004327 -0.113131 -0.0326832 0.993042</span><br><span class="line">-0.50237 -0.0661803 0.322012 -0.00152174 -0.32441 -0.0783827 0.942662</span><br><span class="line">-0.970912 -0.185889 0.872353 -0.00662576 -0.278681 -0.0736078 0.957536</span><br><span class="line">-1.41952 -0.279885 1.43657 -0.00926933 -0.222761 -0.0567118 0.973178</span><br><span class="line">-1.55819 -0.301094 1.6215 -0.02707 -0.250946 -0.0412848 0.966741</span><br></pre></td></tr></table></figure><p>案例主要完成两件事：</p><p>(1). 根据内参计算一对 RGB-D 图像对应的点云；<br>(2). 根据各张图的相机位姿（也就是外参），把点云加起来，组成地图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/format.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;cv::Mat&gt; colorImgs, depthImgs; <span class="comment">// 彩色图和深度图</span></span><br><span class="line">    <span class="comment">// 定义相机位姿容器  用来存储相机位姿</span></span><br><span class="line">    vector&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses;</span><br><span class="line">    <span class="comment">// 读入五张图像的相机位姿（以 Twc 形式）</span></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;./pose.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;请在有pose.txt的目录下运行此程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入五张图片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">boost::format <span class="title">fmt</span><span class="params">(<span class="string">&quot;./%s/%d.%s&quot;</span>)</span></span>; <span class="comment">//图像文件格式</span></span><br><span class="line">        <span class="comment">// 读入彩色图放进容器中</span></span><br><span class="line">        colorImgs.<span class="built_in">push_back</span>(cv::<span class="built_in">imread</span>((fmt % <span class="string">&quot;color&quot;</span> % (i + <span class="number">1</span>) % <span class="string">&quot;png&quot;</span>).<span class="built_in">str</span>()));</span><br><span class="line">        <span class="comment">// 读入深度图放进容器中</span></span><br><span class="line">        depthImgs.<span class="built_in">push_back</span>(cv::<span class="built_in">imread</span>((fmt % <span class="string">&quot;depth&quot;</span> % (i + <span class="number">1</span>) % <span class="string">&quot;pgm&quot;</span>).<span class="built_in">str</span>(), <span class="number">-1</span>)); <span class="comment">// 使用-1读取原始图像</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读入pose中的位姿记录（位姿记录的形式是平移向量加旋转四元数）</span></span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;d : data)</span><br><span class="line">            fin &gt;&gt; d;</span><br><span class="line">        <span class="function">Eigen::Quaterniond <span class="title">q</span><span class="params">(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span></span>; <span class="comment">// qw qx qy qz</span></span><br><span class="line">        <span class="function">Eigen::Isometry3d <span class="title">T</span><span class="params">(q)</span></span>;                                   <span class="comment">// 由四元数构造变换矩阵T</span></span><br><span class="line">        <span class="comment">// 平移</span></span><br><span class="line">        T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])); <span class="comment">// x y z pretanslate 相当于左乘</span></span><br><span class="line">        <span class="comment">// 将位姿信息传入位姿容器</span></span><br><span class="line">        poses.<span class="built_in">push_back</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算点云并拼接</span></span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">double</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">double</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">double</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">double</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">double</span> depthScale = <span class="number">1000.0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正在将图像转换为点云...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义点云使用的格式：这里用的是XYZRGB</span></span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointXYZRGB PointT;</span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointCloud&lt;PointT&gt; PointCloud;</span><br><span class="line">    <span class="comment">// 新建一个点云</span></span><br><span class="line">    <span class="function">PointCloud::Ptr <span class="title">pointCloud</span><span class="params">(<span class="keyword">new</span> PointCloud)</span></span>;</span><br><span class="line">    <span class="comment">// 循环每一张图片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;张图像转换中&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cv::Mat color = colorImgs[i]; <span class="comment">// 读取彩色图</span></span><br><span class="line">        cv::Mat depth = depthImgs[i]; <span class="comment">// 读取对应的深度图</span></span><br><span class="line">        Eigen::Isometry3d T = poses[i]; <span class="comment">// 读入相机位姿</span></span><br><span class="line">        <span class="comment">// 将像素坐标转根据相机位姿换成世界坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; color.rows; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; color.cols; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> d = depth.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(v)[u]; <span class="comment">// 深度值</span></span><br><span class="line">                <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 为0表示没有测量到</span></span><br><span class="line">                Eigen::Vector3d point;</span><br><span class="line">                point[<span class="number">2</span>] = <span class="built_in"><span class="keyword">double</span></span>(d) / depthScale;   <span class="comment">// Z</span></span><br><span class="line">                point[<span class="number">0</span>] = (u - cx) * point[<span class="number">2</span>] / fx; <span class="comment">// X</span></span><br><span class="line">                point[<span class="number">1</span>] = (v - cy) * point[<span class="number">2</span>] / fy; <span class="comment">// Y</span></span><br><span class="line">                Eigen::Vector3d pointWorld = T * point; <span class="comment">// 得到世界坐标系下的点云</span></span><br><span class="line"></span><br><span class="line">                PointT p; <span class="comment">// XYZRGB类型的p</span></span><br><span class="line">                <span class="comment">// 前三位存储点云的世界坐标</span></span><br><span class="line">                p.x = pointWorld[<span class="number">0</span>];</span><br><span class="line">                p.y = pointWorld[<span class="number">1</span>];</span><br><span class="line">                p.z = pointWorld[<span class="number">2</span>]; </span><br><span class="line">                <span class="comment">// 后三位存储点云的bgr值</span></span><br><span class="line">                p.b = color.data[v * color.step + u * color.<span class="built_in">channels</span>()];</span><br><span class="line">                p.g = color.data[v * color.step + u * color.<span class="built_in">channels</span>() + <span class="number">1</span>];</span><br><span class="line">                p.r = color.data[v * color.step + u * color.<span class="built_in">channels</span>() + <span class="number">2</span>]; </span><br><span class="line">                pointCloud-&gt;points.<span class="built_in">push_back</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pointCloud-&gt;is_dense = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点云一共有&quot;</span> &lt;&lt; pointCloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个点。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileBinary</span>(<span class="string">&quot;myPCL.pcd&quot;</span>,*pointCloud);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( joinMap )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="comment"># opencv </span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># eigen </span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3/&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># pcl </span></span><br><span class="line"><span class="keyword">find_package</span>( PCL REQUIRED COMPONENT common io )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;PCL_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"><span class="keyword">add_definitions</span>( <span class="variable">$&#123;PCL_DEFINITIONS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( joinMap joinMap.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( joinMap <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure><p><img src="/2022/03/23/%E6%8B%BC%E6%8E%A5%E7%82%B9%E4%BA%91-PCL%E5%BA%93/PCL.PNG" alt="PCL"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;程序提供了五张 RGB-D 图像，并且知道了每个图像的内参和外参。根据 RGB-D 图像和相机内参，我们可以计算任何一个像素在相机坐标系下的位置。同时，根据相机位姿，又能计算这些像素在世界坐标系下的位置。如果把所有像素的空间坐标都求出来，相当于构建一张类似于地图的东西。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>使用OpenCV操作图像</title>
    <link href="http://lukeyalvin.top/2022/03/22/%E4%BD%BF%E7%94%A8OpenCV%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/"/>
    <id>http://lukeyalvin.top/2022/03/22/%E4%BD%BF%E7%94%A8OpenCV%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/</id>
    <published>2022-03-22T06:40:18.335Z</published>
    <updated>2022-03-25T08:59:37.673Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>OpenCV 提供了大量的开源图像算法，是计算机视觉中使用极广的图像处理算法库。在ubuntu 下，你可以选择从源代码安装和只安装库文件两种方式。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>源代码安装：</p><p>从 <a href="http://opencv.org/downloads.html">http://opencv.org/downloads.html</a> 中下载，选择 OpenCV for Linux 版本即可</p><p>在编译之前，先来安装 OpenCV 的依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libgtk2.0-dev libvtk5-dev libjpeg-dev libtiff4-dev libjasper-dev libopenexr-dev libtbb-dev</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cnake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取argv[1]指定的图像</span></span><br><span class="line">    cv::Mat image;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(argv[<span class="number">1</span>]); <span class="comment">// cv::imread函数读取指定路径下的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据不存在,可能是文件不存在</span></span><br><span class="line">    <span class="keyword">if</span> (image.data == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cerr：输出到标准错误的ostream对象，常用于程序错误信息；</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;文件&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件顺利读取, 首先输出一些基本信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图像的宽为：&quot;</span> &lt;&lt; image.cols</span><br><span class="line">         &lt;&lt; <span class="string">&quot;,高为：&quot;</span> &lt;&lt; image.rows</span><br><span class="line">         &lt;&lt; <span class="string">&quot;通道数为：&quot;</span> &lt;&lt; image.<span class="built_in">channels</span>() &lt;&lt; endl;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, image); <span class="comment">// 用cv::imshow显示图像</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);             <span class="comment">// 暂停程序,等待一个按键输入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断image的类型</span></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">type</span>() != CV_8UC1 &amp;&amp; image.<span class="built_in">type</span>() != CV_8UC3) <span class="comment">// 图像既不是单通道也不是三通道</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 图像类型不符合要求</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入一张彩色图或者灰度图&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历图像, 请注意以下遍历方式亦可使用于随机像素访问</span></span><br><span class="line">    <span class="comment">// 使用 std::chrono 来给算法计时</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> y = <span class="number">0</span>; y &lt; image.rows; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用cv::Mat::ptr获得图像的行指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *row_ptr = image.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(y); <span class="comment">// row_ptr是第y行的头指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> x = <span class="number">0</span>; x &lt; image.cols; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 访问位于 x,y 处的像素</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *data_ptr = &amp;row_ptr[x * image.<span class="built_in">channels</span>()]; <span class="comment">// data_ptr 指向待访问的像素数据</span></span><br><span class="line">            <span class="comment">// 输出该像素的每个通道,如果是灰度图就只有一个通道</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != image.<span class="built_in">channels</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> data = data_ptr[i]; <span class="comment">// data为I(x,y)第c个通道的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;遍历图像用时：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; 秒。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关于 cv::Mat 的拷贝</span></span><br><span class="line">    <span class="comment">// 直接赋值并不会拷贝数据,使用clone函数来拷贝数据</span></span><br><span class="line">    cv::Mat image_clone = image.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="built_in">image_clone</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>) ).<span class="built_in">setTo</span>(<span class="number">0</span>); <span class="comment">// 将左上角100*100的块置零</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image_clone&quot;</span>,image_clone);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMakeLsits.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( imageBasics )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加c++ 14标准支持</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找OpenCV库</span></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3</span> REQUIRED )</span><br><span class="line"><span class="comment"># 添加头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( imageBasics imageBasics.cpp )</span><br><span class="line"><span class="comment"># 链接OpenCV库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( imageBasics <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;OpenCV 提供了大量的开源图像算法，是计算机视觉中使用极广的图像处理算法库。在ubuntu 下，你可以选择从源代码安装和只安装库文件两种方式。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>使用Sophus库</title>
    <link href="http://lukeyalvin.top/2022/03/22/%E4%BD%BF%E7%94%A8Sophus%E5%BA%93/"/>
    <id>http://lukeyalvin.top/2022/03/22/%E4%BD%BF%E7%94%A8Sophus%E5%BA%93/</id>
    <published>2022-03-22T04:58:44.998Z</published>
    <updated>2022-03-25T08:59:34.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Sophus是直接在 Eigen 基础上开发的，我们不需要要安装额外的依赖库。由于历史原因，Sophus 早期版本只提供了双精度的李群/李代数类。后续版本改写成了模板类。模板类的 Sophus 中可以使用不同精度的李群/李代数，但同时增加了使用难度。这里使用的是非模板类。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="comment">// 这里使用的是绝对路径，所以在CMakeLsits.txt里并没有包含Sophus库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/alvin/workspace/slam_ws/slambook/3rdparty/Sophus/sophus/so3.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/alvin/workspace/slam_ws/slambook/3rdparty/Sophus/sophus/se3.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 沿Z轴转45s度的旋转矩阵</span></span><br><span class="line">    Eigen::Matrix3d R = Eigen::<span class="built_in">AngleAxisd</span>(M_PI / <span class="number">4</span>, Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)).<span class="built_in">matrix</span>();</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>); <span class="comment">//保留三位小数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R = &quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造李群</span></span><br><span class="line">    <span class="function">Sophus::SO3 <span class="title">SO3_R</span><span class="params">(R)</span></span>;              <span class="comment">// Sophus::SO(3)可以直接从旋转矩阵构造</span></span><br><span class="line">    <span class="function">Sophus::SO3 <span class="title">SO3_v</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, M_PI / <span class="number">4</span>)</span></span>; <span class="comment">// 亦可从旋转向量构造</span></span><br><span class="line">    <span class="function">Eigen::Quaterniond <span class="title">q</span><span class="params">(R)</span></span>;           <span class="comment">// 或者四元数</span></span><br><span class="line">    <span class="function">Sophus::SO3 <span class="title">SO3_q</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="comment">// 上述表达方式都是等价的</span></span><br><span class="line">    <span class="comment">// 输出SO(3)时，以so(3)形式输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从旋转矩阵构造SO(3): &quot;</span> &lt;&lt; SO3_R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从旋转向量构造SO(3): &quot;</span> &lt;&lt; SO3_v &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从四元数构造SO(3):&quot;</span> &lt;&lt; SO3_q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用对数映射获得它的李代数</span></span><br><span class="line">    Eigen::Vector3d so3 = SO3_R.<span class="built_in">log</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SO3的李代数so3：&quot;</span> &lt;&lt; so3.<span class="built_in">transpose</span>() &lt;&lt; endl; <span class="comment">// transpose纯粹是为了输出美观一些</span></span><br><span class="line">    <span class="comment">// hat 为向量到反对称矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;so3的反对称矩阵：\n&quot;</span></span><br><span class="line">         &lt;&lt; Sophus::SO3::<span class="built_in">hat</span>(so3) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 相对的，vee为反对称到向量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反对称矩阵到其向量：\n&quot;</span></span><br><span class="line">         &lt;&lt; Sophus::SO3::<span class="built_in">vee</span>(Sophus::SO3::<span class="built_in">hat</span>(so3)).<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">    ; <span class="comment">// transpose纯粹是为了输出美观一些</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量扰动模型的更新</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">update_so3</span><span class="params">(<span class="number">1e-4</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">//假设更新量为这么多</span></span><br><span class="line">    Sophus::SO3 SO3_update = Sophus::SO3::<span class="built_in">exp</span>(update_so3) * SO3_R;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SO3 updated = \n&quot;</span></span><br><span class="line">         &lt;&lt; SO3_update &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;************SE*************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3d R1 = Eigen::<span class="built_in">AngleAxisd</span>(M_PI / <span class="number">4</span>, Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)).<span class="built_in">matrix</span>();</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 沿X轴平移1</span></span><br><span class="line">    <span class="function">Sophus::SE3 <span class="title">SE3_Rt</span><span class="params">(R1, t)</span></span>;  <span class="comment">// 从R,t构造SE(3)</span></span><br><span class="line">    <span class="function">Sophus::SE3 <span class="title">SE3_qt</span><span class="params">(q, t)</span></span>;   <span class="comment">// 从q,t构造SE(3)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从R,t构造的SE：\n&quot;</span></span><br><span class="line">         &lt;&lt; SE3_Rt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;从q,t构造的SE：\n&quot;</span></span><br><span class="line">         &lt;&lt; SE3_qt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 李代数se(3) 是一个六维向量，方便起见先typedef一下</span></span><br><span class="line">    <span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Vector6d;</span><br><span class="line">    Vector6d se3 = SE3_Rt.<span class="built_in">log</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se3:\n&quot;</span></span><br><span class="line">         &lt;&lt; se3.<span class="built_in">transpose</span>() &lt;&lt; endl; <span class="comment">// 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样的，有hat和vee两个算符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se3的反对称矩阵：\n&quot;</span> &lt;&lt; Sophus::SE3::<span class="built_in">hat</span>(se3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se3反对称矩阵到其向量：\n&quot;</span> &lt;&lt; Sophus::SE3::<span class="built_in">vee</span>( Sophus::SE3::<span class="built_in">hat</span>(se3) ).<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，演示一下更新</span></span><br><span class="line">    Vector6d update_se3;<span class="comment">//更新量</span></span><br><span class="line">    update_se3.<span class="built_in">setZero</span>();</span><br><span class="line">    <span class="built_in">update_se3</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">1e-4</span>d;</span><br><span class="line">    Sophus::SE3 SE3_updated = Sophus::SE3::<span class="built_in">exp</span>(update_se3)*SE3_Rt;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SE3 updated = \n&quot;</span> &lt;&lt; SE3_updated.<span class="built_in">matrix</span>() &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(useSophus)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(useSophus useSophus.cpp)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;Sophus是直接在 Eigen 基础上开发的，我们不需要要安装额外的依赖库。由于历史原因，Sophus 早期版本只提供了双精度的李群/李代数类。后续版本改写成了模板类。模板类的 Sophus 中可以使用不同精度的李群/李代数，但同时增加了使用难度。这里使用的是非模板类。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>使用Eigen几何模块</title>
    <link href="http://lukeyalvin.top/2022/03/22/%E4%BD%BF%E7%94%A8Eigen%E5%87%A0%E4%BD%95%E6%A8%A1%E5%9D%97/"/>
    <id>http://lukeyalvin.top/2022/03/22/%E4%BD%BF%E7%94%A8Eigen%E5%87%A0%E4%BD%95%E6%A8%A1%E5%9D%97/</id>
    <published>2022-03-22T02:30:59.614Z</published>
    <updated>2022-03-26T08:31:09.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>导入Eigen几何模块，可以使用四元数、欧拉角和旋转矩阵。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="comment">// Eigen 几何模块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"> * 本程序演示了 Eigen 几何模块的使用方法</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Eigen/Geometry 模块提供了各种旋转和平移的表示</span></span><br><span class="line">    <span class="comment">// 3D 旋转矩阵直接使用 Matrix3d 或 Matrix3f</span></span><br><span class="line">    Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::<span class="built_in">Identity</span>(); <span class="comment">// 定义一个单位阵</span></span><br><span class="line">    <span class="comment">// 旋转向量使用 AngleAxis, 它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符）</span></span><br><span class="line">    <span class="function">Eigen::AngleAxisd <span class="title">rotation_vector</span><span class="params">(M_PI / <span class="number">4</span>, Eigen::Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>; <span class="comment">//沿 Z 轴旋转 45 度</span></span><br><span class="line"></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>); <span class="comment">// 保留三位小数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rotation matrix =\n&quot;</span></span><br><span class="line">         &lt;&lt; rotation_vector.<span class="built_in">matrix</span>() &lt;&lt; endl; <span class="comment">//用matrix()转换成矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接赋值</span></span><br><span class="line">    rotation_matrix = rotation_vector.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; rotation_matrix &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 AngleAxis 可以进行坐标变换</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    Eigen::Vector3d v_rotated = rotation_vector * v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在变换后的坐标系下表示：&quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 或者用旋转矩阵</span></span><br><span class="line">    v_rotated = rotation_matrix * v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在变换后的坐标系下表示：&quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧拉角: 可以将旋转矩阵直接转换成欧拉角</span></span><br><span class="line">    Eigen::Vector3d euler_angles = rotation_matrix.<span class="built_in">eulerAngles</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// ZYX顺序，即roll pitch yaw顺序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;旋转矩阵转换成欧拉角：&quot;</span> &lt;&lt; euler_angles.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧氏变换矩阵使用 Eigen::Isometry</span></span><br><span class="line">    Eigen::Isometry3d T = Eigen::Isometry3d::<span class="built_in">Identity</span>(); <span class="comment">// 虽然称为3d，实质上是4＊4的矩阵(齐次坐标)</span></span><br><span class="line">    cout &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">rotate</span>(rotation_vector); <span class="comment">// 按照rotation_vector进行旋转</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T绕rotation_vector旋转后：&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 把平移向量设成(1,3,4)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T按照(1,3,4)平移后：&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用变换矩阵进行坐标变换</span></span><br><span class="line">    Eigen::Vector3d v_transformed = T * v; <span class="comment">// 相当于R*v+t</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在经过T变换后的坐标系下表示：&quot;</span> &lt;&lt; v_transformed.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四元数</span></span><br><span class="line">    <span class="comment">// 可以直接把AngleAxis赋值给四元数，反之亦然</span></span><br><span class="line">    Eigen::Quaterniond q = Eigen::<span class="built_in">Quaterniond</span>(rotation_vector);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;quaternion = \n&quot;</span></span><br><span class="line">         &lt;&lt; q.<span class="built_in">coeffs</span>() &lt;&lt; endl; <span class="comment">// 请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以把旋转矩阵赋给它</span></span><br><span class="line">    q = Eigen::<span class="built_in">Quaterniond</span>(rotation_matrix);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;四元数：&quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用四元数旋转一个向量，使用重载的乘法即可</span></span><br><span class="line">    v_rotated = q * v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;向量v在经过四元数变换后的坐标系下表示：&quot;</span> &lt;&lt; v_transformed.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLsits.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( geometry )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Eigen头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( eigenGeometry eigenGeometry.cpp )</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;导入Eigen几何模块，可以使用四元数、欧拉角和旋转矩阵。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>使用Eigen基础模块</title>
    <link href="http://lukeyalvin.top/2022/03/21/%E4%BD%BF%E7%94%A8Eigen%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/"/>
    <id>http://lukeyalvin.top/2022/03/21/%E4%BD%BF%E7%94%A8Eigen%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/</id>
    <published>2022-03-21T13:41:07.559Z</published>
    <updated>2022-03-25T08:59:50.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Eigen是一个 C++ 开源线性代数库。它提供了快速的有关矩阵的线性代数运算，还包括解方程等功能。许多上层的软件库也使用 Eigen 进行矩阵运算，包括 g2o、Sophus 等。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>官方文档：<a href="https://eigen.tuxfamily.org/dox/">https://eigen.tuxfamily.org/dox/</a></p><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="comment">// Eigen 部分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="comment">// 稠密矩阵的代数运算（逆，特征值等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"> * 本程序演示了 Eigen 基本类型的使用</span></span><br><span class="line"><span class="comment"> ****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Eigen 中所有向量和矩阵都是Eigen::Matrix，它是一个模板类。它的前三个参数为：数据类型，行，列</span></span><br><span class="line">    <span class="comment">// 声明一个2*3的float矩阵</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">3</span>&gt; matrix_23;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，Eigen 通过 typedef 提供了许多内置类型，不过底层仍是Eigen::Matrix</span></span><br><span class="line">    <span class="comment">// 例如 Vector3d 实质上是 Eigen::Matrix&lt;double, 3, 1&gt;，即三维向量</span></span><br><span class="line">    Eigen::Vector3d v_3d;</span><br><span class="line">    <span class="comment">// 这是一样的</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">1</span>&gt; vd_3d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Matrix3d 实质上是 Eigen::Matrix&lt;double, 3, 3&gt;</span></span><br><span class="line">    Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::<span class="built_in">Zero</span>(); <span class="comment">//初始化为零</span></span><br><span class="line">    <span class="comment">// 如果不确定矩阵大小，可以使用动态大小的矩阵</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, Eigen::Dynamic, Eigen::Dynamic&gt; matrix_dynamic;</span><br><span class="line">    <span class="comment">// 更简单的</span></span><br><span class="line">    Eigen::MatrixXd matrix_x;</span><br><span class="line">    <span class="comment">// 这种类型还有很多，我们不一一列举</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是对Eigen阵的操作</span></span><br><span class="line">    <span class="comment">// 输入数据（初始化）</span></span><br><span class="line">    matrix_23 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; matrix_23 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用()访问矩阵中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">matrix_23</span>(i, j) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵和向量相乘（实际上仍是矩阵和矩阵）</span></span><br><span class="line">    v_3d &lt;&lt; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line">    vd_3d &lt;&lt; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 但是在Eigen里你不能混合两种不同类型的矩阵，像这样是错的</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix&lt;double, 2, 1&gt; result_wrong_type = matrix_23 * v_3d;</span></span><br><span class="line">    <span class="comment">// 应该显式转换</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result = matrix_23.cast&lt;<span class="keyword">double</span>&gt;() * v_3d;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result2 = matrix_23 * vd_3d;</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样你不能搞错矩阵的维度</span></span><br><span class="line">    <span class="comment">// 试着取消下面的注释，看看Eigen会报什么错</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix&lt;double, 2, 3&gt; result_wrong_dimension = matrix_23.cast&lt;double&gt;() * v_3d;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些矩阵运算</span></span><br><span class="line">    <span class="comment">// 四则运算就不演示了，直接用+-*/即可。</span></span><br><span class="line">    matrix_33 = Eigen::Matrix3d::<span class="built_in">Random</span>(); <span class="comment">// 随机数矩阵</span></span><br><span class="line">    cout &lt;&lt; matrix_33 &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">transpose</span>() &lt;&lt; endl;   <span class="comment">// 转置</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">sum</span>() &lt;&lt; endl;         <span class="comment">// 各元素和</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">trace</span>() &lt;&lt; endl;       <span class="comment">// 迹</span></span><br><span class="line">    cout &lt;&lt; <span class="number">10</span> * matrix_33 &lt;&lt; endl;          <span class="comment">// 数乘</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">inverse</span>() &lt;&lt; endl;     <span class="comment">// 逆</span></span><br><span class="line">    cout &lt;&lt; matrix_33.<span class="built_in">determinant</span>() &lt;&lt; endl; <span class="comment">// 行列式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( useEigen )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Eigen头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>( eigenMatrix eigenMatrix.cpp )</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">./eigenMatrix</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">1       2       3</span><br><span class="line">4       5       6</span><br><span class="line">10</span><br><span class="line">28</span><br><span class="line">32</span><br><span class="line">77</span><br><span class="line"> 0.680375   0.59688 -0.329554</span><br><span class="line">-0.211234  0.823295  0.536459</span><br><span class="line"> 0.566198 -0.604897 -0.444451</span><br><span class="line"></span><br><span class="line"> 0.680375 -0.211234  0.566198</span><br><span class="line">  0.59688  0.823295 -0.604897</span><br><span class="line">-0.329554  0.536459 -0.444451</span><br><span class="line">1.61307</span><br><span class="line">1.05922</span><br><span class="line"> 6.80375   5.9688 -3.29554</span><br><span class="line">-2.11234  8.23295  5.36459</span><br><span class="line"> 5.66198 -6.04897 -4.44451</span><br><span class="line">-0.198521   2.22739    2.8357</span><br><span class="line">  1.00605 -0.555135  -1.41603</span><br><span class="line"> -1.62213   3.59308   3.28973</span><br><span class="line">0.208598</span><br><span class="line">Eigen values = </span><br><span class="line">0.0242899</span><br><span class="line"> 0.992154</span><br><span class="line">  1.80558</span><br><span class="line">Eigen vectors = </span><br><span class="line">-0.549013 -0.735943  0.396198</span><br><span class="line"> 0.253452 -0.598296 -0.760134</span><br><span class="line">-0.796459  0.316906 -0.514998</span><br><span class="line">time use <span class="keyword">in</span> normal inverse is 0.682ms</span><br><span class="line">time use <span class="keyword">in</span> Qr decomposition is 0.363ms</span><br></pre></td></tr></table></figure><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><h5 id="1-LU三角分解"><a href="#1-LU三角分解" class="headerlink" title="(1)LU三角分解"></a>(1)LU三角分解</h5><p>三角分解法是仅对方阵有效，将原方阵分解成一个上三角形矩阵或是排列(permuted)的<strong>上三角形矩阵</strong>和一个<strong>下三角形矩阵</strong>，这样的分解法又称为LU分解法。它的用途主要在简化一个大矩阵的行列式值的计算过程、求反矩阵和求解联立方程组。不过要注意这种分解法所得到的上下三角形矩阵并非唯一，还可找到数个不同的一对上下三角形矩阵，此两三角形矩阵相乘也会得到原矩阵。<code>[L,U]=lu(A)</code></p><h5 id="2-QR分解"><a href="#2-QR分解" class="headerlink" title="(2)QR分解"></a>(2)QR分解</h5><p>QR分解法对象不一定是方阵，其将矩阵分解成一个<strong>正规正交矩</strong>阵与上<strong>三角形矩阵</strong>,所以称为QR分解法,与此正规正交矩阵的通用符号Q有关。<code>[Q,R]=qr(A)</code></p><h5 id="3-SVD分解"><a href="#3-SVD分解" class="headerlink" title="(3)SVD分解"></a>(3)SVD分解</h5><p>奇异值分解(singular value decomposition,SVD)是另一种正交矩阵分解法；SVD是最可靠的分解法，但是它比QR分解法要花上近十倍的计算时间。<code>[U,S,V]=svd(A)</code>，其中U和V分别代表两个正交矩阵，而S代表一对角矩阵。和QR分解法相同，原矩阵A不必为方阵。使用SVD分解法的用途是解最小平方误差法和数据压缩。</p><h5 id="4-LLT分解"><a href="#4-LLT分解" class="headerlink" title="(4)LLT分解"></a>(4)LLT分解</h5><p>又称Cholesky分解，其把一个对称正定的矩阵表示成一个<strong>下三角矩阵L</strong>和<strong>其转置</strong>的乘积的分解。它要求矩阵为方阵，且所有特征值必须大于零，故分解的下三角的对角元也是大于零的(LU三角分解法的变形)。$A=LL^T$</p><h5 id="5-LDLT分解"><a href="#5-LDLT分解" class="headerlink" title="(5)LDLT分解"></a>(5)LDLT分解</h5><p>LDLT分解法实际上是Cholesky分解法的改进，因为Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题，可用于求解线性方程组。 也需要分解对象为方阵，分解结果为$A=LDL^T$。其中L为一下三角形单位矩阵(即主对角线元素皆为1)，D为一对角矩阵(只在主对角线上有元素，其余皆为零)，$L^T$为L的转置矩阵。</p><h2 id="求解方程组"><a href="#求解方程组" class="headerlink" title="求解方程组"></a>求解方程组</h2><h3 id="求解特征向量与特征值"><a href="#求解特征向量与特征值" class="headerlink" title="求解特征向量与特征值"></a>求解特征向量与特征值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*******求解矩阵的特征向量和特征值*******&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 实对称矩阵可以保证对角化成功,但是也要考虑无法对角化的情况</span></span><br><span class="line">    Eigen::Matrix2f A;</span><br><span class="line">    A &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">    <span class="function">Eigen::EigenSolver&lt;Eigen::Matrix2f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() == Eigen::Success)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;特征值：&quot;</span> &lt;&lt; endl &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;特征向量：&quot;</span> &lt;&lt; endl &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;矩阵不可以对角化&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h3><p>线代中形如<code>Ax=b</code>的线性方程组是最简单的入门示例。对于常规适定的线性方程组(未知数个数=方程个数)，可以采用常规的矩阵分解法求解。在Eigen中有多种解法可供选择，以满足在精度与效率上不同的需求。有如下方程组：</p><script type="math/tex; mode=display">\left\{\begin{aligned}1x_1 + 2x_2+3x_3 & =  3 \\4x_1 + 5x_2+6x_3 & =  3 \\7x_1 + 8x_2+10x_3 & =  4\end{aligned}\right.</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*******求解线性方程组*******&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3f A1;</span><br><span class="line">    Eigen::Vector3f b;</span><br><span class="line">    A1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>;</span><br><span class="line">    b &lt;&lt; <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> time_stt = <span class="built_in">clock</span>();</span><br><span class="line">    Eigen::Vector3f x;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;QR分解&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A1.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(b) &lt;&lt; endl; <span class="comment">// QR分解</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总计用时：&quot;</span> &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt) / (<span class="keyword">double</span>)CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码调用了<code>.colPivHouseholderQr()</code>函数对方程进行求解。Eigen中所有不同方法调用都有固定的格式：<code>x = A.methodName().solve(b)</code>，如下是Eigen中一些常用方法的比较，根据需要选择不同方法。</p><p><img src="/2022/03/21/%E4%BD%BF%E7%94%A8Eigen%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/2019-08-22-01.PNG" alt="img"></p><p>Eigen还可以解一些长的比较“奇怪”的方程组(如x、b并不是向量而是矩阵)，如下方程组：</p><script type="math/tex; mode=display">\left( \begin{matrix} 2  & -1 \\-1 & 3\end{matrix}\right)\left( \begin{matrix} x_1 & x_2 \\x_3 & x_4\end{matrix}\right)=\left( \begin{matrix} 1 & 2 \\3 & 1\end{matrix}\right)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Eigen::Matrix2f A0, b0;</span><br><span class="line">    A0 &lt;&lt; <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>;</span><br><span class="line">    b0 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">clock_t</span> time_stt0 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LDLT分解&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A0.<span class="built_in">ldlt</span>().<span class="built_in">solve</span>(b0) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总计用时：&quot;</span> &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt0) / (<span class="keyword">double</span>)CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;Eigen是一个 C++ 开源线性代数库。它提供了快速的有关矩阵的线性代数运算，还包括解方程等功能。许多上层的软件库也使用 Eigen 进行矩阵运算，包括 g2o、Sophus 等。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>了解cmake编译_hello world</title>
    <link href="http://lukeyalvin.top/2022/03/21/%E4%BA%86%E8%A7%A3cmake%E7%BC%96%E8%AF%91_hello%20world/"/>
    <id>http://lukeyalvin.top/2022/03/21/%E4%BA%86%E8%A7%A3cmake%E7%BC%96%E8%AF%91_hello%20world/</id>
    <published>2022-03-21T13:15:54.389Z</published>
    <updated>2022-03-25T08:59:58.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>理论上说，任意一个 C++ 程序都可以用 g++ 来编译。但当程序规模越来越大时，一个工程可能有许多个文件夹和里边的源文件，这时输入的编译命令将越来越长。通常一个小型 c++ 项目含有十几个类，各类间还存在着复杂的依赖关系。其中一部分要编译成可执行文件，另一部分编译成库文件。如果仅靠 g++ 命令，我们需要输入大量的编译指令，整个编译过程会变得异常繁琐。因此，对于 C++ 项目，使用一些工程管理工具会更加高效。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>库文件：用来存放函数或者类中函数的具体实现</p><p>在一个 C++ 工程中，并不是所有代码都会编译成可执行文件。只有带有 main 函数的文件才会生成可执行程序。而另一些代码，我们只想把它们打包成一个东西，供其他程序调用。这个东西叫做库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个库文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello SLAM&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于库的使用者，只要拿到了头文件和库文件，就可以调用这个库了。</p><p>头文件：存放方法或者类相关的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="comment">// 上面的宏定义是为了防止重复引用这个头文件而引起的重定义错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主函数：main函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libHelloSLAM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 libHelloSLAM.h 中的 printHello() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们需要使用CMakeLists.txt文件帮助我们进行编译</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明要求的 cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个 cmake 工程</span></span><br><span class="line"><span class="keyword">project</span>( HelloSLAM )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译模式</span></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个库</span></span><br><span class="line"><span class="keyword">add_library</span>( hello libHelloSLAM.cpp )</span><br><span class="line"><span class="comment"># 共享库</span></span><br><span class="line"><span class="keyword">add_library</span>( hello_shared SHARED libHelloSLAM.cpp )</span><br><span class="line"><span class="comment"># 将库文件链接到可执行程序上</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( useHello hello_shared )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( useHello useHello.cpp )</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;理论上说，任意一个 C++ 程序都可以用 g++ 来编译。但当程序规模越来越大时，一个工程可能有许多个文件夹和里边的源文件，这时输入的编译命令将越来越长。通常一个小型 c++ 项目含有十几个类，各类间还存在着复杂的依赖关系。其中一部分要编译成可执行文件，另一部分编译成库文件。如果仅靠 g++ 命令，我们需要输入大量的编译指令，整个编译过程会变得异常繁琐。因此，对于 C++ 项目，使用一些工程管理工具会更加高效。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="http://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="http://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
