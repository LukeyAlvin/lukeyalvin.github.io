<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lukey Alvin</title>
  
  <subtitle>一份耕耘,一份收获</subtitle>
  <link href="https://lukeyalvin.top/atom.xml" rel="self"/>
  
  <link href="https://lukeyalvin.top/"/>
  <updated>2022-05-20T11:51:52.065Z</updated>
  <id>https://lukeyalvin.top/</id>
  
  <author>
    <name>爱喝烫水的阿水哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VINS-Mono_5-后端非线性优化_视觉约束</title>
    <link href="https://lukeyalvin.top/posts/1b2b3846.html"/>
    <id>https://lukeyalvin.top/posts/1b2b3846.html</id>
    <published>2022-05-20T09:18:21.000Z</published>
    <updated>2022-05-20T11:51:52.065Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍后端非线性优化中的视觉约束。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-状态向量与目标函数"><a href="#Ⅰ-状态向量与目标函数" class="headerlink" title="Ⅰ.  状态向量与目标函数"></a>Ⅰ.  状态向量与目标函数</h1><p>状态向量共包括滑动窗口内的 $n+1$ 个所有 IMU 状态$\mathbf{x}_k,k\in[0,n]$（包括位置、朝向、速度、加速度计 $bias$ 和陀螺仪 $bias$）、 Camera 到 IMU 的外参 $\mathbf{x}^b_c$、 $m+1$ 个 3D 点的逆深度$\lambda_l,l\in[0,m]$：  </p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}&=[\mathbf{x}_0,\mathbf{x}_1,···,\mathbf{x}_n,\mathbf{x}^b_c,\lambda_0,\lambda_1,···,\lambda_m]\\\mathbf{x}_k&=[\mathbf{p}^w_{b_k},\mathbf{v}^w_{b_k},\mathbf{q}^w_{b_k},\mathbf{b}_a,\mathbf{b}_g],k\in[0,n]\\\mathbf{x}^b_c&=[\mathbf{p}^b_c,\mathbf{q}^b_c]\end{align*}\tag{1}</script><p> $n$ 是关键帧的总数，$m$ 是滑动窗口中的特征总数。 $λ_l$ 是第 $l$ 个特征与其第一次观察的逆深度。</p><p>使用 BA 公式，我们最小化所有测量残差的先验和马氏距离之和，以获得<strong>最大后验估计</strong>为：</p><script type="math/tex; mode=display">\underset{\mathcal{X} }{\min}\left\{\underbrace{\parallel \mathbf{r}_p-\mathbf{H}_p\mathcal{X} \parallel^2}_{边缘化的先验信息}+\underbrace{\sum_{k\in\mathcal{B} }\parallel\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})  \parallel^2_{\mathbf{P}^{b_k}_{b_{k+1} } } }_{IMU 测量残差}+\underbrace{\sum_{(l,j)\in\mathcal{C} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) \parallel^2_{\mathbf{P}^{c_j}_l })}_{视觉的重投影残差}\right\}\tag{2}</script><p>其中 $\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})$ 和 $\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) $ 分别是 IMU 和视觉测量的残差。 $\mathcal{B}$ 是所有 IMU 测量值的集合，$\mathcal{C}$  是在当前滑动窗口中至少观察到两次的特征集合。 $\{\mathbf{r}_p, \mathbf{H}_p\}$ 是来自边缘化的先验信息。 三种残差都是用马氏距离表示。</p><h1 id="Ⅱ-视觉约束"><a href="#Ⅱ-视觉约束" class="headerlink" title="Ⅱ. 视觉约束"></a>Ⅱ. 视觉约束</h1><h2 id="A-残差"><a href="#A-残差" class="headerlink" title="A. 残差"></a>A. 残差</h2><p>视觉残差是重投影误差， 对于第 $l$ 个路标点 $P$，将 $P$ 从第一次观看到它的第 i 个相机坐标系，转换到当前的第 $j $个相机坐标系下的像素坐标，可定义<strong>视觉误差项</strong>为：  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X})&=[\mathbf{b}_1,\mathbf{b}_2]^T\cdot(\hat{\overline{\mathcal{P} } }^{c_j}_l-\frac{\mathcal{P}^{c_j}_l}{\parallel\mathcal{P}^{c_j}_l \parallel^2})\\\end{align*}\tag{3}</script><p> $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 为第 $l$ 个路标点在第 $j$ 个相机归一化相机坐标系中的<strong>观察到的坐标</strong>：  </p><script type="math/tex; mode=display">\hat{\overline{\mathcal{P} } }^{c_j}_l=\pi^{-1}_c\left(\begin{bmatrix}\hat{u}^{c_j}_l\\\hat{v}^{c_j}_l \end{bmatrix}\right)\tag{4}</script><p>$\mathcal{P}^{c_j}_l$ 是估计第 $i$ 个图像中发生的第 $l$个特征的第一次观察，<strong>转换到</strong>第 $j$ 个相机归一化相机坐标系中的<strong>理论的坐标</strong>:  </p><script type="math/tex; mode=display">\mathcal{P}^{c_j}_l =\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}\tag{5}</script><p>其中， $[\hat{u}^{c_i}_l,\hat{v}^{c_i}_l]$ 是第 $i$ 个图像中发生的第 $l$个特征的第一次观察。 $[\hat{u}^{c_j}_l,\hat{v}^{c_j}_l]$ 是对第 $j$ 个图像中相同特征的观察。 $\pi^{-1}_c$ 是反投影函数，它使用相机内在参数将像素位置转换为单位向量。</p><script type="math/tex; mode=display">\overline{\mathcal{P} }^{c_i}_l=\pi^{-1}_c\left(\begin{bmatrix}\hat{u}^{c_i}_l\\\hat{v}^{c_i}_l \end{bmatrix}\right)\tag{6}</script><p>由于视觉残差的自由度为 $2$，我们将残差向量投影到切平面上。  $\mathbf{b}_1$ 和 $\mathbf{b}_2$  是两个任意选择的<strong>正交基</strong>，它们跨越 $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 的切平面，如图所示。在 $(2)$ 中使用的方差 $\mathbf{P}^{c_j}_l$ 也从像素坐标传播到单位球体上.</p><p><img src="/images/VINS-Mono-5-后端非线性优化-视觉约束/image-20220520195143150.png" alt="image-20220520195143150" style="zoom:50%;" /></p><blockquote><p>单位球面上的视觉残差图。 $\hat{\overline{\mathcal{P} } }^{c_j}_l$ 是在第 $j$ 帧中观察第 $l$ 个特征的单位向量。$\mathcal{P}^{c_j}_l$  是通过将其在第 $i$ 帧中的第一个观察值转换为第 $j$ 帧来预测的单位球体上的特征测量。残差定义在  $\hat{\overline{\mathcal{P} } }^{c_j}_l$  的切平面上</p></blockquote><p>这里给出公式 $(5)$ 的推导：</p><p><img src="/images/VINS-Mono-5-后端非线性优化-视觉约束/image-20220520195055396.png" alt="image-20220520195055396"></p><p>设特征 $l$ 点 在第 $i$ 帧被观测到的像素坐标系下的坐标为： $\mathcal{P}_{uv_i}$ ，在世界坐标系下的坐标为：$\mathcal{P}^w_l$，则根据变换矩阵可得：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{P}_{uv_i}&=\lambda_l\pi_c\left({\mathbf{T}^b_c}^{-1}{\mathbf{T}^w_{b_i} }^{-1}\mathcal{P}^w_l  \right)\\\Leftrightarrow \mathcal{P}^w_l&=\mathbf{T}^w_{b_i}\mathbf{T}^b_c\frac{1}{\lambda_l}{\pi_c}^{-1}(\mathcal{P}_{uv_i})\\&=\mathbf{T}^w_{b_i}\mathbf{T}^b_c\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l\\\mathcal{P}^w_l&=\begin{bmatrix}\mathbf{R}^w_{b_i}&\mathbf{p}^w_{b_i}\\0&1\end{bmatrix}\begin{bmatrix}\mathbf{R}^b_c&\mathbf{p}^b_c\\0&1\end{bmatrix}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l\\&=\begin{bmatrix}\mathbf{R}^w_{b_i}\mathbf{R}^b_c&\mathbf{R}^w_{b_i}\mathbf{p}^b_c+\mathbf{p}^w_{b_i}\\0&1\end{bmatrix}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l\\&=\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}\end{align*}\tag{IIA-1}</script><p> 设特征 $l$ 点 在第 $j$ 帧被观测到的相机坐标系下的坐标为： $\mathcal{P}^{c_j}_{l}$ </p><script type="math/tex; mode=display">\begin{align*}\mathcal{P}^{c_j}_l&={\mathbf{T}^b_c}^{-1}{\mathbf{T}^w_{b_j} }^{-1}\mathcal{P}^w_l \\\Leftrightarrow \mathcal{P}^w_l&=\mathbf{T}^w_{b_j}\mathbf{T}^b_c\mathcal{P}^{c_j}_l\\\mathcal{P}^w_l&=\begin{bmatrix}\mathbf{R}^w_{b_j}&\mathbf{p}^w_{b_j}\\0&1\end{bmatrix}\begin{bmatrix}\mathbf{R}^b_c&\mathbf{p}^b_c\\0&1\end{bmatrix}\mathcal{P}^{c_j}_l\\&=\begin{bmatrix}\mathbf{R}^w_{b_j}\mathbf{R}^b_c&\mathbf{R}^w_{b_j}\mathbf{p}^b_c+\mathbf{p}^w_{b_j}\\0&1\end{bmatrix}\mathcal{P}^{c_j}_l\\&=\mathbf{R}^{w}_{b_j}\left(\mathbf{R}^{b}_{c}\mathcal{P}^{c_j}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_j}\end{align*}\tag{IIA-2}</script><p>将 $\mathrm{(IIA-1)}$ 带入 $\mathrm{(IIA-2)}$ ，可以得到：</p><script type="math/tex; mode=display">\begin{align*}&\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}=\mathbf{R}^{w}_{b_j}\left(\mathbf{R}^{b}_{c}\mathcal{P}^{c_j}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_j}\\&\Rightarrow\mathcal{P}^{c_j}_l =\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{1}{\lambda_l}\overline{\mathcal{P} }^{c_i}_l+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]-\mathbf{p}^{b}_{c}\right\}\end{align*}\tag{IIA-3}</script><h2 id="B-优化变量"><a href="#B-优化变量" class="headerlink" title="B. 优化变量"></a>B. 优化变量</h2><p>待优化变量主要是 $i$ 和 $j$ 两个时刻相机的位姿以及逆深度：</p><script type="math/tex; mode=display">[\mathbf{p}^w_{b_i},\mathbf{q}^w_{b_i}],\ \ \ \ \ [\mathbf{p}^w_{b_j},\mathbf{q}^w_{b_j}],\ \ \ \ \ [\mathbf{p}^b_{c},\mathbf{q}^b_{c}],\ \ \ \ \ \lambda_l\tag{7}</script><h2 id="C-Jacobian"><a href="#C-Jacobian" class="headerlink" title="C. Jacobian"></a>C. Jacobian</h2><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian：</p><script type="math/tex; mode=display">\mathbf{J}[0]^{3\times7}=\left[\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_i} },\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_i} }\right]=\begin{bmatrix}\mathbf{R}^c_b\mathbf{R}^{b_j}_w&-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)^{\land}\end{bmatrix}\tag{8}</script><script type="math/tex; mode=display">\mathbf{J}[1]^{3\times7}=\left[\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^w_{b_j} },\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^w_{b_j} }\right]=\begin{bmatrix}-\mathbf{R}^c_b\mathbf{R}^{b_j}_w&\mathbf{R}^c_b\left\{\mathbf{R}^{b_j}_w\left[\mathbf{R}^{w}_{b_i}\left(\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_j}_l}{\lambda_l}+\mathbf{p}^{b}_{c}\right)+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right]\right\}^{\land}\end{bmatrix}\tag{9}</script><script type="math/tex; mode=display">\begin{align*}\mathbf{J}[2]^{3\times7}&=\left[\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{p}^b_c },\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\mathbf{q}^b_c }\right]\\&=\begin{bmatrix}\mathbf{R}^c_b(\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}-I_{3\times3})\\-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\left(\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l} \right)^{\land}+\left(\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l} \right)^{\land}+\left\{\mathbf{R}^c_b\left[\mathbf{R}^{b_j}_w\left(\mathbf{R}^w_{b_i}\mathbf{p}^{b}_{c}+\mathbf{p}^{w}_{b_i}-\mathbf{p}^{w}_{b_j}\right)-\mathbf{p}^{b}_{c}\right]\right\}^{\land}\end{bmatrix}^T\end{align*}\tag{10}</script><script type="math/tex; mode=display">\mathbf{J}[3]^{3\times1}=\frac{\partial \mathbf{r}_{\mathcal{C} } }{\partial\lambda_l }=-\mathbf{R}^c_b\mathbf{R}^{b_j}_w\mathbf{R}^w_{b_i}\\mathbf{R}^{b}_{c}\frac{\overline{\mathcal{P} }^{c_i}_l}{\lambda_l^2}\tag{11}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍后端非线性优化中的视觉约束。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_4-后端非线性优化_IMU约束</title>
    <link href="https://lukeyalvin.top/posts/70ecd932.html"/>
    <id>https://lukeyalvin.top/posts/70ecd932.html</id>
    <published>2022-05-20T09:18:00.000Z</published>
    <updated>2022-05-20T10:08:49.921Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍后端非线性优化中的IMU约束。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-状态向量与目标函数"><a href="#Ⅰ-状态向量与目标函数" class="headerlink" title="Ⅰ.  状态向量与目标函数"></a>Ⅰ.  状态向量与目标函数</h1><p>状态向量共包括滑动窗口内的 $n+1$ 个所有 IMU 状态$\mathbf{x}_k,k\in[0,n]$（包括位置、朝向、速度、加速度计 $bias$ 和陀螺仪 $bias$）、 Camera 到 IMU 的外参 $\mathbf{x}^b_c$、 $m+1$ 个 3D 点的逆深度$\lambda_l,l\in[0,m]$：  </p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}&=[\mathbf{x}_0,\mathbf{x}_1,···,\mathbf{x}_n,\mathbf{x}^b_c,\lambda_0,\lambda_1,···,\lambda_m]\\\mathbf{x}_k&=[\mathbf{p}^w_{b_k},\mathbf{v}^w_{b_k},\mathbf{q}^w_{b_k},\mathbf{b}_a,\mathbf{b}_g],k\in[0,n]\\\mathbf{x}^b_c&=[\mathbf{p}^b_c,\mathbf{q}^b_c]\end{align*}\tag{1}</script><p> $n$ 是关键帧的总数，$m$ 是滑动窗口中的特征总数。 $λ_l$ 是第 $l$ 个特征与其第一次观察的逆深度。</p><p>使用 BA 公式，我们最小化所有测量残差的先验和马氏距离之和，以获得<strong>最大后验估计</strong>为：</p><script type="math/tex; mode=display">\underset{\mathcal{X} }{\min}\left\{\underbrace{\parallel \mathbf{r}_p-\mathbf{H}_p\mathcal{X} \parallel^2}_{边缘化的先验信息}+\underbrace{\sum_{k\in\mathcal{B} }\parallel\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})  \parallel^2_{\mathbf{P}^{b_k}_{b_{k+1} } } }_{IMU 测量残差}+\underbrace{\sum_{(l,j)\in\mathcal{C} }\rho(\parallel\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) \parallel^2_{\mathbf{P}^{c_j}_l })}_{视觉的重投影残差}\right\}\tag{2}</script><p>其中 $\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})$ 和 $\mathbf{r}_\mathcal{C}(\hat{\mathbf{z} }^{c_j}_{l},\mathcal{X}) $ 分别是 IMU 和视觉测量的残差。 $\mathcal{B}$ 是所有 IMU 测量值的集合，$\mathcal{C}$  是在当前滑动窗口中至少观察到两次的特征集合。 $\{\mathbf{r}_p, \mathbf{H}_p\}$ 是来自边缘化的先验信息。 三种残差都是用马氏距离表示。</p><h1 id="Ⅱ-IMU-约束"><a href="#Ⅱ-IMU-约束" class="headerlink" title="Ⅱ. IMU 约束"></a>Ⅱ. IMU 约束</h1><h2 id="残差"><a href="#残差" class="headerlink" title="残差"></a>残差</h2><p>两帧之间的 PVQ 和 $bias$ 的变化量的差  :</p><script type="math/tex; mode=display">\mathbf{r}_{\mathcal{B} }(\hat{\mathbf{z} }^{b_k}_{b_{k+1} },\mathcal{X})=\begin{bmatrix}\delta {\alpha}^{b_k}_{b_{k+1} }\\\delta {\theta}^{b_k}_{b_{k+1} }\\\delta {\beta}^{b_k}_{b_{k+1} }\\\delta {b}_{a}\\\delta {b}_{g}\end{bmatrix}=\begin{align*}\begin{bmatrix}\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}+\frac{1}{2}g^w\Delta t_k^2-\mathbf{v}^w_{b_k}\Delta t_k)-\hat{\alpha}^{b_k}_{b_{k+1} }\\2[{\mathbf{q}^w_{b_k}}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz}\\\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_{k+1} }-\mathbf{v}^w_{b_k}+g^w\Delta t_k)-\hat{\beta}^{b_k}_{b_{k+1} }\\\mathbf{b}_{ab_{k+1} }-\mathbf{b}_{ab_k}\\\mathbf{b}_{wb_{k+1} }-\mathbf{b}_{wb_k}\\\end{bmatrix}\end{align*}\tag{3}</script><p>其中各增量关于 bias 的 Jacobian 可从公式 $(4)$ 的 大 Jacobian 中的相应位置获得。 上面与其中各增量关于 $bias$ 的 Jacobian 可从公式 $(4)$ 的大 Jacobian 中的相应位置获得。</p><script type="math/tex; mode=display">{\mathbf{J}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{J}_{k}\tag{4}</script><h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>待优化变量主要为两个时刻的 PVQ 以及 $bais$:</p><script type="math/tex; mode=display">\begin{align*}k时刻&： [\mathbf{p}^w_{b_k},\mathbf{q}^w_{b_k}],[\mathbf{v}^w_{b_k},\mathbf{b}_{a_k},\mathbf{b}_{w_k}]\\k+1时刻&：[\mathbf{p}^w_{b_{k+1} },\mathbf{q}^w_{b_{k+1} }],[\mathbf{v}^w_{b_{k+1}  },\mathbf{b}_{a_{k+1} },\mathbf{b}_{w_{k+1} }]\\\end{align*}</script><h2 id="Jacobian"><a href="#Jacobian" class="headerlink" title="Jacobian"></a>Jacobian</h2><p>计算 Jacobian 时，残差对应的求偏导对象为上面的优化变量，但是计算时采用扰动方式计算，即扰动为 ：</p><script type="math/tex; mode=display">\begin{align*}k时刻&： [\delta\mathbf{p}^w_{b_k},\delta\theta^w_{b_k}],[\delta\mathbf{v}^w_{b_k},\delta\mathbf{b}_{a_k},\delta\mathbf{b}_{w_k}]\\k+1时刻&：[\delta\mathbf{p}^w_{b_{k+1} },\delta\theta^w_{b_{k+1} }],[\delta\mathbf{v}^w_{b_{k+1}  },\delta\mathbf{b}_{a_{k+1} },\delta\mathbf{b}_{w_{k+1} }]\\\end{align*}</script><script type="math/tex; mode=display">\mathbf{J}[0]^{15\times7}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{p}^w_{b_k} },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{q}^w_{b_k} }]=\begin{bmatrix}-\mathbf{R}^{b_k}_w&\left[\mathbf{R}^{b_k}_w\left(\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}-\mathbf{v}^w_{b_k}\Delta t_k+\frac{1}{2}g^w\Delta t_k^2\right) \right]^{\land}\\0&-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]_{3\times3}\mathcal{L}\left[\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\\0&\left[\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_{k+1} }-\mathbf{v}^w_{b_k}+g^w\Delta t_k)\right]^{\land}\\0&0\\0&0\\\end{bmatrix}\tag{J0}</script><hr><ul><li><strong>推导 $\mathbf{J}[0]$</strong></li></ul><p>定义：$\mathbf{J}[0]_{[i,j]}$ 表示矩阵 $\mathbf{J}[0]$ 的 第 $i$  行 第 $j$ 列；</p><p>首先是 $\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{p}^w_{b_k} }$，显然，由公式 $(3)$，对于 $\mathbf{r}_{\mathcal{B} } $ 而言，只有 $\delta {\alpha}^{b_k}_{b_{k+1} }$ 对 $\mathbf{p}^w_{b_k}$ 求偏导才有值，其他为0，这就组成 $(J0)$ 里矩阵的第一列；</p><p>对于矩阵的 $\mathbf{J}[0]_{[2,1]}$ 和  $\mathbf{J}[0]_{[2,3]}$，可以使用旋转矩阵的左乘扰动模型来求：</p><p>这里为了书写方便，令 $\mathcal{P}^w=\mathbf{p}^w_{b_{k+1} }-\mathbf{p}^w_{b_k}+<br>\frac{1}{2}g^w\Delta t_k^2-\mathbf{v}^w_{b_k}\Delta t_k$</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta {\alpha}^{b_k}_{b_{k+1} } }{\partial \mathbf{p}^w_{b_k} }&=\frac{\partial \left[\mathbf{R}^{b_k}_w\mathcal{P}^w-\hat{\alpha}^{b_k}_{b_{k+1} }\right]}{\partial \mathbf{p}^w_{b_k} }\\&=\underset{\varphi\rightarrow0}{\lim}\frac{(\mathbf{R}^{b_k}_w\exp(\varphi^{\land}))^{-1}\mathcal{P}^w }{\delta\varphi}\\&\approx\underset{\varphi\rightarrow0}{\lim}\frac{(I-\varphi^{\land})\exp(\phi^{\land})\mathcal{P}^w-\exp(\phi^{\land})\mathcal{P} }{\delta\varphi}\\&=\underset{\varphi\rightarrow0}{\lim}-\frac{\varphi^{\land}\mathbf{R}^{b_k}_w\mathcal{P}^w }{\delta\varphi}\\&=\underset{\varphi\rightarrow0}{\lim}\frac{[\mathbf{R}^{b_k}_w\mathcal{P}^w]^{\land}\varphi }{\delta\varphi}\\&=[\mathbf{R}^{b_k}_w\mathcal{P}^w]^{\land}\end{align*}\tag{J0-1}</script><p>因此，对于$\mathbf{J}[0]_{[2,1]}$ 和  $\mathbf{J}[0]_{[2,3]}$，他们仅仅是 $\mathcal{P}^w$ 不同，推导过程都是一样的。</p><p>关键是对于$\mathbf{J}[0]_{[2,2]}$  的推导，是比较关键的，对应的雅可比为 $\frac{\partial \delta {\theta}^{b_k}_{b_{k+1} } }{\partial \mathbf{q}^w_{b_k} }$：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta {\theta}^{b_k}_{b_{k+1} } }{\partial \mathbf{q}^w_{b_k} }&=\frac{\partial 2[{\mathbf{q}^w_{b_k}}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz} }{\partial \mathbf{q}^w_{b_k} }\\&=2\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\left(\mathbf{q}_{b_k}^w\otimes\begin{bmatrix}1\\\frac{\delta\theta^{w}_{b_k} }{2} \end{bmatrix} \right)^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}-\left(\mathbf{q}_{b_k}^w\otimes\begin{bmatrix}1\\0\end{bmatrix} \right)^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=2\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\begin{bmatrix}1\\-\frac{\delta\theta^{w}_{b_k} }{2} \end{bmatrix}\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}-\begin{bmatrix}1\\0 \end{bmatrix}\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=2\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\left(\begin{bmatrix}1\\-\frac{\delta\theta^{w}_{b_k} }{2} \end{bmatrix}-\begin{bmatrix}1\\0 \end{bmatrix}\right)\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\begin{bmatrix}0\\-\delta\theta^{w}_{b_k} \end{bmatrix}\otimes{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}}{\delta {\theta}^{w}_{b_k} }\\&=\underset{\delta {\theta}^{b_k}_{b_{k+1} }\rightarrow0}{\lim}\frac{\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\otimes\begin{bmatrix}0\\-\delta\theta^{w}_{b_k} \end{bmatrix}}{\delta {\theta}^{w}_{b_k} }\\&=-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\\\end{align*}\tag{J0-2}</script><p>对于四元数的左右乘，在第二节的$\mathrm{(IA-3)}$ 提到过，这里再次作展示：</p><p>我们设四元数 $\mathbf{q}=[x,y,z,s]$为 $\mathbf{q}=[w,s]$，则：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}_a)&=\Omega(w)+sI_{4\times4}=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\\\mathcal{L}(\mathbf{q}_a)&=\Psi(w)+sI_{4\times4}=\begin{bmatrix}w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\end{align*}\tag{5}</script><p>则有：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}^{-1})=\Omega(-w)+sI_{4\times4}&=\begin{bmatrix}w^{\land}&-w\\w^T&0\end{bmatrix}+sI_{4\times4}\\\mathcal{L}(\mathbf{q}^{-1})=\Omega(-w)+sI_{4\times4}&=\begin{bmatrix}-w^{\land}&-w\\w^T&0\end{bmatrix}+sI_{4\times4}\\\end{align*}\tag{6}</script><p> 如果我们只取左上角的 $3\times3$ 虚部部分，则有：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}^{-1})=sI_{3\times3}+w^{\land}=\mathcal{L}(\mathbf{q})_{3\times3}\\\mathcal{L}(\mathbf{q}^{-1})=sI_{3\times3}-w^{\land}=\mathcal{R}(\mathbf{q})_{3\times3}\end{align*}\tag{7}</script><p>故而 $\mathrm{(J0-2)}$ 可以整理如下：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta {\theta}^{b_k}_{b_{k+1} } }{\partial \mathbf{q}^w_{b_k} }&=-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\\&=-\mathcal{R}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]_{3\times3}\mathcal{L}\left[\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\end{align*}\tag{J0-3}</script><p><strong>证毕！</strong></p><hr><script type="math/tex; mode=display">\mathbf{J}[1]^{15\times9}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{v}^w_{b_k} },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{a_k} },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{w_k} }]=\begin{bmatrix}-\mathbf{R}^{b_k}_w\Delta t&-\mathbf{J}^{\alpha}_{b_a}&-\mathbf{J}^{\alpha}_{b_w}\\0&0&-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\mathbf{J}^{\gamma}_{b_w}\\-\mathbf{R}^{b_k}_w&-\mathbf{J}^{\beta}_{b_a}&-\mathbf{J}^{\beta}_{b_w}\\0&-\mathbf{I}&0\\0&0&-\mathbf{I}\end{bmatrix}\tag{J1}</script><hr><ul><li><strong>推导 $\mathbf{J}[1]$</strong></li></ul><p>首先第一列的求导都是直接可以看出来的，这里不做推导。</p><p>论文中， $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$  关于偏差的一阶近似可以写成：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&\approx \hat{\alpha}^{b_k}_{b_{k+1} }+\mathbf{J}^{\alpha}_{b_a}\delta b_{a_k}+\mathbf{J}^{\alpha}_{b_w}\delta b_{w_k}\\\beta^{b_k}_{b_{k+1} }&\approx \hat{\beta}^{b_k}_{b_{k+1} }+\mathbf{J}^{\beta}_{b_a}\delta b_{a_k}+\mathbf{J}^{\beta}_{b_w}\delta b_{w_k}\\\gamma^{b_k}_{b_{k+1} }&\approx \hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\end{align*}\tag{8}</script><p>其中 $\mathbf{J}^{\alpha}_{b_a}$ 和 是 $\mathbf{J}^{\alpha}_{b_{k+1} }$ 中的子块矩阵，其位置对应于 $\frac{\delta\alpha^{b_k}_{b_{k+1} } }{\delta b_{a_k} }$ 。 $\mathbf{J}^{\alpha}_{b_w}、\mathbf{J}^{\beta}_{b_a}、\mathbf{J}^{\beta}_{b_w}、\mathbf{J}^{\gamma}_{b_w}$ 也使用相同的含义。当偏差的估计发生轻微变化时，我们使用 $(8)$ 来近似地校正预积分结果，而不是重新传播。</p><p>这里主要对 $\mathbf{J[1]}_{[2,3]}$ 进行推导，对应的雅可比为 $\frac{\partial \delta\theta^{b_k}_{b_{k+1}} }{\partial\mathbf{q}^{w}_{k+1} }$:</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta\theta^{b_k}_{b_{k+1}} }{\partial b_{w_k} }&=\frac{\partial 2[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz} }{\partial b_{w_k} }\\&=2\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\left[\hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\right]}^{-1}-{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\left[\hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\0 \end{bmatrix}\right]}^{-1}}{\delta b_{w_k}}\\&=2\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\begin{bmatrix}0\\-\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}}\otimes{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1}}{\delta b_{w_k}}\\&=\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes{\begin{bmatrix}0\\-\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}}\otimes{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1}}{\delta b_{w_k}}\\&=\underset{\delta b_{w_k}\rightarrow0}{\lim}\frac{\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\otimes\mathcal{R}\left[{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1} \right]\otimes{\begin{bmatrix}0\\-\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix} }}{\delta b_{w_k}}\\&=-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]\mathcal{R}\left[{\hat{\gamma}^{b_k}_{b_{k+1} } }^{-1} \right]\mathbf{J}^{\gamma}_{b_w}\\&=-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} } \right]_{3\times3}\mathcal{L}\left[\hat{\gamma}^{b_k}_{b_{k+1} } \right]_{3\times3}\mathbf{J}^{\gamma}_{b_w}\\&=-\mathcal{L}\left[{\mathbf{q}_{b_k}^w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\mathbf{J}^{\gamma}_{b_w}\end{align*}\tag{J1-1}</script><p><strong>证毕！</strong></p><hr><script type="math/tex; mode=display">\mathbf{J}[2]^{15\times7}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{p}^w_{b_{k+1} } },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{q}^w_{b_{k+1} } }]=\begin{bmatrix}\mathbf{R}^{b_k}_w&0\\0&\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\\0&0\\0&0\\0&0\\\end{bmatrix}\tag{J2}</script><hr><ul><li><strong>推导 $\mathbf{J}[2]$</strong></li></ul><p>主要是对 $\mathbf{J}[2]_{[2,2]}$ 进行推导，即 $\frac{\partial \delta\theta^{b_k}_{b_{k+1}} } {\partial \mathbf{q}^w_{b_{k+1} } }$：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial \delta\theta^{b_k}_{b_{k+1}} } {\partial \mathbf{q}^w_{b_{k+1} } }&=\frac{\partial 2[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1}]_{xyz} }{\partial \mathbf{q}^w_{b_{k+1} } }\\&=2\underset{\delta\theta^w_{b_{k+1} }\rightarrow0}{\lim}\frac{{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{\delta\theta^w_{b_{k+1} } }{2}\end{bmatrix}\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} -{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\begin{bmatrix}1\\0\end{bmatrix}\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} }{\delta\theta^w_{b_{k+1} } }\\&=\underset{\delta\theta^w_{b_{k+1} }\rightarrow0}{\lim}\frac{{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\begin{bmatrix}0\\\delta\theta^w_{b_{k+1} }\end{bmatrix}\otimes(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} }{\delta\theta^w_{b_{k+1} } }\\&=\underset{\delta\theta^w_{b_{k+1} }\rightarrow0}{\lim}\frac{\mathcal{L}[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }]\mathcal{R}[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} ]\begin{bmatrix}0\\\delta\theta^w_{b_{k+1} }\end{bmatrix}}{\delta\theta^w_{b_{k+1} } }\\&=\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\right]\mathcal{R}\left[(\hat{\gamma}^{b_k}_{b_{k+1} })^{-1} \right]\\&=\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\right]_{3\times3}\mathcal{L}\left[(\hat{\gamma}^{b_k}_{b_{k+1} }) \right]_{3\times3}\\&=\mathcal{L}\left[{\mathbf{q}^{b_k}_w}^{-1}\otimes\mathbf{q}^w_{b_{k+1} }\otimes\hat{\gamma}^{b_k}_{b_{k+1} }\right]_{3\times3}\end{align*}</script><p><strong>证毕！</strong></p><hr><script type="math/tex; mode=display">\mathbf{J}[3]^{15\times9}=[\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{v}^w_{b_{k+1} } },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{a_{k+1} } },\frac{\partial \mathbf{r}_{\mathcal{B} } }{\partial \mathbf{b}_{w_{k+1} } }]=\begin{bmatrix}0&0&0\\0&0&0\\\mathbf{R}^{b_k}_w&0&0\\0&\mathbf{I}&0\\0&0&\mathbf{I}\\\end{bmatrix}\tag{J3}</script><p>这个不需要证，应该可以直接看出来。</p><hr><p>上面公式在代码中对应： <code>class IMUFactor : public ceres::SizedCostFunction&lt;15, 7, 9, 7, 9&gt;</code><br>对于 <code>Evaluate</code> 输入 <code>double const *const *parameters, parameters[0], parameters[1], parameters[2],parameters[3]</code> 分别对应 $4$ 个输入参数, 它们的长度依次是 $7,9,7,9$，分别对应 $4$ 个优化变量的<br>参数块。  </p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>代码 <code>IMUFactor::Evaluate()</code> 中 <code>residual</code> 还乘以一个<strong>信息矩阵</strong> <code>sqrt_info</code>，这是因为真正的优化项其实是 马氏距离：$d = \mathbf{r}^T\mathbf{P}^{-1}\mathbf{r}$， $\mathbf{P}$ 是协方差， 又因为 Ceres 只接受最小二乘优化， 也就是  $\min(e^Te)$, 所以把 $\mathbf{P}$ 做 LLT 分解， 即 $𝐿𝐿^T= \mathbf{P}^{-1}$, 则有：  </p><script type="math/tex; mode=display">d=\mathbf{r}^TLL^T\mathbf{r}=(L^T\mathbf{r})^T(L^T\mathbf{r})\tag{9}</script><p>令 $\mathbf{r}^{\prime} = L^T\mathbf{r}$ 作为新的优化误差, 这样就能用 Ceres 求解了。<strong>马氏距离距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大</strong>, 着重优化那些比较确定的残差。若写成 <code>“sqrt_info.setIdentity()”</code> 相当于不加权。  </p><p>其中，$\mathbf{P}$ 是协方差，由之前提出的递推公式得到：</p><p>协方差的迭代公式为：  </p><script type="math/tex; mode=display">{\mathbf{P}^{b_k}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{P}^{b_k}_{k}\mathbf{F}^T+\mathbf{V}\mathbf{Q}\mathbf{V}^T\tag{10}</script><p>其中， 初始值 $\mathbf{P}^{b_k}_{b_k}=0$。 $\mathbf{Q}$ 为表示噪声项的对角协方差矩阵：</p><script type="math/tex; mode=display">\mathbf{Q}^{18\times18}=\begin{bmatrix}\sigma^2_{a}&0&0&0&0&0\\0&\sigma^2_{w}&0&0&0&0\\0&0&\sigma^2_{a}&0&0&0\\0&0&0&\sigma^2_{w}&0&0\\0&0&0&0&\sigma^2_{b_a}&0\\0&0&0&0&0&\sigma^2_{b_w}\\\end{bmatrix}\tag{11}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍后端非线性优化中的IMU约束。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_3-PVQ增量误差、协方差及雅可比推导</title>
    <link href="https://lukeyalvin.top/posts/6eff9a87.html"/>
    <id>https://lukeyalvin.top/posts/6eff9a87.html</id>
    <published>2022-05-20T09:17:43.000Z</published>
    <updated>2022-05-20T10:05:40.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍PVQ增量误差、协方差及雅可比推导。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h2 id="Ⅰ-连续形式下"><a href="#Ⅰ-连续形式下" class="headerlink" title="Ⅰ.  连续形式下"></a>Ⅰ.  连续形式下</h2><h3 id="A-PVQ增量误差"><a href="#A-PVQ增量误差" class="headerlink" title="A. PVQ增量误差"></a>A. PVQ增量误差</h3><p>IMU 在每一个时刻积分出来的值是有误差的，下面我们对误差进行分析。首先我们直<br>接给出在 t 时刻误差项的导数 ：（即推导出 $(8)$ 的误差项的连续时间线性化方程）</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}\delta \dot{\alpha}^{b_k}_t\\\delta \dot{\beta}^{b_k}_t\\\delta \dot{\theta}^{b_k}_t\\\delta \dot{b}_{a_t}\\\delta \dot{b}_{w_t}\\\end{bmatrix}&=\begin{bmatrix}0&\mathbf{I}&0&0&0\\0&0&-\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}]^{\land}&-\mathbf{R}^{b_k}_t&0\\0&0&-[\hat{w}_t-b_{w_t}]^{\land}&0&-\mathbf{I}\\0&0&0&0&0\\0&0&0&0&0\\\end{bmatrix}\begin{bmatrix}\delta {\alpha}^{b_k}_t\\\delta {\beta}^{b_k}_t\\\delta {\theta}^{b_k}_t\\\delta {b}_{a_t}\\\delta {b}_{w_t}\\\end{bmatrix}+\begin{bmatrix}0&0&0&0\\-\mathbf{R}^{b_k}_t&0&0&0\\0&-\mathbf{I}&0&0\\0&0&\mathbf{I}&0\\0&0&0&\mathbf{I}\\\end{bmatrix}\begin{bmatrix}\mathbf{n}_a\\\mathbf{n}_w\\\mathbf{n}_{b_a}\\\mathbf{n}_{b_w}\end{bmatrix}\\&=\mathbf{F}_t\delta\mathbf{z}^{b_k}_t+\mathbf{G}_t\mathbf{n}_t\end{align*}\tag{1}</script><p>其中：$\mathbf{F}^{15\times15}_t,\mathbf{G}^{15\times12}_t,\delta{\mathbf{z}^{b_k}_t}^{15\times1},\mathbf{n}^{12\times1}_t$，下面给出其推导过程。</p><p>在推导之前，引入两个概念：</p><p>​    ① $true$：        真实测量值，包含了噪声 ，包括附加噪声和随机游走</p><p>​    ① $nominal$：无噪声的理论值  </p><ul><li><strong>对于 $\dot{\beta}^{b_k}_t$ 的推导：</strong></li></ul><p>易知$\delta \dot{\beta}^{b_k}_t={\dot{\beta}^{b_k}_t}_{true}-{\dot{\beta}^{b_k}_t}_{nominal}$，我们分别推导${\dot{\beta}^{b_k}_t}_{true}$ 以及${\dot{\beta}^{b_k}_t}_{nominal}$ :</p><script type="math/tex; mode=display">\begin{align*}{\dot{\beta}^{b_k}_t}_{true}&={\mathbf{R}^{b_k}_t}_{true}({\hat{a}_t}_{true}-{b_{a_t} }_{true})\\&=\mathbf{R}^{b_k}_t\exp(\delta\theta^{\land})(\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t})\\&=\mathbf{R}^{b_k}_t(I+\delta\theta^{\land})(\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t})\\&=\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t}+\delta\theta^{\land}(\hat{a}_t-b_{a_t})]\\&=\mathbf{R}^{b_k}_t[\hat{a}_t-b_{a_t}-n_a-\delta b_{a_t}-(\hat{a}_t-b_{a_t})^{\land}\delta\theta]\\{\dot{\beta}^{b_k}_t}_{nominal}&=\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})\end{align*}\tag{IA-1}</script><p>因此，可以得到：</p><script type="math/tex; mode=display">\begin{align*}\delta \dot{\beta}^{b_k}_t&={\dot{\beta}^{b_k}_t}_{true}-{\dot{\beta}^{b_k}_t}_{nominal}\\&=\mathbf{R}^{b_k}_t[-n_a-\delta b_{a_t}-(\hat{a}_t-b_{a_t})^{\land}\delta\theta]\\&=-\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})^{\land}\delta\theta-\mathbf{R}^{b_k}_t\delta b_{a_t}-\mathbf{R}^{b_k}_tn_a\end{align*}\tag{IA-2}</script><ul><li><strong>对于 $\dot{\theta}^{b_k}_t$ 的推导：</strong></li></ul><p>由公式 $(IA-5)$ 可知：</p><script type="math/tex; mode=display">\begin{align*}{\dot{\mathbf{q} }_t}_{true}&=\frac{1}{2}{\mathbf{q}_t}_{true}\otimes\begin{bmatrix}w_{ture}\\0\end{bmatrix}\\&=\frac{1}{2}\mathbf{q}_t\otimes\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}\\{\dot{\mathbf{q} }_t}_{nominal}&=\dot{\mathbf{q} }_t\\&=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\\\end{align*}\tag{IA-3}</script><p>根据导数的性质，又有：</p><script type="math/tex; mode=display">\begin{align*}{\dot{\mathbf{q} }_t}_{true}&=\dot{\overbrace{\mathbf{q}_t\otimes\delta \mathbf{q} } }\\&=\dot{\mathbf{q} }_t\otimes\delta \mathbf{q}+\mathbf{q}_t\otimes\dot{\delta \mathbf{q} }\\&=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}+\mathbf{q}_t\otimes\dot{\delta \mathbf{q} }\\\end{align*}\tag{IA-4}</script><p>综合$ (\mathrm{IA-3})$ 和 $ (\mathrm{IA-4})$：</p><script type="math/tex; mode=display">\begin{align*}&\frac{1}{2}\mathbf{q}_t\otimes\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}+\mathbf{q}_t\otimes\dot{\delta \mathbf{q} }\\&\Leftrightarrow \frac{1}{2}\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}=\frac{1}{2}\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}+\dot{\delta \mathbf{q} }\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\delta\mathbf{q}\otimes\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}-\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix}\otimes\delta \mathbf{q}\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\mathcal{R}\left(\begin{bmatrix}\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\0\end{bmatrix}  \right)\delta \mathbf{q}-\mathcal{L}\left(\begin{bmatrix}\hat{w}_t-b_{w_t}\\0\end{bmatrix} \right)\delta\mathbf{q}\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\left(\begin{bmatrix}-(\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t})^{\land}&\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t}\\-(\hat{w}_t-b_{w_t}-n_w-\delta b_{w_t})^T&0 \end{bmatrix}-\begin{bmatrix}(\hat{w}_t-b_{w_t})^{\land}&\hat{w}_t-b_{w_t}\\-(\hat{w}_t-b_{w_t})^T&0\end{bmatrix}\right)\begin{bmatrix}\frac{\delta\theta}{2}\\1\end{bmatrix}\\&\Leftrightarrow 2\dot{\delta \mathbf{q} }=\begin{bmatrix}-(2\hat{w}_t-2b_{w_t}-n_w-\delta b_{w_t})^{\land}&-n_w-\delta b_{w_t}\\(n_w+\delta b_{w_t})^T&0 \end{bmatrix}\begin{bmatrix}\frac{\delta\theta}{2}\\1\end{bmatrix}\end{align*}</script><p>上式左侧也可以写成：</p><script type="math/tex; mode=display">2\dot{\delta \mathbf{q} }=\begin{bmatrix}\dot{\delta\theta}\\0\end{bmatrix}=\begin{bmatrix}-(2\hat{w}_t-2b_{w_t}-n_w-\delta b_{w_t})^{\land}&-n_w-\delta b_{w_t}\\(n_w+\delta b_{w_t})^T&0 \end{bmatrix}\begin{bmatrix}\frac{\delta\theta}{2}\\1\end{bmatrix}</script><p>故而，可得到：</p><script type="math/tex; mode=display">\begin{align*}\dot{\delta\theta}&=-(2\hat{w}_t-2b_{w_t}-n_w-\delta b_{w_t})^{\land}\frac{\delta\theta}{2}-n_w-\delta b_{w_t}\\&\approx-(\hat{w}_t-b_{w_t})^{\land}\delta\theta-n_w-\delta b_{w_t}\end{align*}\tag{IA-5}</script><ul><li><strong>其他的推导</strong></li></ul><p>对于 $\delta \dot{\alpha}^{b_k}_t$ 而言，我们知道加速度和速度之间就是相差一个导数，因此：$\delta \dot{\alpha}^{b_k}_t=\delta \beta^{b_k}_t$</p><p>对于 $\delta \dot{b}_{a_t}$ 和 $\delta \dot{b}_{w_t}$​ ，已知加速度偏差和陀螺仪偏置被建模为<strong>随机游走</strong>，其导数为高斯，$n_{b_a}\sim\mathcal{N}(0, \sigma^2_{b_a}),n_{b_w}\sim\mathcal{N}(0, \sigma^2_{b_w})$：</p><script type="math/tex; mode=display">\dot{b}_{a_t}=n_{b_a},\ \ \ \ \ \ \dot{b}_{w_t}=n_{b_w}</script><p>故而： $\delta \dot{b}_{a_t}=\delta\mathbf{n_{b_a} }$  ,    $\delta \dot{b}_{w_t}=\delta\mathbf{n_{b_w} }$  </p><h3 id="B-协方差及雅可比"><a href="#B-协方差及雅可比" class="headerlink" title="B. 协方差及雅可比"></a>B. 协方差及雅可比</h3><p>对于公式 $(1)$ 可以简写为：</p><script type="math/tex; mode=display">\delta\dot{\mathbf{z} }^{b_k}_t=\mathbf{F}_t\delta\mathbf{z}^{b_k}_t+\mathbf{G}_t\mathbf{n}_t\tag{2}</script><p>根据导数定义可知：$\delta\dot{\mathbf{z} }^{b_k}_t=\underset{\delta t\rightarrow0}{\lim}\frac{\delta\mathbf{z}^{b_k}_{t+\delta t}+\delta\mathbf{z}^{b_k}_t}{\delta t}$   </p><script type="math/tex; mode=display">\begin{align*}\delta\mathbf{z}^{b_k}_{t+\delta t}&=\delta\mathbf{z}^{b_k}_{t}+\delta\dot{\mathbf{z} }^{b_k}_t \delta t\\&=(\mathbf{I}+\mathbf{F}_t\delta t)\delta\mathbf{z}^{b_k}_t+(\mathbf{G}_t\delta t)\mathbf{n}_t\\&=\mathbf{F}\delta\mathbf{z}^{b_k}_t+\mathbf{V}\mathbf{n}_t\end{align*}\tag{3}</script><p>其中，$\mathbf{F}=\mathbf{I}+\mathbf{F}_t\delta t,\mathbf{V}=\mathbf{G}_t\delta t$。</p><p>这里我们对公式 $(3)$ 的 IMU 误差运动方程再说明，将上式和 EKF 对比可知，上式恰好给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测量误差与上一个时刻的成线性关系，这样<strong>我们根据当前时刻的值，可以预测出下一个时刻的均值和协方差</strong>，而公式 $(3)$ 给出的是均值预测，协方差预测公式如下：  </p><script type="math/tex; mode=display">\mathbf{P}^{b_k}_{t+\delta t}=(\mathbf{I}+\mathbf{F}_t\delta t)\mathbf{P}^{b_k}_{t}(\mathbf{I}+\mathbf{F}_t\delta t)^T+(\mathbf{G}_t\delta t)\mathbf{Q}_t(\mathbf{G}_t\delta t)^T,t\in[k,k+1]\tag{4}</script><p>上式给出了协方差的迭代公式，初始值 $\mathbf{P}^{b_k}_{b_k}=0$。其中， $\mathbf{Q}$ 为表示噪声项的对角协方差矩阵：  </p><script type="math/tex; mode=display">\mathbf{Q}^{12\times12}=\begin{bmatrix}\delta^2_{a}&0&0&0\\0&\delta^2_{w}&0&0\\ 0&0&\delta^2_{b_a}&0\\  0&0&0&\delta^2_{b_w}\\ \end{bmatrix}\tag{5}</script><p>另外根据 $(3)$ 式可获得误差项的 Jacobian 的迭代公式：  </p><script type="math/tex; mode=display">\mathbf{J}_{t+\delta t}=(\mathbf{I}+\mathbf{F}_t\delta t)\mathbf{J}_\tag{6}t</script><p>其中，Jacobian 的初始值 $\mathbf{J}^{b_k}_{b_k}=\mathbf{I}$</p><h2 id="Ⅱ-离散形式下"><a href="#Ⅱ-离散形式下" class="headerlink" title="Ⅱ. 离散形式下"></a>Ⅱ. 离散形式下</h2><h3 id="A-PVQ增量误差-1"><a href="#A-PVQ增量误差-1" class="headerlink" title="A. PVQ增量误差"></a>A. PVQ增量误差</h3><p>我们首先直接给出 PVQ 增量误差在离散形式下的矩阵形式，为了与代码一致，我们修改下变量顺序，这和代码中 <code>midPointIntegration()</code> 函数是一致的。 （ 但不知为何计算的 V 中与前四个噪声项相关的差个负号？ ）  </p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}\delta\alpha_{k+1}\\ \delta\theta_{k+1}\\ \delta\beta_{k+1}\\ \delta b_{a_{k+1} }\\ \delta b_{w_{k+1} }\\ \end{bmatrix}&=\begin{bmatrix}\mathbf{I}&f_{12}&\delta t&f_{14}&f_{15}\\0&f_{22}&0&0&-\delta t\\0&f_{32}&\mathbf{I}&f_{34}&f_{35}\\0&0&0&\mathbf{I}&0\\0&0&0&0&\mathbf{I}\end{bmatrix}\begin{bmatrix}\delta\alpha_k\\\delta\theta_k\\\delta\beta_k\\\delta b_{a_k}\\\delta b_{w_k}\\ \end{bmatrix}+\begin{bmatrix}g_{11}&g_{12}&g_{13}&g_{14}&0&0\\0&\frac{1}{2}\delta t&0&\frac{1}{2}\delta t&0&0\\\frac{1}{2}\mathbf{R}_k\delta t&g_{32}&\frac{1}{2}\mathbf{R}_k\delta t&g_{34}&0&0\\0&0&0&0&\delta t&0\\0&0&0&0&0&\delta t\end{bmatrix}\begin{bmatrix}\mathbf{n}_{a_k}\\ \mathbf{n}_{w_k}\\ \mathbf{n}_{a_{k+1} }\\ \mathbf{n}_{w_{k+1} }\\ \mathbf{n}_{b_a}\\ \mathbf{n}_{b_w}\\ \end{bmatrix}\\&=\mathbf{F}\begin{bmatrix}\delta\alpha_k\\\delta\theta_k\\\delta\beta_k\\\delta b_{a_k}\\\delta b_{w_k}\\ \end{bmatrix}+\mathbf{G}\begin{bmatrix}\mathbf{n}_{a_k}\\ \mathbf{n}_{w_k}\\ \mathbf{n}_{a_{k+1} }\\ \mathbf{n}_{w_{k+1} }\\ \mathbf{n}_{b_a}\\ \mathbf{n}_{b_w}\\ \end{bmatrix}\\\end{align*}\tag{7}</script><p>$\mathbf{F},\mathbf{G}$为两个时刻间的协方差传递矩阵。</p><p>下面给出推导过程。</p><p>首先是两个比较简单的：</p><script type="math/tex; mode=display">\delta b_{a_{k+1} }=\delta b_{a_k}+\delta t\mathbf{n}_a \\\delta b_{w_{k+1} }=\delta b_{w_k}+\delta t\mathbf{n}_w \\</script><p>主要推导其他三个：$\delta\alpha_{k+1}, \delta\theta_{k+1}, \delta\beta_{k+1}$，分别推导：</p><ul><li><strong>对于 $\delta\theta_{k+1}$ 的推导</strong></li></ul><p>由公式 $\mathrm{(IA-5)}$ 可知，角度误差的连续形式为：</p><script type="math/tex; mode=display">\dot{\delta\theta}\approx-(\hat{w}_t-b_{w_t})^{\land}\delta\theta-n_w-\delta b_{w_t}</script><p>则离散形式为：</p><script type="math/tex; mode=display">\dot{\delta\theta_k}\approx-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta\theta_k-\frac{n_{w_k}+n_{w_{k+1} } }{2}-\delta b_{w_k}</script><p>由导数的定义：</p><script type="math/tex; mode=display">\begin{align*}\delta\theta_{k+1} &=\delta\theta_{k}+\dot{\delta\theta_{k} }\ \delta t\\&=f_{22}\ {\color{red}\delta\theta_{k} }-\delta t\  {\color{red}\delta b_{w_k} }-\frac{\delta t}{2}{\color{red}n_{w_k} }  -\frac{\delta t}{2}{\color{red}n_{w_{k+1} } }\end{align*}\tag{IIA-1}</script><p>其中，</p><script type="math/tex; mode=display">f_{22}=I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t\tag{IIA-2}</script><ul><li><strong>对于 $\delta\beta_{k+1}$ 的推导</strong></li></ul><p>由公式 $\mathrm{(IA-2)}$ 可知，速度误差的连续形式为：</p><script type="math/tex; mode=display">\delta \dot{\beta}^{b_k}_t=-\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t})^{\land}\delta\theta-\mathbf{R}^{b_k}_t\delta b_{a_t}-\mathbf{R}^{b_k}_tn_a</script><p>则离散形式为：</p><script type="math/tex; mode=display">\delta \dot{\beta}^{b_k}_t=-\frac{\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}\delta\theta_k+\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\delta\theta_{k+1} }{2}-\frac{\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1} }{2}\delta b_{a_k}-\frac{\mathbf{R}^{b_k}_kn_{a_k}+\mathbf{R}^{b_{k} }_{k+1}n_{a_{k+1} } }{2}</script><p>将公式 $\mathrm{(IIA-1)}$ 代入上式：</p><script type="math/tex; mode=display">\begin{align*}\delta \dot{\beta}^{b_k}_t=&-\frac{1}{2}\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}\delta\theta_k\\&-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\left\{\left[ I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t \right]\delta\theta_{k}-\frac{n_{w_k}+n_{w_{k+1} } }{2}\delta t-\delta b_{w_k}\delta t\right\}\\&-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta b_{a_k}-\frac{1}{2}\mathbf{R}^{b_k}_kn_{a_k}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}n_{a_{k+1} }\\=&\left\{-\frac{1}{2}\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\left[ I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t \right]\right\}\delta\theta_{k}\\&+\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}n_{w_k}+\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}(\hat{a}_{k+1} -b_{a_k})^{\land}n_{w_{k+1} }+\frac{\delta t}{2}\mathbf{R}^{b_{k} }_{k+1}(\hat{a}_{k+1} -b_{a_k})^{\land}\delta b_{w_k}\\&-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta b_{a_k}-\frac{1}{2}\mathbf{R}^{b_k}_kn_{a_k}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}n_{a_{k+1} }\\\end{align*}</script><p>同理，由导数的定义可知：</p><script type="math/tex; mode=display">\begin{align*}\delta \beta^{b_k}_{k+1}&=\delta \beta^{b_k}_k+\delta \dot{\beta}^{b_k}_t\ \delta t\\=&f_{32}\ {\color{red}\delta\theta_k}+{\color{red}\delta \beta^{b_k}_k}-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ {\color{red}\delta b_{a_k} }+f_{35}\ {\color{red}\delta b_{w_k} }\\&-\frac{1}{2}\mathbf{R}^{b_k}_k\delta t\ {\color{red}n_{a_k} }+g_{32}\ {\color{red}n_{w_k} }-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}\delta t\ {\color{red}n_{a_{k+1} } }+g_{34}\ {\color{red}n_{w_{k+1} } }\end{align*}\tag{IIA-3}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}f_{32}&=-\frac{1}{2}\mathbf{R}^{b_k}_k(\hat{a}_k-b_{a_k})^{\land}\delta t-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\left[ I-\left(\frac{\hat{w}_k+\hat{w}_{k+1}}{2}-b_{w_k}\right)^{\land}\delta t \right]\delta t\\f_{35}&=\frac{\delta t}{2}\mathbf{R}^{b_{k} }_{k+1}(\hat{a}_{k+1} -b_{a_k})^{\land}\delta t^2\\g_{32}&=\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\delta t^2\\g_{34}&=\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1} (\hat{a}_{k+1} -b_{a_k})^{\land}\delta t^2\\\end{align*}\tag{IIA-4}</script><ul><li><strong>对于 $\delta\alpha_{k+1}$ 的推导</strong></li></ul><p>我们知道加速度和速度之间就是相差一个导数，因此：$\delta \dot{\alpha}^{b_k}_t=\delta \beta^{b_k}_t$</p><p>则离散形式为：</p><script type="math/tex; mode=display">\begin{align*}\delta \dot{\alpha}^{b_k}_k=&\frac{1}{2}(\delta \beta^{b_k}_k+\delta \beta^{b_k}_{k+1})\\=&\frac{1}{2}(\delta \beta^{b_k}_k+\delta \beta^{b_k}_k+f_{32}\ \delta\theta_k+f_{35}\ \delta b_{w_k}+g_{32}\ n_{w_k}+g_{34}\ n_{w_{k+1} }\\&-\frac{1}{2}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{1}{2}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{1}{2}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} })\\=&\delta \beta^{b_k}_k+\frac{1}{2}f_{32}\ \delta\theta_k+\frac{1}{2}f_{35}\ \delta b_{w_k}+\frac{1}{2}g_{32}\ n_{w_k}+\frac{1}{2}g_{34}\ n_{w_{k+1} }\\&-\frac{1}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{1}{4}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{1}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} }\\\end{align*}</script><p>同理，由导数的定义可知：</p><script type="math/tex; mode=display">\begin{align*}\delta\alpha_{k+1}&=\delta\alpha_{k}+\delta \dot{\alpha}^{b_k}_k\ \delta t\\=&\delta\alpha_{k}+(\delta \beta^{b_k}_k+\frac{1}{2}f_{32}\ \delta\theta_k+\frac{1}{2}f_{35}\ \delta b_{w_k}+\frac{1}{2}g_{32}\ n_{w_k}+\frac{1}{2}g_{34}\ n_{w_{k+1} }\\&-\frac{1}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{1}{4}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{1}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} })\delta t\\=&\delta\alpha_{k}+\delta \beta^{b_k}_k\delta t+\frac{\delta t}{2}f_{32}\ \delta\theta_k+\frac{\delta t}{2}f_{35}\ \delta b_{w_k}+\frac{\delta t}{2}g_{32}\ n_{w_k}+\frac{\delta t}{2}g_{34}\ n_{w_{k+1} }\\&-\frac{\delta t}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ \delta b_{a_k}-\frac{\delta t}{4}\mathbf{R}^{b_k}_k\delta t\ n_{a_k}-\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ n_{a_{k+1} }\\=&{\color{red}\delta\alpha_{k} }+\frac{\delta t}{2}f_{32}\ {\color{red}\delta\theta_k}+\delta t\ {\color{red}\delta \beta^{b_k}_k}-\frac{\delta t}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\ {\color{red}\delta b_{a_k} }+\frac{\delta t}{2}f_{35}\ {\color{red}\delta b_{w_k} }\\&-\frac{\delta t}{4}\mathbf{R}^{b_k}_k\delta t\ {\color{red}n_{a_k} }+\frac{\delta t}{2}g_{32}\ {\color{red}n_{w_k} }-\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\ {\color{red}n_{a_{k+1} } }+\frac{\delta t}{2}g_{34}\ {\color{red}n_{w_{k+1} } }\\\end{align*}\tag{IIA-5}</script><p>所以：</p><script type="math/tex; mode=display">\begin{align*}f_{12}&=\frac{\delta t}{2}f_{32}\\f_{14}&=-\frac{\delta t}{4}(\mathbf{R}^{b_k}_k+\mathbf{R}^{b_{k} }_{k+1})\delta t\\f_{15}&=\frac{\delta t}{2}f_{35}\\g_{11}&=-\frac{\delta t}{4}\mathbf{R}^{b_k}_k\delta t\\g_{12}&=\frac{\delta t}{2}g_{32}\\g_{13}&=-\frac{\delta t}{4}\mathbf{R}^{b_{k} }_{k+1}\delta t\\g_{14}&=\frac{\delta t}{2}g_{34}\\\end{align*}\tag{IIA-6}</script><h3 id="B-协方差及雅可比-1"><a href="#B-协方差及雅可比-1" class="headerlink" title="B. 协方差及雅可比"></a>B. 协方差及雅可比</h3><p>公式 $(7)$ 可以简写为：</p><script type="math/tex; mode=display">\delta{\mathbf{z}_{k+1} }^{15\times1}=\mathbf{F}^{15\times15}\delta{\mathbf{z}_k}^{15\times1}+\mathbf{V}^{15\times18}\mathbf{Q}^{18\times1}\tag{8}</script><p>协方差的迭代公式为：  </p><script type="math/tex; mode=display">{\mathbf{P}^{b_k}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{P}^{b_k}_{k}\mathbf{F}^T+\mathbf{V}\mathbf{Q}\mathbf{V}^T\tag{9}</script><p>其中， 初始值 $\mathbf{P}^{b_k}_{b_k}=0$。 $\mathbf{Q}$ 为表示噪声项的对角协方差矩阵：  </p><script type="math/tex; mode=display">\mathbf{Q}^{18\times18}=\begin{bmatrix}\sigma^2_{a}&0&0&0&0&0\\0&\sigma^2_{w}&0&0&0&0\\0&0&\sigma^2_{a}&0&0&0\\0&0&0&\sigma^2_{w}&0&0\\0&0&0&0&\sigma^2_{b_a}&0\\0&0&0&0&0&\sigma^2_{b_w}\\\end{bmatrix}\tag{10}</script><p>另外根据 $(8)$ 式可获得误差项的 Jacobian 的迭代公式：  </p><script type="math/tex; mode=display">{\mathbf{J}_{k+1} }^{15\times15}=\mathbf{F}\mathbf{J}_{k}\tag{11}</script><p>其中， Jacobian 的初始值为 $\mathbf{J}_k= \mathbf{I}$。 这里计算出来的 $\mathbf{J}_{k+1}$ 只是为了给后面提供对 $bias$ 的 Jacobian。  </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍PVQ增量误差、协方差及雅可比推导。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_2-IMU预积分公式推导</title>
    <link href="https://lukeyalvin.top/posts/9c201995.html"/>
    <id>https://lukeyalvin.top/posts/9c201995.html</id>
    <published>2022-05-20T09:17:31.000Z</published>
    <updated>2022-05-20T11:55:25.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍IMU预积分公式推导。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="VINS公式推导：IMU预积分公式推导"><a href="#VINS公式推导：IMU预积分公式推导" class="headerlink" title="VINS公式推导：IMU预积分公式推导"></a>VINS公式推导：IMU预积分公式推导</h1><h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><p>我们将 $(·)^w$ 视为世界坐标系。重力方向与世界坐标系的 $z$ 轴对齐。$ (·)^b$是body 坐标系，我们定义它和IMU 坐标系一样。$ (·)^c $ 是相机坐标系。</p><p>我们使用旋转矩阵 $R$ 和 Hamilton 四元数 $q$ 来表示旋转。我们主要在状态向量中使用四元数，但旋转矩阵也用于方便地旋转三维向量。  $q^w_b , p^w_b$ 是从本体坐标系到世界坐标系的旋转和平移。$b_k$ 是拍摄第 $k$ 张图像时的本体坐标系。 $c_k$ 是拍摄第 $k$ 张图像时的相机帧。 $\otimes$ 表示两个四元数之间的乘法运算。$g^w = [0, 0, g]^T$ 是世界坐标系中的重力矢量。最后，我们将 $\hat{(·)}$ 表示为某个量的噪声测量或估计。</p><p>···Ⅳ·Ⅴ·Ⅵ·Ⅶ·Ⅷ·Ⅸ·Ⅹ·Ⅺ·Ⅻ</p><h2 id="IMU-噪声模型"><a href="#IMU-噪声模型" class="headerlink" title="IMU 噪声模型"></a>IMU 噪声模型</h2><p>IMU 的原始陀螺仪和加速度计测量值 $\hat{w}$ 和 $\hat{a}$ 由下式给出：</p><script type="math/tex; mode=display">\begin{align*}\hat{a}_t&=a_t+b_{a_t}+R^t_wg^w+n_a\\\hat{w}_t&=w_t+b_{w_t}+n_w\end{align*}\tag{1}</script><p>我们假设加速度和陀螺仪测量中的<strong>附加噪声</strong>是高斯噪声，$n_a\sim\mathcal{N}(0,\sigma^2_a),n_w\sim\mathcal{N}(0,\sigma^2_w)$。加速度偏差和陀螺仪偏差被建模为<strong>随机游走</strong>，其导数为高斯，$n_{b_a}\sim\mathcal{N}(0, \sigma^2_{b_a}),n_{b_w}\sim\mathcal{N}(0, \sigma^2_{b_w})$：</p><script type="math/tex; mode=display">\dot{b}_{a_t}=n_{b_a},\ \ \ \ \ \ \dot{b}_{w_t}=n_{b_w}\tag{2}</script><h2 id="Ⅰ-当前时刻-PVQ"><a href="#Ⅰ-当前时刻-PVQ" class="headerlink" title="Ⅰ.  当前时刻 PVQ"></a>Ⅰ.  当前时刻 PVQ</h2><h3 id="A-连续形式"><a href="#A-连续形式" class="headerlink" title="A.连续形式"></a>A.连续形式</h3><p><img src="/images/VINS-Mono-2-IMU预积分公式推导/image-20220520195515606.png" alt="image-20220520195515606" style="zoom: 50%;" /></p><p>将第 $k$ 帧和第 $k+1$ 帧之间的所有 IMU 进行积分，可得第 $k+1$ 帧的位置、速度和旋转<br>（ PVQ）,作为视觉估计的初始值，这里的旋转采用的四元数。  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{p}^w_{b_{k+1} }&=\mathbf{p}^w_{b_k}+\mathbf{v}^w_{b_k}\Delta t_k+\iint_{t\in[t_k, t_{k+1}]}(\mathbf{R}^w_t(\hat{a}_t-b_{a_t}-n_a)-g^w)dt^2\\\mathbf{v}^w_{b_{k+1} }&=\mathbf{v}^w_{b_k}+\int_{t\in[t_k, t_{k+1}]}(\mathbf{R}^w_t(\hat{a}_t-b_{a_t}-n_a)-g^w)dt\\\mathbf{q}^w_{b_{k+1} }&=\mathbf{q}^w_{b_k}\otimes\int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t}-n_w)\mathbf{q}^{b_k}_tdt\end{align*}\tag{3}</script><p>其中 $\hat{w}$ 和 $\hat{a}$ 分别是 IMU 的原始陀螺仪和加速度计测量值，$\Delta t_k$ 是时间间隔  $[t_k, t_{k+1}]$ 之间的持续时间。且</p><script type="math/tex; mode=display">\Omega(w)=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix},w^{\land}=\begin{bmatrix}0&-w_z&w_y\\w_z&0&-w_x\\-w_y&w_x&0\end{bmatrix}\tag{4}</script><p>其中，$w=\hat{w}_t-b_{w_t}-n_w$</p><p>对于基于四元数的IMU积分，这里做进一步推导，</p><p>公式(1)的 IMU 连续形式下的旋转状态推导如下，首先可写成：  </p><script type="math/tex; mode=display">\mathbf{q}^w_{b_{k+1} }=\mathbf{q}^w_{b_{k} }\otimes\int_{t\in[k,k+1]}\dot{\mathbf{q}}_tdt\tag{IA-1}</script><p>设四元数 $\mathbf{q}=[x,y,z,s]$，由四元数的左乘右乘：</p><script type="math/tex; mode=display">\begin{align*}\mathbf{q}_a\otimes\mathbf{q}_b&=\mathcal{R}(\mathbf{q}_b)\otimes\mathbf{q}_a=\begin{bmatrix}s_b&z_b&-y_b&x_b\\-z_b&s_b&x_b&y_b\\y_b&-x_b&s_b&z_b\\-x_b&-y_b&-z_b&s_b\\\end{bmatrix}\begin{bmatrix}x_a\\y_a\\z_a\\s_a\end{bmatrix}\\&=\mathcal{L}(\mathbf{q}_a)\otimes\mathbf{q}_b=\begin{bmatrix}s_a&-z_a&y_a&x_a\\z_a&s_a&-x_a&y_a\\-y_a&x_a&s_a&z_a\\-x_a&-y_a&-z_a&s_a\\\end{bmatrix}\begin{bmatrix}x_b\\y_b\\z_b\\s_b\end{bmatrix}\end{align*}\tag{IA-2}</script><p>为了简化以上的形式，我们设四元数 $\mathbf{q}=[x,y,z,s]$为 $\mathbf{q}=[w,s]$，则：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{R}(\mathbf{q}_a)&=\Omega(w)+sI_{4\times4}=\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\\\mathcal{L}(\mathbf{q}_a)&=\Psi(w)+sI_{4\times4}=\begin{bmatrix}w^{\land}&w\\-w^T&0\end{bmatrix}+sI_{4\times4}\end{align*}\tag{IA-3}</script><p> 因此，可以推导<strong>四元数的导数</strong>：这里也可以参考：<a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0">四元数求导</a></p><script type="math/tex; mode=display">\begin{align*}\dot{\mathbf{q} }_t&=\underset{\delta t}{\lim}\frac{1}{\delta t}(\mathbf{q}_{t+\delta t}-\mathbf{q}_t)\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}(\mathbf{q}_t\otimes\mathbf{q}^t_{t+\delta t}-\mathbf{q}_t\otimes\begin{bmatrix}0\\1\end{bmatrix})\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}\left(\mathbf{q}_t\otimes\begin{bmatrix}\mathbf{n}\sin\frac{\theta}{2}\\\cos\frac{\theta}{2}\end{bmatrix}-\mathbf{q}_t\otimes\begin{bmatrix}0\\1\end{bmatrix}\right)\\&\approx\underset{\delta t}{\lim}\frac{1}{\delta t}\left(\mathbf{q}_t\otimes\begin{bmatrix}\mathbf{n}\frac{\theta}{2}\\1\end{bmatrix}-\mathbf{q}_t\otimes\begin{bmatrix}0\\1\end{bmatrix}\right)\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}\left[\mathcal{R}\left(\begin{bmatrix}\mathbf{n}\frac{\theta}{2}\\1\end{bmatrix}\right)-\mathcal{R}\left(\begin{bmatrix}0\\1\end{bmatrix}\right)\right]\mathbf{q}_t\\&=\underset{\delta t}{\lim}\frac{1}{\delta t}\begin{bmatrix}-\frac{\theta\mathbf{n}}{2}^{\land}&\frac{\theta\mathbf{n}}{2}\\-\frac{\theta\mathbf{n}}{2}^T&0\end{bmatrix}\mathbf{q}_t\end{align*}\tag{IA-4}</script><p>其中，$\mathbf{n}$ 表示旋转轴，而角速度定义有：$w=\underset{\delta t}{\lim}\frac{\mathbf{n}\theta}{\delta t}$，则有：</p><script type="math/tex; mode=display">\dot{\mathbf{q} }_t=\frac{1}{2}\begin{bmatrix}-w^{\land}&w\\-w^T&0\end{bmatrix}\mathbf{q}_t=\frac{1}{2}\Omega(w)\mathbf{q}_t=\frac{1}{2}\mathcal{R}\left(\begin{bmatrix}w\\0\end{bmatrix}\right)\mathbf{q}_t=\frac{1}{2}\mathbf{q}_t\otimes\begin{bmatrix}w\\0\end{bmatrix}\tag{IA-5}</script><h3 id="B-中值法离散形式"><a href="#B-中值法离散形式" class="headerlink" title="B.中值法离散形式"></a>B.中值法离散形式</h3><p>公式 $(1)$ 给出的是连续时刻的相机当前 PVQ 的迭代公式，实际上，IMU在工作的时候是离散采集数据，所以代码中使用的也是离散形式，为了跟代码一致，下面给出基于中值法的公式，（还有基于欧拉法的公式，但是代码中使用的是前者）， 即从第 $i$ 个 IMU 时刻到第 $i+1$ 个 IMU 时刻的积分过程， 这与 <code>Estimator::processIMU()</code> 函数中的 <code>Ps[j]</code>、 <code>Rs[j]</code> 和 <code>Vs[j]</code> 是一致的，（代码中的 $j$ 时刻即为此处的 $i+1$），IMU 积分出来的第 $j$ 时刻的物理量可以作为第 $j$ 帧图像的初始值。  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{p}^w_{b_{i+1} }&=\mathbf{p}^w_{b_i}+\mathbf{v}^w_{b_i}\delta t+\frac{1}{2}\overline{\hat{a} }_i\delta t^2\\\mathbf{v}^w_{b_{i+1} }&=\mathbf{v}^w_{b_i}+\overline{\hat{a} }_i\delta t\\\mathbf{q}^w_{b_{i+1} }&=\mathbf{q}^w_{b_i}\otimes\begin{bmatrix} 1\\\frac{1}{2}\overline{\hat{w} }_i\delta t \end{bmatrix}\end{align*}\tag{5}</script><p>其中使用 mid-point 方法，即两个相邻时刻 $i$ 到 $j$ 的位姿是用两个时刻的测量值 $ a,w $ 的平均值来计算：</p><script type="math/tex; mode=display">\begin{align*}\overline{\hat{a} }_i&=\frac{1}{2}[\mathbf{q}_i(\hat{a}_i-b_{a_i})-g^w+\mathbf{q}_{i+1}(\hat{a}_{i+1}-b_{a_i})-g^w]\\\overline{\hat{w} }_i&=\frac{1}{2}(\hat{w}_i+\hat{w}_{i+1})-b_{w_i}\end{align*}\tag{6}</script><h2 id="Ⅱ-两帧之间-PVQ"><a href="#Ⅱ-两帧之间-PVQ" class="headerlink" title="Ⅱ. 两帧之间 PVQ"></a>Ⅱ. 两帧之间 PVQ</h2><h3 id="A-连续形式-1"><a href="#A-连续形式-1" class="headerlink" title="A.连续形式"></a>A.连续形式</h3><p>观察公式 $(3)$ 可知， IMU 的预积分需要依赖与第 $k$ 帧的 $\mathbf{v}$ 和 $\mathbf{R}$ ，当我们在后端进行非线性优化时，需要迭代更新第 $k$ 帧的 $\mathbf{v}$ 和 $\mathbf{R}$ ，这将导致我们需要根据每次迭代后值重新进行积分，这将非常耗时。</p><p>因此，我们考虑将优化变量从第 $k$ 帧到第 $k+1$ 帧的 IMU 预积分项中分离开来， 通过对公式 $(3)$ 左右两侧各乘 $\mathbf{R}^{b_k}_{w}$，可化简为：  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{R}^{b_k}_w\mathbf{p}^w_{b_{k+1} }&=\mathbf{R}^{b_k}_w(\mathbf{p}^w_{b_k}+\mathbf{v}^w_{b_k}\Delta t_k-\frac{1}{2}g^w\Delta t_k^2)+\alpha^{b_k}_{b_{k+1} }\\\mathbf{R}^{b_k}_w\mathbf{v}^w_{b_{k+1} }&=\mathbf{R}^{b_k}_w(\mathbf{v}^w_{b_k}-g^w\Delta t_k)+\beta^{b_k}_{b_{k+1} }\\\mathbf{q}^{b_k}_w\otimes\mathbf{q}^w_{b_{k+1} }&=\gamma^{b_k}_{b_{k+1} }\end{align*}\tag{7}</script><p>其中，</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&=\iint_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t}-n_a)dt^2\\\beta ^{b_k}_{b_{k+1} }&=\int_{t\in[t_k, t_{k+1}]}\mathbf{R}^{b_k}_t(\hat{a}_t-b_{a_t}-n_a)dt\\\gamma^{b_k}_{b_{k+1} }&= \int_{t\in[t_k, t_{k+1}]}\frac{1}{2}\Omega(\hat{w}_t-b_{w_t}-n_w)\gamma^{b_k}_tdt\end{align*}\tag{8}</script><p>可以看出，预积分项 $(8)$ 可以仅通过以 $b_k$ (表示第 $k$ 帧时的本体坐标系) 作为参考系的 IMU 测量来获得。</p><p> $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$ 与IMU的 $bais$ 有关，而 $bais$ 也是我们需要优化的变量，这将导致的问题是，当每次迭代时，我们得到一个新的 $bais$ ，又得根据公式 $(8)$ 重新对第 $k$ 帧和第 $k+1$ 帧之间的 IMU 预积分，非常耗时。</p><p>当 $bais$ 的估计发生变化时，如果变化很小，我们通过它们对 $bais$ 的一阶近似来调整 $\alpha^{b_k}_{b_{k+1} },\beta^{b_k}_{b_{k+1} },\gamma^{b_k}_{b_{k+1} }$ ，否则我们进行重新传播。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传播 IMU 测量。一阶近似如下：</p><script type="math/tex; mode=display">\begin{align*}\alpha^{b_k}_{b_{k+1} }&\approx \hat{\alpha}^{b_k}_{b_{k+1} }+\mathbf{J}^{\alpha}_{b_a}\delta b_{a_k}+\mathbf{J}^{\alpha}_{b_w}\delta b_{w_k}\\\beta^{b_k}_{b_{k+1} }&\approx \hat{\beta}^{b_k}_{b_{k+1} }+\mathbf{J}^{\beta}_{b_a}\delta b_{a_k}+\mathbf{J}^{\beta}_{b_w}\delta b_{w_k}\\\gamma^{b_k}_{b_{k+1} }&\approx \hat{\gamma}^{b_k}_{b_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\mathbf{J}^{\gamma}_{b_w}\delta b_{w_k} \end{bmatrix}\end{align*}\tag{9}</script><p>其中 $\mathbf{J}^{\alpha}_{b_a}$ 和 是 $\mathbf{J}^{\alpha}_{b_{k+1} }$ 中的子块矩阵，其位置对应于 $\frac{\delta\alpha^{b_k}_{b_{k+1} } }{\delta b_{a_k} }$ 。 $\mathbf{J}^{\alpha}_{b_w}、\mathbf{J}^{\beta}_{b_a}、\mathbf{J}^{\beta}_{b_w}、\mathbf{J}^{\gamma}_{b_w}$ 也使用相同的含义。</p><h3 id="B-离散形式"><a href="#B-离散形式" class="headerlink" title="B.离散形式"></a>B.离散形式</h3><h4 id="欧拉法"><a href="#欧拉法" class="headerlink" title="欧拉法"></a>欧拉法</h4><p>下面给出离散时刻的 IMU 预积分公式， 首先按照<strong>论文中采用的欧拉法</strong>， 给出第 $i$ 个 IMU<br>时刻与第 $i+1$ 个 IMU 时刻的变量关系为：  </p><script type="math/tex; mode=display">\begin{align*}\hat{\alpha}^{b_k}_{i+1}&=\hat{\alpha}^{b_k}_{i}+\hat{\beta}^{b_k}_{i}\delta t+\frac{1}{2}\overline{\hat{a} }_i^{\prime}\delta t^2\\\hat{\beta}^{b_k}_{i+1}&=\hat{\beta}^{b_k}_{i}+\overline{\hat{a} }_i^{\prime}\delta t\\\hat{\gamma}^{b_k}_{i+1}&=\hat{\gamma}^{b_k}_{i}\otimes\hat{\gamma}^{i}_{i+1}=\hat{\gamma}^{b_k}_{i}\otimes\begin{bmatrix}1\\\frac{1}{2}\overline{\hat{w} }_i^{\prime}\delta t\end{bmatrix}\\\end{align*}\tag{10}</script><p>使用欧拉法，即两个相邻时刻 $i$ 到 $i+1$的位姿是用第 $i$ 时刻的测量值 $\overline{\hat{a} }_i^{\prime}, \overline{\hat{w} }_i^{\prime}$ 来计算:</p><script type="math/tex; mode=display">\begin{align*}\overline{\hat{a} }_i^{\prime}&=\mathbf{R}(\hat{\gamma}^{b_k}_{i})(\hat{a}_i-b_{a_i})\\\overline{\hat{w} }_i^{\prime}&=\hat{w}_i-b_{w_i}\end{align*}\tag{11}</script><h4 id="中值法"><a href="#中值法" class="headerlink" title="中值法"></a>中值法</h4><p>下面给出<strong>代码中采用的基于中值法</strong>的 IMU 预积分公式，这与 <code>Estimator::processIMU()</code> 函<br>数中的 <code>IntegrationBase::push_back()</code>上是一致的。注意这里跟公式 $(5)$ 是不一样的，这里积分出来的是前后两帧之间的 IMU 增量信息，而公式 $(5)$ 给出的当前帧时刻的物理量信息。  </p><script type="math/tex; mode=display">\begin{align*}\hat{\alpha}^{b_k}_{i+1}&=\hat{\alpha}^{b_k}_{i}+\hat{\beta}^{b_k}_{i}\delta t+\frac{1}{2}\overline{\hat{a} }_i^{\prime} \delta t^2\\\hat{\beta}^{b_k}_{i+1}&=\hat{\beta}^{b_k}_{i}+\overline{\hat{a} }_i^{\prime}\delta t\\\hat{\gamma}^{b_k}_{i+1}&=\hat{\gamma}^{b_k}_{i}\otimes\hat{\gamma}^{i}_{i+1}=\hat{\gamma}^{b_k}_{i}\otimes\begin{bmatrix}1\\\frac{1}{2}\overline{\hat{w} }_i^{\prime}\delta t\end{bmatrix}\\\end{align*}\tag{12}</script><p>其中，  </p><script type="math/tex; mode=display">\begin{align*}\overline{\hat{a} }_i^{\prime}&=\frac{1}{2}[\mathbf{q}_i(\hat{a}_i-b_{a_i})+\mathbf{q}_{i+1}(\hat{a}_{i+1}-b_{a_i})]\\\overline{\hat{w} }_i^{\prime}&=\frac{1}{2}(\hat{w}_i+\hat{w}_{i+1})-b_{w_i}\end{align*}\tag{13}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍IMU预积分公式推导。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono_1-总体框架</title>
    <link href="https://lukeyalvin.top/posts/3cf7a3c1.html"/>
    <id>https://lukeyalvin.top/posts/3cf7a3c1.html</id>
    <published>2022-05-20T09:17:11.000Z</published>
    <updated>2022-05-20T11:54:05.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。<strong>本节介绍整体框架。</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/images/VINS-Mono-1-总体框架/image-20220520195226204.png" alt="image-20220520195226204"></p><p>VINS 的功能模块如图所示，可以分为五个部分：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化；代码中主要开启了四个线程，分别是：前端图像跟踪、后端非线性优化（其中初始化和 IMU 预积分在这个线程中）、闭环检测、闭环优化。  </p><h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h2><p>预处理主要指的是视觉前端里的图像处理以及IMU 测量量的处理。</p><p><strong>图像：</strong>提取图像 Harris 角点， 利用<strong>金字塔光流</strong>跟踪相邻帧，利用<strong>基础矩阵模型的RANSAC算法</strong>进行异常点剔除  ，最后将跟踪到的特征点 push 到图像队列中，并通知后端进行处理。  </p><p>另外，在此步骤中还选择了关键帧。  并定义两种选择关键帧的标准：① 与上一个关键帧的平均视差和某个特定阈值相比较；② 跟踪质量。</p><p><strong>IMU：</strong> 将 IMU 数据进行积分，得到当前时刻的位置、速度和旋转（ <strong>PVQ</strong>），同时计算在后端优化中将用到的相邻帧的<strong>预积分增量</strong>，及预积分误差的 <strong>Jacobian 矩阵</strong>和<strong>协方差项</strong>。 </p><p>这里涉及基于四元数的 IMU 推导过程，具体查看：</p><p>LK光流法：<a href="https://blog.csdn.net/sgfmby1994/article/details/68489944">总结：光流—LK光流—基于金字塔分层的LK光流—中值流</a></p><p>基础矩阵模型的RANSAC算法：<a href="https://blog.csdn.net/qq_38898129/article/details/93982154">计算机视觉：RANSAC剔除基础矩阵F错误匹配(Python实现)</a></p><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><p>首先， 利用 SFM 进行纯视觉估计滑窗内所有帧的位姿及 3D 点逆深度， 最后与 IMU 预<br>积分进行对齐求解初始化参数 。</p><p>SfM算法：<a href="https://zhuanlan.zhihu.com/p/55712813">基于单目视觉的三维重建算法综述</a>、<a href="https://blog.csdn.net/qq_20791919/article/details/74936438">SFM算法流程</a>、<a href="https://blog.csdn.net/Mahabharata_/article/details/70799695">[CV] Structure from motion（SFM）- 附我的实现结果</a></p><p>逆深度：<a href="https://blog.csdn.net/weixin_39568744/article/details/88582406">SLAM中的逆深度及参数化问题</a></p><h2 id="3-后端滑窗优化"><a href="#3-后端滑窗优化" class="headerlink" title="3. 后端滑窗优化"></a>3. 后端滑窗优化</h2><p>将视觉约束（视觉测量残差）、 IMU 约束（IMU测量残差）和闭环约束放在一个大的目标函数中进行非线性优化，求解滑窗内所有帧的 PVQ、 bias 等 。</p><h2 id="4-闭环检测和优化"><a href="#4-闭环检测和优化" class="headerlink" title="4. 闭环检测和优化"></a>4. 闭环检测和优化</h2><p>利用 DBoW 进行<strong>闭环检测</strong>，当检测成功后进行<strong>重定位</strong>，最后对整个相机轨迹进行<strong>闭环优</strong><br><strong>化</strong>。  </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;VINS是由香港科技大学秦通等人，于2018年提出的一种强大且通用的单目视觉惯性状态估计器，是初学者接触VIO 比较好的开源学习资料，作者的论文条理清晰，分为五个主要部分对该系统展开描述：测量预处理、初始化、后端非线性优化、闭环检测、闭环优化。&lt;strong&gt;本节介绍整体框架。&lt;/strong&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="VINS" scheme="https://lukeyalvin.top/categories/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="VINS" scheme="https://lukeyalvin.top/tags/VINS/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>七、滑动窗口算法</title>
    <link href="https://lukeyalvin.top/posts/a39e0cda.html"/>
    <id>https://lukeyalvin.top/posts/a39e0cda.html</id>
    <published>2022-05-13T06:57:20.000Z</published>
    <updated>2022-05-16T00:49:11.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>在学习滑动窗口算法之前，推荐读者先阅读，<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>以及<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>，这两篇博客奠定了本文的基础，有助于对本文的理解。</p><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>我们知道，SLAM中的优化问题，就是优化一个最小二乘的问题，这里我们首先介绍一个引例。</p><p>如下图所示，存在这么一个图模型，对于图模型大家肯定不是很陌生，了解过g2o的都应该很清楚，图中圆圈表示顶点，是待优化的变量，而顶点之间的边，表示的顶点之间构建的残差。</p><p><img src="/images/滑动窗口算法/image-20220513195856537.png" alt="image-20220513195856537" style="zoom:50%;" /></p><blockquote><p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p></blockquote><p>对于这样一个系统，我们首先构建出最小二乘，如下：</p><script type="math/tex; mode=display">\xi^*=\underset{\xi}{\arg\min}\frac{1}{2}\sum_i\parallel r_i \parallel^2_{\Sigma_i}\tag{1}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p><p>根据文章<a href="https://lukeyalvin.top/posts/48933.html#more">VSLAM中的非线性优化</a>中提到的，SLAM优化问题，最终运动观测方程优化的部分是<strong>马氏距离</strong>，残差项即为<strong>马氏距离</strong>:</p><script type="math/tex; mode=display">\parallel r_i \parallel^2_{\Sigma_i}=r^T\Sigma^{-1}r\tag{2}</script><p>其中 $\Sigma$ 表示残差的<strong>协方差矩阵</strong>， $\Sigma^{-1}$ 表示残差的<strong>信息矩阵</strong>，因此，此处相当于一种<strong>加权的</strong>最小二乘问题。</p><p>应用高斯牛顿法，可以求解上述最小二乘问题的<strong>正规方程</strong>：</p><script type="math/tex; mode=display">J^T\Sigma^{-1}J\ \delta\xi = -J^T\Sigma^{-1}\ r\tag{3}</script><p>其中海塞矩阵 $H=J^T\Sigma^{-1}J$，矩阵 $g= -J^T\Sigma^{-1}\ r$，雅可比矩阵为：</p><script type="math/tex; mode=display">J=\frac{\partial r}{\partial \xi}=\begin{bmatrix}\frac{\partial r_{12} }{\partial \xi}\\\frac{\partial r_{13} }{\partial \xi}\\\frac{\partial r_{14} }{\partial \xi}\\\frac{\partial r_{15} }{\partial \xi}\\\frac{\partial r_{56} }{\partial \xi}\end{bmatrix}=\begin{bmatrix}J_1\\J_2\\J_3\\J_4\\J_5\\J_6 \end{bmatrix}\tag{4}</script><p>其中，$\xi=[\xi_1,\xi_2,\xi_3,\xi_4,\xi_5,\xi_6]^T$，$r=[r_{12},r_{13},r_{14},r_{15},r_{56}]$</p><p>矩阵乘法公式 $(3)$ 可以写成连加：</p><script type="math/tex; mode=display">\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i J_i\ \delta\xi=-\sum^{5}_{i=1}J^T_i\Sigma^{-1}_i\ r\tag{5}</script><p>由于每个残差只和某几个状态量有关，因此，雅克比矩阵求导时，无关项的雅克比为 0。比如</p><script type="math/tex; mode=display">J_2=\frac{\partial r_{13} }{\partial \xi}=\begin{bmatrix}\frac{\partial r_{13} }{\partial \xi_1}&0&\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\end{bmatrix}\tag{6}</script><p>对应的新的信息矩阵：</p><script type="math/tex; mode=display">Λ_2=J^T_2\Sigma^{-1}_2J_2=\begin{bmatrix}(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_1})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_1}&0&(\frac{\partial r_{13} }{\partial \xi_3})^T\Sigma^{-1}_2\frac{\partial r_{13} }{\partial \xi_3}&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\end{bmatrix}\tag{7}</script><p>同理，可以计算 $Λ_1 , Λ_3 , Λ_4 , Λ_5 $，并且也是稀疏的。</p><p><strong>将五个残差的信息矩阵加起来</strong>，得到样例最终的<strong>信息矩阵</strong> $Λ$，可视化如下：</p><p><img src="/images/滑动窗口算法/image-20220513203817364.png" alt="image-20220513203817364" style="zoom: 33%;" /></p><p>关于稀疏矩阵。我们知道，可以用舒尔消元法或者称之为边缘化，来使之变得稠密，减少计算量。</p><h1 id="基于边际概率的滑动窗口算法"><a href="#基于边际概率的滑动窗口算法" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h1><h2 id="什么是滑动窗口算法？"><a href="#什么是滑动窗口算法？" class="headerlink" title="什么是滑动窗口算法？"></a>什么是滑动窗口算法？</h2><p><strong>什么是滑动窗口算法</strong></p><p>在引例的条件下，我们知道，一般情况下，SLAM问题构建的残差的信息矩阵是一个稀疏矩阵，在此基础上，我们讨论SLAM中的滑动窗口算法。</p><p>所谓的滑动窗口算法，并没有明确的定义，我做了一个动图，其展示的过程就是滑动窗口算法：</p><p><img src="/images/滑动窗口算法/cell-16526620480511.gif" alt="cell"></p><p>**为什么使用滑动窗口算法？</p><p>那么，使用它有什么好处呢？在文章开篇的概述中已经提及，这里再做强调：</p><ul><li>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</li><li>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态<strong>增加或移除优化变量</strong>。</li></ul><p>其实它的作用也是动图中展示的，我们优化的变量就是红色框中的部分，外部的变量不断增加进来，一些历史的变量做清除。</p><p><strong>滑动窗口中的关键问题是什么？</strong></p><p>但是我们需要考虑的关键就是，如何增加或者移除？直接移除吗？比如引例中的变量 $\xi_1$如果直接把顶点连同边一起移除，那么所有的其他变量之间的边可就都没了，边就是误差项，误差都没了，如何优化？这是下面我们需要介绍的重要内容。</p><p><strong>滑动窗口算法大致流程</strong></p><p>① 增加新的变量进入最小二乘系统优化</p><p>② 如果变量数目达到了一定的维度，则移除老的变量。</p><p>③ SLAM 系统不断循环前面两步</p><h2 id="基于边际概率的滑动窗口算法-1"><a href="#基于边际概率的滑动窗口算法-1" class="headerlink" title="基于边际概率的滑动窗口算法"></a>基于边际概率的滑动窗口算法</h2><p>关于这里，有必要回顾文章<a href="https://lukeyalvin.top/posts/2613d057.html">SLAM中的概率基础</a>中的案例，会对此有更加深刻的理解。</p><p>直接丢弃变量和对应的测量值，会损失信息。因此，我们需要选择一种“优雅的”方式丢掉历史信息，正确的做法是使用<strong>边际概率</strong>，将丢弃变量所携带的信息传递给剩余变量。意思就是，历史变量虽然被移除了，但是它的“影响力”还在。</p><p>还是用引例，我们将引例中的历史变量 $\xi_1$ 丢掉，应该如何操作呢？</p><blockquote><p>引自：Matthew R Walter, Ryan M Eustice, and John J Leonard. “Exactly sparse extended information filters for feature-based SLAM”. </p></blockquote><p><img src="/images/滑动窗口算法/image-20220513210526896.png" alt="image-20220513210526896"></p><p>很明显，去除历史变量 $\xi_1$ 之后，其他出现了互相之间的关联，这就是说历史变量 $\xi_1$ 虽然被去除了，但是它把自己的信息传递给其他变量了，虽然自己凉了，但是完成了火炬的传递。</p><p><strong>结论：</strong><span style="color:red;"><strong>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</strong></span> 另外，marg的这一特征也给我们启示，就是在SLAM运动观测模型中，marg特征点的时候，我们要<strong>marg那些不被其他帧观测到的特征点</strong>。因为他们不会显著的使得 H 变得稠密。对于那些被其他帧观测到的特征点，要么就别设置为marg，要么就宁愿丢弃，这就是okvis和dso中用到的一些策略。</p><hr><p>那么，如果在移除变量 $\xi_1$ 的同时，加入新的变量 $\xi_7$，整个信息矩阵又如何变化呢？</p><p>如下图所示，在 $t \in [0, k]$s 时刻, 系统中状态量为 $\xi_i , i \in [1, 6]$。</p><p>在第 $k $ 时刻，最小二乘优化完以后，marg 掉变量 $\xi_1$  。被 marg 的状态量记为 $x_m$ , 剩余的变量 $ξ_i , i \in [2, 5]$ 记为 $x_r $，marg 发生以后， $x_m$ 所有的变量以及对应的测量将被丢弃。同时，这部分信息通过 marg 操作传递给了保留变量 $x_r$ 。</p><p>第 $k^′$ 时刻，加入新的观测和状态量  $\xi_7$，新的变量  $\xi_7$ 跟老的变量  $\xi_2$ 之间存在观测信息，能构建残差 $r_{27}$ 。然后开始新一轮最小二乘优化。</p><p><img src="/images/滑动窗口算法/image-20220513213728826.png" alt="image-20220513213728826"></p><p>新残差加上之前 <strong>marg 留下的信息</strong>，构建新的最小二乘系统，对应的信息矩阵的变化如下图所示：</p><p><img src="/images/滑动窗口算法/image-20220513212137697.png" alt="image-20220513212137697" style="zoom:40%;" /></p><p>注意：  $\xi_2$  自身的信息矩阵由两部分组成，一部分是原来的$Λ^{\prime}$  中的老信息，另一部分是新生成的 $Λ_6$中的新信息，这会使得系统存在<strong>潜在风险</strong>。</p><p>新老信息融合的问题在于<strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。对于零空间的介绍在后文中。</p><hr><p><span style="color:red;"><strong>marg 留下的信息到底是啥？</strong></span></p><p>marg 发生后，留下的到底是什么信息？  </p><p>marg 前，变量 $x_m$ （指将要被 marg 的变量，$\xi_i,i=1$）以及对应测量 $\mathcal{S}_m$ （指的是与 $\xi_1$ 构成的边 $r_{1j},j\in[2,5]$）构建的最小二乘信息矩阵为（使用高斯牛顿）：  </p><script type="math/tex; mode=display">\begin{align*}b_m(k)&=\begin{bmatrix}b_{mm}(k)\\b_{mr}(k)\end{bmatrix}=-\sum_{(i,j)\in\mathcal{S}_m}J^T_{ij}(k)\Sigma^{-1}_{ij}r_{ij}\\Λ_m(k)&=\begin{bmatrix}Λ_{mm}(k)&Λ_{mr}(k)\\Λ_{rm}(k)&Λ_{rr}(k)\end{bmatrix}=\sum_{(i,j)\in\mathcal{S}_m}J^T_{ij}(k)\Sigma^{-1}_{ij}J_{ij}(k)\end{align*}\tag{8}</script><p>然后marg掉  $\xi_1$ ，即丢掉变418133364量  $x_m$ ， 而 $x_m$ 的测量信息，传递给了变量  $x_r$ （指的是 marg 剩余后的变量 $\xi_i,i\in[2,5]$）:  </p><script type="math/tex; mode=display">\begin{align*}b_p(k)&=b_{mr}(k)-Λ_{rm}(k)Λ^{-1}_{mm}(k)b_{mm}(k)\\Λ_p(k)&=Λ_{rr}(k)-Λ_{rm}(k)Λ^{-1}_{mm}(k)Λ_{mm}(k)\end{align*}\tag{9}</script><p>下标 p 表示 prior. 即这些信息将构建一个关于 $x_r$ 的先验信息。</p><p>由：</p><script type="math/tex; mode=display">\begin{align*}Λ_p(k)\delta x&=b_p(k)\\J^T_{p}(k)\Sigma^{-1}J_{p}(k)\ \delta x&= -J^T_{p}(k)\Sigma^{-1}r_p(k)\end{align*}\tag{10}</script><p>因此，我们可以从 $b_p(k),Λ_p(k)$反解出一个残差 $r_p(k)$ 和对应的雅可比矩阵 $J_{p}(k)$ ，需要注意的是<strong>，随着变量 $x_r(k)$ 的后续不断优化变化，残差 $r_p(k)$ 或者 $b_p(k)$ 也跟着变换，但是雅可比 $J_{p}(k)$ 则固定不变了。</strong></p><p>在 $k^′$ 时刻，新残差 $r_{27}$ 和先验信息  $b_p(k),Λ_p(k)$ 以及残差 $r_{56}$ 构建新的最小二乘问题 :</p><script type="math/tex; mode=display">\begin{align*}b_m(k^′)&=\Pi^Tb_p(k)-\sum_{(i,j)\in\mathcal{S}_a(k^′)}J^T_{ij}(k^′)\Sigma^{-1}_{ij}r_{ij}(k^′)\\Λ_m(k^′)&=\Pi^TΛ_p(k) \Pi+\sum_{(i,j)\in\mathcal{S}_a(k^′)}J^T_{ij}(k^′)\Sigma^{-1}_{ij}J_{ij}(k^′)\end{align*}\tag{11}</script><p>其中，$\Pi=[I_{dim\ x_r}\ \ 0]$用来将矩阵的维度进行扩张。 $\mathcal{S}_a$ 用来表示除被marg 掉的测量以外的其他测量，包括原本的与marg 变量无关的  $r_{56}$，以及新加入的变量 $r_{27}$。  </p><p><strong>出现的问题</strong></p><p>由于  $ξ_2$  的信息由两部分组成：</p><ul><li><p>一部分是marg 前的先验信息  $Λ_p(k)$ ，在marg 后，由于被 marg 的变量以及对应的测量已被丢弃，因此之前的雅可比不会被更新了，因此公式 $(11)$ 的等号右侧第一部分的线性化点是<strong>不变的</strong>；</p></li><li><p>另一部分信息就是新的边 $r_{27}$ ，其雅克比会随着 $ξ_2$  的迭代更新而不断在最新的线性化点处计算，因此公式 $(11)$ 的等号右侧第二部分的线性化点是<strong>不断变化的</strong>；</p></li><li><strong>旧的求解雅克比矩阵的变量线性化点和和新的求解雅克比矩阵的变量线性化点不同，它们在相加的时候，可能会导致信息矩阵的零空间发生变化，使得不客观的变量变得可观，从而引入错误信息</strong>。</li></ul><h2 id="信息矩阵的零空间变化"><a href="#信息矩阵的零空间变化" class="headerlink" title="信息矩阵的零空间变化"></a>信息矩阵的零空间变化</h2><p>滑动窗口算法优化的时候，信息矩阵如公式 $(11)$ 变成了两部分，且这两部分计算雅克比时的<strong>线性化点不同</strong>。这可能会导致信息矩阵的零空间发生变化，从而在求解时引入错误信息。  </p><p>这里引用贺博的博客：<a href="https://blog.csdn.net/heyijia0327/article/details/52822104?spm=1001.2014.3001.5501">SLAM中的marginalization 和 Schur complement</a></p><p><img src="/images/滑动窗口算法/image-20220514165208897-16526621209192.png" alt="image-20220514165208897" style="zoom: 33%;" /></p><p>在刘毅(稀疏毅)，王京，晓佳等人讨论下，对这张图作出了如下解释：</p><p>四张能量图中，第一张是说明能量函数 $E$ 由两个同样的非线性函数 $E_1$和 $E_2$组成，我们令函数 $E=0$，这时方程的解为 $x y = 1$ ，对应图中深蓝色的一条曲线。</p><p>第二张能量函数图中的 $E_1^′$对应函数  $E_1$ 在点 $(0.5,1.4)$ 处的二阶泰勒展开;</p><p>第三张能量函数图中的 $E_2^′$ 对应函数在  $E_2$ 点 $(1.2,0.5)$ 处的二阶泰勒展开。注意这两个近似的能量函数 $E_1^′$ 和 $E_2^′$是在不同的线性点附近对原函数展开得到的。</p><p>最后一张图就是把这个近似得到的能量函数合并起来，对整个系统 $E$ 的二阶近似。</p><p>从第四个能量函数图中，我们发现一个大问题，能量函数为 $0$ 的解由以前的一条曲线变成了一个点，<strong>不确定性的东西变得确定了</strong>，专业的术语叫<strong>不可观的状态变量变得可观了</strong>，说明我们人为的引入了错误的信息。回到marg过程，上面这个例子告诉我们，marg 时，被 marg 的那些变量的雅克比已经不更新了，而此时留在滑动窗口里的其他变量的雅克比要用和 marg 时一样的线性点，就是 $FEJ,(first\ estimate\ jocabian)$ 算法，不要用新的线性点了。</p><hr><p><strong>FEJ 算法：</strong>$FEJ,(first\ estimate\ jocabian)$ ,不同残差对同一个状态求雅克比时，线性化点必须一致。这样就能避免零空间退化而使得不可观变量变得可观。  比如: 引例中计算 $r_{27}$ 对 $ξ_2$ 的雅克比时， $ξ_2$ 的线性话点必须和 $r_{12}$对其求导时一致。  </p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="滑动窗口算法" scheme="https://lukeyalvin.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VSLAM中的非线性优化</title>
    <link href="https://lukeyalvin.top/posts/48933.html"/>
    <id>https://lukeyalvin.top/posts/48933.html</id>
    <published>2022-05-13T06:57:20.000Z</published>
    <updated>2022-05-17T05:59:46.738Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经典 SLAM 模型。它由一个状态方程和一个运动方程构成：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},u_{k})+w_{k}\\z_{k,j}&=h(y_j,x_k)+v_{k,j}\end{align*}\tag{1}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$</p><p>对应视觉$SLAM$，这里的 $x_k $乃是相机的位姿，$u_k$ 是运动传感器的读数（有时也叫输入），$y_j$代表的是相机在$x_k $处观察到的路标，并且观察到$y_j$后，产生了一个观测数据 $z_{k,j}$。整个方程里面，求解相机的位姿$x_k $就是一个定位的问题，而求解路标$y_j$就是一个建图的过程，但是由于噪声$w_{k}，v_{k,j}$的影响，我们得到的传感器数据$u_k$ 和$z_{k,j}$肯定不是完全准确的，因此需要使用这两组不太准确的数据，寻找一个相对最优的相机位姿$x_k $以及路标$y_j$。这个过程就是SLAM中的非线性优化问题。</p><h2 id="需要优化什么？"><a href="#需要优化什么？" class="headerlink" title="需要优化什么？"></a>需要优化什么？</h2><p>我们把所有带估计的数据放在一个集合：</p><script type="math/tex; mode=display">x=\left\{x_1,....,x_N,y_1,...y_M\}\right.\tag{2}</script><p>那么，我们的问题就变成求已知输入数据 $u$ 和观测数据 $z$ 的条件下，计算状态 $x$ 的条件概率分布：</p><script type="math/tex; mode=display">P(x|z,u)\tag{3}</script><hr><p>但是多数情况下，我们只有相机观察到的一帧帧的图片$z_{k,j}$，即只考虑观测方程带来的数据时，没有运动传感器$u_k$ ，这个概率分布就变成$P(x|z)$，利用贝叶斯法则：</p><script type="math/tex; mode=display">P(x|z)=\frac{P(z|x)P(x)}{P(z)}∝P (z|x) P (x) .\tag{4}</script><p>$\frac{P(z|x)P(x)}{P(z)}$称为<strong>后验估计</strong>，$P (z|x)$ 称为<strong>似然</strong>，另一部分$ P (x)$ 称为<strong>先验</strong>。</p><p>直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下，后验概率最大化（Maximize a Posterior，MAP），则是可行的：</p><script type="math/tex; mode=display">x^∗_{MAP} = \arg \max P (x|z) = \arg \max P (z|x)P (x).\tag{5}</script><p>但是当我们不知道机器人位姿大概在什么地方，此时就没有了先验,那么，可以求解$x $的最大似然估计（Maximize Likelihood Estimation, MLE）：</p><script type="math/tex; mode=display">x^∗_{MLE} = \arg \max P (z|x)\tag{6}</script><p>最大似然估计的含义就是：相机在什么样的状态下（这里指集合$x$即为相机位姿$x_{k}$以及路标$y_{j}$），最可能产生当前观测到的数据$z_{k,j}$。</p><p><strong>所以我们需要优化的内容就是：求解最优的$x_k , y_j$，使得观测方程带来的最小误差，此时就是求$x$（或者是说$x_k , y_j$）的最大似然然估计。</strong></p><h2 id="最小二乘问题"><a href="#最小二乘问题" class="headerlink" title="最小二乘问题"></a>最小二乘问题</h2><p>只考虑观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{7}</script><p>由于我们假设了噪声项 $v_k ∼ N (0, Q)$，所以观测数据的条件概率为：</p><script type="math/tex; mode=display">P (z_{j,k} |x_k , y_j ) = N (h(y_j , x_k ), Q) .\tag{8}</script><p>我们的目标就是最大化$x_k , y_j$，使得该状态下最可能产生当前观测到的数据$z_{k,j}$。</p><p>考虑一个任意的高维高斯分布 $x ∼ N (\mu, \Sigma)$，它的概率密度函数展开形式为:</p><script type="math/tex; mode=display">\begin{align*}p(x)=\frac{1}{\sqrt{(2\pi)^N det(\Sigma)} }exp(−(x−\mu)\Sigma^{-1} (x−\mu))\end{align*}\tag{9}</script><p>取负对数:</p><script type="math/tex; mode=display">\begin{align*}-ln(p(x))=\frac{1}{2}ln((2\pi)^N det(Σ))+\frac{1}{2}(x−\mu)^TΣ^{-1} (x−\mu)\end{align*}\tag{10}</script><p>对原分布求最大化相当于对负对数求最小化。在最小化上式的 $x$ 时，第一项与 $x $无关，可以略去于是，只要最小化右侧的二次型项，也称为<strong>马氏距离</strong>。带入 SLAM 观测模型：</p><script type="math/tex; mode=display">x^*=\arg\min\left((z_{k,j}-h(x_k,y_j))^TQ^{-1}_{k,j}(z_{k,j}-h(x_k,y_j))\right)\tag{11}</script><p>定义：</p><script type="math/tex; mode=display">\begin{align*}e_{v,k}&=x_k-f(x_{k-1},u_k)\\e_{u,j,k}&=z_{k,j}-h(x_k,y_j)\end{align*}\tag{12}</script><p>考虑运动与观测方程结合来看，我们求解的就是总的<strong>误差的平方和</strong>：</p><script type="math/tex; mode=display">J(x)=\sum_ke^T_{v,k}R^{-1}e_{v,k}+\sum_k\sum_je^T_{y,k,j}Q^{-1}e_{y,k,j}\tag{13}</script><p>这就得到了一个总体意义下的<strong>最小二乘问题</strong>（Least Square Problem）。我们明白它的最优解等价于状态的最大似然估计。直观来讲，由于噪声的存在，当我们把估计的轨迹与地图代入 SLAM 的运动、观测方程中时，它们并不会完美的成立。这时候怎么办呢？我们把状态的估计值进行微调，使得整体的误差下降一些。当然这个下降也有限度，它一般会到达一个极小值。这就是一个典型非线性优化的过程。</p><h2 id="非线性函数线性化"><a href="#非线性函数线性化" class="headerlink" title="非线性函数线性化"></a>非线性函数线性化</h2><p>在非线性优化的过程中，由于高斯分布经过非线性映射后不会再符合高斯分布，因此，一般我们对非线性进行线性化，这里用到泰勒级数：</p><p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}\tag{14}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f^\prime(x_0)(x-x_0)\tag{15}</script><p>如果对于二维以上的，我们的一阶泰勒展开如下：</p><script type="math/tex; mode=display">\begin{align*}f(x，y)&=f(x_0)+\frac{\partial f}{\partial x}|_{x=x_0}(x-x_0)\\&=f(x_0)+J(x)(x-x_0)\end{align*}\tag{16}</script><p>这里的雅克比矩阵代表的就是$f(x)$对于$x$的偏导数。</p><h1 id="求解非线性最小二乘"><a href="#求解非线性最小二乘" class="headerlink" title="求解非线性最小二乘"></a>求解非线性最小二乘</h1><p>对于上文，我们知道通过把最大似然估计问题转化为最小化其负对数的问题，其实就是求解一个非线性函数的最小值的问题，我们暂且考虑一个问题，我们有一个非线性的函数$f(x)$，如何求解它的最小值？</p><p>这就是一个简单的最小二乘问题：</p><script type="math/tex; mode=display">\underset{x}{min}\frac{1}{2}\parallel f(x) \parallel^2\tag{17}</script><p>这里自变量 $x\in \mathbb R^n$ ，$f $是任意一个非线性函数，我们设它有 $m $维：$f (x) \in \mathbb R^m$ 。</p><p>一般求解就是类似于二元函数求极值，对$x$求导，使得$\frac{df}{dx}=0$，即可得到$f(x)$的极值，但是也不是绝对的，我们知道这个点可能是极大值、极小值也可能是鞍点，因此需要比较所有使得$\frac{df}{dx}=0$的自变量对应的函数值$f(x)$.</p><p>但是在SLAM中，$f(x)$将是一个复杂的非线性方程，所以一般我们使用迭代的方法，从一个初始值出发，不断地更新当前的优化变量，使目标函数下降，具体步骤如下：</p><ul><li>给定某个初始值$ x_0$</li><li>对于第$k$次迭代，寻找一个增量$\Delta x_k$，使得$\parallel f(x_k+\Delta x_k)\parallel^2_2$达到极小值。</li><li>若$\Delta x_k$足够小，则停止</li><li>否则，令$x_{k+1}=x_k+\Delta x_k$，返回第二步。</li></ul><p>这让求解导函数为零的问题，变成了一个不断寻找梯度并下降的过程。直到某个时刻增量非常小，无法再使函数下降。此时算法收敛，目标达到了一个极小，我们完成了寻找极小值的过程。在这个过程中，我们只要找到迭代点的梯度方向即可，而无需寻找全局导函数为零的情况。</p><hr><p><strong>如何寻找$\Delta x_k$?</strong></p><h2 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h2><p>我们之前介绍过非线性的线性化方法，我们可以将一个非线性函数在某个点附件进行泰勒展开。</p><p>比如：对于增量方程在$x$附近进行泰勒展开：</p><script type="math/tex; mode=display">\parallel f(x+\Delta x)\parallel^2_2\approx\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{18}</script><p>这里$J$是 $\parallel f(x)\parallel^2$ 关于$ x $的导数（雅可比矩阵），而$ H $则是二阶导数（海塞（Hessian）矩阵）。保留一阶二阶分别就对应了一阶梯度法和二阶梯度法。</p><h3 id="一阶梯度法"><a href="#一阶梯度法" class="headerlink" title="一阶梯度法"></a>一阶梯度法</h3><script type="math/tex; mode=display">\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x\tag{19}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">\Delta x^*=-J^T(x)\tag{20}</script><p>当然，我们还需要该方向上取一个步长$\lambda$，求得最快的下降方式。这种方法被称为<strong>最速下降法</strong>。但是它本身也有缺点：最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。</p><h3 id="二阶梯度-牛顿法"><a href="#二阶梯度-牛顿法" class="headerlink" title="二阶梯度(牛顿法)"></a>二阶梯度(牛顿法)</h3><script type="math/tex; mode=display">\Delta x^*=\arg\min\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x\tag{21}</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">H\Delta x=-J^T.\tag{22}</script><p>但是牛顿法需要计算目标函数的 $H $矩阵，这在问题规模较大时非常困难，我们通常倾向于避免$ H $的计算。</p><h2 id="Gauss-Newton"><a href="#Gauss-Newton" class="headerlink" title="Gauss-Newton"></a>Gauss-Newton</h2><p>Gauss Newton 是最优化算法里面最简单的方法之一。它的思想是$f(x)$而不是$f(x)^2$在$x$处进行一阶泰勒展开：</p><script type="math/tex; mode=display">f(x+\Delta x)\approx f(x)+J(x)\Delta x\tag{23}</script><p>这里$ J (x)$ 为$ f (x) $关于$ x$ 的导数，实际上是一个$ m × n$ 的矩阵，也是一个雅可比矩阵。</p><p>当前的目标是为了寻找下降矢量 $\Delta x$，使得$ f(x+\Delta x)$达到最小。为了求 $\Delta x$，我们需要解一个线性的最小二乘问题：</p><script type="math/tex; mode=display">\Delta x^*=\arg\min\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2\tag{24}</script><p>对上式平方项进行展开：</p><script type="math/tex; mode=display">\begin{align*}\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2&=\frac{1}{2}\left(f(x)+J(x)\Delta x)^T(f(x)+J(x)\Delta x\right)\\&=\frac{1}{2}\left(\parallel f(x)\parallel^2_2+2f(x)^TJ(x)\Delta x+\Delta x^TJ(x)^TJ(x)\Delta x\right)\\\end{align*}\tag{25}</script><p>求上式关于 $\Delta x$ 的导数，并令其为零：</p><script type="math/tex; mode=display">2J(x)^Tf(x)+2J(x)^TJ(x)\Delta x=0\tag{26}</script><p>化简：</p><script type="math/tex; mode=display">J(x)^TJ(x)\Delta x=-J(x)^Tf(x)\tag{27}</script><p>要求解的变量是  $\Delta x$，因此这是一个线性方程组，我们称它为增量方程，也可以称为<strong>高斯牛顿方程 (Gauss Newton equations)</strong> 或者<strong>正规方程 (Normal equations)</strong>。我们把左边的系数定义为 $H$，右边定义为 $g$，那么上式变为：</p><script type="math/tex; mode=display">H \Delta x=g\tag{28}</script><p>对比牛顿法可见，Gauss-Newton 用$J(x)^TJ(x)$作为牛顿法中二阶 Hessian 矩阵的近似，从而省略了计算 $H $的过程。求解增量方程是整个优化问题的核心所在。</p><p>Gauss Newton 求解步骤：</p><ul><li>给定初始值$x_0$</li><li>对于第$k$次迭代，求出当前的雅可比矩阵$J(x_k)和误差$$f(x_k)$</li><li>求解增量方程：$H \Delta x=g$</li><li>若$\Delta x_k$足够小，则停止。否则，令$x_{k+1}=x_k+\Delta x_k$，返回步骤2.</li></ul><p>整个步骤中，增量方程的求解占据着主要地位。原则上，它要求我们所用的近似 $H$ 矩阵是可逆的（而且是正定的），但实际数据中计算得到的 $J(x)^TJ(x)$却只有半正定性。也就是说，在使用 Gauss Newton 方法时，可能出现$J(x)^TJ(x)$为<strong>奇异矩阵</strong>或者<strong>病态 (ill-condition)</strong> 的情况，此时增量的稳定性较差，导致算法不收敛。</p><p>更严重的是，就算我们假设$ H $非奇异也非病态，如果我们求出来的步长$ ∆x $太大，也会导致我们采用的局部近似不够准确，这样一来我们甚至都无法保证它的迭代收敛，哪怕是让目标函数变得更大都是有可能的。</p><h2 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h2><p>由于 Gauss-Newton 方法中采用的近似二阶泰勒展开<strong>只能在展开点附近有较好的近似效果</strong>，所以我们很自然地想到应该给 $\Delta x$ 添加一个信赖区域（$Trust\ Region$），不能让它太大而使得近似不准确。非线性优化种有一系列这类方法，这类方法也被称之为信赖区域方法 $ (Trust\ Region\ Method)$。<strong>在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</strong> </p><p>那么如何确定这个信赖区域的范围呢？一个比较好的方法是<strong>根据我们的近似模型跟实际函数之间的差异来确定这个范围</strong>：如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。因此，考虑使用 $(29)$ 来判断泰勒近似是否够好。</p><script type="math/tex; mode=display">\rho=\frac{f(x+\Delta x)-f(x)}{J(x)\Delta x }\tag{29}</script><p>$\rho$ 的分子是<strong>实际函数下降</strong>的值，分母是<strong>近似模型下降</strong>的值。如果 $\rho$ 接近于 1，则近似是好的。如果 $\rho$  太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。反之，如果 $\rho$  比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513154553510.png" alt="image-20220513154553510" style="zoom: 67%;" /></p><p>我们用 Lagrange 乘子将$(6.24)$ 转化为一个无约束优化问题：</p><script type="math/tex; mode=display">\underset{\Delta x_K}{\min}\frac{1}{2}\parallel f(x_k)+J(x_k)\Delta x_k\parallel^2=\frac{\lambda}{2}\parallel D\Delta x \parallel^2\tag{30}</script><p>类似于 Gauss-Newton 中的做法，把它展开后，我们发现该方法最终也是计算增量的线性方程：</p><script type="math/tex; mode=display">(H+\lambda D^TD)\Delta x=g\tag{31}</script><p>可以看到，增量方程相比于 Gauss-Newton，多了一项 $\lambda D^T D$。如果考虑它的简化形 式，即 $D = I$，那么相当于求解：</p><script type="math/tex; mode=display">(H+\lambda I)\Delta x=g\tag{32}</script><p>我们看到，当参数 $λ$ 比较小时，$H $占主要地位，这说明二次近似模型在该范围内是比 较好的，L-M 方法更接近于 G-N 法。另一方面，当 $λ$ 比较大时，$λI $占据主要地位，L-M 更接近于一阶梯度下降法（即最速下降），这说明附近的二次近似不够好。L-M 的求解方 式，可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题，提供更稳定更准确 的增量 $∆x$。</p><h1 id="BA求解"><a href="#BA求解" class="headerlink" title="BA求解"></a>BA求解</h1><p>通过前文。我们知道SLAM 中的优化问题什么，而且我们知道优化的数学工具最小二乘法，那么如何进行优化，就是我们下面讨论的主要问题。</p><h2 id="投影模型"><a href="#投影模型" class="headerlink" title="投影模型"></a>投影模型</h2><p>从一个世界坐标系中的点 $p$ 出发，把相机的内外参数和畸变都考虑进来，最后投影成像素坐标，一共需要如下几个步骤：</p><ol><li>首先，把世界坐标转换到相机坐标，这里将用到相机外参数$ (R, t)$：</li></ol><script type="math/tex; mode=display">P^\prime=Rp+t=[X^\prime,Y^\prime,Z^\prime]^T\tag{33}</script><ol><li>然后，将 $P^\prime$ 投至归一化平面，得到归一化坐标：</li></ol><script type="math/tex; mode=display">P_c=[u_c,v_c,1]^T=[\frac{X^\prime}{Z^\prime},\frac{Y^\prime}{Z^\prime},1]^T\tag{34}</script><ol><li>对归一化坐标去畸变，得到去畸变后的坐标。这里暂时只考虑径向畸变：</li></ol><script type="math/tex; mode=display">\begin{align*}u_c^\prime=u_c(1+k_1r_c^2+k_2r_c^4)\\v_c^\prime=v_c(1+k_1r_c^2+k_2r_c^4)\\\end{align*}\tag{35}</script><ol><li>最后，根据内参模型，计算像素坐标：</li></ol><script type="math/tex; mode=display">\begin{align*}u_s=f_xu_c^\prime+c_x\\v_s=f_yv_c^\prime+c_y\end{align*}\tag{36}</script><p>对于观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}\tag{37}</script><p>这里的 $x$ 指代此时相机的位姿，即外参 $R, t$，它对应的李代数为 $ξ$。路标 $y$ 即这里的三维点 $p$，而观测数据则是像素坐标$z = [u_s , v_s ]^T $。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220405145736323.png" alt="image-20220405145736323"></p><p>以最小二乘的角度来考虑，那么可以列写关于此次观测的误差：</p><script type="math/tex; mode=display">e=z-h(\xi,p)\tag{38}</script><p>设 $z_{ij}$为在位姿 $\xi_i $处观察路标 $p_j $产生的数据，那么整体的损失函数（Cost Function）为：</p><script type="math/tex; mode=display">\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}\parallel^2=\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel z_{ij}-h(ξ_i,p_j) \parallel^2\tag{39}</script><p>对这个最小二乘进行求解，相当于对位姿和路标同时作了调整，也就是所谓的$BA$。</p><h2 id="BA求解-1"><a href="#BA求解-1" class="headerlink" title="BA求解"></a>BA求解</h2><p>在整体 $BA$目标函数上，我们必须把自变量定义成所有待优化的变量：</p><script type="math/tex; mode=display">x=[\xi_1,...,\xi_m,p_1,...,p_n]^T\tag{40}</script><p>相应的，增量方程中的$ ∆x $则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}+F_{ij}\Delta\xi_i+E_{ij}\Delta p_i \parallel^2\tag{41}</script><p>其中$ F_{ij} $表示整个代价函数在当前状态下对<strong>相机姿态</strong>的偏导数，而 $E_{ij}$ 表示该函数对<strong>路标点位置</strong>的偏导。</p><p><strong>观测相机方程关于相机位姿的导数矩阵：</strong></p><script type="math/tex; mode=display">\begin{align*}F&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\\end{align*}\tag{42}</script><p><strong>观测相机方程关于特征点的导数矩阵</strong></p><script type="math/tex; mode=display">E=\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}R\tag{43}</script><p>关于$E,F$雅可比矩阵的具体求导过程，可以查阅：<a href="https://lukeyalvin.top/posts/20908.html">ch7_求解PnP并使用BA优化</a></p><p>现在，把相机位姿变量放在一起：</p><script type="math/tex; mode=display">x_c=[\xi_1,\xi_2,...,\xi_m]\in\mathbb{R}^{6m}\tag{44}</script><p>并把空间点的变量也放在一起：</p><script type="math/tex; mode=display">x_p=[p_1,p_2,...,p_n]^T\in \mathbb{R}^{3n}\tag{45}</script><p>目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e+F\Delta x_c+E_\Delta x_p \parallel^2\tag{46}</script><p>需要注意的是，该式从一个由<strong>很多个小型二次项之和</strong>，变成了一个更整体的样子。这里的雅可比矩阵 $E $和$ F$ 必须是整体目标函数对整体变量的导数，它将是一个很大块的矩阵，而里头每个小分块，需要由每个误差项的导数 $F_{ij} $和 $E_{ij}$ “拼凑”起来。然后，无论我们使用 $G-N$ 还是$ L-M $方法，最后都将面对增量线性方程：</p><script type="math/tex; mode=display">H\Delta x = g\tag{47}</script><p>如果是高斯牛顿，$H$ 取$J^TJ$；列文伯格是 $J^T J + λI $的形式</p><p>由于我们把变量归类成了位姿和空间点两种，所以雅可比矩阵可以分块为：</p><script type="math/tex; mode=display">J=\begin{bmatrix}F & E\end{bmatrix}\tag{48}</script><p>其中$F$是$2 × 6$的矩阵，$E$是$2 × 3$的矩阵.</p><p>以 G-N 为例，则 H 矩阵为：</p><script type="math/tex; mode=display">H=J^TJ=\begin{bmatrix}F^TF & F^TE\\E^TF & E^TE\end{bmatrix}\tag{49}</script><p>在SLAM中我们会考虑H矩阵的稀疏性，进而加速BA的求解。</p><h2 id="稀疏性和边缘化"><a href="#稀疏性和边缘化" class="headerlink" title="稀疏性和边缘化"></a>稀疏性和边缘化</h2><p>在视觉 SLAM 中，一个图像就会提出数百个特征点，大大增加了这个线性方程的规模。如果直接对 H 求逆来计算增量方程，由于矩阵求逆是复杂度为 $O(n^3 )$ 的操作，这是非常消耗计算资源的。幸运地是，这里的 H 矩阵是有一定的特殊结构的。利用这个特殊结构，我们可以加速求解过程。</p><p>21 世纪视觉 SLAM 的一个重要进展是认识到了矩阵 H 的稀疏结构，并发现该结构可以自然、显式地用图优化来表示 。</p><p>举例：假设一个场景内有 $2$ 个相机位姿 $(C_1 , C_2 )$ 和 $6$ 个路标 $(P_1 , P_2 , P_3 , P_4 , P_5 , P_6 )$。这些相机和点云所对应的变量为 $ξ_i , i = 1, 2$ 以及 $p_j , j = 1, . . . , 6$。相机 $C_1$ 观测到路标 $P_1 , P_2 , P_3 , P_4$ ，相机 $C_2$ 观测到了路标 $P_3 , P_4 , P_5 , P_6$ 。</p><p>如图所示：相机和路标以圆形节点表示。如果 $i$ 相机能够观测到 $j$ 点云，我们就在它们对应的节点连上一条边。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513160409346.png" alt="image-20220513160409346" style="zoom: 33%;" /></p><p>可以推出该场景下的 BA 目标函数应该是：</p><script type="math/tex; mode=display">\frac{1}{2}\left(\parallel e_{11} \parallel^2+\parallel e_{12} \parallel^2+\parallel e_{13} \parallel^2+\parallel e_{14} \parallel^2+\parallel e_{23} \parallel^2+\parallel e_{24} \parallel^2+\parallel e_{25} \parallel^2+\parallel e_{26} \parallel^2\right)\tag{50}</script><p>这里的 $e_{ij}$ 使用之前定义过的代价函数，即式 $(39)$。以 $e_{11}$ 为例，它描述了在 $C_1$ 看到了 $P_1$ 这件事，与其他的相机位姿和路标无关。令 $J_{11}$  为  $e_{11}$  所对应的雅可比矩阵，不难看出  $e_{11}$  对相机变量 $\xi_2$ 和路标点 $p_2 , . . . , p_6$ 的偏导都为 0。我们把所有变量以 $x = (ξ_1 , ξ_2 , p_1 , . . . , p_6 )^T$ 的顺序摆放，则有：</p><script type="math/tex; mode=display">J_{11}=\frac{\partial e_{11} }{\partial x}=\left(\frac{\partial e_{11} }{\partial \xi_1},0,\frac{\partial e_{11} }{\partial p_1},0,0,0,0,0\right)\tag{51}</script><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161314472.png" alt="image-20220513161314472" style="zoom:50%;" /></p><p>类似地，可以推导出如下图案：</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161435601.png" alt="image-20220513161435601" style="zoom: 50%;" /></p><p>现在考虑更一般的情况，假如我们有 $m$ 个相机位姿，$n $ 个路标点。由于通常路标数量 远远会比相机多，于是有 $n ≫ m$。由上面推理可知，实际当中的 H 矩阵会像下图所示的那样。它的左上角块显得非常小，而右下角的对角块占据了大量地方。除此之外，非 对角部分则分布着散乱的观测数据。由于它的形状很像箭头，又称为<strong>箭头形（Arrow-like） 矩阵</strong>。同时它又很像一把镐子，所以也叫<strong>镐形矩阵</strong>。</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513161821872.png" alt="image-20220513161821872" style="zoom: 33%;" /></p><p>于是，对应的线性方程组也可以由 $H∆x = g $ 变为如下形式：</p><script type="math/tex; mode=display">\begin{bmatrix}B&E\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}v\\w\end{bmatrix}\tag{52}</script><p>其中 $B$ 是对角块矩阵，每个对角块的维度和相机参数的维度相同，对角块的个数是相机变量的个数。由于路标数量会远远大于相机变量个数，所以 $C$ 往往也远大于 $B$。三 维空间中每个路标点为三维，于是 $C$ 矩阵为对角块矩阵，每个块为 $3 \times 3$ 维矩阵。</p><p>考虑到对角块矩阵求逆的难度远小于对一般矩阵的求逆难度，我们对线性方程组进行高斯消元，目标是消去右上角的非对角部分 $E$，得：</p><script type="math/tex; mode=display">\begin{bmatrix}I&-EC^{-1}\\0&I\end{bmatrix}\begin{bmatrix}B&E\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}I&-EC^{-1}\\0&I\end{bmatrix}\begin{bmatrix}v\\w\end{bmatrix}\tag{53}</script><p>整理得：</p><script type="math/tex; mode=display">\begin{bmatrix}B-EC^{-1}E^T&0\\E^T&C\end{bmatrix}\begin{bmatrix}\Delta x_c\\\Delta x_p\end{bmatrix}=\begin{bmatrix}v-EC^{-1}w\\w\end{bmatrix}\tag{54}</script><p>经过消元之后，第一行方程组变成和 $∆x_p$ 无关的项。单独把它拿出来，得到关于位姿部分的增量方程：</p><script type="math/tex; mode=display">[B-EC^{-1}E^T]\Delta x_c=v-EC^{-1}w\tag{55}</script><p>这个线性方程组的维度和 $B$ 矩阵一样。我们的做法是先求解这个方程，然后把解得 的 $∆x_c$ 代入到原方程，然后求解 $∆x_p$ 。</p><script type="math/tex; mode=display">\Delta x_p=C^{-1}(w-E^T\Delta x_c)\tag{56}</script><p>这个过程称为 <strong>Marginalization</strong>，或者 <strong>Schur 消元 (Schur Elimination)</strong>。</p><p>我们记 式 $(55)$ 中的 $\Delta x_c$的系数为 $S=B-EC^{-1}E^T$ ，我们看一下它的稀疏性：</p><p><img src="/images/SLAM中的非线性优化数学推导/image-20220513165129947.png" alt="image-20220513165129947" style="zoom: 33%;" /></p><p>$S$ 矩阵的非对角线上的非零矩阵块，表示了该处对应的两个相机变量之间存在着共同观测的路标点，有时候称为<strong>共视（Co-visibility）</strong>。反之，如果该块为零，则表示这两个相机没有共同观测。如上图所示的稀疏矩阵，左上角前 $4 \times 4$ 个矩阵块可以表示对应的相 机变量 $C_1 , C_2 , C_3 , C_4$ 之间有共同观测。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="最小二乘法" scheme="https://lukeyalvin.top/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"/>
    
    <category term="后端优化" scheme="https://lukeyalvin.top/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    <category term="BA与图优化" scheme="https://lukeyalvin.top/tags/BA%E4%B8%8E%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SLAM中的概率基础</title>
    <link href="https://lukeyalvin.top/posts/2613d057.html"/>
    <id>https://lukeyalvin.top/posts/2613d057.html</id>
    <published>2022-05-11T12:38:35.000Z</published>
    <updated>2022-05-13T13:10:28.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="概率与概率密度"><a href="#概率与概率密度" class="headerlink" title="概率与概率密度"></a>概率与概率密度</h2><p><img src="/images/SLAM中的概率基础/image-20220511204935450.png" alt="image-20220511204935450" style="zoom:50%;" /></p><p>图中，函数 $p(x)$ 表示 $x$ 在区间 $[a,b]$ 上的<strong>概率密度</strong>，它表示的是随机变量在区间的分布情况。</p><p>$Pr$ 代表的是 $x$ 在区间 $[c,d]$ 上的<strong>概率</strong>，它是概率密度函数的积分：</p><script type="math/tex; mode=display">Pr(c\leq x \leq d)=\int^d_c p(x)dx\tag{1}</script><p>我们平时所说“高斯分布”、“非高斯分布”均是指它的概率密度。</p><h2 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h2><p><strong>联合概率</strong>表示两个事件共同发生的概率。事件 $A$ 和事件 $B$ 的联合概率表示为 $P(A\cap B),P(A,B),P(AB)$ </p><p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ 的联合概率密度函数可以表示为 $p(x,y)$，其积分表示 $x,y$ 同处在某个区间的概率，满足下式：</p><script type="math/tex; mode=display">\int^b_a\int^s_rp(x,y)dydx=1\tag{2}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p><script type="math/tex; mode=display">p(x,y)=p(x)p(y)\tag{3}</script><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>就是事件 $A$ 在事件 $B$ 发生的条件下发生的概率。即为 $P(B|A)$.</p><p>比如 $x\in[a,b]$ 和 $y\in[r,s]$ ，当在 $y$ 已知的前提下，$x$ 的概率分布满足下式：</p><script type="math/tex; mode=display">p(x)=\int^s_r p(x|y)p(y)dy\tag{4}</script><p>特别地，当 $x$ 和 $y$ 相互独立的时候：</p><script type="math/tex; mode=display">p(x|y)=p(x)\tag{5}</script><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>联合概率分解成条件概率和边缘概率的乘积，即</p><script type="math/tex; mode=display">p(x,y)=p(x|y)p(y)=p(y|x)p(x)\tag{6}</script><p>重新整理，即可得贝叶斯公式</p><script type="math/tex; mode=display">p(x|y)=\frac{p(y|x)p(x)}{p(y)}\tag{7}</script><h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><p>贝叶斯推断可以理解为贝叶斯公式的运用，它是指，如果已知<strong>先验</strong>概率密度函数 $p(x)$，以及<strong>传感器模型</strong> $p(y|x)$，那么就可以根据贝叶斯公式推断出<strong>后验</strong>概率密度。</p><script type="math/tex; mode=display">p(x|y)=\frac{p(y|x)p(x)}{\int p(y|x)p(x)dx}\tag{8}</script><p>实际中，贝叶斯推断有时也叫贝叶斯估计。</p><h2 id="高斯概率密度函数"><a href="#高斯概率密度函数" class="headerlink" title="高斯概率密度函数"></a>高斯概率密度函数</h2><p><strong>一维情况下，</strong>高斯概率密度函数表示：</p><script type="math/tex; mode=display">p(x|\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2} }\exp(-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2})\tag{9}</script><p>其中 $\mu$ 为均值， $\sigma$ 为方差。</p><p><strong>多维情况下，</strong>高斯概率密度函数表示为：</p><script type="math/tex; mode=display">p(x|\mu,\Sigma)=\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)\tag{10}</script><p>其中 $\mu$ 为均值， $\Sigma$ 为方差。</p><p>一般把高斯分布写成 $x\sim\mathcal{N}(\mu,\Sigma)$。</p><h2 id="联合高斯概率密度函数"><a href="#联合高斯概率密度函数" class="headerlink" title="联合高斯概率密度函数"></a>联合高斯概率密度函数</h2><p>若有高斯分布：</p><script type="math/tex; mode=display">\begin{align*}p(x)&=\mathcal{N}(\mu_x,\Sigma_{xx})\\p(x)&=\mathcal{N}(\mu_y,\Sigma_{yy})\end{align*}\tag{11}</script><p>则它们的联合概率密度函数可以表示为:</p><script type="math/tex; mode=display">p(x,y)=\mathcal{N}\left(\begin{bmatrix}\mu_x\\\mu_y\end{bmatrix},\begin{bmatrix}\Sigma_{xx}&\Sigma_{xy}\\\Sigma_{yx}&\Sigma_{yy}\end{bmatrix}\right)\tag{12}</script><p>由于联合概率满足下式:</p><script type="math/tex; mode=display">p(x,y)=p(x|y)p(y)\tag{13}</script><p>该式在高斯分布的前提下可以重新分解。</p><h1 id="高斯分布和协方差矩阵"><a href="#高斯分布和协方差矩阵" class="headerlink" title="高斯分布和协方差矩阵"></a>高斯分布和协方差矩阵</h1><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>由公式 $(10)$可知，零均值的多元高斯分布有如下概率形式：</p><script type="math/tex; mode=display">\begin{align*}p(x)=&\frac{1}{\sqrt{(2\pi)^N\det\Sigma} }\exp\left(-\frac{1}{2}x^T\Sigma^{-1}x\right)\\=&\frac{1}{Z }\exp\left(-\frac{1}{2}x^T\Sigma^{-1}x\right)\end{align*}\tag{14}</script><p>其中 $\Sigma$ 是<strong>协方差矩阵</strong>，协方差矩阵的逆记作 $Λ = \Sigma^{-1}$ ，也称之为<strong>信息矩阵</strong>。</p><p>比如变量 $x$ 为三维的变量时，协方差矩阵为:</p><script type="math/tex; mode=display">\Sigma=\begin{bmatrix}\Sigma_{11}&\Sigma_{12}&\Sigma_{13}\\\Sigma_{21}&\Sigma_{22}&\Sigma_{23}\\\Sigma_{31}&\Sigma_{32}&\Sigma_{33}\end{bmatrix}\tag{15}</script><p>根据协方差的定义，其中 $Σ_{ij} = E(x_ix_j ) $为对应元素求期望。</p><p>关于协方差矩阵的一些案例介绍，可以查看，<a href="https://lukeyalvin.top/posts/8369.html#%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">协方差矩阵</a></p><h2 id="协方差矩阵与信息矩阵"><a href="#协方差矩阵与信息矩阵" class="headerlink" title="协方差矩阵与信息矩阵"></a>协方差矩阵与信息矩阵</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>设 $x_2$ 为室外的温度，$x_1 , x_3$ 分别为房间 $1$ 和房间 $3$ 的室内温度:</p><script type="math/tex; mode=display">\begin{align*}x_2&=v_2\\x_1&=w_1x_2+v_1\\x_3&=w_3x_2+v_3\\\end{align*}\tag{16}</script><p>其中，$w_i$ 为正的常数值，$v_i$ 相互独立，且各自服从协方差矩阵为 $\sigma_i^2$ 的高斯分布。</p><p><img src="/images/SLAM中的概率基础/image-20220512153417672.png" alt="image-20220512153417672" style="zoom:25%;" /></p><p>从上述关系，根据协方差公式的计算方式，我们可以写出 $x$ 的协方差矩阵，先从对角元素开始计算：</p><script type="math/tex; mode=display">\begin{align*}\Sigma_{11}=E(x_1x_1)&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1})({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1}))\\&={\color{red}w_1^2}E({\color{green}v_2^2})+2{\color{red}w_1}E({\color{red}v_1}{\color{green}v_2})+E({\color{red}v_1^2})\\&={\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}\end{align*}\tag{17}</script><p>同理有 $\Sigma_{22}={\color{green}\sigma_2^2},\Sigma_{33}={\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}$ ，对于协方差矩阵的非对角元素：</p><script type="math/tex; mode=display">\begin{align*}\Sigma_{12}&=E(x_1x_2)=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} ){\color{green}v_2})={\color{red}w_1}{\color{green}\sigma_2^2}\\\Sigma_{13}&=E(({\color{red}w_1}{\color{green}v_2}+{\color{red}v_1} )({\color{blue}w_3}{\color{green}v_2}+{\color{blue}v_3} ))={\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\end{align*}\tag{18}</script><p>以此类推，可以得到整个<strong>协方差矩阵</strong>：</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3}{\color{green}\sigma_2^2}&{\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2}\end{bmatrix}\end{align*}\tag{19}</script><p>通过计算<strong>联合高斯分布</strong>从而得到协方差矩阵的逆：</p><script type="math/tex; mode=display">\begin{align*}p(x_1,x_2,x_3)&=p(x_2)p(x_1|x_2)p(x_3|x_2)\\&={\color{green}\frac{1}{Z_2}\exp(-\frac{x^2_2}{2\sigma_2^2})}{\color{red}\frac{1}{Z_1}\exp(-\frac{(x_1-w_1x_2)^2}{2\sigma_1^2})}{\color{blue}\frac{1}{Z_3}\exp(-\frac{(x_3-w_3x_2)^2}{2\sigma_3^2})}\\&=\frac{1}{Z}\exp(-x_2^2[{\color{green}\frac{1}{2\sigma_2^2} }+{\color{red}\frac{w_1^2}{2\sigma_1^2} }-{\color{blue}\frac{w_3^2}{2\sigma_3^2} }]-x_1^2{\color{red}\frac{1}{2\sigma_1^2} }+2x_1x_2{\color{red}\frac{w_1}{2\sigma_1^2} }-x_3^2{\color{blue}\frac{1}{2\sigma_3^2} }+2x_3x_2{\color{blue}\frac{w_3}{2\sigma_3^2} })\\&=\frac{1}{Z}\exp(-\frac{1}{2}\begin{bmatrix}x_1&x_2&x_3\end{bmatrix}\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&{\color{blue}-\frac{w_3}{\sigma_3^2} }\\0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix})\end{align*}\tag{20}</script><p>由此得到协方差矩阵的逆，即<strong>信息矩阵</strong>：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&0\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }+{\color{blue}\frac{w_3^2}{\sigma_3^2} }&{\color{blue}-\frac{w_3}{\sigma_3^2} }\\0&{\color{blue}-\frac{w_3}{\sigma_3^2} }&{\color{blue}-\frac{1}{\sigma_3^2} }\end{bmatrix}\tag{21}</script><p><strong>总结：</strong></p><p><font color="#660066">协方差矩阵中，非对角元素 $\Sigma_{ij}&gt;0，i\ne j$ 表示两个变量之间是<strong>正相关</strong>；非对角元素 $\Sigma_{ij}=0，i\ne j$ 表示两个变量之间是<strong>相互独立</strong>；</font><br /></p><p><font color="#660066">信息矩阵中，非对角元素 $Λ_{ij}&lt;0，i\ne j$ 甚至于  $Λ_{ij}=0，i\ne j$ ，比如 $Λ_{12} &lt; 0$   表示在变量 $x_3$ 发生的条件下，元素 $x_1$ 和 $x_2$ <strong>正相关</strong>。  </font><br /></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>类似与案例一，定义 $x_1,x_2,x_3$ 关系如下：</p><script type="math/tex; mode=display">x_2=w_1x_1+w_3x_3+v_2\tag{22}</script><p>比如特征三角化，两个相机 pose 得到特征三维坐标。</p><p><img src="/images/SLAM中的概率基础/image-20220512164657043.png" alt="image-20220512164657043" style="zoom:25%;" /></p><p>同理，根据协方差矩阵的定义，可以得到协方差矩阵：</p><script type="math/tex; mode=display">\Sigma=\begin{bmatrix}{\color{red}\sigma_1^2}&{\color{red}w_1} {\color{red}\sigma_1^2}&0\\{\color{red}w_1} {\color{red}\sigma_1^2}&{\color{green}\sigma_2^2}+{\color{red}w_1} {\color{red}\sigma_1^2}+{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}w_3}  {\color{blue}\sigma_3^2}\\0&{\color{blue}w_3}  {\color{blue}\sigma_3^2}&{\color{blue}\sigma_3^2}\end{bmatrix}\tag{23}</script><p><strong>协方差矩阵中非对角元素为 0 表示变量之 间没有相关性。</strong>这是否意味着信息矩阵中也会为 0 呢？</p><p>同样的方法求得协方差矩阵的逆，即<strong>信息矩阵</strong>：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }+{\color{green}\frac{w_1^2}{\sigma_2^2} }&{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{w_1w_3}{\sigma_2^2} }\\{\color{green}-\frac{w_1}{\sigma_2^2} }&{\color{green}\frac{1}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }\\{\color{green}\frac{w_1w_3}{\sigma_2^2} }&{\color{green}-\frac{w_3}{\sigma_2^2} }&{\color{BLUE}\frac{1}{\sigma_3^2} }+{\color{green}\frac{w_3^2}{\sigma_2^2} }\end{bmatrix}\tag{24}</script><p><strong>总结：</strong></p><p><span style="color:red;">虽然 $x_1$ 和 $x_3$ <strong>不相关</strong>，但是不说明他们的信息矩阵对应元素 $Λ_{13}$<br>为 0；恰恰信息矩阵中 $Λ_{13} &gt; 0$, 表示的是在变量 $x_2$ 发生的条件下，变 量$x_1$ 和 $x_3$ 成<strong>负相关</strong>。对应上面的例子即  $x_2$ 为常数，<strong>如果 $x_1$  大，则 $x_3$ 小</strong>。</span></p><p><strong>样例的意义: 非常有助于我们了解 SLAM 的信息矩阵 H 的组成。</strong></p><h3 id="去除案例1中变量"><a href="#去除案例1中变量" class="headerlink" title="去除案例1中变量"></a>去除案例1中变量</h3><p>如果我们移除变量，信息矩阵或协方差矩阵如何变化呢?</p><p>比如对于案例一来说，去除变量$x_3$，那么它的信息矩阵或协方差矩阵如何变化呢?</p><p><img src="/images/SLAM中的概率基础/image-20220512170647991.png" alt="image-20220512170647991" style="zoom:25%;" /></p><p>利用协方差的计算公式可知，$x_1 , x_2$ 计算协方差时跟 $x_3$ ，并无关系，所以:</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}&\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}&\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }\\\xcancel{ {\color{red}w_1}{\color{blue}w_3}{\color{green}\sigma_2^2} }&\xcancel{ {\color{blue}w_3}{\color{green}\sigma_2^2} }&\xcancel{ {\color{blue}w_3^2}{\color{green}\sigma_2^2}+{\color{blue}\sigma_3^2} }\end{bmatrix}\end{align*}\tag{25}</script><p>就能得到去除 $x_3$  后的协方差矩阵：</p><script type="math/tex; mode=display">\begin{align*}\Sigma=\begin{bmatrix}{\color{red}w_1^2}{\color{green}\sigma_2^2}+{\color{red}\sigma_1^2}&{\color{red}w_1}{\color{green}\sigma_2^2}\\{\color{red}w_1}{\color{green}\sigma_2^2}&{\color{green}\sigma_2^2}\\\end{bmatrix}\end{align*}\tag{26}</script><p>同样，我们只418133364需要把信息矩阵公式 $(16)$ 中 $x_3$  对应的部分 (蓝色) 去掉 就可以:</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }&\xcancel{0}\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2}+\xcancel{ {\color{blue}\frac{w_3^2}{\sigma_3^2} } } }&\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }\\\xcancel{0}&\xcancel{ {\color{blue}-\frac{w_3}{\sigma_3^2} } }&\xcancel{ {\color{blue}-\frac{1}{\sigma_3^2} } }\end{bmatrix}\tag{27}</script><p>从而得到：</p><script type="math/tex; mode=display">Λ =\Sigma^{-1} =\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\\end{bmatrix}\tag{28}</script><p>是不是非常简单？但是问题在于：<strong>实际操作过程中并不会有这种颜色标记。</strong></p><p>这时，需要引入 marginalization <strong>(边缘化)</strong> 和 Schur’s complement <strong>(舒尔补)</strong>来解决这个问题。</p><h1 id="舒尔补及其应用"><a href="#舒尔补及其应用" class="headerlink" title="舒尔补及其应用"></a>舒尔补及其应用</h1><h2 id="舒尔补的概念"><a href="#舒尔补的概念" class="headerlink" title="舒尔补的概念"></a>舒尔补的概念</h2><p>给定任意矩阵块 $M$，如下所示：</p><script type="math/tex; mode=display">M=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{29}</script><p>如果，矩阵块 $D$ 是可逆的，则 $A − BD^{−1} C$称之为 $D$ 关于 $M$ 的舒尔补。</p><p>如果，矩阵块 $A$ 是可逆的，则 $D − CA^{−1} B$ 称之为 $A$ 关于 $M$ 的舒尔补。</p><h2 id="舒尔补的来由"><a href="#舒尔补的来由" class="headerlink" title="舒尔补的来由"></a>舒尔补的来由</h2><p>将 $M$ 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&B\\C&D\end{bmatrix}=\begin{bmatrix}A&B\\0&\Delta_A\end{bmatrix}\\\begin{bmatrix}A&B\\C&D\end{bmatrix}\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&0\\C&\Delta_A\end{bmatrix}\end{align*}\tag{30}</script><p>其中：$∆_A = D − CA^{−1} B$。联合起来，将 $M$ 变形成对角形：</p><script type="math/tex; mode=display">\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&B\\C&D\end{bmatrix}\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\tag{31}</script><p>反过来，我们又能从对角形恢复成矩阵 $M$：</p><script type="math/tex; mode=display">\begin{bmatrix}I&0\\CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\begin{bmatrix}I&A^{-1}B\\0&I\end{bmatrix}=\begin{bmatrix}A&B\\C&D\end{bmatrix}\tag{32}</script><h2 id="舒尔补分解的好处"><a href="#舒尔补分解的好处" class="headerlink" title="舒尔补分解的好处"></a>舒尔补分解的好处</h2><p><strong>快速求解矩阵 M 的逆</strong>。由于矩阵 $M$ 可以写成：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}=\begin{bmatrix}I&0\\CA^{-1}&I\end{bmatrix}\begin{bmatrix}A&0\\0&\Delta_A\end{bmatrix}\begin{bmatrix}I&A^{-1}B\\0&I\end{bmatrix}\tag{33}</script><p>由此可得到矩阵 $M$ 的逆：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}I&-A^{-1}B\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\tag{34}</script><p>我们发现，原本复杂的求逆矩阵的过程变得更加容易了。</p><h2 id="舒尔补应用于多元高斯分布"><a href="#舒尔补应用于多元高斯分布" class="headerlink" title="舒尔补应用于多元高斯分布"></a>舒尔补应用于多元高斯分布</h2><p>假设多元变量 $x$ 服从高斯分布，且由两部分组成：$x=\begin{bmatrix}a\\b\end{bmatrix}$，变量之间的协方差矩阵为：</p><script type="math/tex; mode=display">K=\begin{bmatrix}Cov(a,a)&Cov(a,b)\\Cov(b,a)&Cov(b,b)\end{bmatrix}=\begin{bmatrix}A&C^T\\C&D\end{bmatrix}\tag{35}</script><p>依据公式 $(6)$ ，变量 $x$ 的概率分布为：</p><script type="math/tex; mode=display">P(a,b)=p(b|a)p(a)∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\tag{36}</script><p>利用舒尔补进行分解指数部分：</p><script type="math/tex; mode=display">\begin{align*}&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}A&C^T\\C&D\end{bmatrix}^{-1}\begin{bmatrix}a\\b\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a\\b\end{bmatrix}^T\begin{bmatrix}I&-A^{-1}C^T\\0&I\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}I&0\\-CA^{-1}&I\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}\begin{bmatrix}a^T&(b-CA^{-1}a)^T\end{bmatrix}\begin{bmatrix}A^{-1}&0\\0&\Delta_A^{-1}\end{bmatrix}\begin{bmatrix}a\\b-CA^{-1}a\end{bmatrix}\right)\\&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)+(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\&∝\exp\left(-\frac{1}{2}(a^TA^{-1}a)\right)\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T)\Delta_A^{-1}(b-CA^{-1}a)\right)\\&∝p(a)p(b|a)\end{align*}\tag{37}</script><p>类似与公式 $(6)$ 的贝叶斯公式，我们将联合概率分解成条件概率和边缘概率的乘积。对于高斯分布而言，我们可以从多元高斯分布 $P(a,b)$ 中分解得到边际概率 $p(a)$ 和 条件概率 $p(b|a)$。</p><h3 id="P-a-P-b-a-的协方差矩阵"><a href="#P-a-P-b-a-的协方差矩阵" class="headerlink" title="$P(a), P(b|a)$ 的协方差矩阵"></a>$P(a), P(b|a)$ 的协方差矩阵</h3><p>$P(a)$ 的启示:</p><script type="math/tex; mode=display">P(a)∝\exp\left(-\frac{1}{2}a^TA^{-1}a\right)\sim\mathcal{N}(0,A)\tag{38}</script><p><span style="color:red;"><strong>启示：边际概率的协方差就是从联合分布中取对应的矩阵块就行了。</strong></span></p><p>$P(b|a)$ 的启示:</p><script type="math/tex; mode=display">P(b|a)∝\exp\left(-\frac{1}{2}(b-CA^{-1}a)^T\Delta_A^{-1}(b-CA^{-1}a)\tag{39}\right)</script><p><span style="color:red;"><strong>启示：$P(b|a)\sim \mathcal{N} (CA^{−1} a,\Delta_A )$。条件概率的协方差变为 $a$ 对应的舒尔补，均值也变了。</strong></span></p><h3 id="P-a-P-b-a-的信息矩阵"><a href="#P-a-P-b-a-的信息矩阵" class="headerlink" title="$P(a), P(b|a)$ 的信息矩阵"></a>$P(a), P(b|a)$ 的信息矩阵</h3><p><strong>为什么要讨论 $P (a), P (b|a)$ 的信息矩阵？</strong><br>因为基于优化的 SLAM 问题中，我们往往直接操作的是<strong>信息矩阵</strong>，而不是协方差矩阵。所以，有必要知道边际概率，条件概率的信息矩阵是何形式。</p><p>假设已知<strong>联合分布的信息矩阵</strong>：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\tag{40}</script><p>另外，由公式 $(34)$ 可知，协方差矩阵各块和信息矩阵之间有：</p><script type="math/tex; mode=display">\begin{bmatrix}A&B\\C&D\end{bmatrix}^{-1}=\begin{bmatrix}A^{-1}+A^{-1}C^T\Delta_A^{-1}CA^{-1}&-A^{-1}C^T\Delta_A^{-1}\\-\Delta_A^{-1}CA^{-1}&\Delta_A^{-1}\end{bmatrix}\triangleq\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\tag{41}</script><p>其中：$∆_A^{-1} = [D − CA^{−1} B]^{-1}$。</p><p>由条件概率 $P (b|a)$ 的<strong>协方差矩阵</strong>为 $∆_A$ 以及公式 $(41)$，易得其<strong>信息矩阵</strong>为：</p><script type="math/tex; mode=display">∆_A^{-1}=Λ_{bb}\tag{42}</script><p>由边际概率 $P (a)$ 的<strong>协方差矩阵</strong>为 $A$ 以及公式$(41)$，易得其<strong>信息矩阵</strong>为：</p><script type="math/tex; mode=display">A^{-1}=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\tag{43}</script><p>由此我们就知道如何从<strong>联合分布的信息矩阵</strong>中求解 $P ( a )$和 $P(b|a)$ 的<strong>信息矩阵</strong>了。</p><h2 id="回顾样例"><a href="#回顾样例" class="headerlink" title="回顾样例"></a>回顾样例</h2><p>回顾 “<strong>去除案例1中变量</strong>” 中去除变量 $x_3$ 的操作</p><p><img src="/images/SLAM中的概率基础/image-20220512213456958.png" alt="image-20220512213456958" style="zoom: 33%;" /></p><p>从联合分布 $P (x_1 , x_2 , x_3 )$中 marg 掉变量 $x_3$ ，即 $P (x_1 , x_2 )$ 对应的信息矩阵可以用公式 $(43)$ 得到。</p><script type="math/tex; mode=display">\begin{align*}\Sigma^{-1}_2&=Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}\\&=Λ_{aa}-\begin{bmatrix}0\\-\frac{w_3}{\sigma^2_3}\end{bmatrix}\sigma^2_3\begin{bmatrix}0&-\frac{w_3}{\sigma^2_3}\end{bmatrix}\\&=Λ_{aa}-\begin{bmatrix}0&0\\0&\frac{w_3}{\sigma^2_3}\end{bmatrix}\\&=\begin{bmatrix}{\color{red}\frac{1}{\sigma_1^2} }&{\color{red}\frac{w_1}{\sigma_1^2} }\\{\color{red}\frac{w_1}{\sigma_1^2} }&{\color{red}\frac{w_1^2}{\sigma_1^2} }+{\color{green}\frac{1}{\sigma_2^2} }\\\end{bmatrix}\end{align*}\tag{44}</script><p>这么操作，就使得在已知<strong>联合分布的信息矩阵</strong>的前提下，我们通过舒尔补的操作，即 $(44)$ 中的 $Λ_{aa}-Λ_{ab}Λ_{bb}^{-1}Λ_{ba}$，65                   </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。 条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。</strong> 表格总结如下:</p><script type="math/tex; mode=display">P(a,b)=\mathcal{N}\left(\begin{bmatrix}\mu_a\\\mu_b\end{bmatrix},\begin{bmatrix}\Sigma_{aa}&\Sigma_{ab}\\\Sigma_{ba}&\Sigma_{bb}\end{bmatrix}\right)=\mathcal{N}^{-1}\left(\begin{bmatrix}\eta_a\\\eta_b\end{bmatrix},\begin{bmatrix}Λ_{aa}&Λ_{ab}\\Λ_{ba}&Λ_{bb}\end{bmatrix}\right)\tag{45}</script><p><img src="/images/SLAM中的概率基础/image-20220512215118251.png" alt="image-20220512215118251" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要介绍SLAM相关的一些基础的概率学知识，并在此基础上，对高斯分布的协方差矩阵以及信息矩阵进行了比较系统的阐述，并引入边缘化以及舒尔补的概念，并利用舒尔补分解多元联合高斯分布，利用边缘化“优雅”的去除多元联合高斯分布中的元素。这些为之后的SLAM 滑动窗口理论奠定了基础。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学基础" scheme="https://lukeyalvin.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="概率基础" scheme="https://lukeyalvin.top/tags/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>六、VIO视觉残差的构建以及雅可比的求取</title>
    <link href="https://lukeyalvin.top/posts/c041a7d0.html"/>
    <id>https://lukeyalvin.top/posts/c041a7d0.html</id>
    <published>2022-05-10T11:40:18.000Z</published>
    <updated>2022-05-17T06:00:49.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。</p><h1 id="VIO残差构建"><a href="#VIO残差构建" class="headerlink" title="VIO残差构建"></a>VIO残差构建</h1><p>VIO重投影误差：</p><p>具体详解见：<a href="https://lukeyalvin.top/posts/ddbf64.html#VIO%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE"><a href="https://lukeyalvin.top/posts/ddbf64.html#VIO重投影误差">VIO重投影误差</a></a></p><p><img src="/images/5-VIO视觉残差的构建以及雅可比的求取/image-20220505205125811-16522560257751.png" alt="image-20220505205125811" style="zoom: 33%;" /></p><p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p><script type="math/tex; mode=display">\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{1}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u_{cj}\\\frac{Y_{cj} }{Z_{cj} }-v_{cj}\end{bmatrix}\tag{2}</script><h1 id="VIO残差的雅可比推导"><a href="#VIO残差的雅可比推导" class="headerlink" title="VIO残差的雅可比推导"></a>VIO残差的雅可比推导</h1><p>按照变换矩阵和旋转矩阵之间的关系：</p><script type="math/tex; mode=display">\begin{align*}T_{bc}^{-1}&=\begin{bmatrix}R^T_{bc}&-R^T_{bc}p_{bc}\\0^T&1\end{bmatrix},\ T_{wb_j}^{-1}=\begin{bmatrix}R^T_{wb_j}&-R^T_{wb_j}p_{wb_j}\\0^T&1\end{bmatrix}\\T_{wb_j}&=\begin{bmatrix}R^T_{wb_j}&p_{wb_j}\\0^T&1\end{bmatrix},\ \ \ \ \  \ \  \ T_{bc}=\begin{bmatrix}R^T_{bc}&p_{bc}\\0^T&1\end{bmatrix}\end{align*}\tag{3}</script><p>根据公式$(3)$将公式$(1)$中拆分成三维坐标形式：</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}=\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\end{bmatrix}&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}\frac{1}{\lambda}\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\&+R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\end{align*}\tag{4}</script><p>为了推导的方便定义如下公式：</p><script type="math/tex; mode=display">\begin{align*}f_{c_i}&=\frac{1}{\lambda}\begin{bmatrix}u_{c_i}\\v_{c_i}\end{bmatrix}\\f_{b_i}&=R_{bc}f_{c_i}+p_{bc}\\f_w&=R_{wb_i}f_{b_i}+p_{wb_i}\\f_{b_j}&=R^T_{wb_j}(f_{w}-p_{bc})\\\end{align*}\tag{5}</script><p>雅可比矩阵 为视觉误差对两个时刻的状态量，外参以及逆深度求导：</p><script type="math/tex; mode=display">J=\begin{bmatrix}\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_ib_i^\prime}\\ \delta\theta_{b_ib_i^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{b_jb_j^\prime}\\ \delta\theta_{b_jb_j^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\begin{bmatrix}\delta\mathbf{p}_{cc^\prime}\\ \delta\theta_{cc^\prime} \end{bmatrix} }&\frac{\partial r_c}{\partial\delta\lambda } \end{bmatrix}\tag{6}</script><p>根据链式法则， Jacobian 的计算可以分两步走:</p><ul><li>第一步误差对 $f_{c_j}$ 求导：  </li></ul><script type="math/tex; mode=display">\frac{\partial r_c}{\partial f_{c_j} }=\begin{bmatrix}\frac{1}{Z_{c_j} }&0&\frac{X_{c_j}}{Z_{c_j}^2 }\\0&\frac{1}{Z_{c_j} }&\frac{Y_{c_j}}{Z_{c_j}^2 }\end{bmatrix}\tag{7}</script><ul><li>第二步对 $f_{c_j}$ 对各状态量求导：</li></ul><ol><li><strong>对 $i$ 时刻的状态量求导</strong></li></ol><p>① 对 $i$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_ib_i^\prime} }=R^{T}_{bc}R^{T}_{wb_j}\tag{8}</script><p>② 对 $i$ 时刻的<strong>角度</strong>增量求导</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}\left(R^{T}_{wb_j}\left( ({\color{red}R_{wb_i} }p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\end{align*}\tag{9}</script><p>上面公式和 $i$ 时刻角度相关的量并不多，下面为了简化，直接丢弃了不相关的部分 :</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }R_{bc}f_{c_i}+R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }p_{bc}+(···)\\&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(R_{bc}f_{c_i}+p_{bc})+(···)\\&=R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}+(···)\end{align*}\tag{9}</script><p> 雅可比矩阵为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }(I+[\delta\theta_{b_ib^\prime_i}]^{\land})f_{b_i}-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }f_{b_i}}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[\delta\theta_{b_ib^\prime_i}]^{\land}f_{b_i} }{\partial\delta\theta_{b_ib^\prime_i} }\\&=-\underset{\delta\theta_{b_{i}b^{\prime}_{i} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} [\delta\theta_{b_ib^\prime_i}]}{\partial\delta\theta_{b_ib^\prime_i} }\\&=-R^{T}_{bc}R^{T}_{wb_j}{\color{red}R_{wb_i} }[f_{b_i}]^{\land} \end{align*}\tag{10}</script><ol><li><strong>对 $j$ 时刻的状态量求导</strong></li></ol><p>① 对 $j$ 时刻的<strong>位移</strong>求导，可以直接写出如下：</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{b_jb_j^\prime} }=-R^{T}_{bc}R^{T}_{wb_j}\tag{11}</script><p>② 对 $j$ 时刻的<strong>角度</strong>增量求导</p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }R_{wb_i}R_{bc}f_{c_i}+R^{T}_{bc}\left({\color{green}R^{T}_{wb_j} }\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)\\&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }\left(R_{wb_i}(R_{bc}f_{c_i}+p_{bc})+p_{wb_j}-p_{wb_j}\right)+(···)\\&=R^{T}_{bc}{\color{green}R^{T}_{wb_j} }(f_w-p_{wb_j})+(···)\\\end{align*}\tag{12}</script><p> 雅可比矩阵为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial\delta\theta_{b_ib^\prime_i} }&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}(I-[\delta\theta_{b_ib^\prime_j}]^{\land}){\color{green}R^T_{wb_j} }(f_w-p_{wb_j})-R^{T}_{bc}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}{\color{green}R^T_{wb_j} }(f_w-p_{wb_j})}{\partial\delta\theta_{b_ib^\prime_i} }\\&=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[\delta\theta_{b_ib^\prime_j}]^{\land}f_{b_j} }{\partial\delta\theta_{b_ib^\prime_i} }\\&-=\underset{\delta\theta_{b_{j}b^{\prime}_{j} }\rightarrow0}{lim}\frac{\partialR^{T}_{bc}[f_{b_j}]^{\land}[\delta\theta_{b_ib^\prime_j}] }{\partial\delta\theta_{b_ib^\prime_i} }\\&=-R^{T}_{bc}[f_{b_j}]^{\land}\end{align*}\tag{13}</script><ol><li><strong>对 imu 和相机之间的外参求导</strong>  </li></ol><p>① 对<strong>位移</strong>求导</p><script type="math/tex; mode=display">\frac{\partial f_{c_j} }{\partial\delta\mathbf{p}_{cc^\prime} }=R^{T}_{bc}(R^{T}_{wb_j}R_{wb_i}-I_{3\times 3})\tag{14}</script><p>② 对<strong>角度</strong>增量求导，由于 $f_{c_j}$ 都和 $R_{bc}$ 有关，并且比较复杂，所以这次分两部分求导  </p><script type="math/tex; mode=display">\begin{align*}f_{c_j}&={\color{green}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i} }+{\color{blue}R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)}\\&={\color{green}f^1_{c_j} }+{\color{blue}f^2_{c_j} }\end{align*}\tag{15}</script><p>第一部分 ${\color{green}f^1_{c_j} }$ 雅可比为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j}^1 }{\partial\delta\theta_{cc^\prime} }=&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\land}) R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(I+[\delta\theta_{cc^\prime}]^{\land}) f_{c_i}-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc} }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[\delta\theta_{cc^\prime}]^{\land}f_{c_i}-[\delta\theta_{cc^\prime}]^{\land} R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}+o^2(\theta_{cc^\prime}) }{\partial\delta\theta_{cc^\prime} }\\&\approx \underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial -R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\land}[\delta\theta_{cc^\prime}]+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\land}[\delta\theta_{cc^\prime}] ) }{\partial\delta\theta_{cc^\prime} }\\&=-R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}[f_{c_i}]^{\land}+[R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}]^{\land}\end{align*}\tag{16}</script><p>第一部分 ${\color{blue}f^2_{c_j} }$ 雅可比为：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j}^2 }{\partial\delta\theta_{cc^\prime} }&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial(I-[\delta\theta_{cc^\prime}]^{\land} ) R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)-R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right) }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial-[\delta\theta_{cc^\prime}]^{\land} R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right) }{\partial\delta\theta_{cc^\prime} }\\&=\underset{\delta\theta_{cc^{\prime} }\rightarrow0}{lim}\frac{\partial-[R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)]^{\land}[\delta\theta_{cc^\prime}]  }{\partial\delta\theta_{cc^\prime} }\\&=[R^{T}_{bc}\left(R^{T}_{wb_j}\left( (R_{wb_i}p_{bc}+p_{wb_j})-p_{wb_j} \right)-p_{bc}\right)]^{\land}\end{align*}\tag{17}</script><p>两个 Jacobian 相加就是视觉误差对外参中的角度增量的最终结果。  </p><ol><li><strong>视觉误差对特征逆深度的求导</strong>  </li></ol><script type="math/tex; mode=display">\begin{align*}\frac{\partial f_{c_j} }{\partial \delta\lambda}&=\frac{\partial f_{c_j} }{\partial f_{c_i} }\frac{\partial f_{c_i} }{\partial \delta\lambda}\\&=R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}(-\frac{1}{\lambda^2}\begin{bmatrix}u_{c_i}\\v_{c_i}\\1 \end{bmatrix})\\&=-\frac{1}{\lambda}R^{T}_{bc}R^{T}_{wb_j}R_{wb_i}R_{bc}f_{c_i}\end{align*}\tag{18}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;在视觉 SLAM 中，我们通过最小化特征点在归一化平面上的位置（估计值）和图像中匹配到的该图像的位置（观测值）的差即重投影误差来对特征点和位姿进行优化。这里我们只有一个观测作为信息来源即相机获取的图像，而在 VIO 中，除了相机以外我们还有 IMU 的测量数据作为另一信息来源，这种情况下我们怎么对这个观测进行误差构建呢？并且对于 IMU 的误差和视觉的误差怎么分配权重并且求其最小值呢，这是这篇博客想要解决的问题。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>五、预积分残差的雅克比求取</title>
    <link href="https://lukeyalvin.top/posts/b68d674.html"/>
    <id>https://lukeyalvin.top/posts/b68d674.html</id>
    <published>2022-05-10T11:38:28.000Z</published>
    <updated>2022-05-11T07:54:42.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>对于右乘雅可比，我们做如下的公式简化：</p><script type="math/tex; mode=display">\frac{\partial x_a}{\partial \delta\theta}=\underset{\delta\theta\rightarrow0}{lim}\frac{R_{ab}\exp([\delta\theta]^{\land})x_b-R_{ab}x_b}{\delta\theta}</script><p>后续简写为：</p><script type="math/tex; mode=display">\frac{\partial x_a}{\partial \delta\theta}=\frac{R_{ab}\exp([\delta\theta]^{\land})x_b}{\delta\theta}</script><h1 id="预积分残差的雅克比求取"><a href="#预积分残差的雅克比求取" class="headerlink" title="预积分残差的雅克比求取"></a>预积分残差的雅克比求取</h1><p>定义：一段时间内 IMU 构建的预积分量作为<strong>测量值</strong>，对两时刻之间的状态量进行约束，  </p><script type="math/tex; mode=display">\begin{align*}\mathbf{e}_{B}(x_i,x_j)=\begin{bmatrix}r_p\\r_q\\r_v\\r_{ba}\\r_{bg}\end{bmatrix}_{15\times1}=\begin{bmatrix}q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-{\color{blue}\alpha_{b_ib_j} }\\2[{\color{blue}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{blue}\beta_{b_ib_j} }\\b^a_j-b^a_i\\b^g_j-b^g_i\end{bmatrix}\end{align*}\tag{1}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t\end{align*}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第二项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p><p>在求解非线性方程时，需要知道误差 $\mathbf{e}_{B}$ 对两个关键帧 $i, j$ 的状态量 $p, q, v, ba, bg$ 的雅可比。对 $i, j$ 时刻的状态量 $p, q, v$ 求导还是比较直观的，直接对误差公式进行计算就行。但是对 $i$ 时刻的 $b^a_i , b^g_i$ 求导就显得十分复杂，下面我们详细讨论。  </p><p>因为 $i$ 时刻的 bias 相关的预积分计算是通过迭代一步一步累计递推的，可以算但是太复杂。所以对于预积分量直接在 $i$ 时刻的 bias 附近用<strong>一阶泰勒展开</strong>来近似，而不用真的去迭代计算。  </p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\alpha_{b_ib_j}+J^{\alpha}_{b^a_i}\delta b^a_i+J^{\alpha}_{b^g_i}\delta b^g_i\\\beta_{b_ib_j}&=\beta_{b_ib_j}+J^{\beta}_{b^a_i}\delta b^a_i+J^{\beta}_{b^g_i}\delta b^g_i\\q_{b_ib_j}&=q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^{q}_{b^g_i}\delta b^g_i \end{bmatrix}\end{align*}\tag{2}</script><p>其中 $J^{\alpha}_{b^a_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^a_i},J^{\alpha}_{b^g_i}=\frac{\partial \alpha_{b_ib_j} }{\partial\delta b^g_i},J^{\beta}_{b^a_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^a_i},J^{\beta}_{b^g_i}=\frac{\partial \beta_{b_ib_j} }{\partial\delta b^g_i},J^{q}_{b^g_i}=\frac{\partial q_{b_ib_j} }{\partial\delta b^g_i}$，表示预积分量对 $i$ 时刻的 bias 求导。</p><p>这些雅克比根据前面讨论的<strong>协方差传递公式</strong>，能一步步递推得到：  </p><script type="math/tex; mode=display">J_{k+1}=\mathbf{F}J_k\tag{3}</script><h2 id="r-v-对各状态量的雅可比"><a href="#r-v-对各状态量的雅可比" class="headerlink" title="$r_v$ 对各状态量的雅可比"></a>$r_v$ 对各状态量的雅可比</h2><p>下面我们来讨论 IMU 误差相对于两帧的 PVQ 的 雅克比:由于 $r_p$ 和 $r_v$ 的误差形式很相近，对各状态量求导的 雅克比形式也很相似，所以这里只对 $r_v$ 的推导进行详细介绍  </p><p>① 对 $i$ 时刻<strong>位移</strong>的雅可比</p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta p_{b_ib^\prime_i} }=0\tag{4}</script><p>② 对 $i$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_v}{\partial\delta \theta_{b_ib^\prime_i} }&=\frac{\partial (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2} \delta \theta_{b_ib^\prime_i}\end{bmatrix})^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial (R_{wb_i}\exp([\delta \theta_{b_ib^\prime_i}]^{\land}))^{-1}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial\exp([-\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial(I-[\delta \theta_{b_ib^\prime_i}]^{\land})R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial -[\delta \theta_{b_ib^\prime_i}]^{\land}[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]}{\partial\delta \theta_{b_ib^\prime_i} }\\ &=\frac{\partial -[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}[\delta \theta_{b_ib^\prime_i}]}{\partial\delta \theta_{b_ib^\prime_i} }\\&=[R_{b_iw}(v^w_j-v^w_i+g^w\Delta t)]^{\land}\end{align*}\tag{5}</script><p>③ 对 $i$ 时刻<strong>速度</strong>的雅可比</p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta v_i^w}=-R_{b_iw}\tag{6}</script><p>④ 对 $i$ 时刻<strong>加速度 bais</strong>的雅可比 ,注意 bias 量只和预积分 $\beta$ 有关：  </p><script type="math/tex; mode=display">\frac{\partial r_v}{\partial\delta b_i^a}=-\frac{\partial \beta_{b_ib_j} }{\partial\delta b_i^a}=-J^{\beta}_{b^a_i}\tag{7}</script><h2 id="r-q-对各状态量的雅可比"><a href="#r-q-对各状态量的雅可比" class="headerlink" title="$r_q$ 对各状态量的雅可比"></a>$r_q$ 对各状态量的雅可比</h2><p>① 对 $i$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial2[q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*\otimes q_{wb_j}]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial-2[(q^*_{b_ib_j}\otimes(q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})^*\otimes q_{wb_j})^*]_{xyz} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=\frac{\partial-2[q_{wb_j}^* \otimes (q_{wb_i}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix})\otimes q_{b_ib_j} ]_{xyz}}{\partial \delta\theta_{b_ib^\prime_i} }\\&=-2[0\ \ I]\frac{\partial[q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_ib^\prime_i}\end{bmatrix} }{\partial \delta\theta_{b_ib^\prime_i} }\\&=-2[0\ \ I][q_{wb_j}^* \otimes q_{wb_i}]_L[q_{b_ib_j}]_R\begin{bmatrix}0\\\frac{1}{2}I\end{bmatrix}\end{align*}\tag{8}</script><p>其中 $[·]_L$ 和 $[·]_R$ 为四元数转为左/右旋转矩阵的算子。  </p><p>② 对 $j$ 时刻<strong>旋转</strong>的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_q}{\partial \delta\theta_{b_ib^\prime_i} }&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=\frac{\partial2[q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}\otimes \begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}\end{bmatrix} ]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=\frac{\partial2[[q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_L\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_jb^\prime_j}\end{bmatrix} ]_{xyz} }{\partial \delta\theta_{b_jb^\prime_j} }\\&=2[0\ \ I][q_{b_ib_j}^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_L\begin{bmatrix}0\\\frac{1}{2}I\end{bmatrix}\end{align*}\tag{9}</script><p>② 对 $i$ 时刻<strong>陀螺仪偏置 $b^g_i$</strong> 的雅可比</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial r_v}{\partial\delta b_i^g}&=\frac{\partial2[q_{b_jb_i}\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial2[(q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*\otimes q_{wb_i}^*\otimes q_{wb_j}]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial-2[((q_{b_ib_j}\otimes\begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})^*\otimes q_{wb_i}^*\otimes q_{wb_j})^*]_{xyz} }{\partial\delta b_i^g}\\&=\frac{\partial-2[q_{wb_j}^*\otimes q_{wb_i}\otimes(q_{b_ib_j} \otimes \begin{bmatrix}1\\\frac{1}{2}J^q_{b^g_i\delta b_i^g}\end{bmatrix})]_{xyz} }{\partial\delta b_i^g}\\&=-2[0\ \ I][q_{wb_j}^*\otimes q_{wb_i}\otimes q_{b_ib_j}]_L\begin{bmatrix}0\\\frac{1}{2}J^q_{b^g_i}\end{bmatrix}\end{align*}\tag{10}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要讨论预积分对于各个状态量的雅可比矩阵的求解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>四、IMU误差状态传递方程的推导</title>
    <link href="https://lukeyalvin.top/posts/aaff1b40.html"/>
    <id>https://lukeyalvin.top/posts/aaff1b40.html</id>
    <published>2022-05-10T07:28:11.000Z</published>
    <updated>2022-05-11T08:06:50.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="IMU误差状态传递方程的推导"><a href="#IMU误差状态传递方程的推导" class="headerlink" title="IMU误差状态传递方程的推导"></a>IMU误差状态传递方程的推导</h1><h2 id="协方差的传播"><a href="#协方差的传播" class="headerlink" title="协方差的传播"></a>协方差的传播</h2><p>例如，已知一个变量$y=Ax,x\in \mathcal{N}(0,\Sigma_{x})$，则有$\Sigma_y=A\Sigma_xA^T$</p><script type="math/tex; mode=display">\begin{align*}\Sigma_y&=E((Ax)(Ax)^T)\\&=E(Axx^TA^T)\\&=A\Sigma_xA^T\end{align*}\tag{1}</script><p>我们知道，一个IMU数据作为测量值的噪声方差我们可以标定 （类似公式$(1)$中的已知量$x$），那么一段时间的多个IMU数据形成的IMU数据积分形式的预积分量的方差（类似公式$(1)$中的已知量$y$），就可以通过以上形式求解，关键是找出IMU  噪声与预积分量之间的<strong>线性递推关系</strong>（类似公式$(1)$中的已知量$y=Ax$）。</p><p>假设已知了<strong>相邻时刻误差的线性传递方程：</strong></p><script type="math/tex; mode=display">\eta_{ik}=\mathbf{F}_{k-1}\eta_{ik-1}+\mathbf{G}_{k-1}\mathbf{n}_{k-1}\tag{2}</script><p>比如：状态量误差为 $\eta_{ik}=[\delta\theta_{ik},\delta\mathbf{v}_{ik},\delta\mathbf{p}_{ik}]$，$\eta_{ik}$为当前时刻的误差，$\eta_{ik-1}$为上一时刻的误差；<strong>测量噪声</strong>为 $\mathbf{n}_{k}=[\mathbf{n}_{k}^a,\mathbf{n}_{k}^g]$，因此，误差的传递由两部分组成，即<strong>当前时刻的误差传递给下一时刻，当前时刻的测量噪声传递给下一时刻</strong>。</p><p>如果已知上面的误差状态传递方程，那么一段时间内IMU积分的协方差矩阵就可以轻松递推算出：</p><script type="math/tex; mode=display">\Sigma_{ik}=\mathbf{F}_{k-1}\Sigma_{ik-1}\mathbf{F}_{k-1}^T+\mathbf{G}_{k-1}\Sigma_\mathbf{n}\mathbf{G}_{k-1}^T\tag{3}</script><p>其中，$\Sigma_n$是<strong>测量噪声的协方差矩阵</strong>，方差从 $i$ 时刻开始进行递推，$\Sigma_{ii}=0$</p><h2 id="状态误差线性递推方程的推导"><a href="#状态误差线性递推方程的推导" class="headerlink" title="状态误差线性递推方程的推导"></a>状态误差线性递推方程的推导</h2><p>通常情况下，对于状态量之间的递推关系是非线性的方程，如 $x_k=f(x_{k-1},\mathbf{u}_{k-1})$，其中状态量 $x,\mathbf{u}$ 为系统的输入量。</p><p>我们可以用两种方法来推导误差传递的线性递推关系：</p><ul><li>一种是<strong>基于一阶泰勒展开</strong>的误差传递方程，主要应用于 EKF 的协方差预测。</li><li>一种是<strong>基于误差随时间变化</strong>的递推方程。</li></ul><h3 id="基于一阶泰勒展开"><a href="#基于一阶泰勒展开" class="headerlink" title="基于一阶泰勒展开"></a>基于一阶泰勒展开</h3><p>令状态量为 $x=\hat{x}+\delta x$，其中，真值为$\hat{x}$，误差为 $\delta x$，另外输入量 $\mathbf{u}$ 的噪声为 $\mathbf{n}$。</p><p>对于非线性系统  $x_k=f(x_{k-1},\mathbf{u}_{k-1})$ 进行一阶泰勒展开有：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},\mathbf{u}_{k-1})\\\hat{x}_k+\delta x_k&=f(\hat{x}_{k-1}+\delta x_{k-1},\hat{\mathbf{u} }_{k-1}+\mathbf{n}_{k-1})\\{\color{blue}\hat{x}_k}+\delta x_k&={\color{blue}f(\hat{x}_{k-1},\hat{\mathbf{u} }_{k-1})}+\mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\end{align*}\tag{4}</script><p>可以看出蓝色字体部分表示真值，他们相互抵消掉了，剩下的就是误差的线性递推关系：</p><script type="math/tex; mode=display">\delta x_k = \mathbf{F}\delta x_{k-1}+\mathbf{G}\mathbf{n}_{k-1}\tag{5}</script><p>其中，$\mathbf{F}$ 是状态量 $x_k$ 对状态量 $x_{k-1}$ 的雅可比矩阵， $\mathbf{G}$ 是状态量 $x_k$ 对输入量 $\mathbf{u}_{k-1}$ 的雅可比矩阵。</p><h3 id="基于误差随时间变化"><a href="#基于误差随时间变化" class="headerlink" title="基于误差随时间变化"></a>基于误差随时间变化</h3><p>如果我们能够推导状态误差随着时间变换的倒数关系，比如：</p><script type="math/tex; mode=display">\dot{\delta x}=\mathbf{A}\delta x+\mathbf{B}\mathbf{n}\tag{6}</script><p>则误差状态的递推方程为：</p><script type="math/tex; mode=display">\begin{align*}&\delta x_k = \delta x_{k-1} + \dot{\delta x_{k-1} }\Delta t\\\rightarrow&\delta x_k=(\mathbf{I}+\mathbf{A}\Delta t)\delta x_{k-1}+\mathbf{B}\Delta t \mathbf{n}_{k-1} \end{align*}\tag{7}</script><p>综合两种方法可以发现：</p><script type="math/tex; mode=display">\mathbf{F}=\mathbf{I}+\mathbf{A}\Delta t,\ \ \ \ \mathbf{G}=\mathbf{B}\Delta t\tag{8}</script><p>由于在 VIO 系统中我们已经知道了状态的导数与状态之间的旋转矩阵，如公式 $(26)$:</p><script type="math/tex; mode=display">\dot{\mathbf{v} }=Ra^b+g\tag{9}</script><p>那么我们就可以推导<strong>速度误差</strong>和<strong>状态误差</strong>之间的关系，再每一项上都加上各自的误差，既有：</p><script type="math/tex; mode=display">\begin{align*}\dot{\mathbf{v} }+\dot{\delta\mathbf{v} }&=R(\mathbf{I}+[\delta\theta]^{\land})(a^b+\delta a^b)+g+\delta g\\\dot{\delta\mathbf{v} }&=R\delta a^b+R[\delta\theta]^{\land}(a^b+\delta a^b)+\delta g\\\dot{\delta\mathbf{v} }&=R\delta a^b-R[a^b]^{\land}\delta\theta+\delta g\end{align*}\tag{10}</script><p>由此就可以以此类推，很轻易的写出整个 $\mathbf{A}$ 和 $\mathbf{B}$ ，这也是此方法的优点。 </p><h1 id="基于一阶泰勒展开的推导"><a href="#基于一阶泰勒展开的推导" class="headerlink" title="基于一阶泰勒展开的推导"></a>基于一阶泰勒展开的推导</h1><p>由上一节的公式$(17)$：IMU 预积分误差的离散形式 ，此时将噪声模型也考虑进去：</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}{\color{red}+\mathbf{n}^a_{k} }-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }{\color{red}+\mathbf{n}^a_{k+1} }-b^a_k)]\\w&=\frac{1}{2}[(w^{b_k}{\color{red}+\mathbf{n}^g_{k} }-b^g_k)+(w^{b_{k+1} }{\color{red}+\mathbf{n}^g_{k+1} }-b^g_k)]\\{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t\end{align*}\tag{11}</script><p>用前面一阶泰勒展开的推导方式，我们希望能推导出如下的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}\delta\alpha_{b_{k+1}b^{\prime}_{k+1} }\\\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\\delta\beta_{b_{k+1}b^{\prime}_{k+1} }\\\delta\mathbf{b}^a_{k+1}\\\delta\mathbf{b}^g_{k+1}\\\end{bmatrix}=\mathbf{F}\begin{bmatrix}\delta\alpha_{b_{k}b^{\prime}_{k} }\\\delta\theta_{b_{k}b^{\prime}_{k} }\\\delta\beta_{b_{k}b^{\prime}_{k} }\\\delta\mathbf{b}^a_{k}\\\delta\mathbf{b}^g_{k}\\\end{bmatrix}+\mathbf{G}\begin{bmatrix}\mathbf{n}^a_{k}\\\mathbf{n}^g_{k}\\\mathbf{n}^a_{k+1}\\\mathbf{n}^g_{k+1}\\\mathbf{n}_{\mathbf{b}^a_k}\\\mathbf{n}_{\mathbf{b}^g_k}\\\end{bmatrix}\tag{12}</script><p>$\mathbf{F},\mathbf{G}$为两个时刻间的协方差传递矩阵。</p><p>这里我们直接给出 $\mathbf{F},\mathbf{G}$ 的最终形式，后面会对部分项进行详细推导：  </p><script type="math/tex; mode=display">\mathbf{F}=\begin{bmatrix}\mathbf{I}&f_{12}&\mathbf{I}\delta t&-\frac{1}{4}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t^2&f_{15}\\0&\mathbf{I}-[\omega]^{\land}&0&0&-\mathbf{I}\delta t\\0&f_{32}&\mathbf{I}&-\frac{1}{2}(q_{b_ib_{k} }+q_{b_ib_{k+1} })\delta t&f_{35}\\0&0&0&\mathbf{I}&0\\0&0&0&0&\mathbf{I}\end{bmatrix}\tag{13}</script><script type="math/tex; mode=display">\mathbf{G}=\begin{bmatrix}\frac{1}{4}q_{b_ib_k}\delta t^2&g_{12}&\frac{1}{4}q_{b_ib_{k+1} }\delta t^2&g_{14}&0&0\\0&\frac{1}{2}\mathbf{I}\delta t&0&\frac{1}{2}\mathbf{I}\delta t&0&0\\\frac{1}{2}q_{b_ib_k}\delta t&g_{32}&\frac{1}{2}q_{b_ib_{k+1} }\delta t&g_{34}&0&0\\0&0&0&0&\mathbf{I}\delta t&0\\0&0&0&0&0&\mathbf{I}\delta t\end{bmatrix}\tag{14}</script><p>其中的系数如下：</p><p><img src="/images/3-2-IMU误差状态传递的推导/image-20220509150144881-16521033725157.png" alt="image-20220509150144881"></p><h2 id="雅克比矩阵-mathbf-F-的推导"><a href="#雅克比矩阵-mathbf-F-的推导" class="headerlink" title="雅克比矩阵 $\mathbf{F}$ 的推导"></a>雅克比矩阵 $\mathbf{F}$ 的推导</h2><h3 id="速度预积分量的雅可比"><a href="#速度预积分量的雅可比" class="headerlink" title="速度预积分量的雅可比"></a>速度预积分量的雅可比</h3><p>$\beta$ 对于各个状态量的雅可比矩阵推导，即 $\mathbf{F}$ 矩阵第三行。速度预积分量 $\beta$ 的递推计算形式:  </p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{15}</script><p>$f_{33}$: 对上一时刻<strong>速度预积分量</strong>的 雅可比：</p><script type="math/tex; mode=display">f_{33}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\beta_{b_{k}b^{\prime}_{k} } }=\mathbf{I}_{3\times 3}\tag{16}</script><p>$f_{32}$: 对上一时刻<strong>角度预积分量</strong>的 雅可比：</p><p>首先将公式 $(32)$写成如下形式：</p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{17}</script><p>那么，<strong>速度的预积分量对角度预积分量</strong>的 雅可比：  </p><script type="math/tex; mode=display">f_{32}=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }=\frac{\partial a\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\tag{18}</script><p>其中分子可以写成：</p><script type="math/tex; mode=display">\begin{align*}a\delta t &=\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}(a^{b_k}-b^a_k)\delta t\\&+\frac{1}{2}q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_kb^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)\delta t\\&=\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t\\&+\frac{1}{2}R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t\end{align*}\tag{19}</script><p>分别对分子的两项进行求导：</p><p>①第一项</p><script type="math/tex; mode=display">\begin{align*}&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }(I + [\delta\theta_{b_kb^{\prime}_{k} }]^{\land})(a^{b_{k} }-b^a_k)\delta t-R_{b_ib_{k} }(a^{b_{k} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[(a^{b_{k} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}[\delta\theta_{b_kb^{\prime}_{k} }]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-R_{b_ib_{k} }[(a^{b_{k} }-b^a_k)\delta t]^{\land}\end{align*}\tag{20}</script><p>②第二项</p><script type="math/tex; mode=display">\begin{align*}&\frac{\partial R_{b_ib_{k} }\exp([\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }(I+[\delta\theta_{b_kb^{\prime}_{k} }]^{\land})\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }[\delta\theta_{b_kb^{\prime}_{k} }]^{\land}[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }\left[\exp([\omega\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\ [\delta\theta_{b_kb^{\prime}_{k} }\right]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\underset{\delta\theta_{b_{k}b^{\prime}_{k} }\rightarrow0}{lim}\frac{\partial R_{b_ib_{k} }\exp([\omega\delta t]^{\land})\left[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})[\delta\theta_{b_kb^{\prime}_{k} }\right]}{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-R_{b_ib_{k} }\exp([\omega\delta t]^{\land})[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\&=-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}\exp([-\omega\delta t]^{\land})\\&\approx-R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}(I-[\omega\delta t]^{\land})\end{align*}\tag{21}</script><p>将上面两部分综合起来就能得到  :</p><script type="math/tex; mode=display">\begin{align*}f_{32}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\theta_{b_{k}b^{\prime}_{k} } }\\&=-\frac{1}{2}\left([a^{b_{k} }-b^a_k]^{\land}\delta t+R_{b_ib_{k+1} }[a^{b_{k+1} }-b^a_k]^{\land}(I-[\omega]^{\land}\delta t)\delta t \right)\end{align*}\tag{22}</script><p>$f_{35}$: <strong>速度预积分量</strong>对 $k$ 时刻<strong>角速度 bias</strong> 的 雅可比：</p><p>递推公式如下:</p><script type="math/tex; mode=display">\begin{align*}\beta_{b_ib_{k+1} }&=\beta_{b_ib_k}+a\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\delta t\\&=\beta_{b_ib_k}+\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k} }\otimes \begin{bmatrix}1\\{\color{red}\frac{1}{2}w\delta t}\end{bmatrix}(a^{b_{k+1} }-b^a_k)]\delta t\end{align*}\tag{23}</script><p>只有红色公式部分和角速度 bias 有关系，因此雅克比的推导只考虑红色公式部分。  </p><script type="math/tex; mode=display">\begin{align}f_{35}&=\frac{\partial \beta_{b_ib_{k+1} } }{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{\partial \frac{1}{2}q_{b_ib_{k} }\otimes \begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes \begin{bmatrix}1\\-\frac{1}{2}\mathbf{b}^g_k\delta t\end{bmatrix}(a^{b_{k+1} }-b^a_k)\delta t-\partial \frac{1}{2}q_{b_ib_{k} }\otimes \begin{bmatrix}1\\\frac{1}{2}w\delta t\end{bmatrix}\otimes (a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }\exp([-\delta\mathbf{b}^g_k\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }(I+[-\delta\mathbf{b}^g_k\delta t]^{\land})(a^{b_{k+1} }-b^a_k)\delta t-R_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)\delta t}{\partial\delta\mathbf{b}^g_k}\\&=\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }[-\delta\mathbf{b}^g_k\delta t]^{\land}[(a^{b_{k+1} }-b^a_k)\delta t]}{\partial\delta\mathbf{b}^g_k}\\&=-\underset{\delta\mathbf{b}^g_k \rightarrow0}{lim}\frac{1}{2}\frac{\partial R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)\delta t]^{\land}[-\delta\mathbf{b}^g_k\delta t]}{\partial\delta\mathbf{b}^g_k}\\&=-\frac{1}{2}(R_{b_ib_{k+1} }[(a^{b_{k+1} }-b^a_k)]^{\land}\delta t)(-\delta t)\end{align}\tag{24}</script><h3 id="旋转预积分量的雅可比"><a href="#旋转预积分量的雅可比" class="headerlink" title="旋转预积分量的雅可比"></a>旋转预积分量的雅可比</h3><p>旋转预积分的递推公式为：  </p><script type="math/tex; mode=display">\begin{align*}q_{b_ib_{k+1} }&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}(\frac{1}{2}(\omega^{b_k}+\omega^{b_{k+1} })-\mathbf{b}^g_k)\delta t\end{bmatrix}\end{align*}\tag{25}</script><p>$f_{22}$: 前一时刻的旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 如何影响当前的旋转误差  $\delta\theta_{b_{k+1}b^{\prime}_{k+1} }$ ？</p><p>假设两个时刻的真值为 $q_{b_ib_{k+1} },\ q_{b_ib_{k} }$，两个时间的增量真值为 $q_{b_kb_{k+1} }$。推导过程只考虑一个变量，即旋转误差 $\delta\theta_{b_{k}b^{\prime}_{k} }$ 的影响，而不考虑测量值 角速度 bias 误差影响，可以假设 $q_{b_kb_{k+1} }\approx\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}$。</p><p>另外，三元组四元数相乘有如下性质：</p><script type="math/tex; mode=display">\mathbf{q}\otimes\mathbf{p}\otimes\mathbf{q}^*=[\mathbf{q}]_L[\mathbf{q}]_R^T\mathbf{p}=\begin{bmatrix}p_w\\R\mathbf{p}_v\end{bmatrix}\tag{26}</script><p>其中 $R$是 $\mathbf{q}$ 对应的旋转矩阵，$\mathbf{q}^*$ 是 $\mathbf{q}$ 的共轭， $p_w$ 为 $\mathbf{p}$ 的实部，  $\mathbf{p}_v$ 为  $\mathbf{p}$ 的虚部。</p><p>下面开始详细推导：  </p><script type="math/tex; mode=display">\begin{align*}q_{b_ib_{k+1} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}&=q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\end{bmatrix}&=q_{b_ib_{k+1} }^*\otimes q_{b_ib_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=q_{b_{k+1}b_{k} }\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&\approx \begin{bmatrix}1\\-\frac{1}{2}\omega\delta t\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\&=\begin{bmatrix}1\\\frac{1}{2}R\delta\theta_{b_{k}b^{\prime}_{k} }\end{bmatrix}\end{align*}\tag{27}</script><p>注意：上面推导过程，也可以用李代数的右扰动   $R\exp([\delta\theta_{k+1}]^{\land})$</p><p>只考虑公式 $(27)$ 中的虚部：</p><script type="math/tex; mode=display">\begin{align*}\delta\theta_{b_{k+1}b^{\prime}_{k+1} }&=R\delta\theta_{b_{k+1}b^{\prime}_{k+1} }\\&=\exp([-w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\\&\approx (I-[w\delta t]^{\land})\delta\theta_{b_{k}b^{\prime}_{k} }\end{align*}\tag{28}</script><p>那么，第 $k+1$ 时刻的旋转预积分的误差相对于第 $k$ 时刻的 雅可比为：</p><script type="math/tex; mode=display">f_{22}=\frac{\partial \delta\theta_{b_{k+1}b^{\prime}_{k+1} } }{\partial \delta\theta_{b_{k}b^{\prime}_{k} } }=I-[w\delta t]^{\land}\tag{29}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要研究上一帧的误差如何传到下一帧的，传递误差的方程是如何推导的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>三、预积分模型以及残差的构建</title>
    <link href="https://lukeyalvin.top/posts/285413d6.html"/>
    <id>https://lukeyalvin.top/posts/285413d6.html</id>
    <published>2022-05-09T13:22:59.000Z</published>
    <updated>2022-05-11T07:53:08.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="IMU的误差模型"><a href="#IMU的误差模型" class="headerlink" title="IMU的误差模型"></a>IMU的误差模型</h1><ul><li><strong>加速度计的误差模型</strong></li></ul><p>设导航系$G$为东北天，$g^G=(0,0,-9.81)^T$。</p><p>理论测量值：</p><script type="math/tex; mode=display">a_m^B=R_{BG}(a^G-g^G)\tag{1}</script><p>如果考虑高斯白噪声，bias，以及尺度因子(通常假设尺度因子为单位矩阵。)，则为：</p><script type="math/tex; mode=display">a_m^B=S_aR_{BG}(a^G-g^G)+n_a+b_a\tag{2}</script><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423171217806.png" alt="image-20220423171217806" style="zoom:50%;" /></p><ul><li><strong>陀螺仪的误差模型</strong></li></ul><p>考虑尺度因子，高斯白噪声，以及 bias, 陀螺仪的误差模型如下：</p><script type="math/tex; mode=display">w^b_m=S_gw^b+n_g+b_g\tag{3}</script><p>低端传感器，考虑加速度对陀螺仪的影响，即 g-灵敏度：</p><script type="math/tex; mode=display">w^b_m=S_gw^b+S_{ga}a^b+n_g+b_g\tag{4}</script><p>陀螺仪受四种噪声的影响分别如下图所示：</p><p><img src="/images/三、VIO预积分的残差构建以及雅可比求解/image-20220423190440715.png" alt="image-20220423190440715" style="zoom: 50%;" /></p><h1 id="IMU模型与运动积分"><a href="#IMU模型与运动积分" class="headerlink" title="IMU模型与运动积分"></a>IMU模型与运动积分</h1><p>忽略 scale 的影响，根据imu的误差模型我们可以假设：角速度读数会在真实值的基础上受到<strong>bias和白噪声</strong>的影响，加速度除了受到<strong>bias和白噪声</strong>的影响，还会受到<strong>重力</strong>的影响。因此我们可以从IMU中得到角速度和加速度的读数，如公式$(5)(6)$的等式左边，它们都是基于IMU坐标系的。</p><script type="math/tex; mode=display">\begin{align*}\tilde{w}^b&=w^b+b_g+n_g\tag{5}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\tilde{a}^b&=q_{bw}(a^w-g^w)+b_a+n_a\tag{6}\end{align*}</script><p>上标$ g$ 表示 gyro，a 表示 acc，$^w $表示在世界坐标系 world，$^b$表示imu 机体坐标系 body。IMU 的真实值为$w, a$, 测量值为$\tilde w, \tilde a$，测量值即为IMU的读数。 </p><p>我们知道<strong>角速度$w$</strong>积分得到<strong>姿态$q$</strong>，<strong>加速度$a$</strong>积分得到<strong>速度$v$</strong>，<strong>速度$v$</strong>积分得到<strong>位移$p$</strong>。而现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型， <strong>P(ose)（位置），V(elocity)（速度），Q(uaternion) （旋转）</strong>对时间的导数可写成：</p><script type="math/tex; mode=display">\begin{align*}\dot p_{wb}&=v^w_t\\\dot v^w_t &=a^w_t\\\dot q_{wb_t} &=q_{wb_t} \otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\end{align*}\tag{7}</script><p>它描述了 IMU坐标系 的姿势和速度的演变。</p><p>第三项，四元数求导参考 <a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0">一、VIO概述以及三维刚体运动知识点回顾</a></p><p> $t + \Delta t $时刻的状态是通过积分方程$(7)$获得的：</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+\int^{t+\Delta t}_t v^w(\tau)d\tau+\iint^{t+\Delta t}_t a^w d\tau^2\\v^w(t+\Delta t)&=v^w(t)+\int^{t+\Delta t}_t a^w d\tau\\q_{wb}(t+\Delta t)&=\int^{t+\Delta t}_t q_{wb}(\tau)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(\tau)\end{bmatrix}d\tau\end{align*}\tag{8}</script><p>根据积分的性质，这里的 $\tau$ 是把 $[t,t+\Delta t]$分割的无限小部分。</p><p>假设 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2} a^w \Delta t^2\\v^w(t+\Delta t)&=v^w(t)+ a^w \Delta t\\q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}(t)\Delta t\end{bmatrix}\end{align*}\tag{9}</script><p>根据公式$(5)(6)$可以将 $a^w$ 和 $q_{wb}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b}\end{bmatrix}$ 写成 IMU 测量的函数，因此 $(9)$ 变为:</p><script type="math/tex; mode=display">\begin{align*}p_{wb}(t+\Delta t)&=p_{wb}(t)+ v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t^2\\v^w(t+\Delta t)&=v^w(t)+g^w\Delta t+ q_{wb}(t)\left(\tilde a(t)-b_a(t)-n_a(t)\right)\Delta t\\q_{wb}(t+\Delta t)&= q_{wb}(t)\otimes \begin{bmatrix}0\\ \frac{1}{2}(\tilde{w}^b(t)-b_g(t)-n_g(t))\Delta t\end{bmatrix}\end{align*}\tag{10}</script><p>方程 $(10)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。<strong>这样就可以得到旋转，速度，平移与 IMU 读数之间的关系，进而可以根据IMU 的读数来估计位姿。</strong></p><h1 id="IMU预积分模型"><a href="#IMU预积分模型" class="headerlink" title="IMU预积分模型"></a>IMU预积分模型</h1><h2 id="IMU-预积分"><a href="#IMU-预积分" class="headerlink" title="IMU 预积分"></a>IMU 预积分</h2><p>如图所示，相机的采样频率是明显低于 IMU 的采样频率的，相机或激光一般在几十 HZ，而 IMU 可以达到几百 HZ，而在 SLAM 中我们通常是求解每一帧图像/激光的位姿，因此需要对两帧图像/激光之间的所有IMU观测进行累加，可以得到 $i$ 帧和 $j$ 帧两个关键帧之间的单个复合的测量值，我们称之为<strong>预积分</strong>。</p><p><img src="/images/3-预积分模型以及误差递推方程的推导/image-20220507202527649-16521033725156.png" alt="image-20220507202527649"></p><p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 $(10)$，我们发现：</p><script type="math/tex; mode=display">\begin{align*}{p_{wb} }_j&={p_{wb} }_i+\sum^{j-1}_{k=i}\left[v^w(t)\Delta t+\frac{1}{2}g^w\Delta t^2+\frac{1}{2}q_{wb_k}\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t^2\right]\\v^w_j&=v^w_i+g^w\Delta t_{ij}+ \prod^{j-1}_{k=i} q_{wb_k}(t)\left(\tilde a_k-b_{ak}-n_{ak}\right)\Delta t\\q_{wb_j}&= q_{wb_i}\otimes \begin{bmatrix}0\\ \frac{1}{2}\prod^{j-1}_{k=i}(\tilde{w}^b_k-b_{gk}-n_{gk})\Delta t\end{bmatrix}\end{align*}\tag{11}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。 $(11)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(11)$ 中的积分（直观地说，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_k}、k = i,…,j-1$ 的变化，因此有必要重新评估 $(11)$ 中的求和和乘积。</p><blockquote><p>这里没有找到离散形势下使用四元数的预积分推导相关资料，而在高博等人的《从零开始手写VIO》课程中，用的是如下连续形式进行推导的，事实上，我认为 $(12)$ 中的连续形式中在递推 $p_{wb_j}$的时候，对速度没有积分是不对的，此处暂且留疑点。</p></blockquote><p>同样的，连续形式下，可以得到:</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t+\iint_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t^2\\v^w_j&=v^w_i+\int_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t\\q_{wb_j}&=\int_{t\in[i,j]}q_{wb_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{12}</script><p>其中，不难发现，旋转 $q_{wb_i}$ 的变化，意味着所有未来旋转 $q_{wb_t}、t \in [i,j]$ 的变化，导致对 $(12)$中的积分进行重复计算。</p><p>一个很简单的公式转换，就可以将积分模型转为预积分模型：  </p><script type="math/tex; mode=display">q_{wb_t}=q_{wb_i}\otimes q_{b_ib_t}\tag{13}</script><p>其中 $\otimes$ 表示四元数的乘法，具体可以可以参考，<a href="https://lukeyalvin.top/posts/28639.html#B-%E5%9B%9B%E5%85%83%E6%95%B0"><strong>四元数的乘法运算</strong></a></p><p>那么， PVQ 积分公式中的积分项则变成相对于第 $i$ 时刻的姿态，而不是相对于世界坐标系的姿态，则公式$(12)$变换为：</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+q_{wb_i}\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\v^w_j&=v^w_i-g^w\Delta t+q_{wb_i}\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{wb_j}&=q_{wb_i}\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{14}</script><p>这样的话，积分里的把相对于世界坐标系的状态量 $q_{wb_i}$ 移出去了，积分里面都是相对于第 $i$ 时刻的状态量 $q_{b_ib_t}$。</p><p>定义预积分量如下，预积分量仅仅跟 IMU 测量值有关，它将一段时间内的 IMU 数据直接积分起来就得到了<strong>预积分量</strong>：  </p><script type="math/tex; mode=display">\begin{align*}\alpha_{b_ib_j}&=\iint_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t^2\\\beta_{b_ib_j}&=\int_{t\in[i,j]}(q_{b_ib_t}a^{b_t})\delta t\\q_{b_ib_j}&=\int_{t\in[i,j]}q_{b_ib_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t}\end{bmatrix}\delta t\end{align*}\tag{15}</script><p>由公式$(14)$与$(15)$重新整理PVQ的积分公式，有：</p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}p_{wb_j}\\v^w_{j}\\q_{wb_j}\\b^a_j\\b^g_j\end{bmatrix}=\begin{bmatrix}p_{wb_i}+v^w_i \Delta t-\frac{1}{2}g^w\Delta t^2+q_{wb_i}\alpha_{b_ib_j}\\v^w_i-g^w\Delta t+q_{wb_i}\beta_{b_ib_j}\\q_{wb_i}q_{b_ib_j}\\b^a_i\\b^g_i\end{bmatrix}\end{align*}\tag{16}</script><h2 id="IMU-预积分残差"><a href="#IMU-预积分残差" class="headerlink" title="IMU 预积分残差"></a>IMU 预积分残差</h2><p>定义：一段时间内 <strong>IMU 构建的预积分量作为测量值</strong>，对两时刻之间的状态量进行约束，  </p><script type="math/tex; mode=display">\begin{align*}\begin{bmatrix}r_p\\r_v\\r_q\\r_{ba}\\r_{bg}\end{bmatrix}_{15\times1}=\begin{bmatrix}q_{b_iw}(p_{wb_j}-p_{wb_i}-v^w_i \Delta t+\frac{1}{2}g^w\Delta t^2)-{\color{red}\alpha_{b_ib_j} }\\q_{b_iw}(v^w_j-v^w_i+g^w\Delta t)-{\color{red}\beta_{b_ib_j} }\\2[{\color{red}q_{b_jb_i} }\otimes(q_{b_iw}\otimes q_{wb_j})]_{xyz}\\b^a_j-b^a_i\\b^g_j-b^g_i\end{bmatrix}\end{align*}\tag{16}</script><p>上面误差中位移，速度，偏置都是直接相减得到。第三项是关于四元数的<strong>旋转误差</strong>，其中$[·]_{xyz }$表示只取四元数的虚部 $(x, y, z)$组成的三维向量。  </p><h2 id="IMU-预积分残差的离散形式"><a href="#IMU-预积分残差的离散形式" class="headerlink" title="IMU 预积分残差的离散形式"></a>IMU 预积分残差的离散形式</h2><p>使用 mid-point 方法，即两个相邻时刻$ k$到$ k+1$ 的位姿是用两个时刻的测量值$ a,w $的平均值来计算。参考公式$(11)(12)$:</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{b_ib_k}(a^{b_k}-b^a_k)+q_{b_ib_{k+1} }(a^{b_{k+1} }-b^a_k)]\\w&=\frac{1}{2}[(w^{b_k}-b^g_k)+(w^{b_{k+1} }-b^g_k)]\\{\color{blue}q_{b_ib_{k+1} } }&=q_{b_ib_k}\otimes\begin{bmatrix}1\\\frac{1}{2}\omega\delta t\end{bmatrix}\\{\color{blue}\alpha_{b_ib_{k+1} } }&=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta t +\frac{1}{2}a\delta t^2\\{\color{blue}\beta_{b_ib_{k+1} } }&=\beta_{b_ib_k}+a\delta t\\b^a_{k+1}&=b^a_k+n_{b^a_k}\delta t\\b^g_{k+1}&=b^g_k+n_{b^g_k}\delta t\end{align*}\tag{17}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要讨论IMU 的误差模型、积分模型以及预积分模型，读者可以清楚为什么使用预积分，以及如何构建预积分的残差。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【文献阅读】On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</title>
    <link href="https://lukeyalvin.top/posts/e6b6704d.html"/>
    <id>https://lukeyalvin.top/posts/e6b6704d.html</id>
    <published>2022-05-08T13:16:58.000Z</published>
    <updated>2022-05-08T13:17:50.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry"><a href="#On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry" class="headerlink" title="On-Manifold Preintegration for Real-Time Visual-Inertial Odometry"></a>On-Manifold Preintegration for Real-Time Visual-Inertial Odometry</h1><p>摘要：当前的视觉惯性里程计（VIO）方法能够通过非线性优化获得高度准确的状态估计。然而，随着轨迹随着时间的推移，实时优化很快变得不可行。尤其是惯性测量以高速率出现的时候，这个问题变得更加突出，因此导致优化中变量数量的快速增长。在本文中，我们<strong>通过预积分关键帧之间的惯性测量以得到单个相对运动约束</strong>。</p><p>我们的第一个贡献是一个预积分理论，它正确地解决了<strong>旋转群的流形结构</strong>。我们正式讨论生成测量模型以及旋转噪声的性质，并推导出最大后验状态估计器的表达式。我们的理论发展能够计算所有必要的雅可比矩阵，以分析形式的优化和后验偏差校正。</p><p>第二个贡献是表明预积分的 IMU 模型可以在因子图的统一框架下被整合到视觉-惯性流程中。这使得<strong>增量平滑算法</strong>的应用和<strong>视觉测量的无结构模型</strong>的使用成为可能，避免了对 3D 点的优化，进一步加速了计算。</p><p>我们在真实和模拟数据集上对我们的单目 VIO 流程进行了广泛的评估。结果证实，我们的建模工作可以实时进行准确的状态估计，优于最先进的方法。</p><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>使用相机和惯性传感器进行三维结构和运动估计已经受到机器人界的极大关注。两种传感器类型都便宜、无处不在且互补。<strong>移动相机</strong>是一种外感知传感器，它允许我们测量三维场景的外观和几何形状，直至未知的度量尺度；<strong>惯性测量单元 (IMU)</strong> 是一种本体感受传感器，可呈现单目视觉和重力可视化的度量尺度 [1]，并提供稳健且准确的帧间运动估计。<strong>视觉惯性里程计（VIO）</strong>的应用范围从无GPS环境的自动驾驶到3D重建和增强现实。</p><p>现有的关于 VIO 的文献在准确性和计算效率之间进行了权衡（第 II 节给出了详细的回顾）。一方面，<strong>滤波方法</strong>可以实现快速推断，但其准确性会因线性化误差的累积而下降。另一方面，<strong>基于非线性优化的完全平滑方法</strong>是准确的，但计算量很大。固定滞后平滑（$Fixed-lag\ Smoothing$）在精度和效率之间提供折中；但是，尚不清楚如何设置估计窗口的长度以保证给定的性能水平。</p><p>在这项工作中，我们表明可以克服这种权衡。我们设计了一个 VIO 系统，可以实现快速增量平滑并实时计算最优的最大后验 (MAP) 估计。第IV给出了我们方法的概述。</p><p>实现这一目标的第一步是发展一个新的预积分理论。在 [2] 中首次提出使用预积分 IMU 测量，其组合两个关键帧间的许多惯性测量为单个相对运动约束。我们在这项工作的基础上提出了一个预积分理论，该理论正确地<strong>解决了旋转群 $SO(3)$ 的流形结构</strong>。我们的预积分理论在第 V-VI 节中介绍。与[2]相比，我们的理论对旋转噪声提供了更正式的处理，并避免了旋转表示中的奇异性。此外，我们能够以解析形式推导出所有必要的雅可比矩阵：具体来说，我们在本文的附录中报告了残差、噪声传播和后验偏差校正的解析雅可比矩阵。</p><p>我们的第二个贡献是<strong>将 IMU 预积分理论框架化为因子图模型</strong>。这使得增量平滑算法的应用成为可能，如 iSAM2 [3]，它避免了线性化误差的累积，并提供了一种优雅的方式来权衡精度和效率。受 [4, 5] 的启发，我们还<strong>采用无结构模型进行视觉测量</strong>，允许在增量平滑期间消除大量变量（即所有 3D 点），从而进一步加速计算（第 VII 节）。与 [5] 相比，我们在增量平滑框架中使用无结构模型。这有两个主要优点：我们不需要延迟视觉测量的处理，我们可以多次重新线性化视觉测量。</p><p>为了证明我们模型的有效性，我们将提议的 IMU 预积分集成到最先进的 VIO 流程中，并在真实和模拟数据集 2（第 VIII 节）上对其进行了测试。我们的理论发展带来了切实的实际优势：本文提出的方法的实现以 100 Hz 的速率执行完全平滑，并相对于具有竞争力的最先进的过滤和优化方法实现了卓越的精度。</p><p>除了技术贡献，论文还为实践者提供了教程贡献。在第III部分和整篇论文中，我们对流形上的不确定性表示以及不确定性传播和雅可比计算的示例推导进行了简短而简洁的总结。所有方程和雅可比矩阵的完整推导——实现我们的模型所必需的——在附录中给出。</p><p>本文是我们之前工作 [6] 的扩展，包括额外的实验、对相关工作的深入讨论和全面的技术推导。新实验的结果突出了偏差估计的准确性，证明了我们方法的一致性，并提供了与全批次估计的比较。我们在 GTSAM 4.0 优化工具箱中发布了预集成 IMU 和无结构视觉因素的实现。</p><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>视觉惯性里程计的相关工作可以沿着三个主要维度进行划分。<strong>第一个维度是 在估计中涉及的相机位姿的数量。</strong>虽然完全平滑器（$full\ smoothers$）（或批量非线性最小二乘算法（$batch\ nonlinear\ least-squares\ algorithms$）估计姿势的完整历史，但固定滞后平滑器（$fixed-lag\ smoothers$）（或滑动窗口估计器（$fixed-lag\ smoothers$）考虑最新姿势的窗口，而过滤方法仅估计最新状态。固定滞后平滑器和滤波器都会<strong>边缘化</strong>旧状态并<strong>吸收</strong>高斯先验中的相应信息。</p><p><strong>第二个维度是 关于测量不确定性和高斯先验的表示</strong>：扩展卡尔曼滤波器 (EKF) 使用协方差矩阵表示不确定性；相反，信息滤波器和平滑器求助于信息矩阵（协方差的倒数）或信息矩阵的平方根 [3, 8]</p><p>最后，<strong>第三个维度 通过查看测量模型线性化的次数来区分现有方法。</strong>虽然标准 EKF（与迭代 EKF 相比）只处理一次测量，但平滑方法允许多次线性化。</p><p>虽然术语很多，但底层算法是紧密相关的。例如，可以证明<strong>迭代扩展卡尔曼滤波器方程等价于高斯牛顿算法</strong>，通常用于平滑 [9]</p><h2 id="A-滤波"><a href="#A-滤波" class="headerlink" title="A. 滤波"></a>A. 滤波</h2><p>滤波算法通过将推理过程限制在系统的最新状态来实现有效的估计。 EKF 的复杂性在估计的地标数量上呈二次增长，因此，通常会跟踪少量地标（大约 20 个）以允许实时操作 [10-12]。另一种方法是采用<strong>“无结构”方法</strong>，其中地标位置被<strong>边缘化</strong>出状态向量。这种策略的一个很好的例子是<strong>多状态约束卡尔曼滤波器</strong>（$Multi-State\ Constraint\ Kalman\ filter\ ，MSC-KF$）[5]。无结构方法需要通过<strong>随机克隆</strong>（$stochastic\ cloning$） [13] 将先前的姿势保留在状态向量中。</p><p>使用无结构方法进行过滤的一个缺点是，<strong>地标测量的处理</strong>需要延迟，直到获得地标的所有测量值 [5]。这会妨碍准确性，因为滤波器不能使用所有当前的视觉信息。<strong>边缘化</strong>也是错误的来源，因为它锁定了<strong>线性化误差</strong>和<strong>错误的异常值测量</strong>。因此，滤除虚假测量值尤为重要，因为单个异常值会不可逆转地破坏滤波器 [14]。此外，<strong>线性化误差</strong>会在估计中引入漂移并导致滤波器不一致。不一致的一个影响是<strong>估计器</strong>变得过于自信，导致非最优信息融合。通常，VIO 问题有四个不可观察的方向：<strong>全局位置</strong>和围绕重力方向（<strong>偏航</strong>，yaw）的方向 [15, 16]。在 [16] 中表明，<strong>错误估计的线性化</strong>仅导致三个不可观察的方向（全局位置）；因此，错误的线性化将偏航方向的虚假信息添加到高斯先验中，从而导致滤波器不一致。这个问题已通过<strong>首次估计雅可比方法</strong> （$first-estimates\ jacobian$）[17] 得到解决，<strong>该方法确保状态不会使用不同的线性化点进行更新</strong>——这是不一致的来源。在可观察性约束（$observability-constrained$）的 EKF (OC-EKF) 中，维持对不可观察方向的估计，这允许仅在可观察的方向上更新滤波器 [16, 18]。在 [1, 15, 19] 中给出了对 VIO 可观察性属性的全面分析。</p><h2 id="B-固定滞后平滑"><a href="#B-固定滞后平滑" class="headerlink" title="B.固定滞后平滑"></a>B.固定滞后平滑</h2><p>固定滞后平滑器（$fixed-lag\ smoothers$）估计落在给定时间窗口内的状态，同时边缘化较旧的状态[20-24]。在最大似然估计设置中，固定滞后平滑器会<strong>导致一组最近状态的优化问题</strong>。对于非线性问题，<strong>平滑方法</strong>通常比滤波更准确，因为它们会<strong>重新线性化过去的测量</strong> [25]。此外，这些方法<strong>对异常值更具弹性</strong>，可以在后验（即优化之后）丢弃，或者可以通过使用鲁棒代价函数来缓解。不利的一面是，<strong>估计窗口外的状态边缘化会导致密集的高斯先验，从而阻碍有效的推理。</strong>出于这个原因，有人提出为了<strong>稀疏性</strong>而放弃某些测量值[24]。此外，由于边缘化，固定滞后平滑器具有过滤的部分问题（一致性、线性化误差的累积）[18、22、26]。</p><h2 id="C-完全平滑"><a href="#C-完全平滑" class="headerlink" title="C. 完全平滑"></a>C. 完全平滑</h2><p>完全平滑（$Full\ Smoothing$）方法<strong>通过解决大型非线性优化问题来估计状态的整个历史</strong>（相机轨迹和 3D 地标）[27-31]。全平滑保证了最高精度；然而，随着轨迹和地图随着时间的推移而增长，实时操作很快变得不可行。因此，已经提出丢弃除选定<strong>关键帧</strong>之外的帧 [24, 32-34] 或使用<strong>跟踪和建图双重架构</strong> [20, 35] 在并行线程中运行优化。一项突破是<strong>增量平滑技术</strong>（$incremental\ smoothing\ techniques$）（iSAM [36]、iSAM2 [3]）的发展，该技术<strong>利用因子图的表达性来保持稀疏性，并仅识别和更新受新测量影响的通常较小的变量子集。</strong></p><p>尽管如此，高频率的惯性测量（通常为 $100 Hz$ 至 $1 kHz$）仍然对平滑方法构成挑战。一个简单的实现需要在每次 IMU 测量时添加一个新状态，这很快就会变得非常慢 [37]。因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。<strong>对于两帧之间的标准 IMU 集成，初始条件由第一帧的状态估计给出。</strong>因此，惯性测量通常在帧之间集成以形成相对运动约束[24,30,38-40]。对于两帧之间的标准 IMU 积分，初始条件由第一帧的状态估计给出。然而，<strong>在优化的每次迭代中，状态估计都会发生变化，这需要在所有帧之间重复 IMU 积分</strong>[24]。 Lupton 和 Sukkarieh [2] 表明，<strong>通过重新参数化相对运动约束可以避免这种重复积分。这种重新参数化称为 IMU 预积分。</strong></p><p>在目前的工作中，我们以开创性工作 [2] 为基础，通过适当<strong>解决旋转群 SO(3) 的流形结构</strong>，使 IMU 预积分理论走向成熟。工作[2]采用欧拉角作为旋转的全局参数。在刚性变换的作用下，使用欧拉角并应用欧几里得空间的通常平均和平滑技术进行状态传播和协方差估计并不具有不变性[41, 42]。此外，欧拉角具有奇异性。我们的研究，另一方面，提供了一个正式的旋转测量的表示（和对应噪声），并提供了完整的最大后验估计量的推导。我们还推导出雅可比矩阵的解析表达式（优化所需），据我们所知，这些表达式以前没有在文献中报道过。在实验部分，我们表明旋转流形的正确表示会导致更高的准确性和鲁棒性，从而比原始提议 [2] 带来切实的优势。</p><h1 id="三、预备知识"><a href="#三、预备知识" class="headerlink" title="三、预备知识"></a>三、预备知识</h1><p>在本文中，我们根据 MAP 估计来制定 VIO。在我们的模型中，MAP 估计会导致非线性优化问题，该问题涉及存在于<strong>平滑流形</strong>上的量（例如，旋转、姿势）。因此，在深入研究细节之前，我们方便地回顾一些有用的几何概念。专家读者可以跳过本节。</p><p>我们将本节结构如下：第 III-A 节提供了与两个主要<strong>黎曼流形</strong>相关的有用概念：<strong>特殊正交群</strong> $SO(3)$ 和<strong>特殊欧几里得群</strong>$ SE(3)$。我们的介绍基于 [43, 44]。第 III-B 节描述了一个合适的模型来描述$ SO(3) $中的不确定旋转。第 III-C 节根据标准参考文献 [45] 回顾了流形上的优化。</p><h2 id="A-黎曼几何的概念"><a href="#A-黎曼几何的概念" class="headerlink" title="A. 黎曼几何的概念"></a>A. 黎曼几何的概念</h2><p>a) 特殊正交群：SO(3) 描述了一组 3D 旋转矩阵，正式定义为$SO(3)\doteq \{R\in\mathbb{R}^{3\times3}:R^TR=I,\det(R)=1\}.$群运算就是通常的矩阵乘法，逆运算就是矩阵转置。群 $ SO(3) $也形成一个<strong>光滑的流形</strong>。流形（恒等式）的<strong>切线空间表示</strong>为 $\mathfrak{so}(3)$，也称为<strong>李代数</strong>，与 $3\times3$ 斜对称矩阵的空间重合。我们可以使用$hat$算子在 R3 中用一个向量识别每个倾斜对称矩阵：</p><script type="math/tex; mode=display">w^{\land}=\begin{bmatrix}w_1\\w_2\\w_3\end{bmatrix}^{\land}=\begin{bmatrix}0&-w_3&w_2\\w_3&0&-w_1\\-w_2&w_1&0\end{bmatrix}\in\mathfrak{so}(3).\tag{1}</script><p>类似地，我们可以使用 $vee $算子$(\cdot)^{\lor}$ 将斜对称矩阵映射到$\mathbb{R}^3 $中的向量：对于<strong>斜对称矩阵</strong> $S= ω^{\land}$，$vee $ 算子使得 $S^{\lor}= ω$。稍后将有用的斜对称矩阵的属性是：</p><script type="math/tex; mode=display">a^{\land}b=-b^{\land}a,\forall a,b\in\mathbb{R}^3.\tag{2}</script><p><strong>指数映射</strong>（恒等式）$ \exp : \mathfrak{so}(3)\rightarrow SO(3)$将李代数的一个元素与旋转相关联，并与标准矩阵指数（罗德里格斯公式）一致：</p><script type="math/tex; mode=display">\exp(\phi)^{\land}=I+\frac{\sin(\parallel\phi\parallel)}{\parallel\phi\parallel}\phi^{\land}+\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel}(\phi^{\land})^2.\tag{3}</script><p>我们稍后将使用的指数映射的一阶近似是：</p><script type="math/tex; mode=display">\exp(\phi)^{\land}\approx I+\phi^{\land}.\tag{4}</script><p><strong>对数映射</strong>（恒等式）将 $SO(3)$ 中的矩阵 $R\ne I $与斜对称矩阵相关联：</p><script type="math/tex; mode=display">\log(R)=\frac{\varphi\cdot(R-R^T)}{2\sin(\varphi)},\varphi=\cos^{-1}(\frac{\tr(R)-1}{2}).\tag{5}</script><p>注意$ \log(R)^{\lor}= a\varphi$，其中 $a $和 $\varphi $分别是 $R$ 的旋转轴和旋转角度。如果 $R = I$，则 $\varphi= 0 $，并且 $a$ 是不确定的，因此可以任意选择。</p><p>如果限制在一个开放的球内$\parallel\phi\parallel&lt;\pi$，<strong>指数映射</strong>是<strong>双射</strong>，对应的逆是<strong>对数映射</strong>。然而，如果我们不限制定义域，指数映射就会变成<strong>满射</strong>的，因为每个向量$ \phi= (\varphi + 2k\pi)a, k \in \mathbb{Z}$ 将是 $R$ 的一个可容许对数。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507100016617.png" alt="image-20220507100016617"></p><p>为了符号方便，我们采用指数和对数图的“矢量化”版本：</p><script type="math/tex; mode=display">\begin{align*}Exp&:\ \mathbb{R}^3\rightarrow SO(3)\ ;\ \phi\mapsto \exp(\phi^{\land})\\Log&:\ SO(3)\rightarrow \mathbb{R}^3\ ;\ R\mapsto \log(R)^{\lor}\end{align*}\tag{6}</script><p>它直接对向量进行操作，而不是对$ \mathfrak{so}(3) $中的斜对称矩阵进行操作。</p><p>稍后，我们将使用以下一阶近似：</p><script type="math/tex; mode=display">Exp(\phi+\delta\phi)\approx Exp(\phi)\ Exp(J_r(\phi)\delta\phi).\tag{7}</script><p>$J_r(\phi)$是$SO(3)$ [43, p.40] 的右雅可比行列式，并将切线空间中的加法增量与右侧应用的乘法增量相关联（图 1）：</p><script type="math/tex; mode=display">J_r(\phi)=I-\frac{1-\cos(\parallel\phi\parallel)}{\parallel\phi\parallel^2}\phi^{\land}+\frac{\parallel\phi\parallel-\sin(\parallel\phi\parallel)}{\parallel\phi^3\parallel}(\phi^{\land})^2.\tag{8}</script><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507102404953.png" alt="image-20220507102404953" style="zoom: 50%;" /></p><blockquote><p>图 1：右雅可比$ J_r $将切线空间中的加性微扰 $\delta\phi$ 与流形$ SO(3)$ 上的乘性微扰联系起来，如方程。 (7)。</p></blockquote><p>类似的一阶近似适用于对数：</p><script type="math/tex; mode=display">Log(Exp(\phi)\ Exp(\delta\phi))\approx\phi+J_r^{-1}(\phi)\delta\phi.\tag{9}</script><p>右雅可比行列式的倒数是:</p><script type="math/tex; mode=display">\begin{align*}J_r^{-1}=I+\frac{1}{2}\phi^{\land}+\left(\frac{1}{\parallel\phi\parallel^2}+\frac{1+\cos(\parallel\phi\parallel)}{2\parallel\phi\parallel\sin(\parallel\phi\parallel)}\right)(\phi^{\land})^2,\end{align*}</script><p>当$\parallel\phi\parallel= 0$ 时，右雅可比 $J_r(\phi)$ 及其逆$J_r^{-1}(\phi)$简化为单位矩阵。</p><p>指数映射的另一个有用属性是：</p><script type="math/tex; mode=display">\begin{align*}&R \ Exp(\phi)R^T=\exp(R\phi^{\land}R^T)=Exp(R\phi)\tag{10} \\ &\Leftrightarrow Exp(\phi)R=RExp(R^T\phi)\tag{11}\end{align*}</script><p>b) 特殊欧几里得群：$SE(3)$ 描述了 $3D$ 中刚体运动的群，是 $SO(3)$ 和 $\mathbb{R}^3 $的半直积，定义为 $SE(3) \doteq \{(R, p ) : R \in SO(3), p \in\mathbb{R}^3\}$。给定 $T_1, T_2 ∈ SE(3)$，组运算为$ T_1 \cdot T_2 = (R_1R_2 , p_1 + R_1p_2)$，逆运算为$ T_1^{-1} = (R^T_1 , −R^T_1 p_1)$。 $SE(3)$的指数映射和对数映射在 [44] 中定义。但是，本文不需要这些，原因将在第 III-C 节中明确说明。</p><h2 id="B-SO-3-中的不确定性描述"><a href="#B-SO-3-中的不确定性描述" class="headerlink" title="B. SO(3) 中的不确定性描述"></a>B. SO(3) 中的不确定性描述</h2><p>$SO(3)$中不确定性的自然定义是定义切线空间中的分布，然后通过指数映射$(6)$[44, 46, 47] 将其映射到$ SO(3)$：</p><script type="math/tex; mode=display">\tilde{R}=R\ Exp(\epsilon),\epsilon \sim\mathcal{N}(0,\Sigma),\tag{12}</script><p>其中 $R$是给定的无噪声旋转（平均值）并且$\epsilon$是一个小的正态分布扰动，均值为零，协方差为$\Sigma$。</p><p>为了获得 $R$分布的显式表达式，我们从$\mathbb{R}^3$中高斯分布的积分开始：</p><script type="math/tex; mode=display">\int_{\mathbb{R}^3}p(\epsilon)d\epsilon=\int_{\mathbb{R}^3}\alpha e^{-\frac{1}{2}\parallel\epsilon\parallel^2_{\Sigma} }d\epsilon=1,\tag{13}</script><p>其中$ \alpha= 1/\sqrt{(2\pi)^3 \det(\Sigma)} $， $\parallel\epsilon\parallel^2_{\Sigma}\doteq\epsilon^T\Sigma^{-1}\epsilon$是具有协方差 $\Sigma$ 的平方<strong>马氏距离</strong>。然后，应用坐标的变化$\epsilon = Log(R^{−1}\tilde{R})$ （当$ \parallel\epsilon\parallel&lt;\pi$ 时，这是 $(12)$ 的倒数），积分 $(13)$ 变为：</p><script type="math/tex; mode=display">\int_{SO(3)}\beta(\tilde{R})e^{-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma}}d\tilde{R}=1,\tag{14}</script><p>其中 $\beta(\tilde{R})$是归一化因子。归一化因子的形式为 $\beta(\tilde{R})= α/|\det\left(\mathcal{J} (\tilde{R})\right)|$，其中$ \mathcal{J} (\tilde{R}) \doteq J_r( Log(R^{-1}\tilde{R})) $，并且$ J_r(·)$ 是右雅可比行列式 $(8)$；$\mathcal{J} (\tilde{R})$ 是变量变化的副产品，推导参见 [46]。</p><p>根据$ (14) $的论点，我们可以直接读取 $SO(3)$ 中的“高斯”分布：</p><script type="math/tex; mode=display">p(\tilde{R})=\beta(\tilde{R})e^{-\frac{1}{2} \parallel Log(R^{-1}\tilde{R}) \parallel^2_{\Sigma} }.\tag{15}</script><p>对于小的协方差，我们可以逼近$ β\simeqα$，因为当接$\tilde{R}$近 $R$ 时，$J_r( Log(R^{-1}\tilde{R}))$ 可以很好地由单位矩阵逼近。请注意，$(14)$ 已经假设协方差 $\Sigma$相对较小，因为它“剪裁”了半径为 $\pi$的开放球之外的概率尾部（这是由于重新参数化$\epsilon = Log(R^{−1}\tilde{R})$，将 $\epsilon $限制为 $\parallel\epsilon\parallel &lt; \pi$）。将$ β$ 近似为一个常数，给定一个如$(15)$中分布的测量值$\tilde{R}$，旋转 $R$ 的负对数似然是：</p><script type="math/tex; mode=display">\mathcal{L}(R)=\frac{1}{2}\parallel Log(R^{−1}\tilde{R}) \parallel^2_{\Sigma}+const=\frac{1}{2}\parallel Log(\tilde{R}^{−1}R) \parallel^2_{\Sigma}+const.\tag{16}</script><p>几何上可以解释为由逆不确定性$Σ^{-1}$加权的$\tilde{R}$和$R$之间的平方角（$SO(3)$中的测地线距离）。</p><h2 id="C-流形上的高斯-牛顿法"><a href="#C-流形上的高斯-牛顿法" class="headerlink" title="C. 流形上的高斯-牛顿法"></a>C. 流形上的高斯-牛顿法</h2><p>欧几里得空间中的标准高斯-牛顿方法通过反复优化（通常为非凸的）目标函数的二次近似来工作。求解二次近似简化为求解一组线性方程（正规方程），并且这个局部近似的解用于更新当前估计。在这里，我们回顾一下如何将这种方法扩展到（无约束的）优化问题，其变量属于某个流形 $\mathcal{M}$。让我们考虑以下优化问题：</p><p>让我们考虑以下优化问题：</p><script type="math/tex; mode=display">\underset{x\in\mathcal{M} }{\min}f(x),\tag{17}</script><p>其中变量 $x$ 属于流形$\mathcal{M}$；为简单起见，我们在 $(17)$ 中考虑单个变量，而描述很容易推广到多个变量。</p><p>与欧几里得情况相反，不能直接将 $(17) $近似为 $x$ 的二次函数。这是由于两个主要原因。首先，直接在 $x$上工作会导致问题的过度参数化（例如，我们对具有 $9$ 个元素的旋转矩阵进行参数化，而 $3D$ 旋转完全由 $\mathbb{R}^3$中的向量定义），这会使正规方程不确定，其次，所得近似的解一般不属于 $\mathcal{M}$。</p><p>流形优化的标准方法 [45, 48] 包括定义<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$，它是切线空间（在$ x$ 处）的元素 $\delta x$ 和 $x \in\mathcal{M} $的邻域之间的<strong>双射映射</strong>。使用回缩（$retraction$），我们可以将我们的问题重新参数化如下：</p><script type="math/tex; mode=display">\underset{x\in\mathcal{M} }{\min}f(x)  \Longrightarrow \underset{\delta x\in\mathbb{R}^n }{\min}f(\mathcal{R}_x(\delta x)).\tag{18}</script><p>重新参数化通常称为<strong>提升</strong>（$lifting$） [45]。粗略地说，我们在当前估计定义的切空间中工作，该空间在局部表现为欧几里得空间。使用<strong>回缩</strong>（$retraction$）允许在合适维度的欧几里德空间上构建优化问题（例如，当我们在 $SO(3) $中工作时，$\delta x ∈ \mathbb{R}^3$）。</p><p>我们现在可以将标准优化技术应用于 $(18) $右侧的问题。在 Gauss-Newton 框架中，我们将当前估计的成本平方。然后我们求解二次逼近得到一个向量$\delta x^{\star}$在切线空间。最后，流形上的当前猜测被更新为:</p><script type="math/tex; mode=display">\hat{x}\leftarrow \mathcal{R}_{\hat{x} }(\delta x^{\star}).\tag{19}</script><p>这种“lift-solve-retract”方案可以推广到任何信任区域方法[45]。此外，它提供了错误状态模型的基础和统一概括，该模型通常用于航空航天文献中的过滤[49]，最近在机器人技术中用于优化[23, 34]。</p><p>我们通过讨论<strong>回缩</strong>（$retraction$）$ \mathcal{R}_x$的选择来结束本节。一个可能的<strong>回缩</strong>（$retraction$）是指数映射。众所周知，在计算上，这可能不是最方便的选择，参见 [50]。</p><p>这项工作中，我们对 $SO(3)$ 使用以下<strong>回缩</strong>（$retraction$），</p><script type="math/tex; mode=display">\mathcal{R}_R(\phi)=R\ Exp(\delta\phi),\ \ \delta\phi\in\mathbb{R}^3,\tag{20}</script><p>对于$SE(3)$，我们使用$ T \doteq(R, p) $处的<strong>回缩</strong>（$retraction$）：</p><script type="math/tex; mode=display">\mathcal{R}_T(\delta\phi,\delta p)=(R\ Exp(\delta\phi),p+R\delta p),\ \ [\delta\phi\ \delta p]\in\mathbb{R}^6,\tag{21}</script><p>这就解释了为什么在第 III-A 节中我们只定义了 $SO(3)$ 的指数映射：通过这种<strong>回缩</strong>（$retraction$）选择，我们永远不需要计算 SE(3) 的指数映射。</p><h1 id="四、最大后验视觉惯性状态估计"><a href="#四、最大后验视觉惯性状态估计" class="headerlink" title="四、最大后验视觉惯性状态估计"></a>四、最大后验视觉惯性状态估计</h1><p>我们考虑一个VIO问题，其中我们想跟踪一个<strong>感知系统</strong>（$sensing\ system$）（例如，一个自主机器人，一个UAV，或者一个手持设备）的状态，其装备一个IMU和一个单目相机。我们假设IMU坐标系“B”和我们想要跟踪的身体坐标系重合，相机和IMU之间的变换是固定的，并且通过之前的标定已经知道（见图2）。此外，我们假设一个前端提供在未知位置的3D路标的图片测量。前端还选择一组图片，称为<strong>关键帧</strong>[32]，我们想计算它的位姿估计。第7节-B1讨论了应用，包括我们实验的前端选择。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507153228526.png" alt="image-20220507153228526" style="zoom:50%;" /></p><blockquote><p>图 2：$T_{WB}\doteq  (R_{WB}, _\mathrm{W}\mathbf{p})$ 是Body坐标系相对于世界坐标系 $W$的位姿。我们假设Body坐标与 IMU 坐标系重合。 $T_{BC}$ 是相机在Body坐标中的位姿，由先验标定已知。</p></blockquote><h2 id="A-状态"><a href="#A-状态" class="headerlink" title="A. 状态"></a>A. 状态</h2><p>系统在时间 $i $的状态由 IMU 方向、位置、速度和偏差描述：</p><script type="math/tex; mode=display">\mathrm{x}_i\doteq    [R_i,\mathbf{p}_i,\mathbf{v}_i,\mathbf{b}_i].\tag{22}</script><p>姿态 $(R_i,\mathbf{p}_i)$属于$ SE(3)$，而速度存在于向量空间中，即 $\mathbf{v}_i \in \mathbb{R}^3$。 IMU 偏差可以写为 $\mathbf{b}_i = [\mathbf{b}_i^g\ \ \mathbf{b}_i^a] \in \mathbb{R}^6$，其中 $\mathbf{b}_i^g\ , \mathbf{b}_i^a\in \mathbb{R}^3 $分别是陀螺仪和加速度计偏差。</p><p>令 $\mathcal{K}_k$ 表示直到时间 $k$ 的所有关键帧的集合。在我们的方法中，我们估计所有关键帧的状态：</p><script type="math/tex; mode=display">\mathcal{X}_k\doteq    \{\mathrm{x}_i\}_{i\in\mathcal{K_k} }.\tag{23}</script><p>在我们的实现中，我们采用了<strong>无结构</strong>的方法（参见第 VII 节），因此 3D 地标不是要估计的变量。但是，提出的方法可以推广到一般方法来估计路标和相机内参以及外参。</p><h2 id="B-测量"><a href="#B-测量" class="headerlink" title="B. 测量"></a>B. 测量</h2><p>我们估计问题的<strong>输入是来自相机和 IMU 的测量值</strong>。我们用 $\mathcal{C}_i$表示关键帧$i$处的图像测量值。在时间 $i$，相机可以观察到多个地标 $l$，因此 $\mathcal{C}_i$包含多个图像测量值 $\mathrm{z}_{il}$。我们稍微滥用符号，我们记 $ l \in \mathcal{C}_i$ 为在 $i$ 时刻看到地标 $l$ 。</p><p>我们用 $\mathcal{I}_{ij}$ 表示在两个连续关键帧 $i$ 和 $j$ 之间获得的<strong>一组 IMU 测量值</strong>。根据 IMU 测量速率和所选关键帧的频率，每个集合 $\mathcal{I}_{ij}$ 可以包含从少量到数百个 IMU 测量值。到时间 $k$ 收集的测量值集是:</p><script type="math/tex; mode=display">\mathcal{Z}_k\doteq\{\mathcal{C}_i,\mathcal{I}_{ij}\}_{(i,j)\in\mathcal{K}_k}.\tag{24}</script><h2 id="C-因子图和-MAP-估计"><a href="#C-因子图和-MAP-估计" class="headerlink" title="C. 因子图和 MAP 估计"></a>C. 因子图和 MAP 估计</h2><p>给定可用的视觉和惯性测量 $\mathcal{Z}_k$ 和先验 $p(\mathcal{X}_0)$，变量 $\mathcal{X}_k$ 的后验概率为：</p><script type="math/tex; mode=display">\begin{align*}p(\mathcal{X}_k|\mathcal{Z}_k)&\propto p(\mathcal{X}_0)\ p(\mathcal{X}_k|\mathcal{Z}_k)\overset{(a)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{C}_i,\mathcal{I}_{ij}|\mathcal{X}_k)\\&\overset{(b)}{=}p(\mathcal{X}_0)\prod_{(i,j)\in\mathcal{K}_k}p(\mathcal{I}_{ij}|\mathrm{x}_i,\mathrm{x}_j)\prod_{i\in\mathcal{K}_k}\prod_{l\in\mathcal{C}_i}p(\mathrm{z}_{il}|\mathrm{x}_i)\end{align*}\tag{25}</script><p>分解 $(a)$ 和 $(b)$ 遵循测量之间的标准独立假设。此外，马尔可夫属性应用于$(b)$（例如，时间 $i$ 的图像测量仅取决于时间 $i$ 的状态）。</p><p>由于测量值 $\mathcal{Z}_k$ 是已知的，我们可以自由地将它们作为变量消除，并将它们视为<strong>实际未知数的联合概率因子</strong>的参数。这自然会导致众所周知的因子图表示，这是一类可用于表示这种因子密度的<strong>二分图模型</strong> [51, 52]。图 3 给出了 VIO 问题背后的因子图的连通性示意图（无结构视觉因子的连通性将在第 VII 节中阐明）。<strong>因子图</strong>由<strong>未知数节点</strong>和定义在其上的<strong>概率因子节点</strong>组成，<strong>图结构表示每个因子涉及哪些未知数</strong>。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507162306950.png" alt="image-20220507162306950"></p><blockquote><p>图 3：左：VIO 中的视觉和惯性测量。右图：因子图，其中几个 IMU 测量值汇总在单个预积分 IMU 因子中，无结构视觉因子约束关键帧观察相同的地标。</p></blockquote><p>MAP 估计 $\mathcal{X}_k^{\star}$ 对应于 $(25)$ 的最大值，或者等效地，负对数后验的最小值。在零均值高斯噪声的假设下，<strong>负对数后验</strong>可以写为<strong>残差平方和</strong>：</p><script type="math/tex; mode=display">\begin{align*}\mathcal{X}_k^{\star}&\doteq\arg\underset{\mathcal{X}_k}{\min}-\log_ep(\mathcal{X}_k|\mathcal{Z}_k)\\&=\arg\underset{\mathcal{X}_k}{\min}\parallel r_0 \parallel^2_{\Sigma_0}+\sum_{(i,j)\in\mathcal{K}_k}\parallel r_{\mathcal{I}_{ij} } \parallel^2_{\Sigma_{ij} }+\sum_{i\in\mathcal{K}_k}\sum_{j\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\end{align*}\tag{26}</script><p>其中 $r_0,r_{\mathcal{I}_{ij} },r_{\mathcal{C}_{il} }$ 是与测量相关的<strong>残差</strong>，而 $\Sigma_0,\Sigma_{ij} $和 $\Sigma_{\mathcal{C} }$ 是相应的<strong>协方差矩阵</strong>。粗略地说，残差是 $\mathcal{X}_k$ 的函数，其在给定状态 $\mathcal{X}_k$ 和先验的前提下，量化测量值和预测值的差。以下部分的目标是提供残差和协方差的表达式。</p><h1 id="五、IMU模型与运动积分"><a href="#五、IMU模型与运动积分" class="headerlink" title="五、IMU模型与运动积分"></a>五、IMU模型与运动积分</h1><p>IMU 通常包括一个 3 轴加速度计和一个 3 轴陀螺仪，，并允许我们来测量传感器相对一个惯性坐标系的旋转速度和加速度。测量值，即 $_B\tilde{a}(t)$ 和 $_B\tilde{w}_{WB}(t)$，受加性白噪声 $\eta$ 和缓慢变化的传感器偏差 $\mathbf{b}$ 的影响：</p><script type="math/tex; mode=display">\begin{align*}_\mathrm{B}\tilde{\omega}_{\mathrm{WB} }(t)&= \ _\mathrm{B}\omega_{\mathrm{WB} }(t)+\mathbf{b}^g(t)+\mathbf{\eta}^g(t)\tag{27}\\_\mathrm{B}\tilde{a}(t)&=R^T_{\mathrm{WB} }(t)(\ _\mathrm{W}\mathbf{a}(t)-\ _\mathrm{W}\mathbf{g})+\mathbf{b}^a(t)+\mathbf{\eta}^a(t)\tag{28}\end{align*}</script><p>在我们的符号中，前缀 $\mathrm{B}$ 表示相应的量在坐标系中 $\mathrm{B}$ 表示（参见图 2）。 IMU 的位姿由变换 $\{R_\mathrm{WB},\ _\mathrm{W}p\}$ 描述，该变换将传感器坐标系 $\mathrm{B}$ 中的一个点映射到 $\mathrm{W}$ 。向量 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)\in \mathbb{R}^3$ 是坐标系 $\mathrm{B}$ 中表示的 $\mathrm{B}$ 相对于 $\mathrm{W}$ 的<strong>瞬时角速度</strong>，而$\ _\mathrm{W}\mathbf{a}(t)\in \mathbb{R}^3$是传感器的<strong>加速度</strong>； $\ _\mathrm{W}\mathbf{g}$ 是世界坐标中的<strong>重力加速度</strong>。我们忽略了地球自转的影响，这相当于假设 $\mathrm{W}$ 是一个惯性系。</p><p>现在的目标是从 IMU 测量中推断系统的运动。为此，我们引入了以下运动学模型 [49, 53]：</p><script type="math/tex; mode=display">\begin{align*}\dot{R}_\mathrm{WB}&={R}_\mathrm{WB}\ _B{\omega}^{\land}_\mathrm{WB}\\_\mathrm{W}\dot{\mathbf{v} }&=\ _\mathrm{W}\mathbf{a}\\_\mathrm{W}\dot{\mathbf{p} }&=\ _\mathrm{W}\mathbf{v}\end{align*}\tag{29}</script><p>它描述了 $\mathrm{B}$ 的姿势和速度的演变。</p><p> $t + \Delta t $时刻的状态是通过积分方程$(29)$获得的：</p><script type="math/tex; mode=display">\begin{align*}{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\int^{t + \Delta t }_t\ _B{\omega}_\mathrm{WB}(\tau)d\tau\right) \\_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+ \int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau\\_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\int^{t + \Delta t }_t\  _\mathrm{W}\mathbf{v}(\tau)d\tau+\iint^{t + \Delta t }_t\  _\mathrm{W}\mathbf{a}(\tau)d\tau^2\end{align*}</script><p>假设 $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$ 在时间间隔 $[t, t + \Delta t]$ 内保持不变，我们可以写成：</p><script type="math/tex; mode=display">\begin{align*}{R}_\mathrm{WB}(t + \Delta t )&={R}_\mathrm{WB}(t)Exp\left(\ _B{\omega}_\mathrm{WB}(t)\Delta t\right) \\_\mathrm{W}\mathbf{v}(t + \Delta t)&=\ _\mathrm{W}\mathbf{v}(t)+\ _\mathrm{W}\mathbf{a}(t)\Delta t\\_\mathrm{W}\mathbf{p}(t + \Delta t)&=\ _\mathrm{W}\mathbf{p}(t)+\  _\mathrm{W}\mathbf{v}(t)\Delta t+\frac{1}{2}\  _\mathrm{W}\mathbf{a}(t)\Delta t^2\end{align*}\tag{30}</script><p>使用方程式。 (27)–(28)，我们可以将  $\ _\mathrm{W}\mathbf{a}$ 和 $ \ _\mathrm{B}\omega_{\mathrm{WB} }(t)$  写为 IMU 测量的函数，因此 (30) 变为:</p><script type="math/tex; mode=display">\begin{align*}{R}(t + \Delta t )&={R}(t)Exp\left(\ (\tilde{\omega}(t)-\mathbf{b}^g(t)-\mathbf{\eta}^{gd}(t))\Delta t\right) \\\mathbf{v}(t + \Delta t)&=\ \mathbf{v}(t)+\mathbf{g}\Delta t+\ R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t\\\mathbf{p}(t + \Delta t)&=\ \mathbf{p}(t)+\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R(t)(\tilde{\mathbf{a} }(t)-\mathbf{b}^a(t)-\mathbf{\eta}^{ad}(t))\Delta t^2\end{align*}\tag{31}</script><p>为了便于阅读，我们删除了坐标系下标（从现在开始，符号应该是明确的）。速度和位置的这种数值积分假定两个测量之间 $R(t)$是常数，对于具有非零旋转速率的测量，这不是微分方程 $(29)$ 的精确解。在实践中，使用高速IMU 可以减轻这种近似的影响。我们采用 $(31)$ 的积分方案，<strong>因为它简单，且对于建模和不确定性传播是经得起检验的。</strong>虽然我们表明这种积分方案在实践中表现非常好，但我们注意到对于较慢的 IMU 测量速率，可以考虑使用高阶数值积分方法 [54-57]。</p><p>离散时间噪声 $\eta^{gd}$ 的协方差是采样率的函数，并且通过 $Cov(\eta^{gd}(t)) = \frac{1}{\Delta t}Cov(\eta^{g}(t))$ 与连续时间频谱噪声 $\eta^{g}$ 相关。同样的关系也适用于 $\eta^{ad}$（参见 [58, 附录]）。</p><h1 id="六、-流形上的IMU预积分"><a href="#六、-流形上的IMU预积分" class="headerlink" title="六、 流形上的IMU预积分"></a>六、 流形上的IMU预积分</h1><p>虽然等式 $(31)$  可以很容易地被视为因子图中的概率约束，它需要在因子图中以高速率包含状态。直观地说，方程。 $(31)$  将时间 $t$ 和 $t + \Delta t$ 的状态关联起来，其中 $\Delta t$ 是 IMU 的采样周期。因此，我们必须在每次新的 IMU 测量时在估计中添加新状态 [37]。</p><p>在这里，我们展示了在时间 $k = i$ 和 $k = j$（见图 4）的两个关键帧之间的所有测量值可以总结为单个复合测量值，称为预积分 IMU 测量值，它限制了连续关键帧之间的运动。这个概念最初是在 [2] 中使用欧拉角提出的，我们通过开发一种适用于流形 $SO(3)$ 上的预积分的理论来扩展它。</p><p><img src="/images/【文献阅读】On-Manifold-Preintegration-for-Real-Time-Visual-Inertial-Odometry/image-20220507202527649.png" alt="image-20220507202527649"></p><blockquote><p>图 4：IMU 和相机的不同速率。</p></blockquote><p>我们假设 IMU 与相机同步，并在离散时间 $k$ 处提供测量值（参见图 4）。在时间 $k = i$ 和 $k= j$ 处对两个连续关键帧之间的所有 $\Delta t$ 间隔迭代使用 IMU 积分 (31)，我们发现：</p><script type="math/tex; mode=display">\begin{align*}{R}_j&={R}_i\prod^{j-1}_{k=i} Exp\left( (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)\Delta t\right) \\\mathbf{v}_j&=\ \mathbf{v}_i+\mathbf{g}\Delta t_{ij}+\ \prod^{j-1}_{k=i}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\\mathbf{p}_j&=\mathbf{p}_i+\sum^{j-1}_{k=i}\left[\  \mathbf{v}(t)\Delta t+\frac{1}{2}\  \mathbf{g}\Delta t^2+\frac{1}{2}R_k(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] \end{align*}\tag{32}</script><p>为了便于阅读，我们引入了简写 $\Delta t_{ij} \doteq  \sum^{j−1}_{k=i} \Delta t$ 和 $(·)_i \doteq (·)(t_i)$。虽然等式。 $(32)$ 已经提供了时间 $t_i$ 和 $t_j$ 之间运动的估计，它的缺点是，只要时间 $t_i$  的线性化点发生变化，就必须重复 $(32)$ 中的积分 [24]（直观地说，旋转 $R_i$ 的变化，意味着所有未来旋转 $R_k、k = i,…,j-1$ 的变化，因此有必要重新评估 $(32)$ 中的求和和乘积。</p><p>我们希望避免在时间 $t_i$ 的线性化点发生变化时重新计算上述积分。因此，我们遵循 [2] 并定义以下相对运动增量，这些增量与 $t_i$ 处的位姿和速度无关:</p><script type="math/tex; mode=display">\begin{align*}\Delta{R}_{ij}&\doteq{R}^T_iR_j\prod^{j-1}_{k=i} Exp\left( (\tilde{\omega}_k-\mathbf{b}^g_k-\mathbf{\eta}^{gd}_k)\Delta t\right) \\\Delta\mathbf{v}_{ij}&\doteq{R}^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})\ = \sum^{j-1}_{k=i}\Delta R_{ij}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t\\\Delta\mathbf{p}_{ij}&\doteq{R}^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\sum^{j-1}_{k=i}\mathbf{g}\Delta t^2)\\&=\sum^{j-1}_{k=i}\left[\  \mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta R_{ik}(\tilde{\mathbf{a} }_k-\mathbf{b}^a_k-\mathbf{\eta}^{ad}_k)\Delta t^2\right] \end{align*}\tag{33}</script><p>其中 $\Delta{R}_{ik}\doteq R^T_i R_k $ 和 $\Delta\mathbf{v}_{ik} \doteq R^T_i (\mathbf{v}_{k}−\mathbf{v}_{i}−\mathbf{g}\Delta t_{ik})$。我们强调，与“delta”旋转 $\Delta{R}_{ij}$ 相比， $\Delta\mathbf{v}_{ij}$  和 $\Delta\mathbf{p}_{ij}$都不对应于速度和位置的真实物理变化，而是以一种方式定义的，使得 $(33)$ 的右侧独立于时间 $i$ 的状态以及引力效应。事实上，我们将能够直接从两个关键帧之间的惯性测量中计算 $(33)$ 的右侧。</p><p>不幸的是，$(33)$ 中的求和和乘积仍然是偏差估计的函数。我们分两步解决这个问题。在第 VI-A 节中，我们假设$\mathbf{b}_{i}$ 是已知的；然后，在第 VI-C 节中，我们展示了如何在偏差估计发生变化时避免重复积分。</p><p>在本文的其余部分，我们假设两个关键帧之间的偏差保持不变：</p><script type="math/tex; mode=display">\mathbf{b}^g_{i}=\mathbf{b}^g_{i+1}=···=\mathbf{b}^g_{j-1},\ \ \ \ \mathbf{b}^a_{i}=\mathbf{b}^a_{i+1}=···=\mathbf{b}^a_{j-1}.\tag{34}</script><h2 id="A-预积分-IMU-测量"><a href="#A-预积分-IMU-测量" class="headerlink" title="A. 预积分 IMU 测量"></a>A. 预积分 IMU 测量</h2><p>等式 $(33)$ 将关键帧 $i$ 和 $j$ 的状态（左侧）与测量值（右侧）相关联。从这个意义上说，它已经可以理解为一种测量模型。不幸的是，它对测量噪声有相当复杂的依赖性，这使得 MAP 估计的直接应用变得复杂。直观地说，MAP 估计器需要清楚地定义测量的密度（及其对数似然）。在本节中，我们修改 $(33)$  以便更容易推导测量对数似然。在实践中，我们在 $(33)$ 中隔离了单个惯性测量的噪声项。如上所述，在本节中，假设时间 $t_i$ 的偏差是已知的。</p><p>让我们从 $(33)$ 中的旋转增量 $\Delta{R}_{ij}$ 开始。我们使用一阶近似 $(7)$（旋转噪声“小”）并重新排列术语，通过使用关系$(11)$将噪声“移动”到末尾：</p><script type="math/tex; mode=display">\begin{align*}\Delta{R}_{ij} &\overset{eq.(7)}{\simeq}\prod^{j-1}_{k=i}\left[Exp((\tilde{\omega}_k-\mathbf{b}^g_i)\Delta t)Exp(-J^k_r\eta^{gd}_k\Delta t)\right]\\&\overset{eq.(11)}{\simeq}\Delta{\tilde R}_{ij}\prod^{j-1}_{k=i}Exp(-\Delta \tilde R^T_{k+1 j} J^k_r \eta^{gd}_k \Delta t)\\&\doteq    \Delta{\tilde R}_{ij}Exp(-\delta \phi_{ij})    \end{align*}\tag{35}</script><p>其中，$J^k_r \doteq J^k_r(( \tilde\omega_k − b^g_i )Δt)$。在 $(35)$ 的最后一行，我们定义了预积分旋转测量 $\Delta{\tilde R}_{ij} \doteq \prod^{j−1}_{k=i} Exp (( \tilde\omega_k − b^g_i) Δt)$，及其噪声 $\delta\phi_{ij}$，将在下一节中分析。</p><p>将 $(35)$ 代回 $(33)$ 中 $\Delta\mathbf{v}_{ij}$ 的表达式，使用 $Exp(-\delta \phi_{ij})    $ 的一阶近似 $(4)$，并去掉高阶噪声项，我们得到：</p><script type="math/tex; mode=display">\begin{align*}\Delta\mathbf{v}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t -\Delta{\tilde R}_{ik}\eta^{gd}_k\Delta t\\&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{v} }_{ij}+\sum^{j-1}_{k=i}\left[\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t - \Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t\right]\\&\doteq    \Delta\tilde{\mathbf{v} }_{ij}-\delta\mathbf{v}_{ij}\end{align*}\tag{36}</script><p>其中，我们定义了预积分速度测量 $\Delta\tilde{\mathbf{v} }_{ij}\doteq\sum^{j-1}_{k=i}<br>\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\Delta t $及其噪声 $\delta\mathbf{v}_{ij}$。</p><p>类似地，将$(35)$ 和$(36)$ 代入$(33)$ 中的 $\Delta\mathbf{p}_{ij}$ 表达式，并使用一阶近似 $(4)$，我们得到：</p><script type="math/tex; mode=display">\begin{align*}\Delta\mathbf{p}_{ij} &\overset{eq.(4)}{\simeq}\sum^{j-1}_{k=i}\left[(\Delta\tilde{\mathbf{v} }_{ik}-\delta\mathbf{v}_{ik})\Delta t+\frac{1}{2}\Delta{\tilde R}_{ik}(I-\delta\phi^{\land}_{ik})(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)\Delta t^2 -\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\\&\overset{eq.(2)}{\simeq}\Delta\tilde{\mathbf{p} }_{ij}+\sum^{j-1}_{k=i}\left[-\delta\mathbf{v}_{ik}\Delta t+\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t^2 - \frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2\right]\\&\doteq    \Delta\tilde{\mathbf{p} }_{ij}-\delta\mathbf{p}_{ij}\end{align*}\tag{37}</script><p>其中我们定义了预集成的位置测量 $\Delta\tilde{\mathbf{p} }_{ij}$ 及其噪声 $\delta\mathbf{p}_{ij}$。</p><p>将表达式 $(35), (36), (37)$ 代入$ (33)$ 中 $\Delta{R}_{ij}, \Delta\mathbf{v}_{ij}, \Delta\mathbf{p}_{ij}$ 的原始定义，我们最终得到了我们的<strong>预积分测量模型</strong>（记住 $Exp(-\delta\phi_{ij})^T = Exp(\delta\phi_{ij})$):</p><script type="math/tex; mode=display">\begin{align*}\Delta{\tilde R}_{ij}&=R^T_iR_j\mathrm{Exp}(\delta\phi_{ij})\\R^T_i\Delta\tilde{\mathbf{v} }_{ij}&=R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})+\delta\mathbf{v}_{ij}\\\Delta\tilde{\mathbf{p} }_{ij}&=R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)+\delta\mathbf{p}_{ij}\end{align*}\tag{38}</script><p>其中我们的复合测量被写为（待估计）状态“加上”随机噪声的函数，由随机向量 $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 描述。</p><p>为了总结本节的内容，我们将 $(33)$ 的测量模型重新写为 $(38)$。$(38)$ 的优势在于，对于一个合适的噪声分布，它直接定义了对数似然。例如，具有零均值加性高斯噪声（ $(38)$的最后两行）测量的（负）对数是一个二次函数。类似地，如果 $\delta\phi_{ij}$  是零均值高斯噪声，我们计算与 $\Delta\tilde R_{ij}$ 相关的（负）对数似然。噪声项的性质将在下一节中讨论。</p><h2 id="B-噪声传播"><a href="#B-噪声传播" class="headerlink" title="B. 噪声传播"></a>B. 噪声传播</h2><p>在本节中，我们推导出噪声向量  $[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T$ 的统计量。虽然我们已经观察到将噪声向量近似为零均值正态分布是很方便的，但准确地建模噪声协方差是至关重要的。实际上，噪声协方差对 MAP 估计器有很大的影响（逆噪声协方差用于对优化中的项进行加权 $(26)$）。因此，在本节中，我们提供了预积分测量的协方差 $\Sigma_{ij}$ 的推导：</p><script type="math/tex; mode=display">\eta^{\Delta}_{ij}\doteq[\delta\phi^T_{ij},\ \delta\mathbf{v}_{ij}^T,\ \delta\mathbf{p}_{ij}^T]^T\sim\mathcal{N}(0_{9\times1},\Sigma_{ij})\tag{39}</script><p>我们首先考虑预积分的旋转噪声 $\delta\phi_{ij}$。回想一下 $(35)$</p><script type="math/tex; mode=display">\mathrm{Exp}(-\delta\phi_{ij})\doteq\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\tag{40}</script><p>取两边的对数并改变符号，我们得到：</p><script type="math/tex; mode=display">\delta\phi_{ij}=-\mathrm{Log}\left(\prod^{j-1}_{k=1}\mathrm{Exp}(-\Delta\tilde R^T_{K+1j} J^k_r\eta^{gd}_k\Delta t)\right)\tag{41}</script><p>一阶近似 $(9)$ 的重复应用（回想一下，$\eta^{gd}_k$ 和 $\delta\phi_{ij}$ 都是小的旋转噪声，因此右雅可比矩阵接近恒等式）产生：</p><script type="math/tex; mode=display">\delta\phi_{ij}\simeq\sum^{j-1}_{k=1}\Delta\tilde R^T_{K+1j}J^k_r\eta^{gd}_k\Delta t\tag{42}</script><p>保留到一阶，噪声  $\delta\phi_{ij}$ 是零均值和高斯的，因为它是零均值噪声项 $\eta^{gd}_k$ 的线性组合。这是可取的，因为它使旋转测量模型 $(38)$ 完全符合形式 $(12)$。</p><script type="math/tex; mode=display">\begin{align*}\delta \mathbf{v}_{ij}&\simeq \sum^{j-1}_{k=i}\left[-\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t +\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t\right]\\\delta\mathbf{p}_{ij} &\simeq\sum^{j-1}_{k=i}\left[\delta\mathbf{v}_{ik}\Delta t-\frac{1}{2}\Delta{\tilde R}_{ik}(\tilde{\mathbf{a} }_{k}-\mathbf{b}^a_i)^{\land}\delta\phi_{ik}\Delta t ^2 +\frac{1}{2}\Delta{\tilde R}_{ik}\eta^{ad}_k\Delta t^2 \right]\end{align*}\tag{43}</script><p>其中关系到一阶都是正确的。</p><p>方程。 $(42)-(43)$ 将预积分噪声 $\eta^{\Delta}_{ij}$ 表示为 IMU 测量噪声 $\eta^d_k \doteq [\eta^{gd}_k , \eta^{ad}_k ], k = 1, . . .,j − 1$, 的线性函数。因此，根据 $\eta^{d}_{k}$  的协方差知识（在 IMU 规范中给出），我们可以通过简单的线性传播计算 $\eta^{\Delta}_{ij}$ 的协方差，即 $\Sigma_{ij}$。</p><p>在附录 IX-A 中，我们提供了一种更巧妙的方法来计算$\Sigma_{ij}$。特别是，我们展示了 $\Sigma_{ij}$ 可以方便地以迭代形式计算：当一个新的 IMU 测量到达时，我们只更新 $\Sigma_{ij}$，而不是从头开始重新计算。迭代计算导致更简单的表达式并且更适合在线推理。</p><h2 id="C-组合偏差更新"><a href="#C-组合偏差更新" class="headerlink" title="C. 组合偏差更新"></a>C. 组合偏差更新</h2><p>在上一节中，我们假设在 $k = i$ 和 $k = j$ 之间的预积分期间使用的偏差 $\{\overline{b}^a_i , \overline{b}^g_i\}$ 是正确的并且不会改变。然而，更有可能的是，偏差估计在优化过程中会发生少量 $\delta\mathbf{b}$ 的变化。一种解决方案是在偏差发生变化时重新计算 delta 测量值；但是，这在计算上是昂贵的。相反，给定偏差更新 $\mathbf{b}\gets \mathbf{b} + \delta\mathbf{b}$，我们可以使用一阶展开更新 delta 测量：</p><script type="math/tex; mode=display">\begin{align*}\Delta\tilde{R}_{ij}(\mathbf{b}^g_i)&\simeq\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)\\\Delta\tilde{\mathbf{v} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\\\Delta\tilde{\mathbf{p} }_{ij}(\mathbf{b}^g_i,\mathbf{b}^a_i) &\simeq\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g_i+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a_i\end{align*}\tag{44}</script><p>这类似于 [2] 中的偏差校正，但直接在 $SO(3)$ 上运行。雅可比矩阵 $\{ \frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g} , \frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g} , . . .\}$（在  $\overline{\mathbf{b} }_i$ 计算，积分时的偏差估计）描述了测量值如何由于偏差估计的变化而变化。雅可比矩阵保持不变，并且可以在预积分期间预先计算。雅可比矩阵的推导与我们在第 VI-A 节中用于将测量值表示为大值加上小扰动的推导非常相似，并在附录 IX-B 中给出。</p><h2 id="D-预积分IMU因子"><a href="#D-预积分IMU因子" class="headerlink" title="D. 预积分IMU因子"></a>D. 预积分IMU因子</h2><p>给定 $(38)$ 中的预积分测量模型，并且由于测量噪声是零均值和高斯（协方差 $\Sigma_{ij}$）直到一阶 $(39)$，现在很容易写出残差 $r_{\mathcal{I}_{ij} }\doteq [r^T_{\Delta R_{ij} }, r^T_{\Delta \mathbf{v}_{ij} },r^T_{\Delta \mathbf{p}_{ij} }]^T \in \mathbb{R}^9$, 其中:</p><script type="math/tex; mode=display">\begin{align*}r_{\Delta R_{ij} }&\doteq \mathrm{Log}\left(\left(\Delta\tilde{R}_{ij}(\overline{\mathbf{b} }^g_i)\mathrm{Exp}\left(\frac{\partial\Delta\overline{R}_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g \right)\right)^TR^T_iR_j\right)\\r_{\Delta \mathbf{v}_{ij} }&\doteq R^T_i(\mathbf{v}_j-\mathbf{v}_i-\mathbf{g}\Delta t_{ij})-\left[\Delta\tilde{\mathbf{v} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g+\frac{\partial\Delta\overline{\mathbf{v} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a\right]\\r_{\Delta \mathbf{p}_{ij} }&\doteq R^T_i(\mathbf{p}_j-\mathbf{p}_i-\mathbf{v}_i\Delta t_{ij}-\frac{1}{2}\mathbf{g}\Delta t_{ij}^2)-\left[\Delta\tilde{\mathbf{p} }_{ij}(\overline{\mathbf{b} }^g_i,\overline{\mathbf{b} }^a_i)+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^g}\delta\mathbf{b}^g+\frac{\partial\Delta\overline{\mathbf{p} }_{ij} }{\partial\mathbf{b}^a}\delta\mathbf{b}^a\right]\\\end{align*}\tag{45}</script><p>其中我们还包括了方程的偏差更新 $(44)$。</p><p>根据“lift-solve-retract”方法（第 III-C 节），在每次 Gauss-Newton 迭代中，我们需要使用<strong>回缩($retraction$)</strong> $(21)$重新参数化 $(45)$。然后，“解决”步骤需要围绕当前估计线性化结果成本。出于线性化的目的，计算残差的雅可比行列式分析表达式很方便，我们在附录 IX-C 中推导出了该表达式。</p><h2 id="E-偏置模型"><a href="#E-偏置模型" class="headerlink" title="E. 偏置模型"></a>E. 偏置模型</h2><p>在介绍 IMU 模型 $(27)$ 时，我们说偏差是缓慢随时间变化的量。因此，我们用“布朗运动”对它们进行建模，即综合白噪声：</p><script type="math/tex; mode=display">\dot{b}^g(t)=\eta^{bg}, \ \ \ \ \dot{b}^a(t)=\eta^{ba}\tag{46}</script><p>在两个连续关键帧 $i$ 和 $j$ 之间的时间间隔 $[t_i, t_j]$ 上对 $(46)$ 进行积分，我们得到：</p><script type="math/tex; mode=display">\mathbf{b}^g_j(t)=\mathbf{b}^g_i+\eta^{bgd}, \ \ \ \ \ \mathbf{b}^a_j(t)=\mathbf{b}^a_i+\eta^{bad}\tag{47}</script><p>其中，如前所述，我们使用简写 $\mathbf{b}^g_j\doteq \mathbf{b}^g(t_i)$，我们定义离散噪声 $\eta^{bgd}$ 和 $\eta^{bad}$，它们的均值和协方差为零 $\Sigma^{bgd}\doteq \Delta t_{ij} Cov(\eta^{bg})$ 和 $\Sigma^{bad}\doteq \Delta t_{ij} Cov(\eta^{ba})$，分别（参见[58，附录]）。</p><p>模型 $(47)$ 可以很容易地包含在我们的因子图中，作为 $(26)$ 中所有连续关键帧的进一步附加项：</p><script type="math/tex; mode=display">\parallel r_{b_{ij} } \parallel^2 \doteq\parallel \mathbf{b}^g_j- \mathbf{b}^g_i \parallel^2_{\Sigma_{bgd} }+\parallel \mathbf{b}^a_j- \mathbf{b}^a_i \parallel^2_{\Sigma_{bad} }\tag{48}</script><h1 id="七、无结构视觉因子"><a href="#七、无结构视觉因子" class="headerlink" title="七、无结构视觉因子"></a>七、无结构视觉因子</h1><p>在本节中，我们将介绍我们用于视觉测量的无结构模型。我们方法的关键特征是地标的线性消除。请注意，在每次 Gauss-Newton 迭代中都会重复消除，因此我们仍然可以保证获得最佳 MAP 估计。</p><p>视觉测量通过如下求和贡献到代价函数 $(26)$ 中:</p><script type="math/tex; mode=display">\sum_{i\in\mathcal{K}_k}\sum_{l\in\mathcal{C}_i}\parallel r_{\mathcal{C}_{il} } \parallel^2=\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel r_{\mathcal{C}_{il} } \parallel^2_{\Sigma_{\mathcal{C} } }\tag{49}</script><p>其中，在右侧，我们将其重写为每个地标 $l = 1 ,. . , L$, 的贡献的总和。在 (49) 中，$\mathcal{X}(l)$ 表示看到 $l$ 的关键帧的子集。</p><p>单个图像测量 $\mathbf{z}_{il}$ 的残差的一个相当标准的模型是重投影误差：</p><script type="math/tex; mode=display">r_{\mathcal{c}_{il} }=\mathbf{z}_{il}-\pi(R_i,\mathbf{p}_{i},ρ_l)\tag{50}</script><p>其中 $ρ_l \in \mathbb{R}^3$ 表示第 $l$ 个地标的位置，$π(·)$ 是标准透视投影，它也编码了（已知的）IMU 相机变换 $T_{BC}$。</p><p>直接使用 $(50)$ 将需要包括地标位置 $ρ_l, l = 1, 。 . . , L$ 在优化中，这对计算产生负面影响。因此，在下文中，我们采用了一种无结构的方法，避免对地标进行优化，从而确保检索 MAP 估计</p><p>正如在第 III-C 节中回顾的那样，在每次 GN 迭代中，我们使用<strong>回缩($retraction$)</strong> $(21)$来提升成本函数。对于视觉因素，这意味着原始残差 $(49)$ 变为：</p><script type="math/tex; mode=display">\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel \mathbf{z}_{il}-\check{\pi}(\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l)\parallel^2_{\Sigma_{\mathcal{C} } }\tag{51}</script><p>其中 $\delta\phi_i,\delta\mathbf{p}_i,\deltaρ_l$ 是欧几里得修正，$\check{\pi}(·)$ 是提升的成本函数。 GN 方法中的“求解”步骤基于残差的线性化：</p><script type="math/tex; mode=display">\sum^L_{l=1}\sum_{i\in\mathcal{X}(l)}\parallel \mathbf{F}_{il}\delta\mathbf{T}_{i}+\mathbf{E}_{il}\delta ρ_l-\mathbf{b}_{il}\parallel^2\tag{52}</script><p>其中 $\delta \mathbf{T}_i \doteq [\delta\phi_i,\delta\mathbf{p}_i]^T$; 雅可比矩阵 $\mathbf{F}_{il},\mathbf{E}_{il}$ 和向量 $\mathbf{b}_{il}$（均由 $\Sigma^{1/2}_{\mathcal{C}}$ 归一化）来自线性化。向量$\mathbf{b}_{il}$是线性化点处的残差。将 $(52)$ 中的第二个和写成矩阵形式，我们得到：</p><script type="math/tex; mode=display">\sum^L_{l=1}\parallel \mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}\parallel^2\tag{53}</script><p>其中，对于所有 $i \in \mathcal{X}(l)，\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 分别通过堆叠 $\mathbf{F}_{il},\mathbf{E}_{il},\mathbf{b}_{il}$ 获得。</p><p>由于地标 $l$ 出现在总和 $(53)$ 的单个项中，因此对于任何给定的姿态扰动 $\delta\mathbf{T}_{\mathcal{X}(l)}$ 选择，最小化代价函数 $\parallel<br>\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}+\mathbf{E}_{l}\delta ρ_l-\mathbf{b}_{l}<br>\parallel^2$ 的地标扰动 $\deltaρ_l$ 是：</p><script type="math/tex; mode=display">\deltaρ_l=-(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\tag{54}</script><p>将 $(54)$ 代回 $(53)$ 我们可以从优化问题中消除变量 $\deltaρ_l$ ：</p><script type="math/tex; mode=display">\sum^L_{l=1}\parallel (\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T)(\mathbf{F}_{l}\delta\mathbf{T}_{\mathcal{X}(l)}-\mathbf{b}_{l})\parallel^2\tag{55}</script><p>其中 $\mathbf{I}-\mathbf{E}_{l}(\mathbf{E}_{l}^T\mathbf{E}_{l})^{-1}\mathbf{E}_{l}^T$ 是 $\mathbf{E}_{l}$的正交投影。在附录 IX-D 中，我们展示了可以进一步操纵成本 $(55)$，从而实现更有效的实施。</p><p>这种方法在BA文献中被称为 Schur 补码技巧($Schur\ complement\ trick$)，其中一种标准做法是通过反向替换来更新 $ρ_l$ 的线性化点 [61]。相反，我们使用快速线性三角测量从姿势的线性化点获得更新的地标位置。使用这种方法，我们将涉及姿势和地标的大量因子 $(51)$ 减少为仅涉及姿势的较小 $L$ 因子集 $(55)$。特别是，与界标 $l$ 对应的因子仅涉及观察 $l$ 的状态 $\mathcal{X}(l)$，创建图 3 的连接模式。MSCKF [5] 中也使用相同的方法来避免在状态向量中包含界标.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文对经典的预积分理论的原始论文进行了翻译，但是里面的细节暂时不是很理解。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="预积分理论" scheme="https://lukeyalvin.top/tags/%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>外积、内积、张量积、Kronecker积</title>
    <link href="https://lukeyalvin.top/posts/bdcf3114.html"/>
    <id>https://lukeyalvin.top/posts/bdcf3114.html</id>
    <published>2022-05-08T13:08:37.000Z</published>
    <updated>2022-05-08T13:26:11.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h1><p>内积又称为点积，有两种定义方式，一种是代数方式，一种是集合方式。</p><ul><li><strong>代数定义</strong></li></ul><p>两个向量$\vec{a}=[a_1,a_2,···,a_n]$和$\vec{b}=[b_1,b_2,···,b_n]$的点积定义为：</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b}=\sum^{n}_{i=1}a_ib_i=a_1b_1+a_2b_2+···+a_nb_n\tag{1}</script><p>点积也可以写成$\vec{a}\vec{b}^T$</p><ul><li><strong>几何定义</strong></li></ul><p>在欧几里得空间中，点积可以直观地定义为:</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\cos\theta\tag{2}</script><p>其中，$|\vec{x}|$表示$\vec{x}$的模长，$\theta$表示两个向量之间的夹角。</p><h1 id="叉积（Cross-product）"><a href="#叉积（Cross-product）" class="headerlink" title="叉积（Cross product）"></a>叉积（Cross product）</h1><ul><li><strong>定义</strong></li></ul><p>叉积又称为向量积（有时候也说是外积，这里为了区分，就不这么说，因为你会发现好多外积），是对三维空间中的两个向量的二元运算，使用符号$\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量$a$和$b$，它们的外积写作 $a\times b$，是 $ a $和$b$所在平面的法线向量，与$ a $和$b$都垂直。</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506153837169.png" alt="image-20220506153837169" style="zoom: 25%;" /></p><p>两个向量$a$和$b$的叉积仅在三维空间有定义，写作 $a\times b$，叉积也可以定义为：</p><script type="math/tex; mode=display">a\times b=\parallel a \parallel \parallel b\parallel \sin(\theta)n\tag{3}</script><p>其中$\theta$表示$a$和$b$在它们所定义的平面上的夹角，$\parallel a \parallel$和$\parallel b \parallel$表示向量$a$和$b$的模长，而$n$则是一个与$a$和$b$所构成的平面的垂直的单位向量，方向由右手定则决定。</p><ul><li><strong>矩阵表示</strong></li></ul><p>叉积也可以定义为：</p><script type="math/tex; mode=display">a\times b=\left|\begin{matrix}i&j&k\\a_1&a_2&a_3\\b_1&b_2&b_3\end{matrix}\right|=\begin{bmatrix}a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1\end{bmatrix}=\begin{bmatrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\end{bmatrix}b\triangleq a^{\land}b\tag{4}</script><p>这里引入符号$^{\land}$，成为反对称符号，这样就可以把外积$a\times b$写成了矩阵与向量的乘法$a^{\land}b$，把它变成可线性运算。在《视觉SLAM十四讲》中也有提及。</p><h1 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h1><p>在数学中，张量积，记为$\otimes$，可以应用于不同的上下文中如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的:最一般的双线性运算。在某些上下文中也叫做外积。</p><script type="math/tex; mode=display">b\otimes a \rightarrow \begin{bmatrix}b_1\\b_2\\b_3\\b_4\end{bmatrix}_{4\times 1}\begin{bmatrix}a_1&a_2&a_3\end{bmatrix}_{1\times 3}=\begin{bmatrix}a_1b_1&a_2b_1&a_3b_1\\a_1b_2&a_2b_2&a_3b_2\\a_1b_3&a_2b_3&a_3b_3\\a_1b_4&a_2b_4&a_3b_4\\\end{bmatrix}_{4\times 3}\tag{5}</script><p>对于张量积之后的秩：</p><script type="math/tex; mode=display">rank(V\otimes U)=rank(V)+rank(U)\tag{6}</script><h1 id="Kronecker积"><a href="#Kronecker积" class="headerlink" title="Kronecker积"></a>Kronecker积</h1><p>数学上，克罗内克积（英语：Kronecker product）是两个任意大小的矩阵间的运算，表示为⊗。克罗内克积是外积从向量到矩阵的推广，也是张量积在标准基下的矩阵表示。</p><p>如果$A$是一个$m\times n$的矩阵，$B$是一个$p\times q$的矩阵，克罗内克积为$A\otimes B$则是一个$mp\times nq$的矩阵：</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162341626.png" alt="image-20220506162341626" style="zoom: 20%;" /></p><p>更具体的表示为：</p><p><img src="/images/外积、内积、张量积、Kronecker积/image-20220506162438902.png" alt="image-20220506162438902" style="zoom:40%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要讨论数学上的内积、外积，为了不在学习中混淆，其中SLAM中用的比较多的还是点乘和叉乘。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学基础" scheme="https://lukeyalvin.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="内积与外积" scheme="https://lukeyalvin.top/tags/%E5%86%85%E7%A7%AF%E4%B8%8E%E5%A4%96%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>相机模型简要分析</title>
    <link href="https://lukeyalvin.top/posts/ddbf64.html"/>
    <id>https://lukeyalvin.top/posts/ddbf64.html</id>
    <published>2022-05-08T13:06:11.000Z</published>
    <updated>2022-05-08T13:08:07.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="相机成像模型"><a href="#相机成像模型" class="headerlink" title="相机成像模型"></a>相机成像模型</h1><p>相机模型基于小孔成像：</p><p><img src="/images/相机模型简要分析/image-20220505170737171.png" alt="image-20220505170737171" style="zoom: 67%;" /></p><p>这里出现了几个坐标系：</p><ul><li>世界坐标系$\{W\}$，在世界坐标系下，特征点$P$在世界坐标系下的坐标为$P_w=(X_w,Y_w,Z_w)$</li><li><p>相机坐标系$\{C\}$，对相机来说，也有一个相机坐标系，也可以称之为机器人本体坐标系，因为相机属于机器人，特征点$P$在相机坐标系下的坐标为$P_c=(X_c,Y_c,Z_c)$</p></li><li><p>像素平面坐标系$\{P^{\prime}\}$，这个是通过相机内部得到的投影平面坐标系，它是一个二维的平面，特征点$P$在像素平面坐标系下的坐标为$P^{\prime}=(X^{\prime},Y^{\prime})$，</p></li><li><p>像素坐标系$\{P_{uv}\}$，像素坐标系是素平面坐标系$\{P^{\prime}\}$经过缩放和平移得到的，后面介绍。</p></li></ul><p>那么我们需要明白这几个坐标系之间的关系：</p><p><img src="/images/相机模型简要分析/image-20220505171918452.png" alt="image-20220505171918452"></p><h2 id="世界坐标系——相机坐标系"><a href="#世界坐标系——相机坐标系" class="headerlink" title="世界坐标系——相机坐标系"></a>世界坐标系——相机坐标系</h2><p>这个很简单，两者就相差一个刚体变换，这变换矩阵为$T_{cw}$，则对于特征点$P$来说，就有：</p><script type="math/tex; mode=display">P_{c}=(T_{cw}P_{w})_{(1:3)}=(T_{cw}\begin{bmatrix}X_{w}\\Y_{w}\\Z_{w}\end{bmatrix})_{(1:3)}\tag{1}</script><p>这里$(T_{cw})_{(1:3)}$指的是纯旋转的情况下，考虑他的前三项。</p><h2 id="相机坐标系——像平面坐标系"><a href="#相机坐标系——像平面坐标系" class="headerlink" title="相机坐标系——像平面坐标系"></a>相机坐标系——像平面坐标系</h2><p><img src="/images/相机模型简要分析/image-20220505172602891.png" alt="image-20220505172602891"></p><p>如图所示，展示相机内部投影的过程，</p><script type="math/tex; mode=display">\begin{align*}X^{\prime}=f\frac{X_c}{Z_c}\\Y^{\prime}=f\frac{Y_c}{Z_c}\end{align*}\tag{2}</script><h2 id="像平面坐标系——像素坐标系"><a href="#像平面坐标系——像素坐标系" class="headerlink" title="像平面坐标系——像素坐标系"></a>像平面坐标系——像素坐标系</h2><p>像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。我们设像素坐标在$u$ 轴上缩放了 $\alpha$倍，在 $v$上缩放了 $\beta$ 倍。同时，原点平移了$ [c_x,c_y]^T$。那么， $P^′$ 的坐标与像素坐标 $[u,v]^T $的关系为：  </p><script type="math/tex; mode=display">\left\{\begin{array}{L}u=\alpha X^{\prime}+c_x\\v=\alpha Y^{\prime}+c_y\end{array}\right.\\tag{3}</script><p>将$(2)$带入$(3)$:</p><script type="math/tex; mode=display">\left\{\begin{array}{L}u=f_x \frac{X_c}{Z_c}+c_x\\v=f_y \frac{Y_c}{Z_c}+c_y\end{array}\right.\\tag{3}</script><p>其中$f_x= \alpha f$，$f_y= \beta f$，$f$ 的单位为米， $\alpha,\beta$ 的单位为像素每米，所以 $f_x,f_y $的单位为像素 。</p><h2 id="相机坐标系——像素坐标系"><a href="#相机坐标系——像素坐标系" class="headerlink" title="相机坐标系——像素坐标系"></a>相机坐标系——像素坐标系</h2><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}\triangleq \lambda KP_c\tag{4}</script><p>其中，$\lambda$称为逆深度，$K$表示相机的内参。</p><ul><li>采用逆深度的方式，表达一个点的坐标$(x,y,z)$变成成了$1/λ * [u,v,1]^T$，将$3$个优化变量，变成了一个优化变量（$u,v$为归一化相机坐标系下的三维点的坐标，通过观测数据是可知的），所以优化变量少。</li><li>同时，对于深度很大的点，在数值上很大，采用逆深度的方式，倒一下，数值上变小了，有利于优化过程中数值的稳定性，不会因为很远的点（深度值很大）导致一次优化过程中出现较大的误差函数的变换，因此再远的点（如天空中的点）也能表达了，所以能表达非常远的点。</li><li>将深度值倒数一下，变成小数，跟接近高斯分布的函数表达形式，方便优化。</li></ul><p><strong>归一化坐标</strong></p><p>另外我们引入归一化坐标的概念，它位于相机前方 $z = 1$ 处的平面上。该平面称为<strong>归一化平面</strong>。  比如对$P_c$进行归一化处理得到$\overline{P}$</p><script type="math/tex; mode=display">\overline{P}=\frac{1}{Z_c}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\tag{5}</script><p>因此，可以得到像素坐标与归一化坐标之间的关系为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}\triangleq  K\overline{P}\tag{6}</script><p>可以发现相机归一化坐标$\overline{P}$经过相机内参就可以得到像素坐标，所以我们可以把像素坐标$[u,v]^T$ ，看成对归一化平面上的点进行量化测量的结果。  </p><h2 id="相机坐标系——世界坐标系"><a href="#相机坐标系——世界坐标系" class="headerlink" title="相机坐标系——世界坐标系"></a>相机坐标系——世界坐标系</h2><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=\frac{1}{Z_c}\begin{bmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{bmatrix}(R_{cw}P_w+t)\triangleq \lambda KT_{cw}P_w\tag{7}</script><h1 id="VO重投影误差"><a href="#VO重投影误差" class="headerlink" title="VO重投影误差"></a>VO重投影误差</h1><p>重投影误差如图示，我们通过特征匹配可知，观测值$p_1$和$p_2$是同一个空间点$P$的投影，而实际上我们利用帧间的位姿估计，可以通过观测值$p_1$求得对应的匹配$\hat{p}_2$，理论上，我们的计算值$\hat{p}_2$与观测值$p_1$应该是重合的，但是，由于我们估计的帧间位姿并不是准确的，因此就会出现误差$e$，我们称之为重投影误差。</p><p><img src="/images/相机模型简要分析/image-20220505202300998.png" alt="image-20220505202300998" style="zoom:50%;" /></p><p>按照之前的基础知识，可以推导：</p><script type="math/tex; mode=display">s_iu_i=K\exp(\xi^{\land})P_i\tag{8}</script><p>其中，$u_i=[u_i,v_i]^T$表示特征点$P$的投影坐标，$s_i$表示深度，$K$表示相机内参，$\exp(\xi^{\land})$则是变换$T_{cw}$的李代数形式，这里的$P_i$是特征点的世界坐标。这里类似于公式$(7)$。</p><p>通过重投影误差的定义可知，我们的目的在于不断优化变量$\xi$，从而得到一个最优的$\xi$使得$e$的值达到最小，因此构建最小二乘：</p><script type="math/tex; mode=display">\xi^*=\arg\underset{\xi}{\min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1}{s_i}K\exp(\xi^{\land})P_i\parallel^2_2\tag{9}</script><p>然后就是对其优化的内容了，这里可以参考：<a href="https://lukeyalvin.top/posts/20908.html#1-%E9%87%8D%E6%8A%95%E5%BD%B1%E8%AF%AF%E5%B7%AE">PnP_重投影误差</a></p><h1 id="VIO重投影误差"><a href="#VIO重投影误差" class="headerlink" title="VIO重投影误差"></a>VIO重投影误差</h1><p>由构建于VIO重投影误差省略了相机内参$K$，那么，我们在公式$(6)$的基础上把$K$去掉，就发现<strong>特征点在相机归一化平面的坐标就是像素坐标</strong>$[u,v]^T$，其中$[u,v]^T$是观测值，由于$T_{cw}$是估计出来的，所以等式右边是估计值，理想情况下有：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\\1\end{bmatrix}=T_{cw}\begin{bmatrix}\frac{X_w}{Z_w}\\\frac{Y_w}{Z_w}\\1\end{bmatrix}=\begin{bmatrix}\frac{X_c}{Z_c}\\\frac{Y_c}{Z_c}\\1\end{bmatrix}\triangleq  \overline{P}</script><p>而此时的重投影误差就变成了：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_c}{Z_c}-u\\\frac{Y_c}{Z_c}-v\end{bmatrix}</script><p>熟悉这个之后，我们再来学习一下VIO重投影误差。</p><p><img src="/images/相机模型简要分析/image-20220505205125811.png" alt="image-20220505205125811" style="zoom: 33%;" /></p><p>特征点逆深度在第$i$帧中初始化得到，在第 $j$ 帧又被观测到，预测其在第$ j$ 中的坐标为：  </p><script type="math/tex; mode=display">\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}=T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}\begin{bmatrix}\frac{1}{\lambda}u_{ci}\\\frac{1}{\lambda}v_{ci}\\\frac{1}{\lambda}\\1\end{bmatrix}\tag{10}</script><p>设特征点$P$经过特征匹配，得到在$i,j$两帧上的投影观测值，目前特征点在$i$帧的观测值是初始化值，所以在$i$帧相机坐标为$\begin{bmatrix}\frac{1}{\lambda}u_{cj}\\\frac{1}{\lambda}v_{cj}\\\frac{1}{\lambda}\\1\end{bmatrix}$，然后使用估计的位姿变换$T^{-1}_{bc}T^{-1}_{wb_j}T_{wb_i}T_{bc}$进行一系列坐标变换，得到的是该特征点在第$j$帧估计的相机坐标$\begin{bmatrix}X_{cj}\\Y_{cj}\\Z_{cj}\\1\end{bmatrix}$，把它化为归一化坐标，得到$\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }\\\frac{Y_{cj} }{Z_{cj} }\end{bmatrix}$,我们知道，在忽略$K$的前提下，归一化坐标就是像素坐标，由于一直第$j$帧下的像素坐标观测值为$\begin{bmatrix}u_{c_j}\\v_{c_j}\end{bmatrix}$,所以，就可以构建如下的残差项：</p><script type="math/tex; mode=display">r_c=\begin{bmatrix}\frac{X_{cj} }{Z_{cj} }-u\\\frac{Y_{cj} }{Z_{cj} }-v\end{bmatrix}\tag{11}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要对相机模型做详细的解读，在此基础之上对VO以及VIO重投影误差问题作简要的概括。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
    <category term="相机模型" scheme="https://lukeyalvin.top/tags/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="VO" scheme="https://lukeyalvin.top/tags/VO/"/>
    
  </entry>
  
  <entry>
    <title>状态估计模型与贝叶斯滤波</title>
    <link href="https://lukeyalvin.top/posts/b04da399.html"/>
    <id>https://lukeyalvin.top/posts/b04da399.html</id>
    <published>2022-05-04T11:29:54.032Z</published>
    <updated>2022-05-08T13:27:20.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><strong>滤波器的本质：</strong>结合预测和观测，得到“最精确”的后验值。这个精确值是相对的，因为实际中，预测和观测均是从传感器而来的，因此滤波器的作用就是结合各个传感器得到一个最好的融合结果。这就是一个数据融合的过程，关于数据融合的介绍可以参考：<a href="https://lukeyalvin.top/posts/8369.html#%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88">数据融合</a></p><p><img src="/images/滤波器基本原理/image-20220504151009319.png" alt="image-20220504151009319" style="zoom:50%;" /></p><p>1) 实际中预测往往从IMU、编码器等传感器递推而来；<br>2) 观测往往从GPS、雷达、相机等传感器而来；<br>3) 后验为融合后的结果，即定位模块的输出。</p><h1 id="状态估计模型"><a href="#状态估计模型" class="headerlink" title="状态估计模型"></a>状态估计模型</h1><p>实际状态估计任务中，待估计的后验概率密度可以表示为：</p><script type="math/tex; mode=display">p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})\tag{1}</script><p>其中：$\tilde{x}_0$表示的是状态初始值；$v_{1:k}$表示从第1时刻到第$k$时刻的输入；$y_{0:k}$表示从第0时刻到第$k$时刻的观测。</p><p>因此，滤波问题可以直观表示为，根据所有历史数据（输入、观测、初始状态），得出的最终的融合结果。历史数据之间的关系，可以用下面的图模型表示，</p><p><img src="/images/滤波器基本原理/image-20220504205031587.png" alt="image-20220504205031587" style="zoom: 33%;" /></p><p>图模型中体现了<strong>马尔可夫性</strong>，即当前状态只跟前一时刻状态相关，和其他历史时刻状态无关。数学表达该性质，</p><script type="math/tex; mode=display">\left\{\begin{aligned}运动方程：x_k&=f(x_{k-1},v_k,w_k)\\观测方程：y_k&=g(x_k,n_k)\end{aligned}\right.\tag{2}</script><h1 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h1><p>根据贝叶斯公式，$k$时刻后验概率密度可以表示为</p><script type="math/tex; mode=display">\begin{align*}p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})&=\frac{p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}{p(y_k|\tilde{x}_0,v_{1:k},y_{0:k-1})}\\&=\eta p(y_k|x_k,\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\end{align*}\tag{3}</script><p>根据观测方程，$y_k$只与$x_k$相关，因此上式可以简写为：</p><script type="math/tex; mode=display">p(x_k|\tilde{x}_0,v_{1:k},y_{0:k})=\eta p(y_k|x_k)p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\tag{4}</script><p>应用系统的马尔可夫性进一步化简公式，</p><script type="math/tex; mode=display">\begin{align*}&p(x_k|\tilde{x}_0,v_{1:k},y_{0:k-1})\\&=\int p(x_k,x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\&=\int p(x_k|x_{k-1}，\tilde{x}_0,v_{1:k},y_{0:k-1})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\\&=\int p(x_k|x_{k-1},v_{k})p(x_{k-1}|\tilde{x}_0,v_{1:k},y_{0:k-1})dx_{k-1}\end{align*}\tag{3}</script><p>经过以上化简，最终后验概率可以写为</p><p><img src="/images/滤波器基本原理/image-20220504211503741.png" alt="image-20220504211503741" style="zoom: 50%;" /></p><p>根据以上结果，可以画出贝叶斯滤波的信息流图如下</p><p><img src="/images/滤波器基本原理/image-20220504210156815.png" alt="image-20220504210156815"></p><p>贝叶斯滤波分为很多种实现形式：</p><p><img src="/images/滤波器基本原理/image-20220504211643228.png" alt="image-20220504211643228" style="zoom: 50%;" /></p><p>实际中，粒子滤波（PF）多用于(早期的)2D激光SLAM方案中。在高斯假设前提下，用贝叶斯滤波的原始形式比较复杂，可以利用高斯的特征得到简化形式，即广义高斯滤波，后面KF、EKF、IEKF、UKF的推导均采用这种形式，只有PF例外，因为它是针对非高斯的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;基于滤波器的激光SLAM方法，目前已经相对落后，因为滤波是用于估计当前的状态，如果我们之前的数据出现错误，是没有办法进行修正的，所以这个方法的整体效果并不是特别好。但是这个方法在整个激光SLAM的发展中还是占有很重要的地位的，而且这里蕴含的很多数学知识是非常重要的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="滤波器" scheme="https://lukeyalvin.top/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    
    <category term="概率基础" scheme="https://lukeyalvin.top/tags/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    
    <category term="贝叶斯滤波" scheme="https://lukeyalvin.top/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>点云地图的建立、畸变补偿和定位</title>
    <link href="https://lukeyalvin.top/posts/f737dac5.html"/>
    <id>https://lukeyalvin.top/posts/f737dac5.html</id>
    <published>2022-05-03T10:44:59.183Z</published>
    <updated>2022-05-04T01:30:50.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>点云地图的建立</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="建图流程"><a href="#建图流程" class="headerlink" title="建图流程"></a>建图流程</h1><p>建图流程设计的核心原则是准确、高效地把<strong>里程计相对位姿</strong>、<strong>回环相对位姿</strong>、<strong>惯导先验位姿</strong>进行融合。</p><p><img src="/images/点云地图的建立/image-20220503190523343.png" alt="image-20220503190523343" style="zoom: 33%;" /></p><ul><li>轨迹对齐</li></ul><p>里程计的初始位姿是从激光雷达收到第一帧点云开始的，它的初始位姿就是单位阵，平移和旋转均为0；而对于惯导而言，它的旋转是以东北天坐标系为准的，因此它的初始位姿并不一定为0；因此里程计第一帧之间的位姿和惯导第一帧的位姿出现了相对旋转，这会导致里程计和先验之间出现很大的误差，所以我们求第一帧时里程计和惯导位姿之间的相对变换即可，这样就可以把里程计的轨迹拉到与惯导轨迹（一般和小车行进方向一致）一致的方向。这个过程就是<strong>轨迹对齐</strong>。</p><ul><li>回环检测</li></ul><p>这里涉及一个简单的回环检测的策略，比如如下的回环，我们检测回环不可能每一帧都进行检测，而是在一定的范围内，并且两帧之间的时间差必须大于一定的阈值，另外当某一帧被检测为闭环了，那么它相邻的一些帧则不做重复的检测，把相邻帧做“吸收化”之后，在后续段进行闭环检测。</p><p><img src="/images/点云地图的建立/image-20220503191428273.png" alt="image-20220503191428273" style="zoom: 50%;" /></p><ul><li>优化周期</li></ul><p>固定优化周期，可以在一定周期内进行优化，可以在误差累积相对较小的情况下进行优化，因为累积误差小，优化时间短，这样前端里程计构建过程中可以同步实现后端的优化，可以提高效率。</p><h1 id="畸变补偿"><a href="#畸变补偿" class="headerlink" title="畸变补偿"></a>畸变补偿</h1><ul><li><strong>产生原因：</strong></li></ul><p>由于一帧点云中的激光点是不同时刻采集的，激光点的坐标原点是采集时刻的雷达位姿，雷达在不同时刻的位姿有变化的时候，各个激光点原点不一致，拼接成一帧时，点云的形状便和实际物体形状不一致。</p><p><img src="/images/点云地图的建立/image-20220503193403250.png" alt="image-20220503193403250" style="zoom:50%;" /></p><p><img src="/images/loam论文深度解析/image-20220411193701848.png" alt="image-20220411193701848" style="zoom:33%;" /></p><ul><li><strong>补偿方法：</strong></li></ul><p>对于每一个激光点坐标做补偿，补偿量为激光点云与原点（即当时激光雷达坐标）相对于该帧起始时刻的变换。</p><h2 id="计算相对坐标"><a href="#计算相对坐标" class="headerlink" title="计算相对坐标"></a>计算相对坐标</h2><p>在匀速模型假设前提下，坐标 = 运动×时间。</p><p>假设第一帧点云的起始位姿为：</p><script type="math/tex; mode=display">T_0=\begin{bmatrix}R_0&t_0\\0&1\end{bmatrix}\tag{1}</script><p>第$i$个激光点采集时，雷达的位姿为：</p><script type="math/tex; mode=display">T_i=\begin{bmatrix}R_i&t_i\\0&1\end{bmatrix}\tag{2}</script><p>第$i$个激光点的坐标为：</p><script type="math/tex; mode=display">P_i=[p_{ix} \ p_{iy} \ p_{iz}]^T\tag{3}</script><p>则第$i$个激光点补偿畸变后的坐标应该为：</p><script type="math/tex; mode=display">\overline{P}_i=T_0^{-1}T_iP_i\tag{4}</script><p>上式可以理解为，只需要计算$0$到$i$时刻，激光雷达的相对旋转和相对平移变换即可。</p><p>实际上，雷达点云是局部坐标系下的表示，当以0时刻雷达的位姿为基准坐标系的时候，此时$T_0$为单位阵，$T_i$即为$0$到$i$时刻的相对旋转和平移。</p><p>此时有：</p><script type="math/tex; mode=display">\begin{align*}R_i&=\omega\nabla t\\t_i&=V\nabla t\end{align*}\tag{5}</script><p>即，只需要知道$0$到$i$时刻的平均角速度和平均速度即可。</p><p><strong>那么时间差如何进行求取呢？</strong></p><p>由于是顺序扫描，我们可以通过$\arctan\frac{y}{x}$来计算出该激光点相对于第一个激光点旋转过的角度$\beta$，已知雷达内部旋转$360°$用了$100ms$，那么旋转$\beta$角度所用的时间就可以计算出来了。</p><p>但是由于$\arctan\frac{y}{x}\in[-90°,90°]$的范围。而雷达的周期是$360°$，因此计算出来的$\arctan\frac{y}{x}$还需要进行角度补偿。</p><p>下面摘自：<a href="https://zhuanlan.zhihu.com/p/109379384">从零开始做自动驾驶定位(八): 点云畸变补偿</a></p><h2 id="点云数据排列方式"><a href="#点云数据排列方式" class="headerlink" title="点云数据排列方式"></a>点云数据排列方式</h2><p>做激光定位的多数都看过loam的程序，会发现在计算激光点采集时刻这一步上我们和它是有区别的，这就是这个点云排列方式导致的。</p><p>从激光雷达原理上讲，每次采集一列，边扫描边采集，所以数据应该是一列一列地存储，这样保证第一个点一定是最早时刻被采集的，最后一个点是最晚时刻被采集的，这样做有一个好处，那就是可以计算雷达真正扫描了多少度，因为它就是第一个点和最后一个点的角度差。</p><p>而在这个bag文件里，是按行存储的，也就是先索引第一根线上的点，再第二根，依次类推，直到最后一根，这样的缺点是，我们无法通过这个来计算雷达实际扫描角度了，因为第一个点不一定是时间最早的点，如果第一根线前半部分被遮挡，那么你就会得到错误的计算角度，所以这时候，像我们这样直接强制把扫描角度设置成360度是更稳妥的，缺点就是它不够精确。</p><p>这个问题的原因应该是数据的二次加工导致的，kitti先把数据存成bin文件，kitti2bag再转成bag文件，改变了原来的排列方式。一般雷达驱动中输出的数据都是按列排列的。</p><p>所以如果各位以后使用的数据是列排列的，那么时间计算上可以使用loam里的方法，会更准确。</p><h1 id="定位流程"><a href="#定位流程" class="headerlink" title="定位流程"></a>定位流程</h1><p>在地图匹配的过程中，鲁棒性和运行速度特别重要，因此实际中，基于NDT的匹配使用更为广泛。由于NDT匹配需要较准确的初始位姿，因此在定位之前需要初始化环节，给出载体的初始位姿。<br>按照难度由低到高，常见的初始化需求有这样几种：</p><p>1）已知位姿的初始化<br>2）位置已知而姿态未知的初始化<br>3）位置和姿态均未知的初始化</p><p><img src="/images/点云地图的建立/image-20220504092212456.png" alt="image-20220504092212456" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;点云地图的建立&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="建图" scheme="https://lukeyalvin.top/tags/%E5%BB%BA%E5%9B%BE/"/>
    
    <category term="畸变补偿" scheme="https://lukeyalvin.top/tags/%E7%95%B8%E5%8F%98%E8%A1%A5%E5%81%BF/"/>
    
  </entry>
  
  <entry>
    <title>后端位姿图优化</title>
    <link href="https://lukeyalvin.top/posts/aed03174.html"/>
    <id>https://lukeyalvin.top/posts/aed03174.html</id>
    <published>2022-05-02T13:26:34.855Z</published>
    <updated>2022-05-03T10:35:42.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="后端优化的基本原理"><a href="#后端优化的基本原理" class="headerlink" title="后端优化的基本原理"></a>后端优化的基本原理</h1><ul><li><strong>后端优化的目的：</strong></li></ul><p>利用回环检测结果和惯导先验位姿修正里程计误差，而回环在此提供的是两帧之间的相对位姿。</p><ul><li><strong>后端优化的方法：</strong></li></ul><p>假设马尔可夫性，简单的一阶马氏性认为，$k $时刻状态只与$ k − 1 $时刻状态有关，而与再之前的无关。如果做出这样的假设，我们就会得到以扩展卡尔曼滤波（EKF）为代表的滤波器方法。在滤波方法中，我们会从某时刻的状态估计，推导到下一个时刻。</p><p>另外一种方法是依然考虑 $k$ 时刻状态与之前所有状态的关系，此时将得到非线性优化为主体的优化框架。在视觉SLAM中非线性优化如BA与图优化、位姿图优化等。</p><ul><li><strong>总结而言，后端优化的观测主要从这三个方面：</strong></li></ul><p>①连续两帧之间的相对位姿观测（里程计）</p><p>②闭环匹配得到的相对位姿观测（闭环检测）</p><p>③组合导航提供的先验位姿估计（IMU）</p><p>①②的观测构成了<strong>基于回环的位姿修正</strong>，①③的观测构成了<strong>基于先验观测的位姿修正，</strong>当然三者也可以结合使用。三者的关系是，②③在①的基础上对位姿进行修正，这里对里程计的平滑性有一定的要求。</p><h1 id="基于回环的位姿修正"><a href="#基于回环的位姿修正" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h1><h2 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h2><p><img src="/images/后端位姿图优化/fc51f93b-322d-475b-bfa5-cae57a6750f9.jpeg" alt="回环检测是什么"></p><p>首先我们需要了解什么是回环检测，如是上图所示，对于里程计而言，它用来估计帧与帧之间的位姿估计，而这个位姿估计会因为噪声而产生漂移，（即使每一帧之间我们都进行了BA优化，但微小的漂移仍是无法避免的），由于里程计帧之间的位姿估计有很多，因此积少成多，漂移最终累积特别大，就会导致机器人在达到初始位置是，观测显示已经回到初始位置，而位姿估计却显示与初始位置相差一段距离，如上图所示。</p><p>我们通过构建位姿估计的位置和初始位置的残差项，对整个回环进行优化和修正，进而得到如下的地图。（理论而言，没有漂移的情况下，位姿估计的位置和初始位置是重合的。）</p><p><img src="/images/后端位姿图优化/32fa19ca-c057-4ccb-8075-802d0a456991.jpeg" alt="什么是回环检测"></p><p>因此，回环检测的目的就是消除累积误差。</p><h2 id="位姿图优化"><a href="#位姿图优化" class="headerlink" title="位姿图优化"></a>位姿图优化</h2><p>与之前的BA优化不同，比如我们之前学习的重投影模型，它考虑的是相邻帧之间的位姿估计，需要优化每个相机的位姿和特征点的位置，即使我们使用关键帧，对于大场景而言，特征点的观测是非常巨大的，这种计算量也是巨大的。</p><p>而位姿图优化，构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。</p><p><img src="/images/后端位姿图优化/image-20220503095925699.png" alt="image-20220503095925699" style="zoom:50%;" /></p><h2 id="基于回环的位姿修正-1"><a href="#基于回环的位姿修正-1" class="headerlink" title="基于回环的位姿修正"></a>基于回环的位姿修正</h2><h3 id="构建残差"><a href="#构建残差" class="headerlink" title="构建残差"></a>构建残差</h3><p>在上文，我们找到如何构建残差项，下一步就是对残差项进行修正，那么我们就需要求得残差项对相应状态量的雅可比矩阵，从而才能知道从哪个方向修正状态量能够达到优化的目的。</p><p>位姿图优化关心的是两帧之间的观测，这两帧并不一定是相邻的两帧，比如回环检测中的两帧。设第$i$和第$j$帧之间的观测，在李群SE3上可以表示为：</p><script type="math/tex; mode=display">\Delta T_{ij}=T_i^{-1}T_j.\tag{1}</script><p>很容易理解，如果说第$i$和第$j$帧构成回环，那么$T_i^{-1}T_j=I$，也就不存在误差。</p><p>也可以用李代数表示：</p><script type="math/tex; mode=display">\Delta \xi_{ij}=\xi^{-1}_i◦\xi_j=\ln(T_i^{-1}T_j)^{\lor}.\tag{2}</script><p>构建残差：</p><script type="math/tex; mode=display">\begin{align*}e_{ij}&=\ln(\Delta T_{ij}^{-1}T_i^{-1}T_j)^{\lor}\\&=\ln(\exp((-\xi_{ij})^{\land})\exp((-\xi_i)^{\land})\exp(\xi^{\land}_j))^{\lor}\end{align*}.\tag{3}</script><p>位姿图优化的思想是通过调整状态量（即位姿），使残差项的值最小化，这就是需要用残差项求雅可比矩阵，才能使用梯度下降方法进行迭代优化。</p><h3 id="求雅可比矩阵"><a href="#求雅可比矩阵" class="headerlink" title="求雅可比矩阵"></a>求雅可比矩阵</h3><p>我们对位姿$T_i$和$T_j$分别左乘一个扰动$\Delta T=\exp(\delta\xi^{\land})$</p><script type="math/tex; mode=display">\begin{align*}\hat{e}_{ij}&=\ln \left(T_{ij}^{-1}T_i^{-1}\exp((-\delta\xi_i)^{\land})\exp(\delta\xi_j^{\land})T_j\right)^{\lor}\\&=\ln \left( T_{ij}^{-1}T_i^{-1}T_j\exp\left(  (-Ad(T_j^{-1})\delta\xi_i)^{\land}  \right)\exp\left(    (Ad(T_j^{-1})\delta\xi_j)^{\land} \right)\right)^{\lor}\\&\approx\ln \left( \exp(e_{ij})\exp\left((-Ad(T_j^{-1})\delta\xi_i)^{\land}+(Ad(T_j^{-1})\delta\xi_j)^{\land}\right)\right)^{\lor}\\&\approx e_{ij}-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\delta\xi_i+\mathcal{J}_r^{-1}Ad(T_j^{-1})\delta\xi_j\end{align*}\tag{4}</script><hr><p>这里推导过程的第一步到第二步利用了李群的伴随性质：</p><ul><li><strong>SO(3)上的伴随性质</strong></li></ul><script type="math/tex; mode=display">R\exp(p^{\land})R^T=\exp((Rp)^{\land})\\</script><ul><li><strong>SE(3)上的伴随性质</strong></li></ul><script type="math/tex; mode=display">T\exp(\xi^{\land})T^{-1}=\exp((Ad(T)\xi)^{\land})\\</script><p>其中伴随矩阵的定义如下：</p><script type="math/tex; mode=display">Ad(T)=\begin{bmatrix}R&t^{\land}R\\ 0&R\end{bmatrix}</script><p>第二步第三步使用的是BCH公式：</p><ul><li><strong>SO(3)上的BCH公式</strong></li></ul><script type="math/tex; mode=display">\ln(\exp(\phi_1^{\land})\exp(\phi_2^{\land}))\approx\left\{\begin{aligned}J_l(\phi_2)^{-1}\phi_1+\phi_2\ ,\ 当\phi_1为小量 \\J_r(\phi_1)^{-1}\phi_2+\phi_1\ ,\ 当\phi_2为小量\end{aligned}\right.</script><p>其中左乘雅可比为：</p><script type="math/tex; mode=display">J_l=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})aa^T+\frac{1-\cos\theta}{\theta}a^{\land}</script><p>所以：</p><script type="math/tex; mode=display">J_l^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})aa^T-\frac{\theta}{2}a^{\land}</script><p>右乘雅可比仅需要在左乘雅可比的基础上对自变量取负号，即：</p><script type="math/tex; mode=display">J_r(\phi)=J_l(-\phi)</script><ul><li><strong>SE(3)上的BCH公式</strong></li></ul><script type="math/tex; mode=display">\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\left\{\begin{aligned}J_l(\xi_2)^{-1}\xi_1+\xi_2\ ,\ 当\xi_1为小量 \\J_r(\xi_1)^{-1}\xi_2+\xi_1\ ,\ 当\xi_2为小量\end{aligned}\right.</script><p>其中右乘雅可比为：</p><script type="math/tex; mode=display">\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi^{\land}&\rho^{\land}\\0&\phi^{\land}\end{bmatrix}</script><p>一般情况下，若$\xi$非常小，该雅克比矩阵可以直接使用单位阵，此时：</p><script type="math/tex; mode=display">\ln(\exp(\xi_1^{\land})\exp(\xi_2^{\land}))^{\lor}\approx\ln(\exp(\xi_1^{\land}+\xi_2^{\land}))^{\lor}</script><p>这里第二步到第三步的推导用的就是这个式子。</p><hr><p>所以，残差关于$T_i$的雅可比为：</p><script type="math/tex; mode=display">A_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_i}=-\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{5}</script><p>残差关于$T_j$的雅可比为：</p><script type="math/tex; mode=display">B_{ij}=\frac{\partial e_{ij} }{\partial \delta \xi_j}=\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1})\tag{6}</script><p>其中：</p><script type="math/tex; mode=display">\mathcal{J}_r^{-1}(\xi)\approx I+\frac{1}{2}\begin{bmatrix}\phi_e^{\land}&\rho_e^{\land}\\0&\phi_e^{\land}\end{bmatrix}\tag{7}</script><p>为了找到梯度方向，需要对残差进行一阶泰勒展开：</p><script type="math/tex; mode=display">\begin{align*}&e_{ij}(x_i+\Delta x_i,x_j+\Delta x_j)\\=&e_{ij}(x+\Delta x)\\\approx&e_{ij}+J_{ij}\Delta x\end{align*}\tag{8}</script><p>其中$J_{ij}$即为前面推导的残差关于位姿的雅可比组成的矩阵：</p><script type="math/tex; mode=display">J_{ij}=(0···0\ A_{ij}\ 0···0 \ B_{ij} \ 0···0)</script><p>至此，我们就把非线性优化变成了一个线性化问题。</p><h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><p>位姿图优化就是把所有的观测和状态放在一起优化，在实际使用中，各个残差会被分配一个权重，也就是信息矩阵，它相当于对残差进行加权，考虑信息矩阵后，总的残差可以表示为:</p><script type="math/tex; mode=display">F(x)=\sum_{i,j\in \mathcal{C} }F_{ij}=\sum_{i,j\in \mathcal{C}} e_{ij}^T\Omega_{ij}e_{ij}\tag{9}</script><blockquote><p>权重矩阵又称为信息矩阵，它是协方差矩阵的逆，即为：$\Omega_{ij}=\Sigma_{ij}^{-1}$，因为每个残差都看作高斯分布，而每个高斯分布都可以归一化为标准的高斯分布$N(0,1)$，这种归一化操作是减去均值求平方然后除以方差。残差预期均值为0，所以不用减只需要除以方差，扩展到多维的话就变成了信息矩阵加权形式。</p></blockquote><p>所以此时的优化问题就是：</p><script type="math/tex; mode=display">x^*=\arg\underset{x}{\min}\ F(x)\tag{10}</script><p>对于每一个残差块，都有：</p><script type="math/tex; mode=display">\begin{align*}&F_{ij}(x+\Delta x)\\&=e_{ij}(x+\Delta x)^T\Omega_{ij}e_{ij}(x+\Delta x)\\&\approx e_{ij}^T\Omega_{ij}e_{ij}+2e_{ij}^T\Omega_{ij}J_{ij}\Delta x+\Delta x^TJ_{ij}^T\Omega_{ij}J_{ij}\Delta x\\&=c_{ij}+2b^T_{ij}\Delta x+\Delta x^TH_{ij}\Delta x\end{align*}\tag{11}</script><p>其中：</p><script type="math/tex; mode=display">c_{ij}=e_{ij}^T\Omega_{ij}e_{ij}</script><script type="math/tex; mode=display">H^T_{ij}=J_{ij}^T\Omega_{ij}J_{ij}=\begin{bmatrix}··· & ··· & ··· & ··· \\··· &A^T_{ij}\Omega_{ij}A_{ij}&···&A^T_{ij}\Omega_{ij}B_{ij}\\··· & ··· & ··· & ··· \\··· &B^T_{ij}\Omega_{ij}A_{ij}&···&B^T_{ij}\Omega_{ij}B_{ij}\\··· & ··· & ··· & ··· \\\end{bmatrix}</script><script type="math/tex; mode=display">b_{ij}=e_{ij}^T\Omega_{ij}J_{ij}=\begin{bmatrix} ···\\A^T_{ij}\Omega_{ij}e_{ij}\\···\\B^T_{ij}\Omega_{ij}e_{ij}\\···\end{bmatrix}</script><p>所以，要使得误差最小，只需要使得：</p><script type="math/tex; mode=display">H\Delta x = -b\tag{11}</script><p>根据修正量，修正$x$的值，即完成依次迭代：</p><script type="math/tex; mode=display">x^*=x+\Delta x\tag{12}</script><p>多次迭代，直至残差满足收敛条件时，则终止循环，完成优化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;BA 能精确地优化每个相机位姿与特征点位置。不过在更大的场景中，大量特征点的存在会严重降低计算效率，导致计算量越来越大以至于无法实时化。本讲介绍两种在更大场景下使用的后端优化方法：位姿图。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="后端优化" scheme="https://lukeyalvin.top/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    <category term="位姿图优化" scheme="https://lukeyalvin.top/tags/%E4%BD%8D%E5%A7%BF%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ScanContext解析与实践</title>
    <link href="https://lukeyalvin.top/posts/3df51dc4.html"/>
    <id>https://lukeyalvin.top/posts/3df51dc4.html</id>
    <published>2022-04-30T02:00:58.104Z</published>
    <updated>2022-05-02T11:19:41.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p><strong>Scan Context</strong> 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在<strong>IROS</strong>(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/images/ScanContext解析与实践/1-16512834289741.gif" alt="1"></p><p>对于SLAM来说，回环检测是重要的一步，我们知道，当机器人做一个回环时，可能会出现已经达到达起始点，但是由于漂移，位姿估计值却显示当前位置和初始位置还有相差一段距离，这时候，我们就依赖回环检测，把当前位置拉回初始位置，这样就消除了漂移，这个过程就是回环检测的目的。</p><p>所以回环检测的关键是，对于某一帧点云来说，它经过一个历史状态之后，我们如何去索引当前帧是否在历史帧中出现过，即检测有没有发生回环。当然，最容易想到的也是最朴素的做法就是，将这一帧的3D点云与历史所有帧做匹配，找到最接近的那一个。但是对于3D点云来这么做计算量无疑是巨大的，而且三维匹配还存在一个初值的问题。</p><p>因此，作者提出了ScanContext，上面的动画可以看出ScanContext的工作过程就是把3D点云通过俯视图的方式转换为2D，然后用过2D匹配找到回环，达到回环检测的目的，这样将三维降为两维进行匹配大大减小了计算量，并且它对初值相对不敏感。</p><p>ScanContext的主要流程如下：</p><p><img src="/images/ScanContext解析与实践/image-20220430131549451.png" alt="image-20220430131549451" style="zoom: 50%;" /></p><h1 id="点云切割"><a href="#点云切割" class="headerlink" title="点云切割"></a>点云切割</h1><p>首先是进行点云分割，如下图所示:</p><p>首先使用来自 3D 扫描的点云的俯视图，以扫描的中心充当全局关键点。对点云的俯视图进行圆环分割和扇区分割，可以看出以扫描中心为关键点，向外扩散形成$N_r$个同心圆，我们称之为$N_r$个环。然后以中心为关键点对圆环的$[0,2\pi]$进行均匀分割，得到$N_s$ 个扇区。论文中取 $N_s= 60$ 和 $N_r = 20$。</p><p><img src="/images/ScanContext解析与实践/image-20220430133756320.png" alt="image-20220430133756320" style="zoom: 33%;" /></p><p><img src="/images/ScanContext解析与实践/image-20220430132509355.png" alt="image-20220430132509355"></p><p>可以发现，沿着半径增大的方向（绿色箭头的方向），把点云分割成了$N_r$个圆环，每个圆环的宽度为：</p><script type="math/tex; mode=display">d_r=\frac{L_{max} }{N_r}\tag{1}</script><p>其中$L_{max}$表示激光雷达测得点云的最远距离。</p><p>通过图不难发现，我们一共得到$N_r$个环和$N_s$ 个扇区，每个环都与扇区有重叠区域，这个重叠区域称之为bin，而且远离传感器的 bin 的物理面积比近的 bin 更宽。设$\mathcal{P}_{ij}$是属于第$ i $个环和第 $j$ 个扇区重叠的 bin 的点集。设激光点经过分割后的集合为$\mathcal{P}$，则：</p><script type="math/tex; mode=display">\mathcal{P}=\underset{i\in[N_r],j\in[N_s]}{\cup}\mathcal{P}_{ij}\tag{2}</script><p>其中，符号 $[N_s] =\{1, 2, …, N_{s-1}, N_s\},[N_r] =\{1, 2, …, N_{r-1}, N_r\}$。</p><h1 id="生成ScanContext"><a href="#生成ScanContext" class="headerlink" title="生成ScanContext"></a>生成ScanContext</h1><p>经过分割后，我们发现分割后的点云的集合就是bin的集合，而bin是$N_r$个环和$N_s$ 个扇区的重叠区域，每个bin区域可能会有点云也可能没有点云（图（b）中的蓝色像素），而我们将bin的集合表示为矩阵形式，就可以得到一个$N_r\times N_s$的矩阵，其中矩阵的每一行代表一个圆环，则一共有$N_r$行，所以下图纵坐标范围为$[0,L_{max}]$；矩阵的每一列代表一个扇区，则一共有$N_s$列，所以下图横坐标范围为$[0,2\pi]$。</p><p><img src="/images/ScanContext解析与实践/image-20220430135402491.png" alt="image-20220430135402491" style="zoom: 67%;" /></p><p>那么bin的值如何确定呢？我们知道，没有点云的bin，我们对其赋值为0，图中用蓝色像素表示；那么有点云的bin如何表示呢？作者在这里使用的是<strong>最大高度</strong>。</p><p>设某个点云为$p$， $z(\cdot ) $是返回点 $p$ 的$ z $坐标值的函数，则任一个点云集合bin的值为：</p><script type="math/tex; mode=display">\phi(\mathcal{P}_{ij})=\underset{p\in\mathcal{P}_{ij}}{\max}z(p)\tag{3}</script><p>这么做有什么好处？我们知道，在开始我们把三维点云降为二维，损失了高度信息，而这里对高度信息相当于一次补偿作用，保留了信息的完整性。</p><h1 id="基于ScanContext的匹配"><a href="#基于ScanContext的匹配" class="headerlink" title="基于ScanContext的匹配"></a>基于ScanContext的匹配</h1><p>在得到ScanContext数据之后，我们如何利用ScanContext进行匹配，进而完成回环检测，这是ScanContext最终的目的。</p><p>设</p><ul><li><p>$I^q$为当前帧的ScanContext， $c^q_j $为$I^q$中的第$j$列；</p></li><li><p>$ I^c $为历史帧的ScanContext，$c^c_j $为$I^c$中的第$j$列；</p></li></ul><p>两帧之间的距离函数定义为：</p><script type="math/tex; mode=display">d(I^q,I^c)=\frac{1}{N_s}\sum^{N_s}_{j=1}(1-\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}).\tag{4}</script><p>通过这个距离函数可以发现，它反应了两帧之间的差异性，对于相似的两帧，它们的相同列向量的内积的模应该为1，即$\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}=1$，则距离接近为0，当然这仅仅是理想情况下，实际上，我们通过设置阈值的方式，当距离函数小于某一个阈值时，认为该历史帧为回环检测的回环帧。</p><p><strong>但是这里存在一个问题，就是历史帧有旋转的时候：</strong></p><p>这里我们定义的是当前帧与历史帧的相同列进行比较，这个条件是十分强的，假设激光雷达在经过一个地方的时候方向与之前的方向恰恰相反，或者该地方为一个十字路口，激光雷达从不同的方向经过一个地方，则雷达相对于全局坐标的坐标会发生变化，导致得到的ScanContext中的列向量顺序可能发生变化，进而使得两帧的距离函数比较大，导致经过相同地方的两帧点云的距离函数非常大，最终回环检测匹配失败。</p><p>如下图所示，这是经过相同地方的两帧点云，它们由于激光雷达的朝向发生了改变，导致两者的ScanContext中的列向量顺序发生变化，距离函数值随之变得非常大。</p><p><img src="/images/ScanContext解析与实践/image-20220430143355265.png" alt="image-20220430143355265" style="zoom:50%;" /></p><p>不难发现，将图(b)后半部分切割放到前面，如下图所示，就可以得到与(a)十分相似的ScanContext.</p><p><img src="/images/ScanContext解析与实践/image-20220430143946603.png" alt="image-20220430143946603" style="zoom:50%;" /></p><p>对于人而言，上述规律是非常容易发现的。但是实际程序中怎么切割，怎么移动才能达到上述效果？</p><p>最简单也是最朴素的做法就是，将历史帧$I^c$按列平移，得到$[N_s]$个ScanContext，依次与当前帧的ScanContext计算距离，选择距离最小的，即为闭环匹配的帧。</p><p>但是这种方法的计算量也是相对较大的，作者在代码中对此方法进行了优化，优化方法就是将当前帧与历史帧对应列分别求列和，然后根据列和我们找到可能的最佳切割点，但是由于我们降维之后会损失一部分信息，因此我们寻找的切割点并不是足够准确的，所以我们将在切割点附近对对应的二维$m$列依次进行切割平移，得到远远小于$n(n&lt;&lt;[N_s])$个的ScanContext，依次与当前帧的ScanContext计算距离，选择距离最小的，即为闭环匹配的帧。</p><p><img src="/images/ScanContext解析与实践/image-20220430153440012.png" alt="image-20220430153440012" style="zoom: 67%;" /></p><h1 id="计算相对位姿"><a href="#计算相对位姿" class="headerlink" title="计算相对位姿"></a>计算相对位姿</h1><p>设$I^c_n$ 是一个$\mathrm{Scan Context}$，它的第$n$列是从原始的$\mathrm{Scan Context}$偏移过来的。由于列向量代表的是分辨率为$\frac{2\pi}{N_s}$的扇区，所以每个列对应的角度为$\frac{2\pi}{N_s}$。整个过程，把历史帧切割，然后进行列平移之后，得到与当前帧的良好匹配， 良好的匹配意味着我们通过分割平移将历史帧对应的位姿旋转到当前帧对应位姿的朝向，那么，反过来，我们可以根据平移来求得旋转的角度。</p><p>假设距离最小时，对应的列的平移量为：</p><script type="math/tex; mode=display">n^*=\underset{n\in[N_s]}{\arg\min} \ d(I^q,I^c_n)\tag{5}</script><p>因此，历史帧与当前帧之间的旋转的角度为：</p><script type="math/tex; mode=display">\phi=\frac{2\pi}{N_s}\times n^*\tag{6}</script><p>这个旋转分辨率在作者代码中为$\frac{2\pi}{N_s}=\frac{2\pi}{60}=6°$，所以匹配的精确度小于$6°$，这并不是一个精确的值，需要进一步精确的话则需要使用ICP或者NDT匹配。因此可以作为ICP或者NDT匹配的初始位姿，用于<strong>精确匹配</strong>得到闭环约束相对位姿。</p><h1 id="解决时间复杂度问题"><a href="#解决时间复杂度问题" class="headerlink" title="解决时间复杂度问题"></a>解决时间复杂度问题</h1><p><strong>目的：</strong>ScanContext可以使用矩阵对应列的相似度来计算两帧的相似性，但是遍历所有历史帧的相似度计算量比较高，需要做一个快速初步筛选。</p><p><strong>思路：</strong>相似帧之间，落在同等半径的圆环中的点的数量应该相似，可以用来快速查找。</p><p>比如，某一帧中，在圆环$r_i,i\in[N_r]$中，被$[N_s]$个扇区分割为$[N_s]$个bin，对于相似的两帧，对应圆环中，含有点云的bin占有率应该相同，如公式$(8)$。通过这种方法可以进行<strong>第一阶段的粗略匹配</strong>。</p><p><strong>方法：</strong></p><p><img src="/images/ScanContext解析与实践/image-20220430164906076.png" alt="image-20220430164906076" style="zoom:50%;" /></p><p>这里作者引入了一个$ring\ key$的概念。</p><p><strong>（1）每一帧生成一个向量$k$</strong></p><p>$ring\ key$实质上就是$\mathrm{Scan Context}$的每一行$r$经过编码函数$\psi$编码成一个实数值后，$N_r$个圆环组成了一个$N_r$维向量的$ring\ key$，即为</p><script type="math/tex; mode=display">k=(\psi(r_1),...,\psi(r_{N_r})),\mathrm{where}\ \psi:r_i\rightarrow\mathbb{R}\tag{7}</script><p>其中，我们使用的环编码函数$\psi$是使用 $L_0$范数的环的占用率：</p><script type="math/tex; mode=display">\psi(r_i)=\frac{\parallel r_i \parallel_0}{N_s}\tag{8}</script><p>$\parallel r_i \parallel_0$表示半径$r_i$对应的圆环中非空分割单元的个数。</p><p><strong>（2）根据（1）中计算的向量，所有历史帧共同构建KDtree;</strong></p><p><strong>（3）使用当前帧对应的向量，在KDtree中查找，找到$n$个可能的相似帧，作为候选索引$\mathcal{C}$ 。</strong></p><p><strong>（4）使用$\mathrm{Scan Context}$进行第二阶段的精确匹配</strong></p><p>虽然不如$\mathrm{Scan Context}$信息丰富，但$ring\ key$支持快速搜索，以找到$n$个可能的候选闭环。使用距离公式将这些恒定数量的候选$\mathrm{Scan Context}$与要查询的$\mathrm{Scan Context}$进行比较。最接近的满足给定阈值$\tau$ 的候选项被选为重新访问的位置：</p><script type="math/tex; mode=display">c^*=\underset{c_k\in\mathcal{C} }{\arg\min}\ D(I^q,I^c),s.t. \ D<\tau\tag{9}</script><p>其中 $\mathcal{C}$ 是从 KD 树中提取的一组候选索引，$\tau$ 是给定的接受阈值。 $c^∗ $是确定为闭环的位置的索引。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;&lt;strong&gt;Scan Context&lt;/strong&gt; 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在&lt;strong&gt;IROS&lt;/strong&gt;(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    
    <category term="ScanContext" scheme="https://lukeyalvin.top/tags/ScanContext/"/>
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
  </entry>
  
  <entry>
    <title>ScanContext论文翻译</title>
    <link href="https://lukeyalvin.top/posts/79ac789e.html"/>
    <id>https://lukeyalvin.top/posts/79ac789e.html</id>
    <published>2022-04-29T08:07:21.546Z</published>
    <updated>2022-05-02T01:35:44.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p><strong>Scan Context</strong> 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在<strong>IROS</strong>(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="mathrm-Scan-Context-用于-3D-点云地图中地点识别的以自我为中心的空间描述子"><a href="#mathrm-Scan-Context-用于-3D-点云地图中地点识别的以自我为中心的空间描述子" class="headerlink" title="$\mathrm{Scan Context}$:用于 3D 点云地图中地点识别的以自我为中心的空间描述子"></a>$\mathrm{Scan Context}$:用于 3D 点云地图中地点识别的以自我为中心的空间描述子</h1><p><img src="/images/Scan-Context论文阅读/1-16512834289741.gif" alt="1"></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>与用于视觉场景的各种特征检测器和描述子相比，使用结构信息描述地点的研究相对较少。同时定位和建图 (SLAM) 的最新进展提供了环境的密集 3D 地图，并且定位是由不同的传感器提出的。针对基于结构信息的全局定位，我们提出了 $\mathrm{Scan Context}$，这是一种来自 3D 光检测和测距（激光雷达） (Light Detection and Ranging ，LiDAR) 扫描的基于非直方图的全局描述子。与先前研究的方法不同，所提出的方法直接从传感器记录可见空间的 3D 结构，而不依赖于直方图或先前的训练。此外，该方法提出了使用相似度分数来计算两个$\mathrm{Scan Context}$之间的距离，以及一种两阶段搜索算法来有效地检测回环。$\mathrm{Scan Context}$及其搜索算法使回环检测不受激光雷达视点变化的影响，从而可以在重新访问同一个地点和拐角等地方检测到闭环。$\mathrm{Scan Context}$性能已经通过 3D激光雷达扫描的各种基准数据集进行了评估，并且所提出的方法显示出充分改进的性能。</p><h1 id="Ⅰ-引言"><a href="#Ⅰ-引言" class="headerlink" title="Ⅰ.引言"></a>Ⅰ.引言</h1><p>在许多机器人应用中，位置识别是重要的问题。特别是对于 SLAM，这种识别为闭环提供了候选项，这对于纠正漂移误差和构建全局一致的地图至关重要 [1]。虽然闭环对机器人导航至关重要，但错误的匹配可能是灾难性的，需要仔细匹配。视觉识别随着相机传感器的广泛使用而流行，然而，由于光照变化和短期（例如，移动的物体）或长期（例如，季节）的变化，它本质上是困难的。因此，最近的文献集中在通过检查表示 [2] 和弹性后端 [3] 的鲁棒位置识别。</p><p>与这些视觉传感器不同，激光雷达最近因其对感知方差的强不变性而受到关注。早期，传统的局部关键点描述子 [4, 5, 6, 7] 最初是为计算机视觉中的 3D 模型设计的，尽管它们容易受到噪声的影响，但已被用于位置识别。基于激光雷达的位置识别方法已在机器人文献中广泛提出 [8, 9, 10]。这些工作侧重于从结构信息（例如点云）中以局部 [8] 和全局方式 [10] 开发描述子。</p><p>现有的基于 LiDAR 的位置识别方法一直试图克服两个问题。首先，无论视点变化如何，都需要描述子来实现旋转不变性。其次，噪声处理是这些空间描述子的另一个主题，因为点云的分辨率随距离而变化，并且法线是有噪声的。现有方法主要使用直方图[9,11,12]来解决上述两个问题。然而，由于直方图方法只提供场景的随机索引，描述场景的详细结构并不简单。这种限制使得描述子对于地点识别问题的可识别性降低，从而导致潜在的误匹配。</p><p><img src="/images/Scan-Context论文阅读/image-20220429164041335-16512834289762.png" alt="image-20220429164041335" style="zoom:50%;" /></p><p><img src="/images/Scan-Context论文阅读/image-20220429164059389-16512834289774.png" alt="image-20220429164059389" style="zoom:50%;" /></p><blockquote><p>图 1. 两步$\mathrm{Scan Context}$创建。使用来自 3D 扫描的点云的俯视图 (a)，我们将地面区域划分为 bin，根据方位角（在 LiDAR 框架内从 0 到 2π）和径向（从中心到最大感应范围）进行划分方向。我们将黄色区域称为一个环，将青色区域称为一个扇区，将黑色填充区域称为一个 bin。$\mathrm{Scan Context}$是（b）中的矩阵，它明确地保留了点云的绝对几何结构。 (a) 中描述的环和扇区在 (b) 中分别由相同颜色的列和行表示。从位于每个 bin 中的点中提取的代表值用作 (b) 的对应像素值。在本文中，我们使用 bin 中点的最大高度。</p></blockquote><p>在本文中，我们提出了 $\mathrm{Scan Context}$，这是一种具有匹配算法的新型空间描述子，专门针对使用单个 3D 扫描的户外地点识别。我们的表示将 3D 扫描中的整个点云编码为矩阵（图 1）。所提出的表示描述了以自我为中心的 2.5D 信息。该方法的贡献点是：</p><ul><li><strong>高效的 bin 编码功能。</strong>与现有的点云描述子 [7, 10] 不同，所提出的方法不需要计算 bin 中的点数，而是提出了一种更有效的用于位置识别的 bin 编码函数。这种编码对点云的密度和法线具有不变性。</li><li><strong>保留点云的内部结构。</strong>如图 1 所示，矩阵的每个元素值仅由属于 bin 的点云确定。因此，与将点的相对几何描述为直方图并丢失点的绝对位置信息的[9]不同，我们的方法通过有意避免使用直方图来保留点云的绝对内部结构。这提高了判别能力，还可以在计算距离时将查询扫描与候选扫描（在我们的实验中，6°方位角分辨率）进行视点对齐。因此，也可以通过使用$\mathrm{Scan Context}$来检测反向闭环。</li><li><strong>有效的两相匹配算法。</strong>为了实现可行的搜索时间，我们为第一个最近邻搜索提供了一个旋转不变的子描述子，并将其与成对相似度评分分层结合，从而避免搜索所有数据库进行闭环检测。</li><li><strong>针对其他最先进的空间描述子进行彻底验证。</strong>与其他现有的全局点云描述子相比，例如 M2DP [8]、形状函数集合 (ESF) [11] 和 Z 投影 [12]，所提出的方法具有实质性的改进。</li></ul><h1 id="Ⅱ-相关工作"><a href="#Ⅱ-相关工作" class="headerlink" title="Ⅱ.相关工作"></a>Ⅱ.相关工作</h1><p>移动机器人的位置识别方法可以分为基于视觉和基于激光雷达的方法。视觉方法已普遍用于 SLAM 文献中的地点识别 [13, 14, 15]。 FAB-MAP [13] 通过学习视觉词袋的生成模型，使用概率方法提高了鲁棒性。然而，视觉表示具有局限性，例如易受光照条件变化的影响[16]。已经提出了几种方法来克服这些问题。 SeqSLAM [17] 提出了基于道路的方法，并显示出比 FAB-MAP 大大提高的性能。 SRAL [2] 融合了几种不同的表示，例如颜色、GIST [18] 和 HOG [19]，用于长期视觉位置识别。</p><p>LiDAR 对上述这些感知变化具有很强的鲁棒性。基于 LiDAR 的方法被进一步分类为局部和全局描述子。局部描述子，例如 PFH [4]、SHOT [5]、shape context[7]或 spin image [6]，首先找到一个关键点，将附近的点分成 bin，并将周围 bin 的模式编码为直方图。Steder 等人提出了以词袋的方式利用点特征和完形描述子（gestalt descriptor） [20] 的位置识别方法[8]。</p><p>然而，这些关键点描述子显示出局限性，因为它们最初是为 3D 模型部分匹配而不是为位置识别而设计的。例如，与 3D 模型不同，3D 扫描（例如，来自 VLP-16）中的点云密度会随着与传感器的距离而变化。此外，由于现实世界中的非结构化对象（例如树），点的法线比模型噪声更大。因此，局部方法通常需要关键点的法线，因此不太适合户外的地点识别。</p><p>全局描述子不包括关键点检测阶段。 GLARE [9] 及其变体 [21, 22] 将点之间的几何关系编码为直方图，以代替搜索关键点和提取描述子。 ESF [11] 使用了由形状函数制成的直方图的串联。 Muhammad 和 Lacroix 提出了 Z 投影 [12]，它是法向量的直方图，以及具有两个距离函数的双阈值方案。Heet 等人提出了 M2DP [10]，它将扫描的整个 3D 点云投影到多个 2D 平面并提取 192 维紧凑的全局表示。M2DP 表现出比现有点云描述子更高的性能以及对噪声和分辨率变化的鲁棒性。如本段所述，全局描述子通常使用直方图。最近，SegMatch [23] 引入了一种基于分段的匹配算法。这是一种高级感知，但需要一个训练步骤，并且需要在全局参考框架中表示点。</p><p>在本文中，我们提出了一种新的位置描述子，称为$\mathrm{Scan Context}$，它将 3D 扫描的点云编码为矩阵。$\mathrm{Scan Context}$可以被认为是Shape Context [7] 的扩展，用于定位 3D LiDAR 扫描数据的位置识别。具体来说，$\mathrm{Scan Context}$包含三个组成部分：在每个 bin 中保留点云的绝对位置信息的表示、高效的 bin 编码函数和两步搜索算法。</p><h1 id="Ⅲ-mathrm-Scan-Context-进行地点识别"><a href="#Ⅲ-mathrm-Scan-Context-进行地点识别" class="headerlink" title="Ⅲ.$\mathrm{Scan Context}$进行地点识别"></a>Ⅲ.$\mathrm{Scan Context}$进行地点识别</h1><p>在本节中，我们描述了给定来自 3D 扫描的点云的$\mathrm{Scan Context}$创建，并提出了一种计算两个$\mathrm{Scan Context}$之间距离的度量。接下来，介绍两步搜索过程。使用$\mathrm{Scan Context}$进行位置识别的整体流程如图 2 所示。$\mathrm{Scan Context}$的创建和验证也可以在 scancontext.mp4 中找到。</p><h2 id="A-mathrm-Scan-Context"><a href="#A-mathrm-Scan-Context" class="headerlink" title="A.$\mathrm{Scan Context}$"></a>A.$\mathrm{Scan Context}$</h2><p>我们为户外地点识别定义了一个名为 $\mathrm{Scan Context}$ 的地点描述子。</p><p><img src="/images/Scan-Context论文阅读/image-20220429192701251-16512834289773.png" alt="image-20220429192701251" style="zoom: 50%;" /></p><blockquote><p>图 2. 算法概述。首先，将单个 3D 扫描中的点云编码到$\mathrm{Scan Context}$中。然后，从$\mathrm{Scan Context}$中对 $N_t$（环数）维向量进行编码，并用于检索最近的候选项以及 KD 树的构造。最后，将检索到的候选与查询$\mathrm{Scan Context}$进行比较。满足接受阈值并最接近查询的候选被认为是闭环。</p></blockquote><p>$\mathrm{Scan Context}$的关键思想受到 Belongie 等人提出的 Shape Context [7] 的启发，它将局部关键点周围的点云的几何形状编码为图像。然而他们的方法只是简单地计算点的数量来总结点的分布，我们的方法与他们的不同之处在于我们使用每个 bin 中点云的高度。使用高度的原因是为了有效地总结周围结构的垂直形状，而不需要大量的计算来分析点云的特征。此外，最大高度表示从传感器可以看到周围结构的哪一部分。这种以自我为中心的可视化在城市设计文献中一直是一个众所周知的概念，用于分析一个地方的身份[24, 25]。</p><p>与Shape Context [7] 类似，我们首先将 3D 扫描划分为传感器坐标中的方位角和径向 bin，但采用等间距的方式，如图 1(a) 所示。扫描的中心充当全局关键点，因此我们将$\mathrm{Scan Context}$称为以自我为中心的位置描述子。$N_s$ 和 $N_r$ 分别是扇区和环的数量。也就是说，如果我们将 LiDAR 传感器的最大感应范围设置为 $L_{max}$，则环之间的径向间隙为 $\frac{L_{max} }{N_r}$，扇形的中心角等于$\frac{2\pi}{N_s}$。在本文中，我们使用 $N_s= 60$ 和 $N_r = 20$。</p><p>因此，制作$\mathrm{Scan Context}$的第一个过程是将 3D 扫描的整个点划分为相互排斥的点云，如图 1(a) 所示。$\mathcal{P}_{ij}$是属于第$ i $个环和第 $j$ 个扇区重叠的 bin 的点集。符号 $[N_s]$ 等于$ \{1, 2, …, N_{s-1}, N_s\}$。因此，分区在数学上是</p><script type="math/tex; mode=display">\mathcal{P}=\underset{i\in[N_r],j\in[N_s]}{\cup}\mathcal{P}_{ij}\tag{1}</script><p>因为点云是按固定间隔划分的，所以远离传感器的 bin 的物理面积比近的 bin 更宽。但是，两者都被同等地编码到$\mathrm{Scan Context}$的单个像素中。因此，$\mathrm{Scan Context}$补偿了由于远点稀疏导致的信息量不足，并将附近的动态对象视为稀疏噪声。</p><p>在点云分区之后，使用该 bin 中的点云为每个 bin 分配一个实数值：</p><script type="math/tex; mode=display">\phi:\mathcal{P}_{ij}\rightarrow\mathbb{R}\tag{2}</script><p>我们使用最大高度，其灵感来自城市能见度分析 [24, 25]。因此，bin 编码函数为:</p><script type="math/tex; mode=display">\phi(\mathcal{P}_{ij})=\underset{p\in\mathcal{P}_{ij}}{\max}z(p)\tag{3}</script><p>其中 $z(\cdot ) $是返回点 $p$ 的$ z $坐标值的函数。我们为空的bin分配零。例如，如图 1(b) 所示，$\mathrm{Scan Context}$中的蓝色像素意味着与其 bin 对应的空间是空闲的，或者由于遮挡而未观察到。</p><p>通过上述过程，最终将$\mathrm{Scan Context}$ $I$ 表示为$ N_r\times N_s$ 矩阵:</p><script type="math/tex; mode=display">I=(a_{ij})\in\mathbb{R}^{N_r\times N_s},a_{ij}=\phi(\mathcal{P}_{ij})\tag{4}</script><p>为了对变换进行鲁棒的识别，我们通过$\mathit{ root\ shifting}$ 来增强 $\mathrm{Scan Context}$。通过这样做，在轻微运动扰动下从原始扫描中获取各种$\mathrm{Scan Context}$变得可行。</p><p>在重新访问到过的地方时，单个$\mathrm{Scan Context}$可能对平移运动下的扫描中心位置敏感。例如，当重新访问不同通道中的相同位置时，可能不会保留$\mathrm{Scan Context}$的行顺序。为了克服这种情况，我们根据水平间隔将原始点云转换为 $N_{trans}$ 个邻居（本文中使用$N_{trans}=8$  ），并将从这些$\mathit{ root\ shifting}$ 点云获得的$\mathrm{Scan Context}$存储在一起。我们假设即使在实际移动的位置也能获得类似的点云，这是有效的，除了少数情况下，比如一个新空间突然出现的交叉点。</p><h2 id="B-mathrm-Scan-Context-之间的相似度得分"><a href="#B-mathrm-Scan-Context-之间的相似度得分" class="headerlink" title="B. $\mathrm{Scan Context}$之间的相似度得分"></a>B. $\mathrm{Scan Context}$之间的相似度得分</h2><p>给定一个$\mathrm{Scan Context}$对，我们需要一个距离度量来衡量两个地方的相似性。$I^q$ 和$ I^c $分别是从查询点云和候选点云获取的$\mathrm{Scan Context}$。它们以列方式进行比较。也就是说，距离是同一索引处的列之间的距离之和。余弦距离用于计算相同索引处的两个列向量 $c^q_j $和 $c^c_j $之间的距离。此外，我们将总和除以总列数$N_s$用于归一化。因此，距离函数为:</p><script type="math/tex; mode=display">d(I^q,I^c)=\frac{1}{N_s}\sum^{N_s}_{j=1}(1-\frac{c^q_j\cdot c^c_j}{\parallel c^q_j \parallel \parallel c^c_j \parallel}).\tag{5}</script><p>考虑到贯穿扇区的一致性，基于列的比较对动态物体特别有效。然而，候选$\mathrm{Scan Context}$的列甚至可以在相同的地方移动，因为激光雷达的视角对于不同的地方是不同的(例如，在相反的方向或角落重新访问一个地方)。图3说明了这种情况。由于$\mathrm{Scan Context}$是依赖于传感器位置的表示，因此行顺序始终是一致的。但是，如果 LiDAR 传感器相对于全局坐标的坐标发生变化，则列顺序可能会有所不同。</p><p><img src="/images/Scan-Context论文阅读/image-20220429201446582-16512834290096.png" alt="image-20220429201446582" style="zoom:50%;" /></p><blockquote><p>图 3. 具有时间间隔的同一地点的$\mathrm{Scan Context}$示例。重新访问时传感器视点的变化导致$\mathrm{Scan Context}$的列移位，如 (a) 所示。但是，这两个矩阵包含相似的形状并显示相同的行顺序。</p></blockquote><p>为了解决这个问题，我们使用所有可能的列移位后的$\mathrm{Scan Context}$来计算距离，并找到最小距离。$I^c_n$ 是一个$\mathrm{Scan Context}$，它的第$n$列是从原始的$\mathrm{Scan Context}$偏移过来的。这与以$\frac{2\pi}{N_s}$分辨率粗略对齐两个点云以获取旋转分量中的偏航角的任务相同。然后，我们确定最佳对齐的列移位数量$(7)$和对应的距离$(6)$:</p><script type="math/tex; mode=display">\begin{align*}D(I^q,I^c)&=\underset{n\in[N_s]}{\min}d(I^q,I^c_n),\tag{6}\\n^*&=\underset{n\in[N_s]}{\arg\min}\ d(I^q,I^c_n),\tag{7}\end{align*}</script><p>请注意，此附加移位信息可以作为进一步定位细化的良好初始值，例如迭代最近点 (ICP)，如第 IV-C 节所示。</p><h2 id="C-两阶段搜索算法"><a href="#C-两阶段搜索算法" class="headerlink" title="C. 两阶段搜索算法"></a>C. 两阶段搜索算法</h2><p>当在位置识别的ScanContext搜索时，有三个主要的典型工作流：成对相似性评分、最近邻搜索和稀疏优化[26]。我们的搜索算法将成对评分和最近邻搜索分层融合，以获得可接受的搜索时间。</p><p>由于我们在(6)中的距离计算比其他全局描述子如[12，10]更加耗时，我们通过引入ring key提供了一个两阶段分层搜索算法。Ring key是一个具有旋转不变性的描述子，它是从$\mathrm{Scan Context}$中提取的。$\mathrm{Scan Context}$的每一行，$r$，都通过环形编码函数$\psi$编码成一个实数值。矢量<strong>$k$</strong>的第一个元素来自距离传感器最近的环，随后的元素来自下一个环，如图4所示。因此，ring key成为一个 $N_r$ 维向量，如 (8)：</p><script type="math/tex; mode=display">k=(\psi(r_1),...,\psi(r_{N_r})),\mathrm{where}\ \psi:r_i\rightarrow\mathbb{R}\tag{8}</script><p>我们使用的环编码函数$\psi$是使用 $L_0$范数的环的占用率：</p><script type="math/tex; mode=display">\psi(r_i)=\frac{\parallel r_i \parallel_0}{N_s}\tag{9}</script><p>由于占用率与视点无关，因此ring key实现了旋转不变性。</p><p><img src="/images/Scan-Context论文阅读/image-20220429203142763-16512834290095.png" alt="image-20220429203142763" style="zoom:50%;" /></p><blockquote><p>图 4. 快速搜索的ring key生成。</p></blockquote><p>虽然不如$\mathrm{Scan Context}$信息丰富，但ring key支持快速搜索，以找到可能的候选闭环。向量$k$用作构建KD树的key。同时，要查询扫描的ring key用于查找相似的key及其对应的扫描索引。将被检索的相似key的数量由用户决定。使用距离(6)将这些恒定数量的候选$\mathrm{Scan Context}$与要查询的$\mathrm{Scan Context}$进行比较。最接近的满足给定阈值的候选项被选为重新访问的位置:</p><script type="math/tex; mode=display">c^*=\underset{c_k\in\mathcal{C} }{\arg\min}\ D(I^q,I^c),s.t. \ D<\tau\tag{10}</script><p>其中 $\mathcal{C}$ 是从 KD 树中提取的一组候选索引，$\tau$ 是给定的接受阈值。 $c^∗ $是确定为闭环的位置的索引。</p><h1 id="Ⅳ-实验评估"><a href="#Ⅳ-实验评估" class="headerlink" title="Ⅳ.实验评估"></a>Ⅳ.实验评估</h1><p>略…….</p><h1 id="Ⅴ-结论"><a href="#Ⅴ-结论" class="headerlink" title="Ⅴ.结论"></a>Ⅴ.结论</h1><p>在这篇文章中，我们提出了一个空间描述子——$\mathrm{Scan Context}$，将一个地方概括为一个矩阵，这个矩阵明确描述了以自我为中心的环境的2.5D结构信息。与使用点云的现有全局描述子相比，$\mathrm{Scan Context}$在各种数据集上显示出更高的闭环检测性能。</p><p>在未来的工作中，我们计划通过引入额外的层来扩展$\mathrm{Scan Context}$。也就是说，其他bin编码函数(例如，bin的语义信息)可被用于提高性能，即使对于具有高度重复结构的数据集，如复杂城市激光雷达数据集。</p><p>Lidar定位：Scan Context<a href="https://zhuanlan.zhihu.com/p/359523177">https://zhuanlan.zhihu.com/p/359523177</a></p><p>Scan Context 介绍及理解<a href="https://zhuanlan.zhihu.com/p/393353116">https://zhuanlan.zhihu.com/p/393353116</a></p><p>从零开始做自动驾驶定位(二): 数据集<a href="https://zhuanlan.zhihu.com/p/104875159">https://zhuanlan.zhihu.com/p/104875159</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;&lt;strong&gt;Scan Context&lt;/strong&gt; 由韩国KAIST大学的 Giseop Kim, Ayoung Kim 于2018年发表在&lt;strong&gt;IROS&lt;/strong&gt;(International Conference on Intelligent Robots and Systems).Scan Context 应用于基于3D点云的重定位和场景识别，主要思想是将场景3维信息压缩，将笛卡尔坐标系的信息转换到极坐标系下计算。优势是高效利用场景点云分布特征，引入”旋转不变性”描述子，快速搜索。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/categories/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="ScanContext" scheme="https://lukeyalvin.top/tags/ScanContext/"/>
    
    <category term="激光SLAM" scheme="https://lukeyalvin.top/tags/%E6%BF%80%E5%85%89SLAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
