<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lukey Alvin</title>
  
  <subtitle>一份耕耘,一份收获</subtitle>
  <link href="https://lukeyalvin.top/atom.xml" rel="self"/>
  
  <link href="https://lukeyalvin.top/"/>
  <updated>2022-04-26T01:20:20.931Z</updated>
  <id>https://lukeyalvin.top/</id>
  
  <author>
    <name>爱喝烫水的阿水哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三、基于优化的IMU预积分与视觉信息融合</title>
    <link href="https://lukeyalvin.top/posts/60742.html"/>
    <id>https://lukeyalvin.top/posts/60742.html</id>
    <published>2022-04-25T09:25:33.008Z</published>
    <updated>2022-04-26T01:20:20.931Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要对IMU的运动模型以及误差模型进行了分析，并针对连续时间和离散模型的处理做了简单的概要。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-基于BA的-VIO-融合"><a href="#Ⅰ-基于BA的-VIO-融合" class="headerlink" title="Ⅰ.基于BA的 VIO 融合"></a>Ⅰ.基于BA的 VIO 融合</h1><p>BA为问题早在学习《视觉SLAM十四讲》的时候我们就接触过，当时提到的PnP问题，涉及到的重投影误差，如下图所示，我们通过对相机的位姿进行优化，就可以得到最小的误差$e$，这个问题就是一个BA问题。类似的还有直接法中的光度误差。</p><p><img src="/posts/60742.htm/image-20220425154741376.png" alt="image-20220425154741376.png"></p><p>所谓的 Bundle Adjustment，是指从视觉重建中提炼出最优的 3D 模型和相机参数（内参数和外参数）。从每一个特征点反射出来的几束光线（bundles of light rays），在我们把相机姿态和特征点空间位置做出最优的调整 (adjustment) 之后，最后收束到相机光心的这个过程，简称为 BA。</p><p>但是在实际的VIO中不仅涉及到类似的重投影误差问题，还需要考虑IMU的优化问题，如图所示，图中：$q_{bc},p_{bc}$分别表示相机坐标系到机器人本体坐标系的旋转四元数和平移向量。$f_i,f_j$则是我们观察到的特征点的3D坐标。$z_{f_j}^{c_i}$z在相机不同的位姿$c_1,c_2,c_3$下的观测值。</p><p><img src="/posts/60742.htm/image-20220425153047596.png" alt="image-20220425153047596"></p><p>我们的优化问题有两个：</p><p>①首先就是相机位姿的优化，我们通过特征匹配得到相邻两帧中的特征点的匹配，然后用过相机位姿将两帧的特征点统一在某一帧上，理论上，这两个点应该重合，这时由于偏差，两点会出现偏差$e$，其实就是之前的重投影误差，然后对相机的位姿进行优化，这里优化的就是$q_{bc},p_{bc}$，来缩小这个偏差的过程，就是求解BA的过程。</p><p>求解BA实际上就是一个最小二乘的求解问题，构建误差函数如下：</p><script type="math/tex; mode=display">\underset{q,p,f}{\arg\min}\sum^m_{i=1}\sum^m_{j=1}||\pi(q_{wc_i},p_{wc_i},f_{j})-z^{c_i}_{f_j} ||_{\sum_{ij} }\tag{1}</script><p>其中函数$\pi(\cdot)$表示投影函数，$\sum_{ij}$表示范数，然后这个误差函数可以通过之前学习的Ceres或g2o等库来进行求解。具体算法后文会介绍，比如高斯牛顿法，LM算法等。</p><p>②然后就是构建IMU的误差$z_{b_1b_2}$，这个构建的过程主要就是通过预积分，通过上图可以发现，图像中$b_3$与$b_2$之间的小点就是IMU的数据，这些数据通过预积分的操作，就可以把这么多IMU数据变成一个约束$z_{b_2b_3}$。关于此知识点，高博在《视觉SLAM14讲》中并未提及，这也是本章介绍的重点。</p><h1 id="Ⅱ-最小二乘问题的求解"><a href="#Ⅱ-最小二乘问题的求解" class="headerlink" title="Ⅱ.最小二乘问题的求解"></a>Ⅱ.最小二乘问题的求解</h1><p>最小二乘在之前的文章中有提及过，只不过叙述的是线性最小二乘，如果对最小二乘的概念理解不够透彻，从线性最小二乘入手不失为一种比较好的方式：<a href="https://lukeyalvin.top/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/">线性最小二乘</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要对IMU的运动模型以及误差模型进行了分析，并针对连续时间和离散模型的处理做了简单的概要。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>二、IMU传感器</title>
    <link href="https://lukeyalvin.top/posts/19228.html"/>
    <id>https://lukeyalvin.top/posts/19228.html</id>
    <published>2022-04-25T09:20:38.421Z</published>
    <updated>2022-04-26T01:20:20.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本节主要对IMU的运动模型以及误差模型进行了分析，并针对连续时间和离散模型的处理做了简单的概要。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-旋转运动学"><a href="#Ⅰ-旋转运动学" class="headerlink" title="Ⅰ.旋转运动学"></a>Ⅰ.旋转运动学</h1><h2 id="A-线速度与角速度"><a href="#A-线速度与角速度" class="headerlink" title="A.线速度与角速度"></a>A.线速度与角速度</h2><p>如图所示，粒子在坐标系中的$z=h$的平面内做圆周运动，坐标为$r=(a\cos\theta,a\sin\theta,h)$，对坐标求导得：</p><script type="math/tex; mode=display">\begin{align*}\dot r&=(-a\dot\theta\sin\theta,a\dot\theta\cos\theta,0)^T\\&=\begin{bmatrix}0&-\dot\theta&0\\\dot\theta&0&0\\0&0&0\end{bmatrix}\begin{bmatrix}a\cos\theta\\a\sin\theta\\h\end{bmatrix}\\&=w^{\land} r\end{align*}\tag{1}</script><p>其中$w$是角速度，它是一个矢量，即$w=\begin{bmatrix}0\\0\\ \dot\theta\end{bmatrix}=\dot\theta z$,其中$|\dot\theta|$是角速度的大小。对公式$(1)$取模：</p><script type="math/tex; mode=display">|\dot r|=|w||r|sin\phi=a|\dot\theta|</script><p><img src="/posts/19228.htm/image-20220422093936869.png" alt="image-20220422093936869"></p><h2 id="B-旋转坐标系下的运动学"><a href="#B-旋转坐标系下的运动学" class="headerlink" title="B.旋转坐标系下的运动学"></a>B.旋转坐标系下的运动学</h2><p>如图，考虑两个坐标系，一个是世界坐标系(惯性坐标系)$W$，它本身是静止不动的；一个是机器人本体坐标系$B$，它本身在做角速度为$w_B$的纯旋转，设质量块在坐标系$B$下做速度为$v_B$，加速度为$a_B$的匀加速直线运动，它在$B$坐标系下坐标为$r_B=(x_1,x_2,x_3)^T$，设从坐标系世界坐标系$W$到是机器人本体坐标系$B$只考虑旋转的时候，旋转矩阵$R_{WB}$。</p><p><img src="/posts/19228.htm/image-20220422155242434.png" alt="image-20220422155242434"></p><p>这里定义一些变量：</p><blockquote><p>①设物体在坐标系$B$下做速度为$v_B$，加速度为$a_B$，对应在坐标系$W$下的速度为$v_W$，加速度为$a_W$</p><p>并且设坐标系$B$下的速度和加速度在坐标系$W$下的表示分别为：$v=R_{WB}v_B$，$a=R_{WB}a_B$，一定注意这里的$v\ne v_W,a\ne a_W$</p><p>②设坐标轴$B$旋转的角速度为$w_B$，对应在世界坐标系中其旋转的角速度变为$w_W$，且$w_W=R_{WB}w_B$</p><p>③设物体在坐标系$B$下的坐标为$r_B$，对应在坐标系$W$下的坐标为$r_W$，且$r_W=R_{WB}r_B$</p></blockquote><p>则对应到世界坐标系下：</p><script type="math/tex; mode=display">r_W(t)=x_1(t)i+x_2(t)j+x_3(t)k=R_{WB}r_B</script><p>一般简写为：$r_B=x_ie_i$</p><p>经过一番定义之后，我们考虑几个问题:</p><ul><li><strong>求物体在$W$坐标系下的速度</strong></li></ul><p>对时间求导：</p><script type="math/tex; mode=display">\begin{align*}\dot r_W=v_W&=R_{WB}\dot r_B+\dot R_{WB} r_B\\&=R_{WB}v_B+w_W^{\land} r_W \ \ \ \ 参见公式(3) \\ &=v+w_W^{\land} r_W\Leftrightarrow v=v_W-w_W^{\land} r_W\\\end{align*}\tag{2}</script><p>其中$w_W=R_{WB}w_b$表示body坐标系$B$的角速度在世界坐标系$W$下的表示。具体推导参见公式$(3)$.</p><p>这里可以明显看出$v\ne v_W$，两者之间相差一个$w_W^{\land} r_W$项。</p><hr><p>推导$\dot R_{WB} r_B$，使用右乘扰动模型:</p><script type="math/tex; mode=display">\begin{align*}\dot R_{WB} r_B&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}\exp([w_B\Delta t]^{\land})r_B-R_{WB}r_B}{\Delta t}\\&\approx\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}(I+[w_B\Delta t]^{\land})r_B-R_{WB}r_B}{\Delta t}\\&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}[w_B\Delta t]^{\land}r_B}{\Delta t}\\&=\underset{\Delta t \rightarrow0}{lim}\frac{-R_{WB}r_B^{\land}[w_B\Delta t]}{\Delta t}\\&=-R_{WB}r_B^{\land}w_B\\ &=R_{WB}w_B^{\land}r_B\\&=(R_{WB}w_B)^{\land}R_{WB}r_B\\&=w^{\land}_Wr_W\end{align*}\tag{3}</script><hr><ul><li><strong>求物体在$W$坐标系下的加速度</strong></li></ul><p>对时间求导：</p><script type="math/tex; mode=display">\begin{align*}\ddot r_W =\dot v_W = a_W&=\frac{d(R_{WB}v_B+w_W^{\land}\dot r_W)}{dt}\\&=R_{WB}\dot v_B+\dot R_{WB} v_B+w_W^{\land}\dot r_W+\dot w_W^{\land}r_W\\&=a+w^{\land}v+(w^{\land}v+w^{\land}(w^{\land} r_W))+\dot w^{\land}r_W\\&=a+2w^{\land}v+w^{\land}(w^{\land} r_W)+\dot w^{\land}r_W\\\end{align*}\tag{4}</script><p>上式的每一项的推导见下面。这里可以明显看出$a\ne a_W$，两者之间相差三个项，分别是<strong>科氏力：$2w^{\land}v$，离心力：$w^{\land}(w^{\land} r_W)$、欧拉力：$\dot w^{\land}r_W$。</strong></p><hr><ul><li>第一项：</li></ul><script type="math/tex; mode=display">R_{WB}\dot v_B=R_{WB}a_B=a</script><ul><li>第二项：</li></ul><p>参考公式$(3)$，很容易就可以推出来：</p><script type="math/tex; mode=display">\begin{align*}\dot R_{WB} v_B&=\underset{\Delta t \rightarrow0}{lim}\frac{R_{WB}\exp([w_B\Delta t]^{\land})v_B-R_{WB}v_B}{\Delta t}\\&=(R_{WB}w_B)^{\land}R_{WB}r_B\\&=w^{\land}_Wv\end{align*}</script><ul><li>第三项：</li></ul><script type="math/tex; mode=display">\begin{align*}w_W^{\land}\dot r_W&=w_W^{\land}(v+w_W^{\land}r_W)\\&=w_W^{\land}v+w_W^{\land}(w_W^{\land}r_W)\end{align*}</script><hr><p>整个过程的作用是什么？</p><p>我们在已知$B$坐标系下的物体的加速度、速度以及旋转轴的角速度，我们就可以求得对应世界坐标系下的相应的物理量，那么相应的求可以求得世界坐标系下的位姿（速度积分得到位姿）、四元数（根据角速度）。</p><h1 id="Ⅱ-IMU-测量模型及运动模型"><a href="#Ⅱ-IMU-测量模型及运动模型" class="headerlink" title="Ⅱ.IMU 测量模型及运动模型"></a>Ⅱ.IMU 测量模型及运动模型</h1><h2 id="A-加速度计工作原理"><a href="#A-加速度计工作原理" class="headerlink" title="A.加速度计工作原理"></a>A.加速度计工作原理</h2><p>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示:</p><p><img src="/posts/19228.htm/image-20220422191601477.png" alt="image-20220422191601477.png"></p><p>注意这里的加速度计测量值$a_m$为弹簧拉力对应的加速度，所以有：</p><script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g\tag{5}</script><p>其中$f $为弹簧拉力，$a$ 为物体在惯性系下的加速度，$g$为重力加速度。</p><p>另外，实际的加速度计大都是$MEMS $加速度计，它利用电容或者电阻桥来等原理来测量$ a_m$</p><p>其原理可以参考：<a href="https://m.elecfans.com/article/596137.html"><strong>MEMS 加速度传感器的原理与构造介绍</strong></a></p><p>通常情况下我们假设地球表面为惯性参考系，但是对于高端的测量单元来说，这种精度远远不够（需要考虑地球自转的影响），所以就将惯性参考系的原点记为地球的质心，而位于地球表面的坐标系称为地面参考系或东北天坐标系（ENU坐标系）, 如下图所示。在此坐标系下$g=(0,0,-9.81)^T$</p><p><img src="/posts/19228.htm/image-20220422192532908.png" alt="image-20220422192532908.png"></p><p>假设 IMU 坐标系就是 ENU 坐标系，$R_{WB }= I$，静止时有$a=0,a_m=-g$，自由落体时有$a=g,a_m=0$</p><h2 id="B-陀螺仪测量原理"><a href="#B-陀螺仪测量原理" class="headerlink" title="B.陀螺仪测量原理"></a>B.陀螺仪测量原理</h2><p>陀螺仪侦测的是角速度。其工作原理基于科里奥利力的原理：当一个物体在坐标系中直线移动时，假设坐标系做一个旋转，那么在旋转的过程中，物体会感受到一个垂直的力和垂直方向的加速度。</p><p>按测量原理分有<strong>振动陀螺</strong>，<strong>光纤陀螺</strong>等。</p><p><img src="/posts/19228.htm/陀螺仪.gif" alt="陀螺仪.gif"></p><p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 科氏力（Coriolis force ）来间接得到角速度。MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴，比如，如图示，高速运动的物体速度为$v$，在旋转坐标系下，物体会受到科氏力的影响，我们通过求科氏力就可以求得角速度$w$的大小。</p><p><img src="/posts/19228.htm/image-20220422195814350.png" alt="image-20220422195814350.png"></p><p>但是实际制作的过程中我们不只是使用一个质量块，而是使用两个质量块，就是<strong>音叉陀螺仪</strong>，如图所示，叉子的中间为旋转轴，叉子左右两个质量块，做方反的正弦运动，质量块受到的科氏力方向相反。</p><p><img src="/posts/19228.htm/image-20210905220130.png" alt="20210905220130.png"></p><p>当两个完全相同的质量块的运动方向相反，但是旋转相同的时候，它们就会受到相反的科氏力以及相同的外部加速度影响力。将两个质量块所受到该方向上的力做差，就会得到两倍的科氏力。</p><p><strong>但是为啥要用这么做呢? 一个质量块不行么？</strong></p><p>①利用二倍的科氏力对应的电压指数更大，测量也变得更准确；②因为有可能在科氏力方向上物体本身具有一定的加速度，所以利用音叉陀螺仪构成差分模型，可以将两个外部力相互抵消（科氏力方向物体本身的加速度），消除自身的影响，是的获得的科氏力更准。</p><p>但是，实际上，两个质量块不可能完全一致，也就是说陀螺仪的测量可能会受到外部加速度的影响，即常称的 <strong>G-sensitivity</strong>，一般的IMU手册里面都会有这个指数，它的含义就是告诉你IMU受加速度影响的系数有多大。</p><h1 id="Ⅲ-IMU-误差模型"><a href="#Ⅲ-IMU-误差模型" class="headerlink" title="Ⅲ.IMU 误差模型"></a>Ⅲ.IMU 误差模型</h1><p>误差的分类：加速度计和陀螺仪的误差可以分为：确定性误差以及随机的误差，确定性的误差一般是事先通过标定确定，但是随机误差通常情况下假设噪声服从的是高斯分布。</p><h2 id="A-确定性误差与标定"><a href="#A-确定性误差与标定" class="headerlink" title="A.确定性误差与标定"></a>A.确定性误差与标定</h2><h3 id="1-确定性误差"><a href="#1-确定性误差" class="headerlink" title="1.确定性误差"></a>1.确定性误差</h3><ul><li><strong>Bias</strong></li></ul><p>理论上，当没有外部作用时，IMU 传感器的输出应该为$0$。但是，实际数据存在一个偏置$ b$。加速度计 bias 对位姿估计的影响：</p><script type="math/tex; mode=display">v_{err}=b_at,\ \ \ p_{err}=\frac{1}{2}b_at^2</script><p>这里的$p_{err}$指的是位移，因为有时间$t$的存在，为了区分，将位移定义为$p$.</p><ul><li><strong>Scale</strong></li></ul><p>scale 可以看成是实际数值和传感器输出值之间的比值。</p><p><img src="/posts/19228.htm/image-20220422204953295.png" alt="image-20220422204953295.png"></p><ul><li><strong>Nonorthogonality/Misalignment Errors</strong></li></ul><p>特别的在多轴的IMU传感器中，由于制作工艺的问题，有可能对导致$xyz$轴并不是严格意义的正交，如下图所示，$z$轴并不是严格意义上与$xOy$平面垂直，则会影响对应的$x,y$上的分量。</p><p><img src="/posts/19228.htm/image-20220422204127003.png" alt="image-20220422204127003.png"></p><p>加上之前的scale的影响：</p><script type="math/tex; mode=display">\begin{align*}scale+Misalignment:&\\&\begin{bmatrix}l_{ax}\\l_{ay}\\l_{az}\end{bmatrix}=\begin{bmatrix}s_{xx}&m_{xy}&m_{xz}\\m_{yx}&s_{yy}&m_{yz}\\m_{zx}&m_{zy}&s_{zz}\end{bmatrix}\begin{bmatrix}a_{x}\\a_{y}\\a_{z}\end{bmatrix}\end{align*}</script><h3 id="2-确定性误差的标定"><a href="#2-确定性误差的标定" class="headerlink" title="2.确定性误差的标定"></a>2.确定性误差的标定</h3><h4 id="六面法标定加速度计和陀螺仪"><a href="#六面法标定加速度计和陀螺仪" class="headerlink" title="六面法标定加速度计和陀螺仪"></a>六面法标定加速度计和陀螺仪</h4><p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。<br>如果各个轴都是正交的，那很容易得到 bias 和 scale：</p><p>因为静止状态下，向上和向下所得到IMU的示数相加正好抵消掉了重力的影响，所以两次测量相加得到两倍的bias；</p><p>向上和向下所得到IMU的示数相减可以抵消bias;</p><script type="math/tex; mode=display">b=\frac{l^{up}_f+l^{down}_f}{2}\\S=\frac{l^{up}_f-l^{down}_f}{2g}\tag{6}</script><p>其中，$l $为加速度计某个轴的测量值，$g$ 为当地的重力加速度</p><p><strong>考虑轴间误差的时候，实际加速度和测量值之间的关系为：</strong></p><p>当考虑轴间的误差的时候，就变成$L = S · a + b$，其中$S$为$3\times3$的矩阵，</p><script type="math/tex; mode=display">\begin{bmatrix}l_{ax}\\l_{ay}\\l_{az}\end{bmatrix}=\begin{bmatrix}s_{xx}&m_{xy}&m_{xz}\\m_{yx}&s_{yy}&m_{yz}\\m_{zx}&m_{zy}&s_{zz}\end{bmatrix}\begin{bmatrix}a_{x}\\a_{y}\\a_{z}\end{bmatrix}+\begin{bmatrix}b_{ax}\\b_{ay}\\b_{az}\end{bmatrix}\tag{7}</script><p>水平放置$6$面，就会得到$6$个$a$向量，加速度的理论值为</p><script type="math/tex; mode=display">a_1=\begin{bmatrix}g\\0\\0\end{bmatrix},a_2=\begin{bmatrix}-g\\0\\0\end{bmatrix},a_3=\begin{bmatrix}0\\g\\0\end{bmatrix},a_4=\begin{bmatrix}0\\-g\\0\end{bmatrix},a_5=\begin{bmatrix}0\\0\\g\end{bmatrix},a_6=\begin{bmatrix}0\\0\\-g\end{bmatrix}</script><p>对应的$L$为$L=\begin{bmatrix}l_1&amp;l_2&amp;l_3&amp;l_4&amp;l_5&amp;l_6\end{bmatrix}$</p><p>在得知六组数据$(a_1,l_1)…(a_6.l_6)$，我们就可以利用最小二乘就可以得出$S$和$b$的具体值。线性最小二乘可以参考：<a href="https://lukeyalvin.top/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/">线性最小二乘</a></p><p><strong>同理陀螺仪的六面法标定与其类似，和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这里的$6 $面是指各个轴顺时针和逆时针旋转。</strong></p><h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><p>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</p><p>两种标定方法：</p><ul><li>soak method：控制恒温室的温度值，然后读取传感器数值进行标定。</li><li>ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</li></ul><h2 id="B-随机误差与标定"><a href="#B-随机误差与标定" class="headerlink" title="B.随机误差与标定"></a>B.随机误差与标定</h2><h3 id="1-随机误差"><a href="#1-随机误差" class="headerlink" title="1.随机误差"></a>1.随机误差</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>IMU 数据<strong>连续时间</strong>上受到一个均值为$ 0$，方差为$\sigma$，各时刻之间相互独立的高斯过程$ n(t)$：</p><script type="math/tex; mode=display">\begin{align*}&E[n(t)]\equiv0\\&E[n(t_1)n(t_2)]=\sigma^2\delta(t_1-t_2)\end{align*}\tag{8}</script><p>其中$\delta()$表示狄拉克函数。</p><p>实际上，IMU 传感器获取的数据为<strong>离散采样</strong>，离散和连续高斯白噪声的方差之间存在如下转换关系：</p><p>定义$n_d[k]$</p><script type="math/tex; mode=display">\begin{align*}n_d[k]\triangleq n(t_0+t_1)≃\frac{1}{\Delta t}\int^{t_0+\Delta t}_{t_0}{n(\tau)}dt\end{align*}</script><p>对其求方差$Var(X)=E[(X-\mu)^2]$,已知均值为$0$，$X=n_d[k]$：</p><script type="math/tex; mode=display">\begin{align*}E(n_d[k]^2)&=E(\frac{1}{\Delta t^2}\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{n(\tau)}{n(t)}d\tau dt)\\&=E(\frac{\sigma^2}{\Delta t^2}\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{\delta(t-\tau)}d\tau dt)\\&=E(\frac{\sigma^2}{\Delta t})\end{align*}\tag{9}</script><p>对应相等，可得：</p><script type="math/tex; mode=display">n_d[k]=\sigma_dw[k]\tag{10}</script><p>其中，</p><script type="math/tex; mode=display">w[k]\sim N(0,1)\\\sigma_d=\sigma\frac{1}{\sqrt{\Delta t} }\tag{11}</script><p><strong>也就是说高斯白噪声的连续时间到离散时间之间差一个$\frac{1}{\sqrt{\Delta t} }$ ，$\sqrt{\Delta t} $是传感器的采样时间。</strong></p><h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走。</p><script type="math/tex; mode=display">\dot b(t)=n(t)=\sigma_bw(t)\tag{12}</script><p>其中$ w $是方差为$ 1 $的白噪声。</p><p>同样，离散和连续之间的转换：</p><p>定义$b_d[k]$</p><script type="math/tex; mode=display">b_d[k]\triangleq b(t_0)+\int^{t_0+\Delta t}_{t_0}{n(t)}dt</script><p>求方差：</p><script type="math/tex; mode=display">\begin{align*}E((b_d[k]-b_d[k-1])^2)&=E(\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}{n(t)}{n(\tau)}d\tau dt)\\&=E(\sigma_b^2\int^{t_0+\Delta t}_{t_0}\int^{t_0+\Delta t}_{t_0}\delta (t-\tau)d\tau dt)\\&=E(\sigma_b^2\Delta t)\end{align*}\tag{13}</script><p>所以：</p><script type="math/tex; mode=display">b_d[k]=b_d[k-1]+\sigma_{bd}w[k]\tag{14}</script><p>其中：</p><script type="math/tex; mode=display">w[k]\sim N(0,1)\\\sigma_{bd}=\sigma_b \sqrt{\Delta t}\tag{15}</script><p><strong>bias 随机游走的噪声方差从连续时间到离散之间需要乘以</strong>$\sqrt{\Delta t}$</p><h3 id="2-随机误差的标定"><a href="#2-随机误差的标定" class="headerlink" title="2.随机误差的标定"></a>2.随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><blockquote><p>在统计学中描述随机变量的两个经典参数是均值和方差，早期在定量表征原子钟的频率稳定度时采用的就是经典方差方法。1996 年，学者 D.W.Allan 在分析铯原子钟频标的频率稳定度时发现经典方差随着时间的增长而发散，为了解决该问题，提出了一种新的评定方法，后来称为艾伦方差。由于惯性器件也具有振荡器的特征，Allan 方差分析也被广泛应用于惯性器件的随机误差建模，IEEE 标准中就将 Allan 方差方法引入到了激光陀螺的建模分析。</p></blockquote><p>具体的流程如下：</p><p>①保持传感器绝对静止获取数据。</p><p>②对数据进行分段，设定时间段的时长，如下图所示。</p><p><img src="/posts/19228.htm/image-20220423162306358.png" alt="image-20220423162306358"></p><p>③将传感器数据按照时间段进行平均。</p><p>④计算方差，绘制艾伦曲线。</p><p>得到的艾伦曲线如下图所示：</p><p><img src="/posts/19228.htm/image-20220423162352964.png" alt="image-20220423162352964"></p><p>从艾伦方差曲线中可以辨识出 IMU 的五种噪声，分别为：量化噪声、角度随机游走、零偏不稳定性噪声，角速率随机游走，速率斜坡，一般在 IMU 噪声辨识中用的比较多的是中间 3 种。</p><h2 id="C-误差模型"><a href="#C-误差模型" class="headerlink" title="C .误差模型"></a>C .误差模型</h2><h3 id="1-加速度计的误差模型"><a href="#1-加速度计的误差模型" class="headerlink" title="1.加速度计的误差模型"></a>1.加速度计的误差模型</h3><p>设导航系$G$为东北天，$g^G=(0,0,-9.81)^T$。</p><p>理论测量值：</p><script type="math/tex; mode=display">a_m^B=R_{BG}(a^G-g^G)\tag{16}</script><p>如果考虑高斯白噪声，bias，以及尺度因子(通常假设尺度因子为单位矩阵。)，则为：</p><script type="math/tex; mode=display">a_m^B=S_aR_{BG}(a^G-g^G)+n_a+b_a\tag{17}</script><p><img src="/posts/19228.htm/image-20220423171217806.png" alt="image-20220423171217806.png"></p><h3 id="2-陀螺仪的误差模型"><a href="#2-陀螺仪的误差模型" class="headerlink" title="2.陀螺仪的误差模型"></a>2.陀螺仪的误差模型</h3><p>考虑尺度因子，高斯白噪声，以及 bias, 陀螺仪的误差模型如下：</p><script type="math/tex; mode=display">w^B_m=S_gw^B+n_g+nb_g\tag{18}</script><p>低端传感器，考虑加速度对陀螺仪的影响，即 g-灵敏度：</p><script type="math/tex; mode=display">w^B_m=S_gw^B+S_{ga}a^B+n_g+nb_g\tag{19}</script><p>陀螺仪受四种噪声的影响分别如下图所示：</p><p><img src="/posts/19228.htm/image-20220423190440715.png" alt="image-20220423190440715"></p><h1 id="Ⅳ-运动模型离散时间处理"><a href="#Ⅳ-运动模型离散时间处理" class="headerlink" title="Ⅳ.运动模型离散时间处理"></a>Ⅳ.运动模型离散时间处理</h1><p>忽略 scale 的影响，只考虑白噪声和 bias 随机游走：</p><script type="math/tex; mode=display">\begin{align*}\tilde{w}^b&=w^b+b^g+n^g\tag{20}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\tilde{a}^b&=q_{bw}(a^w+g^w)+b^a+n^a\tag{21}\end{align*}</script><p>上标$ g$ 表示 gyro，a 表示 acc，$w $表示在世界坐标系 world，$b $表示imu 机体坐标系 body。IMU 的真实值为$w, a$, 测量值为$\tilde w, a$。</p><p>P(ose),V(elocity),Q(uaternion) 对时间的导数可写成：</p><script type="math/tex; mode=display">\begin{align*}\dot p_{wb}&=v^w_t\\\dot v^w_t &=a^w_t\\\dot q_{wb_t} &=q_{wb_t} \otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\end{align*}\tag{22}</script><h2 id="A-连续时间下-IMU-运动模型"><a href="#A-连续时间下-IMU-运动模型" class="headerlink" title="A.连续时间下 IMU 运动模型"></a>A.连续时间下 IMU 运动模型</h2><p>根据上面的导数关系，可以从第 i 时刻的 PVQ，通过对 IMU 的测量值进行积分，得到第 j 时刻的 PVQ:</p><script type="math/tex; mode=display">\begin{align*}p_{wb_j}&=p_{wb_i}+v^w_i \Delta t+\iint_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t^2\\v^w_j&=v^w_i+\int_{t\in[i,j]}(q_{wb_t}a^{b_t}-g^w)\delta t\\q_{wb_j}&=\int_{t\in[i,j]}q_{wb_t}\otimes \begin{bmatrix}0\\ \frac{1}{2}w^{b_t} \end{bmatrix}\delta t\end{align*}\tag{23}</script><h2 id="B-运动模型的离散积分"><a href="#B-运动模型的离散积分" class="headerlink" title="B.运动模型的离散积分"></a>B.运动模型的离散积分</h2><h3 id="1-欧拉法"><a href="#1-欧拉法" class="headerlink" title="1.欧拉法"></a>1.欧拉法</h3><p>使用欧拉法，即两个相邻时刻 $k$ 到 $k+1 $的位姿是用第$k$ 时刻的测量值 $a, w$ 来计算</p><script type="math/tex; mode=display">\begin{align*}p_{wb_{k+1} }&=p_{wb_k}+v^w_k \Delta t +\frac{1}{2}a\Delta t^2\\v^w_{k+1}&=v^w_k+a\Delta t \\q_{wb_{k+1} }&=q_{wb_k}\otimes \begin{bmatrix}1\\ \frac{1}{2}w \delta t\end{bmatrix}\tag{24}\end{align*}</script><p>其中，</p><script type="math/tex; mode=display">\begin{align*}a&=q_{wb_{k+1} }(a^{b_k}-b^a_k)-g^w\\w&=w^{b_k}-b^g_k\end{align*}\tag{25}</script><h3 id="2-中值法"><a href="#2-中值法" class="headerlink" title="2.中值法"></a>2.中值法</h3><p>使用 mid-point 方法，即两个相邻时刻$ k$到$ k+1$ 的位姿是用两个时刻的测量值$ a,w $的平均值来计算。</p><script type="math/tex; mode=display">\begin{align*}p_{wb_{k+1} }&=p_{wb_k}+v^w_k \Delta t +\frac{1}{2}a\Delta t^2\\v^w_{k+1}&=v^w_k+a\Delta t \\q_{wb_{k+1} }&=q_{wb_k}\otimes \begin{bmatrix}1\\ \frac{1}{2}w \delta t\end{bmatrix}\end{align*}\tag{26}</script><p>其中，</p><script type="math/tex; mode=display">\begin{align*}a&=\frac{1}{2}[q_{wb_{k} }(a^{b_k}-b^a_k)-g^w+q_{wb_{k+1} }(a^{b_{k+1} }-b^a_k)-g^w]\\w&=\frac{1}{2}[(w^{b_k}-b^g_k)+(w^{b_{k+1} }-b^g_k)]\end{align*}\tag{27}</script><h1 id="Ⅴ-IMU-数据仿真"><a href="#Ⅴ-IMU-数据仿真" class="headerlink" title="Ⅴ.IMU 数据仿真"></a>Ⅴ.IMU 数据仿真</h1><ul><li>思路 1：指定轨迹方程，求一阶导得到速度, 角速度，求二阶导得到加速度。</li></ul><p>我们可以指定物体运动的轨迹，比如是圆周运动还是正弦运动，也就是可以指定其运动方程，进而可以对方程直接求导得到速度和加速度。</p><ul><li>思路 2：已有 pose 轨迹，不知道方程，利用 B-Spline 产生 IMU数据。</li></ul><h2 id="A-旋转基础知识"><a href="#A-旋转基础知识" class="headerlink" title="A.旋转基础知识"></a>A.旋转基础知识</h2><h3 id="1-旋转积分的几种方式"><a href="#1-旋转积分的几种方式" class="headerlink" title="1.旋转积分的几种方式"></a>1.旋转积分的几种方式</h3><ul><li>四元数形式</li></ul><script type="math/tex; mode=display">q_{wb^\prime }=q_{wb}\otimes \begin{bmatrix}1\\ \frac{1}{2}w \Delta t\end{bmatrix}\tag{28}</script><ul><li>SO3形式</li></ul><script type="math/tex; mode=display">R_{wb^\prime}=R_{wb}\exp(w\cdot\Delta t)\tag{29}</script><ul><li>欧拉角形式</li></ul><script type="math/tex; mode=display">\vartheta_{wb^\prime}=\vartheta_{wb}+E_{wb}\cdot w\Delta t\tag{30}</script><p>其中$\vartheta=(\psi_{roll},\theta_{pitch},\phi_{yaw})^T$,$E_{wb}$表示IMU坐标系（Body坐标系）下的角速度转换成欧拉角角速度。</p><h3 id="2-欧拉角形式的旋转变换"><a href="#2-欧拉角形式的旋转变换" class="headerlink" title="2.欧拉角形式的旋转变换"></a>2.欧拉角形式的旋转变换</h3><p>世界坐标系$\left\{ W \right\}$一个点旋转到机器人本体坐标系$\left\{ B \right\}$，很容易想到使用旋转矩阵表示，但是实际上使用欧拉角则更为方便，直观性更好。</p><p>$step\ 1. $绕着惯性坐标系的$ z$轴旋转，得到新的坐标系$b^1$</p><script type="math/tex; mode=display">x^1_b=\begin{bmatrix}\cos\phi&\sin\phi&0\\-\sin\phi&\cos\phi&0\\0&0&1\end{bmatrix}x^0_b=R(\phi)x^0_b</script><p>$step\ 2. $绕着新的坐标系$b^1$的$ y$轴旋转，得到新的坐标系$b^2$</p><script type="math/tex; mode=display">x^2_b=\begin{bmatrix}\cos\theta&0&-\sin\theta\\0&1&0\\\sin\theta&0&\cos\theta\end{bmatrix}x^1_b=R(\theta)x^1_b</script><p>$step\ 3. $绕着新的坐标系$b^2$的$ x$轴旋转，得到新的坐标系$b^3$，$b^3$就是我们的body 坐标系。</p><script type="math/tex; mode=display">x^3_b=\begin{bmatrix}1&0&0\\0&\cos\psi&\sin\psi\\0&-\sin\psi&\cos\psi\end{bmatrix}x^2_b=R(\psi)x^2_b</script><p>综合起来，得到：</p><script type="math/tex; mode=display">\begin{align*}x_b&=R(\psi)R(\theta)R(\phi)x\\&=\begin{bmatrix}c\theta c\phi &c\theta s\phi &-s\theta \\-c\psi s\phi +s\psi s\theta c\phi &c\psi c\phi +s\psi s\theta s\phi &s\psi c\theta \\s\psi s\phi +c\psi s\theta c\phi &-s\psi c\phi +c\psi s\theta s\phi &c\psi c\theta \end{bmatrix}x\\&=R(\psi,\theta,\phi)x\end{align*}\tag{31}</script><h3 id="3-欧拉角速度和-body-角速度的转换"><a href="#3-欧拉角速度和-body-角速度的转换" class="headerlink" title="3.欧拉角速度和 body 角速度的转换"></a>3.欧拉角速度和 body 角速度的转换</h3><p>欧拉角速度和 body 角速度的转换:</p><script type="math/tex; mode=display">\begin{align*}w&=R(\psi)R(\theta)\begin{bmatrix}0\\0\\\frac{d\phi}{dt}\end{bmatrix}+R(\psi)\begin{bmatrix}0\\\frac{d\theta}{dt}\\0\end{bmatrix}+\begin{bmatrix}\frac{d\psi}{dt}\\0\\0\end{bmatrix}\\&=\begin{bmatrix}1&0&-\sin\theta\\0&\cos\psi&\sin\psi\cos\theta\\0&-\sin\psi&\cos\psi\cos\theta\end{bmatrix}\begin{bmatrix}\frac{d\psi}{dt}\\\frac{d\theta}{dt}\\\frac{d\phi}{dt}\end{bmatrix}\\\end{align*}\tag{32}</script><p>公式$ (31)$ 取逆就能得到，body 角速度到欧拉角速度的变换：</p><script type="math/tex; mode=display">\frac{d\vartheta}{dt}=\begin{bmatrix}1&\sin\psi\tan\theta&\cos\psi\tan\theta\\0&\cos\psi&-\sin\psi\\0&\sin\psi/cos\theta&\cos\psi/\cos\theta\end{bmatrix}\overrightarrow{w}\tag{33}</script><h2 id="B-仿真"><a href="#B-仿真" class="headerlink" title="B.仿真"></a>B.仿真</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本节主要对IMU的运动模型以及误差模型进行了分析，并针对连续时间和离散模型的处理做了简单的概要。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>一、课程概要</title>
    <link href="https://lukeyalvin.top/posts/28639.html"/>
    <id>https://lukeyalvin.top/posts/28639.html</id>
    <published>2022-04-25T09:17:10.447Z</published>
    <updated>2022-04-26T01:20:20.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本课程专注于<strong>视觉 +IMU 融合定位</strong>的基础理论和实现，作为视觉SLAM 的进阶课程<br>在本课程中，你将学习到的重点内容有：</p><ul><li>IMU 的工作原理和噪声方程</li><li>视觉与 IMU 紧耦合的基础理论</li><li>从零开始实现 VIO 紧耦合优化器（仅基于 Eigen）</li></ul><p>相比视觉 SLAM 基础课程，本次课程更加注重 IMU 融合的理论推导与实现。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>本课程专注于<strong>视觉 +IMU 融合定位</strong>的基础理论和实现，作为视觉SLAM 的进阶课程<br>在本课程中，你将学习到的重点内容有：</p><ul><li>IMU 的工作原理和噪声方程</li><li>视觉与 IMU 紧耦合的基础理论</li><li>从零开始实现 VIO 紧耦合优化器（仅基于 Eigen）</li></ul><p>相比视觉 SLAM 基础课程，本次课程更加注重 IMU 融合的理论推导与实现。</p><h1 id="Ⅰ-VIO-概述"><a href="#Ⅰ-VIO-概述" class="headerlink" title="Ⅰ.VIO 概述"></a>Ⅰ.VIO 概述</h1><h2 id="A-IMU与视觉里程"><a href="#A-IMU与视觉里程" class="headerlink" title="A.IMU与视觉里程"></a>A.IMU与视觉里程</h2><p>IMU（Inertial Measurement Unit），惯性测量单元，用于测量物体三轴姿态角(或角速率)以及加速度的装置。一般情况下，一个IMU内会装有三轴的陀螺仪和三个方向的加速度计，分别用来测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。为了提高可靠性，还可以为每个轴配备更多的传感器。一般而言IMU要安装在被测物体的重心上。</p><ul><li>典型 6 轴 IMU 本身由一个陀螺仪和一个加速度计组成，分别测量自身的角速度和加速度，并以较高频率（≥ 100Hz）返回。</li></ul><p><img src="/posts/28639.htm/image-20220420150139375.png" alt="image-20220420150139375"></p><ul><li>但是IMU，受自身温度、零偏、振动等因素干扰，积分得到的平移和旋转容易漂移</li></ul><p>手机等电子产品多使用价格低廉的 MEMS IMU（如 MPU 6050），自动驾驶类则多使用几万元的 IMU（如 Apollo 中使用的 Novatel SPAN-IGM-A1）</p><p><img src="/posts/28639.htm/image-20220420150543613.png" alt="image-20220420150543613"></p><p>视觉 Visual Odometry</p><ul><li>以图像形式记录数据，频率较低（15 − 60Hz 居多）</li><li>通过图像特征点或像素推断相机运动，因此容易受成像质量的影响。</li></ul><p><strong>IMU 与视觉定位方案优势与劣势对比：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">方案</th><th style="text-align:center">IMU</th><th style="text-align:center">视觉</th></tr></thead><tbody><tr><td style="text-align:center">优势</td><td style="text-align:center">快速响应<br>不受成像质量影响<br>角速度普遍比较准确<br>可估计绝对尺度</td><td style="text-align:center">（静止）不产生漂移<br>直接测量旋转与平移</td></tr><tr><td style="text-align:center">劣势</td><td style="text-align:center">存在零偏<br>低精度 IMU 积分位姿发散<br>高精度价格昂贵</td><td style="text-align:center">受图像遮挡、运动物体干扰<br>单目视觉无法测量尺度<br>单目纯旋转运动无法估计<br>快速运动时易丢失</td></tr></tbody></table></div><p>整体上，视觉和 IMU 定位方案存在一定互补性质：</p><ul><li>IMU 适合计算短时间、快速的运动；</li><li>视觉适合计算长时间、慢速的运动。</li></ul><p>同时，可利用视觉定位信息来估计 IMU 的零偏，减少 IMU 由零偏导致的发散和累积误差；反之，IMU 可以为视觉提供快速运动时的定位。</p><h2 id="B-VIO"><a href="#B-VIO" class="headerlink" title="B.VIO"></a>B.VIO</h2><p>VIO：（Visual-Inertial Odometry）视觉惯性里程计，有时候也叫视觉惯性系统（VINS，visual-inertial system），是融合相机和IMU数据实现SLAM的算法。</p><p>IMU 数据可与多种定位方案融合，比如自动驾驶中通常用 IMU+GPS/差分 GPS/RTK 的融合定位方案，<br>形成 GNSS-INS 组合导航系统，达到厘米组定位精度；头戴式 AR/VR 头盔则多使用视觉 +IMU 的 VIO 定位系统，形成高帧率定位方案。</p><p>根据融合框架的区别VIO可以分为紧耦合和松耦合：</p><ul><li><strong>松耦合</strong></li></ul><p>松耦合将 IMU 定位与视觉/GNSS 的位姿直接进行融合，融合过程对二者本身不产生影响，作为后处理方式输出。典型方案为卡尔曼滤波器。</p><p><img src="/posts/28639.htm/image-20220420151628700.png" alt="image-20220420151628700"></p><ul><li><strong>紧耦合</strong></li></ul><p>紧耦合则是使用两个传感器的原始数据共同估计一组变量，传感器噪声也是相互影响的，紧耦合算法上比较复杂，但充分利用了传感器数据，可以实现更好的效果，是目前研究的重点。典型方案为 MSCKF 和非线性优化。</p><p><img src="/posts/28639.htm/image-20220420151708384.png" alt="image-20220420151708384"></p><p><strong>为什么要使用紧耦合？</strong></p><ul><li>单纯凭（单目）视觉或 IMU 都不具备估计 Pose 的能力：视觉存在尺度不确定性、IMU 存在零偏导致漂移；</li><li>松耦合中，视觉内部 BA 没有 IMU 的信息，在整体层面来看不是最优的。</li><li>紧耦合可以一次性建模所有的运动和测量信息，更容易达到最优。</li></ul><h1 id="Ⅱ-知识点回顾"><a href="#Ⅱ-知识点回顾" class="headerlink" title="Ⅱ.知识点回顾"></a>Ⅱ.知识点回顾</h1><h2 id="A-三维刚体运动"><a href="#A-三维刚体运动" class="headerlink" title="A.三维刚体运动"></a>A.三维刚体运动</h2><p>在三维刚体运动中，我们定义机器人上的各种坐标系，世界坐标系$W$，IMU坐标系(Body系)$I$，相机坐标系$C$。通过十四讲的学习我们可以知道，坐标系之间的转换可以通过$SE(3)$给出，比如$I$到$W$坐标系的变换矩阵为$T_{WI}$:</p><script type="math/tex; mode=display">T_{WI}=\begin{bmatrix}R_{WI}&t_{WI}\\0^T&1\end{bmatrix}\in\R^{4×4}\tag{1}</script><p>其中，$R_{WI}$为$3×3$的旋转矩阵，$t_{WI}$为平移向量。我们可以用$T_{WI}$右乘一个$I$坐标系下的坐标，将得到该点$W$系下的坐标。</p><h2 id="B-四元数"><a href="#B-四元数" class="headerlink" title="B.四元数"></a>B.四元数</h2><p>三维刚体的运动可以有旋转矩阵来表达，也可以用四元数$q$描述。四元数有一个实部和三个虚部。我们把实部写在前：</p><script type="math/tex; mode=display">q=[q_0,q_1,q_2,q_3]^T或q=[w,x,y,z]^T\tag{2}</script><p>其中 $q_0$ 为实部，$[q_1, q_2, q_3]^T$为虚部。因为实部为标量，虚部为矢量，所以也可记为：</p><script type="math/tex; mode=display">q=[s,\pmb{v}]^T\tag{3}</script><p>其中 $s $为标量，$\pmb{v}$为虚部的矢量。</p><p><strong>四元数的乘法运算：</strong></p><script type="math/tex; mode=display">\begin{align*}q_a\otimes q_b&=w_aw_b − x_ax_b − y_ay_b − z_az_b\\&+ (w_ax_b + x_aw_b + y_az_b − z_ay_b)i\\&+ (w_ay_b − x_az_b + y_aw_b + z_ax_b) j\\&+ (w_az_b + x_ay_b − y_ax_b + z_aw_b) k.\end{align*}\tag{4}</script><p>或者是：</p><script type="math/tex; mode=display">q_a\otimes q_b=[s_as_b-\pmb{v}_a^T\pmb{v}_b,s_a\pmb{v}_b+s_b\pmb{v}_a+\pmb{v}_a\times\pmb{v}_b]^T\tag{5}</script><p>四元数的其他四则运算，不作具体展开，参阅《视觉SLAM十四讲》。</p><p><strong>四元数表示旋转：</strong></p><p>另外单位四元数可表达任意三维旋转，且无奇异性。如设轴角为$w$和$\theta$，那么它对应的四元数为：</p><script type="math/tex; mode=display">q=[cos\frac{\theta}{2},wsin\frac{\theta}{2}]^T\tag{6}</script><p>利用此性质可推导四元数求导。</p><p><strong>四元数的求导：</strong></p><p>四元数时间导数：设初始旋转为 $q = [s, \pmb{v}]$，然后，发生了角轴为 $w, \theta$ 的旋转（右乘，对应四元数记作$\Delta q=[cos\frac{\theta}{2},wsin\frac{\theta}{2}]^T$），那么 $q $相对该旋转的导数为：</p><script type="math/tex; mode=display">\begin{align*}\underset{\theta \rightarrow 0}{lim}\frac{q\otimes \Delta q-q}{\theta}&=\underset{\theta \rightarrow 0}{lim}\frac{[s \cos\frac{\theta}{2}-\pmb{v}^Tw \sin\frac{\theta}{2},sw \sin\frac{\theta}{2}+cos\frac{\theta}{2}\pmb{v}+\pmb{v}\times w \sin\frac{\theta}{2}]^T-q}{\theta}\\&=\underset{\theta \rightarrow 0}{lim}\frac{[s (\cos\frac{\theta}{2}-1)-\pmb{v}^Tw \sin\frac{\theta}{2},sw \sin\frac{\theta}{2}+(\cos\frac{\theta}{2}-1)\pmb{v}+\pmb{v}\times w \sin\frac{\theta}{2}]^T}{\theta}\\&=[-\frac{1}{2}\pmb{v}^Tw,\frac{1}{2}sw+\frac{1}{2}\pmb{v}\times w]^T\\&=q\otimes[0,\frac{1}{2}w]^T\end{align*}\tag{7}</script><p>因此，若角速度为 $w$，那么旋转的时间导数即为：</p><script type="math/tex; mode=display">\dot q= q\otimes[0,\frac{1}{2}w]^T\tag{8}</script><h2 id="C-李代数"><a href="#C-李代数" class="headerlink" title="C.李代数"></a>C.李代数</h2><p>除了利用四元数求导，亦可利用李代数进行旋转求导。<br>使用旋转矩阵$R$时，角速度为 $w$，那么 $R$ 相对于时间的导数可写作：</p><script type="math/tex; mode=display">\dot R= Rw^{\land}\tag{9}</script><p>该式被称为<strong>泊松公式</strong>（Possion’s equation），其中${\land}$为反对称矩阵算子：</p><script type="math/tex; mode=display">w^{\land}=\begin{bmatrix}0&-w_3&w_2\\w_3&0&-w_1\\-w_2&w_1&0\end{bmatrix}\tag{10}</script><p>其实结合之前的知识，可以发现，这里的$w^{\land}$不就是旋转矩阵对应的李代数$\mathfrak{so}(3)$嘛，十四讲里面用的是$\phi^{\land}$。</p><p><strong>$\mathfrak{so}(3)$导数：</strong></p><p>在优化带有旋转的函数时，通常计算一个增量 $\phi\in \mathfrak{so}(3)$，然后用它更新当前估计值：</p><script type="math/tex; mode=display">R\leftarrow R\ exp(\phi^{\land})\tag{11}</script><p>其中$exp$为$\mathfrak{so}(3)$至$SO(3)$上的指数映射。</p><blockquote><p>注意：</p><blockquote><p>①不同的$R$函数，具体的导数形式也不同</p><p>②在程序中，不必区分$R$是以矩阵存储或是以四元数存储，只需按照该式更新即可。</p></blockquote></blockquote><h2 id="D-扰动模型的雅可比"><a href="#D-扰动模型的雅可比" class="headerlink" title="D.扰动模型的雅可比"></a>D.扰动模型的雅可比</h2><p><strong>常见的一些雅可比：</strong>（以自变量为$R$举例）</p><ul><li>旋转点的左扰动雅可比：</li></ul><p>这里将对$R$进行一次的扰动$\Delta R$加在其对应的李代数$\varphi $上，而非李群上。</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial(Rp)}{\partial \varphi}&=\underset{\varphi\rightarrow0}{lim}\frac{exp(\varphi^{\land})\cdot exp(\phi^{\land})p-exp(\phi^{\land})p}{\varphi}\\&\approx \underset{\varphi\rightarrow0}{lim}\frac{(I+\varphi^{\land})\cdot exp(\phi^{\land})p-exp(\phi^{\land})p}{\varphi} \ \ \ 一阶泰勒展开\\&=\underset{\varphi\rightarrow0}{lim}\frac{\varphi^{\land}Rp}{\varphi} \ \ \ 根据 a^{\land}b=-b^{\and}a\\&=\underset{\varphi\rightarrow0}{lim}\frac{-(Rp)^{\land}\varphi}{\varphi}\\&=-(Rp)^{\land}\end{align*}\tag{12}</script><ul><li>旋转点的右扰动雅可比：</li></ul><script type="math/tex; mode=display">\begin{align*}\frac{\partial(Rp)}{\partial \varphi}&=\underset{\varphi\rightarrow0}{lim}\frac{ exp(\phi^{\land})\cdot exp(\varphi^{\land})p-exp(\phi^{\land})p}{\varphi}\\&\approx \underset{\varphi\rightarrow0}{lim}\frac{ exp(\phi^{\land})\cdot(I+\varphi^{\land})p-exp(\phi^{\land})p}{\varphi} \ \ \ 一阶泰勒展开\\&=\underset{\varphi\rightarrow0}{lim}\frac{R\varphi^{\land}p}{\varphi} \ \ \ 根据 a^{\land}b=-b^{\and}a\\&=\underset{\varphi\rightarrow0}{lim}\frac{-Rp^{\land}\varphi}{\varphi}\\&=-Rp^{\land}\end{align*}\tag{13}</script><ul><li>旋转连乘的雅可比：</li></ul><p>①这里将对$R_2$进行一次的扰动$\Delta R_2$加在其对应的李代数$\phi $上，而非李群上。</p><script type="math/tex; mode=display">\begin{align*}\frac{d\ ln(R_1R_2)^{\lor} }{dR_2}&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\cdot exp(\phi^{\land}))^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&\approx\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2)^{\lor}+J^{-1}_r\phi-ln(R_1R_2)^{\lor} }{\phi}\\&=J^{-1}_r(ln(R_1R_2)^{\lor})\end{align*}\tag{14}</script><p>第一步到第二步使用的是$BCH$近似公式：</p><script type="math/tex; mode=display">\ln (\exp(\phi_{1}^{\land})\exp(\phi_{2}^{\land}) )^{\lor} \approx\left\{ \begin{array}{l}J_l(\phi_{2})^{-1}\phi_{1}+\phi_{2}\ \ \ \ 当\phi_{1}为小量\\J_r(\phi_{1})^{-1}\phi_{2}+\phi_{1}\ \ \ \ 当\phi_{2}为小量    \\\end{array} \right.\tag{15}</script><p>此处就是：对任意$R$</p><script type="math/tex; mode=display">\ln (R\exp(\phi^{\land}) )^{\lor} \approx\ln(R)^{\lor}+J_r^{-1}\phi\tag{16}</script><p>其中$J_r^{-1}$为$SO(3)$上的右雅可比：</p><script type="math/tex; mode=display">J_r^{-1}(\theta w)=\frac{1}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})ww^T+\frac{\theta}{2}w^{\land}\tag{17}</script><p>②这里将对$R_1$进行一次的扰动$\Delta R_1$加在其对应的李代数$\phi $上，而非李群上。</p><script type="math/tex; mode=display">\begin{align*}\frac{d\ ln(R_1R_2)^{\lor} }{dR_2}&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1\cdot \exp(\phi^{\land})\ R_2)^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\cdot[R_2^T\cdot \exp(\phi^{\land})\ R_2])^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&=\underset{\phi\rightarrow0}{lim}\frac{ln(R_1R_2\exp((R_2^T\phi)^{\land}))^{\lor}-ln(R_1R_2)^{\lor} }{\phi}\\&=J^{-1}_r(ln(R_1R_2)^{\lor})R_2^T\end{align*}\tag{18}</script><p>第一步到第二步用到了$sO(3)$的伴随性质：</p><script type="math/tex; mode=display">R^T\exp(\phi^{\land})R=\exp((R^T\phi)^{\land})\tag{19}</script><p>有关 $SE(3)$：由于$ SE(3)$ 李代数性质复杂，在 VIO 中，我们通常使用$SO(3) + t $的形式表达旋转和平移。对平移部分使用矢量更新而非$SE(3) $上的更新。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本课程专注于&lt;strong&gt;视觉 +IMU 融合定位&lt;/strong&gt;的基础理论和实现，作为视觉SLAM 的进阶课程&lt;br&gt;在本课程中，你将学习到的重点内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IMU 的工作原理和噪声方程&lt;/li&gt;
&lt;li&gt;视觉与 IMU 紧耦合的基础理论&lt;/li&gt;
&lt;li&gt;从零开始实现 VIO 紧耦合优化器（仅基于 Eigen）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比视觉 SLAM 基础课程，本次课程更加注重 IMU 融合的理论推导与实现。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="从零开始手写VIO" scheme="https://lukeyalvin.top/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99VIO/"/>
    
    
    <category term="VIO" scheme="https://lukeyalvin.top/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>aloam_velodyney源代码深度解析</title>
    <link href="https://lukeyalvin.top/posts/60089.html"/>
    <id>https://lukeyalvin.top/posts/60089.html</id>
    <published>2022-04-18T01:31:17.245Z</published>
    <updated>2022-04-26T01:20:20.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>体验过LOAM代码之后，大多数人应该对源代码有种不太好的印象，我觉得更多是因为LOAM作者受当时发展的局限，没有使用像现在流行的李代数、Eigen、Ceres等，A-LOAM就在其基础上对源代码进行了改进，最明显的就是坐标变化部分引入了Eigen，优化部分使用Ceres自动求导代替LOAM作者手推的ICP优化部分，代码变得十分简洁，但是同时也降低了LOAM算法的效率。尽管如此，这位香港大学的秦师兄写的代码还是很让人佩服的。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>首先看一下ROS节点图，明显可以发现比LOAM的简洁太多了：</p><p><img src="/posts/60089.htm/1308994-20200506202232477-859678963.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;体验过LOAM代码之后，大多数人应该对源代码有种不太好的印象，我觉得更多是因为LOAM作者受当时发展的局限，没有使用像现在流行的李代数、Eigen、Ceres等，A-LOAM就在其基础上对源代码进行了改进，最明显的就是坐标变化部分引入了Eigen，优化部分使用Ceres自动求导代替LOAM作者手推的ICP优化部分，代码变得十分简洁，但是同时也降低了LOAM算法的效率。尽管如此，这位香港大学的秦师兄写的代码还是很让人佩服的。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM项目实践" scheme="https://lukeyalvin.top/categories/SLAM%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="ALOAM" scheme="https://lukeyalvin.top/tags/ALOAM/"/>
    
  </entry>
  
  <entry>
    <title>loam_velodyney源代码深度解析</title>
    <link href="https://lukeyalvin.top/posts/49015.html"/>
    <id>https://lukeyalvin.top/posts/49015.html</id>
    <published>2022-04-13T13:08:50.276Z</published>
    <updated>2022-04-26T01:20:20.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>对于LOAM的论文以及原理清晰之后，我们还需要对论文算法的具体实现做深度剖析，做到将论文的每一部分与代码相对应，并学习LOAM实现的方式。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ.概述"></a>Ⅰ.概述</h1><p>由于LOAM使用机器人操作系统(ROS)进行管理，所以我们比较关注节点和消息发布与接收的关系，我们可以通过rqt_graph查看所有的节点以及消息之间的关系，代码的框架图：</p><p><img src="/posts/49015.htm/rosgraph_loam-16498556914162.png" alt="rosgraph_loam"></p><p>其中椭圆框代表节点(node)，矩形框代表消息(Message)。</p><h1 id="Ⅱ-scanRegistration"><a href="#Ⅱ-scanRegistration" class="headerlink" title="Ⅱ.scanRegistration"></a>Ⅱ.scanRegistration</h1><p> <span style="color:red;"><strong>节点的主要功能:</strong></span> <span style="color:blue;"><strong>对点云和IMU数据进行预处理，用于特征点的配准。</strong></span> </p><p><img src="/posts/49015.htm/image-20220416144530168.png" alt="image-20220416144530168"></p><h2 id="A-laserCloudHandler"><a href="#A-laserCloudHandler" class="headerlink" title="A.laserCloudHandler"></a>A.laserCloudHandler</h2><p><img src="/posts/49015.htm/image-20220414193914478.png" alt="image-20220414193914478"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描周期, velodyne频率10Hz，周期0.1s</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> scanPeriod = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化控制变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> systemDelay = <span class="number">20</span>; <span class="comment">//弃用前20帧初始数据</span></span><br><span class="line"><span class="keyword">int</span> systemInitCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> systemInited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//激光雷达线数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_SCANS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点云曲率, 40000为一帧点云中点的最大数量</span></span><br><span class="line"><span class="keyword">float</span> cloudCurvature[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//曲率点对应的序号</span></span><br><span class="line"><span class="keyword">int</span> cloudSortInd[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点是否筛选过标志：0-未筛选过，1-筛选过</span></span><br><span class="line"><span class="keyword">int</span> cloudNeighborPicked[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点分类标号:2-代表曲率很大，1-代表曲率比较大,-1-代表曲率很小，0-曲率比较小(其中1包含了2,0包含了1,0和1构成了点云全部的点)</span></span><br><span class="line"><span class="keyword">int</span> cloudLabel[<span class="number">40000</span>];</span><br></pre></td></tr></table></figure><p><code>N_SCANS</code> 是将 <code>3D</code> 的激光点云按照激光的接受器做了个划分，比如 <code>N_SCANS</code>是 $16 $表明是 $16 $线的激光（程序中的默认值，作者用过 <code>velodyne16</code>）。</p><p>论文中存储每个点的曲率用的是数组，因此需要考虑数组的大小，这里设置为了$40000$，另外使用<code>cloudLabel</code>来标记论文中提到的将扫描分割成四个相同的子区域，2-代表曲率很大(sharp)，1-代表曲率比较大(less_sharp)，-1-代表曲率很小(flat)，0-曲率比较小(less_flat)。</p><h3 id="1-线束模型"><a href="#1-线束模型" class="headerlink" title="1.线束模型"></a>1.线束模型</h3><p>对于一堆点云并不是像 LaserScan（二维的数据结构）那样按照角度给出个距离值，保证每次的扫描都能够有相同大小的数据量。PointCloud2 接受到的点云的大小在变化，因此在数据到达需要一些运算来判断点的一些特性。例如下面这段通过计算 pitch 角度判断该点属于哪个<code>Scan</code>。</p><p>(具体查看：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#A-%E7%BA%BF%E6%9D%9F%E6%A8%A1%E5%9E%8B">loam论文深度解析-Ⅲ.特征提取（点云注册）A.线束模型</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lidar扫描线是否旋转过半</span></span><br><span class="line"><span class="keyword">bool</span> halfPassed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> count = cloudSize;</span><br><span class="line">PointType point;</span><br><span class="line">std::vector&lt;pcl::PointCloud&lt;PointType&gt;&gt; <span class="built_in">laserCloudScans</span>(N_SCANS);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//坐标轴交换，velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系</span></span><br><span class="line">    point.x = laserCloudIn.points[i].y;</span><br><span class="line">    point.y = laserCloudIn.points[i].z;</span><br><span class="line">    point.z = laserCloudIn.points[i].x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算点的仰角(根据lidar文档垂直角计算公式),根据仰角排列激光线号，velodyne每两个scan之间间隔2度</span></span><br><span class="line">    <span class="keyword">float</span> angle = <span class="built_in">atan</span>(point.y / <span class="built_in">sqrt</span>(point.x * point.x + point.z * point.z)) * <span class="number">180</span> / M_PI;</span><br><span class="line">    <span class="keyword">int</span> scanID;</span><br><span class="line">    <span class="comment">//仰角四舍五入(加减0.5截断效果等于四舍五入)</span></span><br><span class="line">    <span class="keyword">int</span> roundedAngle = <span class="built_in"><span class="keyword">int</span></span>(angle + (angle &lt; <span class="number">0.0</span> ? <span class="number">-0.5</span> : +<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">if</span> (roundedAngle &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    scanID = roundedAngle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    scanID = roundedAngle + (N_SCANS - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤点，只挑选[-15度，+15度]范围内的点,scanID属于[0,15]</span></span><br><span class="line">    <span class="keyword">if</span> (scanID &gt; (N_SCANS - <span class="number">1</span>) || scanID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【解析】这里8-11行的坐标轴变换，有点绕，作者的意思就是把velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系：</p><p><img src="/posts/49015.htm/image-20220414153416294.png" alt="image-20220414153416294"></p><p>然后就是利用勾股定理与三角函数相关的知识求出仰角$Pitch=atan(z/\sqrt{x^2+y^2})$，即可根据该角度判断点云属于哪条<code>Scan</code>，这样就可以计算出每个点的<code>scanID</code>。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描周期, velodyne频率10Hz，周期0.1s</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> scanPeriod = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">typedef</span> pcl::PointXYZI PointType;</span><br><span class="line">PointType point;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//-0.5 &lt; relTime &lt; 1.5（点旋转的角度与整个周期旋转角度的比率, 即点云中点的相对时间）</span></span><br><span class="line"><span class="keyword">float</span> relTime = (ori - startOri) / (endOri - startOri);</span><br><span class="line"><span class="comment">//点强度=线号+点相对时间（即一个整数+一个小数，整数部分是线号，小数部分是该点的相对时间）,匀速扫描：根据当前扫描的角度和扫描周期计算相对扫描起始位置的时间</span></span><br><span class="line">point.intensity = scanID + scanPeriod * relTime;</span><br></pre></td></tr></table></figure><p>【解析】点云中点的相对时间是用当前的点旋转的角度占整个周期旋转角度的比，然后使用<code>PointXYZI</code>点云类型存储点云数据，整数部分：scan ID，小数部分：每个点扫描的时间。</p><blockquote><p><code>PointXYZI</code>是一个简单的<code>XYZ</code>坐标加<code>intensity</code>的<code>point</code>类型，理想情况下，这四个变量将新建单独一个结构体，并且满足存储对齐，然而，由于<code>point</code>的大部分操作会把<code>data[4]</code>元素设置成$0$或$1$（用于变换），不能让<code>intensity</code>与<code>xyz</code>在同一个结构体中，如果这样的话其内容将会被覆盖。例如，两个点的点积会把他们的第四个元素设置成0，否则该点积没有意义，等等。因此，对于兼容存储对齐，用三个额外的浮点数来填补intensity，这样在存储方面效率较低，但是符合存储对齐要求，运行效率较高。</p></blockquote><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//IMU部分代码.......</span></span><br><span class="line">    laserCloudScans[scanID].<span class="built_in">push_back</span>(point);<span class="comment">//将每个补偿矫正（IMU部分代码）的点放入对应线号的容器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得有效范围内的点的数量</span></span><br><span class="line">cloudSize = count;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_SCANS; i++)</span><br><span class="line">&#123; <span class="comment">//将所有的点按照线号从小到大放入一个容器</span></span><br><span class="line">    *laserCloud += laserCloudScans[i];<span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【解析】将点压入到每个线中，然后循环迭代每一条<code>Scan</code>,更新到总的点云<code>laserCloud</code>。</p><hr><h3 id="2-插入IMU数据"><a href="#2-插入IMU数据" class="headerlink" title="2.插入IMU数据"></a>2.插入IMU数据</h3><p>插入<code>IMU</code>数据的目的就是校正点云畸变，论文中提到蓝色线段表示扫描$k$时感知到的点云 $P_k$，在$k$次扫描结束时，经过<strong>畸变校正</strong>之后将$P_k$重新投影到时间戳$t_{k+1}$，得到绿色线段$\overline{P}_k$，这里的畸变校正使用的就是插入<code>IMU</code>数据进行补偿来进行校正的。通过代码看一下如何使用<code>IMU</code>进行校正的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lidar扫描线是否旋转过半</span></span><br><span class="line"><span class="keyword">bool</span> halfPassed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> count = cloudSize;</span><br><span class="line">PointType point;</span><br><span class="line">std::vector&lt;pcl::PointCloud&lt;PointType&gt;&gt; <span class="built_in">laserCloudScans</span>(N_SCANS);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 线束模型部分的代码....</span></span><br><span class="line">  <span class="keyword">float</span> relTime = (ori - startOri) / (endOri - startOri);</span><br><span class="line">  <span class="comment">//点强度=线号+点相对时间（即一个整数+一个小数，整数部分是线号，小数部分是该点的相对时间）,匀速扫描：根据当前扫描的角度和扫描周期计算相对扫描起始位置的时间</span></span><br><span class="line">  point.intensity = scanID + scanPeriod * relTime;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点时间=点云时间+周期时间</span></span><br><span class="line">  <span class="keyword">if</span> (imuPointerLast &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;                                         <span class="comment">//如果收到IMU数据,使用IMU矫正点云畸变</span></span><br><span class="line">    <span class="keyword">float</span> pointTime = relTime * scanPeriod; <span class="comment">//计算点的周期时间</span></span><br><span class="line">    <span class="comment">//寻找是否有点云的时间戳小于IMU的时间戳的IMU位置:imuPointerFront</span></span><br><span class="line">    <span class="keyword">while</span> (imuPointerFront != imuPointerLast)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeScanCur + pointTime &lt; imuTime[imuPointerFront])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      imuPointerFront = (imuPointerFront + <span class="number">1</span>) % imuQueLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeScanCur + pointTime &gt; imuTime[imuPointerFront])</span><br><span class="line">    &#123; <span class="comment">//没找到,此时imuPointerFront==imtPointerLast,只能以当前收到的最新的IMU的速度，位移，欧拉角作为当前点的速度，位移，欧拉角使用</span></span><br><span class="line">      imuRollCur = imuRoll[imuPointerFront];</span><br><span class="line">      imuPitchCur = imuPitch[imuPointerFront];</span><br><span class="line">      imuYawCur = imuYaw[imuPointerFront];</span><br><span class="line"></span><br><span class="line">      imuVeloXCur = imuVeloX[imuPointerFront];</span><br><span class="line">      imuVeloYCur = imuVeloY[imuPointerFront];</span><br><span class="line">      imuVeloZCur = imuVeloZ[imuPointerFront];</span><br><span class="line"></span><br><span class="line">      imuShiftXCur = imuShiftX[imuPointerFront];</span><br><span class="line">      imuShiftYCur = imuShiftY[imuPointerFront];</span><br><span class="line">      imuShiftZCur = imuShiftZ[imuPointerFront];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//找到了点云时间戳小于IMU时间戳的IMU位置,则该点必处于imuPointerBack和imuPointerFront之间，据此线性插值，计算点云点的速度，位移和欧拉角</span></span><br><span class="line">      <span class="keyword">int</span> imuPointerBack = (imuPointerFront + imuQueLength - <span class="number">1</span>) % imuQueLength;</span><br><span class="line">      <span class="comment">//按时间距离计算权重分配比率,也即线性插值</span></span><br><span class="line">      <span class="keyword">float</span> ratioFront = (timeScanCur + pointTime - imuTime[imuPointerBack]) / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);</span><br><span class="line">      <span class="keyword">float</span> ratioBack = (imuTime[imuPointerFront] - timeScanCur - pointTime) / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);</span><br><span class="line"></span><br><span class="line">      imuRollCur = imuRoll[imuPointerFront] * ratioFront + imuRoll[imuPointerBack] * ratioBack;</span><br><span class="line">      imuPitchCur = imuPitch[imuPointerFront] * ratioFront + imuPitch[imuPointerBack] * ratioBack;</span><br><span class="line">      <span class="keyword">if</span> (imuYaw[imuPointerFront] - imuYaw[imuPointerBack] &gt; M_PI)</span><br><span class="line">      &#123;</span><br><span class="line">        imuYawCur = imuYaw[imuPointerFront] * ratioFront + (imuYaw[imuPointerBack] + <span class="number">2</span> * M_PI) * ratioBack;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (imuYaw[imuPointerFront] - imuYaw[imuPointerBack] &lt; -M_PI)</span><br><span class="line">      &#123;</span><br><span class="line">        imuYawCur = imuYaw[imuPointerFront] * ratioFront + (imuYaw[imuPointerBack] - <span class="number">2</span> * M_PI) * ratioBack;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        imuYawCur = imuYaw[imuPointerFront] * ratioFront + imuYaw[imuPointerBack] * ratioBack;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//本质:imuVeloXCur = imuVeloX[imuPointerback] + (imuVelX[imuPointerFront]-imuVelX[imuPoniterBack])*ratioFront</span></span><br><span class="line">      imuVeloXCur = imuVeloX[imuPointerFront] * ratioFront + imuVeloX[imuPointerBack] * ratioBack;</span><br><span class="line">      imuVeloYCur = imuVeloY[imuPointerFront] * ratioFront + imuVeloY[imuPointerBack] * ratioBack;</span><br><span class="line">      imuVeloZCur = imuVeloZ[imuPointerFront] * ratioFront + imuVeloZ[imuPointerBack] * ratioBack;</span><br><span class="line"></span><br><span class="line">      imuShiftXCur = imuShiftX[imuPointerFront] * ratioFront + imuShiftX[imuPointerBack] * ratioBack;</span><br><span class="line">      imuShiftYCur = imuShiftY[imuPointerFront] * ratioFront + imuShiftY[imuPointerBack] * ratioBack;</span><br><span class="line">      imuShiftZCur = imuShiftZ[imuPointerFront] * ratioFront + imuShiftZ[imuPointerBack] * ratioBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//如果是第一个点,记住点云起始位置的速度，位移，欧拉角</span></span><br><span class="line">      imuRollStart = imuRollCur;</span><br><span class="line">      imuPitchStart = imuPitchCur;</span><br><span class="line">      imuYawStart = imuYawCur;</span><br><span class="line"></span><br><span class="line">      imuVeloXStart = imuVeloXCur;</span><br><span class="line">      imuVeloYStart = imuVeloYCur;</span><br><span class="line">      imuVeloZStart = imuVeloZCur;</span><br><span class="line"></span><br><span class="line">      imuShiftXStart = imuShiftXCur;</span><br><span class="line">      imuShiftYStart = imuShiftYCur;</span><br><span class="line">      imuShiftZStart = imuShiftZCur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//计算之后每个点相对于第一个点的由于加减速非匀速运动产生的位移速度畸变，并对点云中的每个点位置信息重新补偿矫正</span></span><br><span class="line">      <span class="built_in">ShiftToStartIMU</span>(pointTime);</span><br><span class="line">      <span class="built_in">VeloToStartIMU</span>();</span><br><span class="line">      <span class="built_in">TransformToStartIMU</span>(&amp;point);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  laserCloudScans[scanID].<span class="built_in">push_back</span>(point); <span class="comment">//将每个补偿矫正的点放入对应线号的容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截止到现在，我们已经把一帧杂乱的点云数据有条理的放在了容器里</p><h3 id="3-曲率计算"><a href="#3-曲率计算" class="headerlink" title="3.曲率计算"></a>3.曲率计算</h3><p>在前面的论文深度剖析中，我们提到点云的注册就是进行特征提取，而LOAM进行特征提取采用的是曲率$c$进行判断的，提取的特征主要为边缘点和平面点两种特征。</p><p><strong>平面光滑度</strong>$c$：</p><script type="math/tex; mode=display">c=\frac{1}{|S|·\parallel X^L_{(k,i)}\parallel} \sum_{j\in S,j\ne i} \parallel (X^L_{(k,i)}-X^L_{(k,j)}) \parallel \tag{1}</script><p><strong>代码部分：</strong></p><p>这里计算曲率的方式和论文中有点不同，计算以某点与其相邻的$10$个点所构成的平面在该点出的曲率：</p><p>由曲率公式知：$K=1/R$，因此为简化计算可通过$10$个向量的和向量的模长表示其在该点处曲率半径的长，因此$R×R$可用来表示曲率的大小 $R×R$越大，该点处越不平坦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scanCount = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 选取该点周围十个点（向前找五个，向后找五个），将这十个点的坐标分别和该点作差，得到每一维坐标的差值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">5</span>; i++) </span><br><span class="line">&#123;<span class="comment">//使用每个点的前后五个点计算曲率，因此前五个与最后五个点跳过</span></span><br><span class="line">    <span class="keyword">float</span> diffX = laserCloud-&gt;points[i - <span class="number">5</span>].x + laserCloud-&gt;points[i - <span class="number">4</span>].x </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">3</span>].x + laserCloud-&gt;points[i - <span class="number">2</span>].x </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">1</span>].x - <span class="number">10</span> * laserCloud-&gt;points[i].x </span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">1</span>].x + laserCloud-&gt;points[i + <span class="number">2</span>].x</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">3</span>].x + laserCloud-&gt;points[i + <span class="number">4</span>].x</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">5</span>].x;</span><br><span class="line">    <span class="keyword">float</span> diffY = laserCloud-&gt;points[i - <span class="number">5</span>].y + laserCloud-&gt;points[i - <span class="number">4</span>].y </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">3</span>].y + laserCloud-&gt;points[i - <span class="number">2</span>].y </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">1</span>].y - <span class="number">10</span> * laserCloud-&gt;points[i].y </span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">1</span>].y + laserCloud-&gt;points[i + <span class="number">2</span>].y</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">3</span>].y + laserCloud-&gt;points[i + <span class="number">4</span>].y</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">5</span>].y;</span><br><span class="line">    <span class="keyword">float</span> diffZ = laserCloud-&gt;points[i - <span class="number">5</span>].z + laserCloud-&gt;points[i - <span class="number">4</span>].z </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">3</span>].z + laserCloud-&gt;points[i - <span class="number">2</span>].z </span><br><span class="line">                + laserCloud-&gt;points[i - <span class="number">1</span>].z - <span class="number">10</span> * laserCloud-&gt;points[i].z </span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">1</span>].z + laserCloud-&gt;points[i + <span class="number">2</span>].z</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">3</span>].z + laserCloud-&gt;points[i + <span class="number">4</span>].z</span><br><span class="line">                + laserCloud-&gt;points[i + <span class="number">5</span>].z;</span><br><span class="line">    <span class="comment">//曲率计算（将三个维度的差值求平方和得到R×R）</span></span><br><span class="line">    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;</span><br><span class="line">    <span class="comment">//记录曲率点的索引</span></span><br><span class="line">    cloudSortInd[i] = i;</span><br><span class="line">    <span class="comment">//初始时，点全未筛选过</span></span><br><span class="line">    cloudNeighborPicked[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化为less flat点</span></span><br><span class="line">    cloudLabel[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个scan，只有第一个符合的点会进来，因为每个scan的点都在一起存放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloud-&gt;points[i].intensity) != scanCount) </span><br><span class="line">    &#123;</span><br><span class="line">      scanCount = <span class="built_in"><span class="keyword">int</span></span>(laserCloud-&gt;points[i].intensity);<span class="comment">//控制每个scan只进入第一个点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//曲率只取同一个scan计算出来的，跨scan计算的曲率非法，排除，也即排除每个scan的前后五个点</span></span><br><span class="line">      <span class="keyword">if</span> (scanCount &gt; <span class="number">0</span> &amp;&amp; scanCount &lt; N_SCANS) </span><br><span class="line">      &#123;</span><br><span class="line">        scanStartInd[scanCount] = i + <span class="number">5</span>;<span class="comment">// 该scan的起始点位置的索引（滤出前5个点）</span></span><br><span class="line">        scanEndInd[scanCount - <span class="number">1</span>] = i - <span class="number">5</span>;  <span class="comment">// 该scan的终止点位置的索引(滤出后5个点)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个scan曲率点有效点序从第5个开始，最后一个激光线结束点序size-5</span></span><br><span class="line">scanStartInd[<span class="number">0</span>] = <span class="number">5</span>;<span class="comment">// 第一条线的起始位置</span></span><br><span class="line">scanEndInd.<span class="built_in">back</span>() = cloudSize - <span class="number">5</span>;  <span class="comment">// 最后一条线的终止位置</span></span><br></pre></td></tr></table></figure><p>【解析】：这里对所有的点云的曲率进行了计算，由于这里使用的方法是某个点云的前后各五点与该点进行作差处理，所以循环的开始就跳过了前后各5个点云的计算。因为是按照线的序列存储，因此接下来能够得到起始和终止的 index。</p><h3 id="4-排除不可考点"><a href="#4-排除不可考点" class="headerlink" title="4.排除不可考点"></a>4.排除不可考点</h3><p>参照论文对与点位筛选的条件：1. 平面/直线与激光近似平行的点不能要； 2. 被遮挡的边缘点不能要</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挑选点，排除容易被斜面挡住的点以及离群点，有些点容易被斜面挡住，而离群点可能出现带有偶然性，这些情况都可能导致前后两次扫描不能被同时看到</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; i++)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/*2. 被遮挡的边缘点不能要*/</span></span><br><span class="line">    <span class="comment">//与后一个点差值，所以减6</span></span><br><span class="line">    <span class="keyword">float</span> diffX = laserCloud-&gt;points[i + <span class="number">1</span>].x - laserCloud-&gt;points[i].x;</span><br><span class="line">    <span class="keyword">float</span> diffY = laserCloud-&gt;points[i + <span class="number">1</span>].y - laserCloud-&gt;points[i].y;</span><br><span class="line">    <span class="keyword">float</span> diffZ = laserCloud-&gt;points[i + <span class="number">1</span>].z - laserCloud-&gt;points[i].z;</span><br><span class="line">    <span class="comment">//计算有效曲率点与后一个点之间的距离平方和</span></span><br><span class="line">    <span class="keyword">float</span> diff = diffX * diffX + diffY * diffY + diffZ * diffZ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0.1</span>)</span><br><span class="line">    &#123; <span class="comment">//前提:两个点之间距离要大于0.1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//点的深度</span></span><br><span class="line">      <span class="keyword">float</span> depth1 = <span class="built_in">sqrt</span>(laserCloud-&gt;points[i].x * laserCloud-&gt;points[i].x +</span><br><span class="line">                          laserCloud-&gt;points[i].y * laserCloud-&gt;points[i].y +</span><br><span class="line">                          laserCloud-&gt;points[i].z * laserCloud-&gt;points[i].z);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//后一个点的深度</span></span><br><span class="line">      <span class="keyword">float</span> depth2 = <span class="built_in">sqrt</span>(laserCloud-&gt;points[i + <span class="number">1</span>].x * laserCloud-&gt;points[i + <span class="number">1</span>].x +</span><br><span class="line">                          laserCloud-&gt;points[i + <span class="number">1</span>].y * laserCloud-&gt;points[i + <span class="number">1</span>].y +</span><br><span class="line">                          laserCloud-&gt;points[i + <span class="number">1</span>].z * laserCloud-&gt;points[i + <span class="number">1</span>].z);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//按照两点的深度的比例，将深度较大的点拉回后计算距离</span></span><br><span class="line">      <span class="keyword">if</span> (depth1 &gt; depth2)</span><br><span class="line">      &#123;</span><br><span class="line">        diffX = laserCloud-&gt;points[i + <span class="number">1</span>].x - laserCloud-&gt;points[i].x * depth2 / depth1;</span><br><span class="line">        diffY = laserCloud-&gt;points[i + <span class="number">1</span>].y - laserCloud-&gt;points[i].y * depth2 / depth1;</span><br><span class="line">        diffZ = laserCloud-&gt;points[i + <span class="number">1</span>].z - laserCloud-&gt;points[i].z * depth2 / depth1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边长比也即是弧度值，若小于0.1，说明夹角比较小，斜面比较陡峭,点深度变化比较剧烈,点处在近似与激光束平行的斜面上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>(diffX * diffX + diffY * diffY + diffZ * diffZ) / depth2 &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123; <span class="comment">//排除容易被斜面挡住的点</span></span><br><span class="line">          <span class="comment">//该点及前面五个点（大致都在斜面上）全部置为筛选过</span></span><br><span class="line">          cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        diffX = laserCloud-&gt;points[i + <span class="number">1</span>].x * depth1 / depth2 - laserCloud-&gt;points[i].x;</span><br><span class="line">        diffY = laserCloud-&gt;points[i + <span class="number">1</span>].y * depth1 / depth2 - laserCloud-&gt;points[i].y;</span><br><span class="line">        diffZ = laserCloud-&gt;points[i + <span class="number">1</span>].z * depth1 / depth2 - laserCloud-&gt;points[i].z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>(diffX * diffX + diffY * diffY + diffZ * diffZ) / depth1 &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">          cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*1. 平面/直线与激光近似平行的点不能要；*/</span></span><br><span class="line">    <span class="keyword">float</span> diffX2 = laserCloud-&gt;points[i].x - laserCloud-&gt;points[i - <span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">float</span> diffY2 = laserCloud-&gt;points[i].y - laserCloud-&gt;points[i - <span class="number">1</span>].y;</span><br><span class="line">    <span class="keyword">float</span> diffZ2 = laserCloud-&gt;points[i].z - laserCloud-&gt;points[i - <span class="number">1</span>].z;</span><br><span class="line">    <span class="comment">//与前一个点的距离平方和</span></span><br><span class="line">    <span class="keyword">float</span> diff2 = diffX2 * diffX2 + diffY2 * diffY2 + diffZ2 * diffZ2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点深度的平方和</span></span><br><span class="line">    <span class="keyword">float</span> dis = laserCloud-&gt;points[i].x * laserCloud-&gt;points[i].x + laserCloud-&gt;points[i].y * laserCloud-&gt;points[i].y + laserCloud-&gt;points[i].z * laserCloud-&gt;points[i].z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与前后点的平方和都大于深度平方和的万分之二，这些点视为离群点，包括陡斜面上的点，强烈凸凹点和空旷区域中的某些点，置为筛选过，弃用</span></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0.0002</span> * dis &amp;&amp; diff2 &gt; <span class="number">0.0002</span> * dis)</span><br><span class="line">    &#123;</span><br><span class="line">      cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>【解析】：遍历所有点（除去前五个和后六个），判断该点及其周边点是否可以作为为特征点位：当某点及其后点间的距离平方大于某阈值$a$（说明这两点有一定距离），且两向量夹角小于某阈值$b$时（夹角小就可能存在遮挡），将其一侧的临近$6$个点设为不可标记为特征点的点；若某点到其前后两点的距离均大于$c$倍的该点深度，则该点判定为不可标记特征点的点（入射角越小，点间距越大，即激光发射方向与投射到的平面越近似水平）。</p><h3 id="5-边缘点-平面点判断与存储"><a href="#5-边缘点-平面点判断与存储" class="headerlink" title="5.边缘点/平面点判断与存储"></a>5.边缘点/平面点判断与存储</h3><p>这部分代码比较长，现把整个代码结构概览一下：</p><ul><li>首先是相关的变量定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个scan曲率点有效点序从第5个开始，最后一个激光线结束点序size-5</span></span><br><span class="line">scanStartInd[<span class="number">0</span>] = <span class="number">5</span>;<span class="comment">// 第一条线的起始位置</span></span><br><span class="line">scanEndInd.<span class="built_in">back</span>() = cloudSize - <span class="number">5</span>;  <span class="comment">// 最后一条线的终止位置</span></span><br><span class="line"><span class="comment">// 用于提取边缘点</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; cornerPointsSharp;     <span class="comment">//曲率特别大的边缘点（sharp）</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; cornerPointsLessSharp; <span class="comment">//曲率大的边缘点（less_sharp）</span></span><br><span class="line"><span class="comment">// 用于提取平面点</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; surfPointsFlat;        <span class="comment">//曲率特别小的平面点（flat）</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; surfPointsLessFlat;    <span class="comment">//曲率特小的平面点（less_flat）</span></span><br></pre></td></tr></table></figure><p>【解析】：至此，我们得到了一组有条理的点云，且把那些与我们想提取的特征不符的点标记了出来，但是为了使得特征点均匀分布在环境中，将一次扫描划分为$4$个独立的子区域，每个子区域最多提供$2$个边缘点和$4$个平面点。我们只需要预先设定好阈值，就可以轻松加随意的将这些点分类了。</p><hr><ul><li>最主要的部分就是下面这个循环：</li></ul><p><img src="/posts/49015.htm/image-20220414184417130.png" alt="image-20220414184417130"></p><p>【解析】：这里作者将每一线划分为等间距的 $6 $段分别处理，每一段的点按照曲率升序排列。<code>cloudSortInd</code>是对曲率排序得到的序列。</p><blockquote><p>为啥分成六等份？</p><p>这里作者将360°分成六等份，每一份去提取相同的特征点。这样做的目的主要是为了使得特征点的分配更加均匀。如果不这么操作，很容易出现某一个视角区域大曲率的点特别多，而某些视角区域却特别少，造成特征点提取的不均匀，大都集中在某个特别窄的视角内，这会使得在求解或优化的时候造成病态。</p></blockquote><ul><li>按曲率从小到大冒泡排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sp + <span class="number">1</span>; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &gt;= sp + <span class="number">1</span>; l--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果后面曲率点大于前面，则交换</span></span><br><span class="line">        <span class="keyword">if</span> (cloudCurvature[cloudSortInd[l]] &lt; cloudCurvature[cloudSortInd[l - <span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cloudSortInd[l - <span class="number">1</span>];</span><br><span class="line">            cloudSortInd[l - <span class="number">1</span>] = cloudSortInd[l];</span><br><span class="line">            cloudSortInd[l] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>挑选边缘特征点：每个分段的曲率很大和比较大的点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//曲率点对应的序号</span></span><br><span class="line"><span class="keyword">int</span> cloudSortInd[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点是否筛选过标志：0-未筛选过，1-筛选过</span></span><br><span class="line"><span class="keyword">int</span> cloudNeighborPicked[<span class="number">40000</span>];</span><br><span class="line"><span class="comment">//点分类标号:2-代表曲率很大，1-代表曲率比较大,-1-代表曲率很小，0-曲率比较小(其中1包含了2,0包含了1,0和1构成了点云全部的点)</span></span><br><span class="line"><span class="keyword">int</span> cloudLabel[<span class="number">40000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//挑选每个分段的曲率很大和比较大的点</span></span><br><span class="line"><span class="keyword">int</span> largestPickedNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = ep; k &gt;= sp; k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = cloudSortInd[k]; <span class="comment">//曲率最大点的点序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果曲率大的点，曲率的确比较大（阈值大于0.1），并且未被筛选过滤掉（cloudNeighborPicked=0）</span></span><br><span class="line">    <span class="keyword">if</span> (cloudNeighborPicked[ind] == <span class="number">0</span> &amp;&amp; cloudCurvature[ind] &gt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largestPickedNum++;</span><br><span class="line">        <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;                      <span class="comment">//挑选曲率最大的前2个点放入sharp点集合</span></span><br><span class="line">            cloudLabel[ind] = <span class="number">2</span>; <span class="comment">// 2代表点曲率很大</span></span><br><span class="line">            cornerPointsSharp.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line">            cornerPointsLessSharp.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">20</span>)</span><br><span class="line">        &#123;                      <span class="comment">//挑选曲率最大的前20个点放入less sharp点集合</span></span><br><span class="line">            cloudLabel[ind] = <span class="number">1</span>; <span class="comment">// 1代表点曲率比较尖锐</span></span><br><span class="line">            cornerPointsLessSharp.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cloudNeighborPicked[ind] = <span class="number">1</span>; <span class="comment">//筛选标志置位</span></span><br><span class="line">        <span class="comment">//将曲率比较大的点的前后各5个连续距离比较近的点筛选出去，防止特征点聚集，使得特征点在每个方向上尽量分布均匀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l - <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l - <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l - <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l + <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l + <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l + <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【解析】：对每个段进行循环迭代，将曲率比较大的（代码中定义阈值为0.1），而且要求该点并且未被筛选过滤掉，经过冒泡排序后，所有的曲率都已经完成排序，我们将前2个曲率最大的存入为“sharp”点集合，将前20曲率最大存入“less_sharp”点集合；为了使得特征点在每个方向上尽量分布均匀，不聚集，将曲率比较大的点的前后各5个连续距离比较近的点筛选出去。</p><ul><li>挑选平面特征点：每个分段的曲率很小比较小的点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挑选每个分段的曲率很小比较小的点</span></span><br><span class="line"><span class="keyword">int</span> smallestPickedNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = cloudSortInd[k];</span><br><span class="line">    <span class="comment">//如果曲率的确比较小，并且未被筛选出</span></span><br><span class="line">    <span class="keyword">if</span> (cloudNeighborPicked[ind] == <span class="number">0</span> &amp;&amp; cloudCurvature[ind] &lt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cloudLabel[ind] = <span class="number">-1</span>; <span class="comment">//-1代表曲率很小的点</span></span><br><span class="line">        surfPointsFlat.<span class="built_in">push_back</span>(laserCloud-&gt;points[ind]);</span><br><span class="line"></span><br><span class="line">        smallestPickedNum++;</span><br><span class="line">        <span class="keyword">if</span> (smallestPickedNum &gt;= <span class="number">4</span>)</span><br><span class="line">        &#123; <span class="comment">//只选最小的四个，剩下的Label==0,就都是曲率比较小的</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cloudNeighborPicked[ind] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">        &#123; <span class="comment">//同样防止特征点聚集</span></span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l - <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l - <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l - <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> diffX = laserCloud-&gt;points[ind + l].x - laserCloud-&gt;points[ind + l + <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">float</span> diffY = laserCloud-&gt;points[ind + l].y - laserCloud-&gt;points[ind + l + <span class="number">1</span>].y;</span><br><span class="line">            <span class="keyword">float</span> diffZ = laserCloud-&gt;points[ind + l].z - laserCloud-&gt;points[ind + l + <span class="number">1</span>].z;</span><br><span class="line">            <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【解析】：这里与边缘特征点的选取大同小异，只不过这里选择了四个平面特征点。</p><ul><li>将剩余的点（包括之前被排除的点）全部归入平面点中less flat类别中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将剩余的点（包括之前被排除的点）全部归入平面点中less flat类别中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        surfPointsLessFlatScan-&gt;<span class="built_in">push_back</span>(laserCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后对每个分段less flat的点进行体素栅格滤波</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于less flat点最多，对每个分段less flat的点进行体素栅格滤波</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt; surfPointsLessFlatScanDS;</span><br><span class="line">pcl::VoxelGrid&lt;PointType&gt; downSizeFilter;</span><br><span class="line">downSizeFilter.<span class="built_in">setInputCloud</span>(surfPointsLessFlatScan);</span><br><span class="line">downSizeFilter.<span class="built_in">setLeafSize</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);</span><br><span class="line">downSizeFilter.<span class="built_in">filter</span>(surfPointsLessFlatScanDS);</span><br><span class="line"><span class="comment">// less flat点汇总</span></span><br><span class="line">surfPointsLessFlat += surfPointsLessFlatScanDS;</span><br></pre></td></tr></table></figure><p>收尾部分：最后作者用 4 个 pcl::Point XYZ 类型的数组来存储 IMU 的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">laserCloudHandler</span><span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">  <span class="comment">// publish消除非匀速运动畸变后的所有的点</span></span><br><span class="line">  sensor_msgs::PointCloud2 laserCloudOutMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(*laserCloud, laserCloudOutMsg);</span><br><span class="line">  laserCloudOutMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  laserCloudOutMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubLaserCloud.<span class="built_in">publish</span>(laserCloudOutMsg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// publish消除非匀速运动畸变后的平面点和边沿点</span></span><br><span class="line">  sensor_msgs::PointCloud2 cornerPointsSharpMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(cornerPointsSharp, cornerPointsSharpMsg);</span><br><span class="line">  cornerPointsSharpMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  cornerPointsSharpMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubCornerPointsSharp.<span class="built_in">publish</span>(cornerPointsSharpMsg);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 cornerPointsLessSharpMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(cornerPointsLessSharp, cornerPointsLessSharpMsg);</span><br><span class="line">  cornerPointsLessSharpMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  cornerPointsLessSharpMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubCornerPointsLessSharp.<span class="built_in">publish</span>(cornerPointsLessSharpMsg);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 surfPointsFlat2;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(surfPointsFlat, surfPointsFlat2);</span><br><span class="line">  surfPointsFlat2.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  surfPointsFlat2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubSurfPointsFlat.<span class="built_in">publish</span>(surfPointsFlat2);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 surfPointsLessFlat2;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(surfPointsLessFlat, surfPointsLessFlat2);</span><br><span class="line">  surfPointsLessFlat2.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  surfPointsLessFlat2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubSurfPointsLessFlat.<span class="built_in">publish</span>(surfPointsLessFlat2);</span><br><span class="line">    <span class="comment">// publich IMU消息,由于循环到了最后，因此是Cur都是代表最后一个点，即最后一个点的欧拉角，畸变位移及一个点云周期增加的速度</span></span><br><span class="line">  <span class="function">pcl::PointCloud&lt;pcl::PointXYZ&gt; <span class="title">imuTrans</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//起始点欧拉角</span></span><br><span class="line">  imuTrans.points[<span class="number">0</span>].x = imuPitchStart;</span><br><span class="line">  imuTrans.points[<span class="number">0</span>].y = imuYawStart;</span><br><span class="line">  imuTrans.points[<span class="number">0</span>].z = imuRollStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最后一个点的欧拉角</span></span><br><span class="line">  imuTrans.points[<span class="number">1</span>].x = imuPitchCur;</span><br><span class="line">  imuTrans.points[<span class="number">1</span>].y = imuYawCur;</span><br><span class="line">  imuTrans.points[<span class="number">1</span>].z = imuRollCur;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最后一个点相对于第一个点的畸变位移和速度</span></span><br><span class="line">  imuTrans.points[<span class="number">2</span>].x = imuShiftFromStartXCur;</span><br><span class="line">  imuTrans.points[<span class="number">2</span>].y = imuShiftFromStartYCur;</span><br><span class="line">  imuTrans.points[<span class="number">2</span>].z = imuShiftFromStartZCur;</span><br><span class="line"></span><br><span class="line">  imuTrans.points[<span class="number">3</span>].x = imuVeloFromStartXCur;</span><br><span class="line">  imuTrans.points[<span class="number">3</span>].y = imuVeloFromStartYCur;</span><br><span class="line">  imuTrans.points[<span class="number">3</span>].z = imuVeloFromStartZCur;</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 imuTransMsg;</span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(imuTrans, imuTransMsg);</span><br><span class="line">  imuTransMsg.header.stamp = laserCloudMsg-&gt;header.stamp;</span><br><span class="line">  imuTransMsg.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">  pubImuTrans.<span class="built_in">publish</span>(imuTransMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ⅲ-laserOdometry"><a href="#Ⅲ-laserOdometry" class="headerlink" title="Ⅲ.laserOdometry"></a>Ⅲ.laserOdometry</h1><p><img src="/posts/49015.htm/image-20220415103708452.png" alt="image-20220415103708452"></p><p>这部分是里程计部分，对应的是论文中的特征匹配问题，通过对论文的阅读，我们知道特征匹配主要是将$t$时刻的点云和$t+1$时刻的点云联系起来（如果有<code>IMU</code>或者里程计可以先进行一个初步的变换，作为初始信息用于匹配）;</p><p>我们知道$t$时刻讲过校正的点云为$\overline{P}_k$，将该集合中的边缘点生成的线和$t+1$时刻提取的边缘点对应起来，我们需要找到一个$t$时刻到$t+1$时刻的最优位姿$T$，使得损失最小，对应的就是求点到直线的最短距离，在论文中我们已经通过求偏导的方式把雅可比矩阵做了详细的推导，把它应用在代码中即可。（对于平面点特征，同样的考虑点到面的距离。）详细推导查看：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3">LOAM-SLAM深度剖析-Ⅳ.特征点匹配-C.雅可比矩阵求解</a></p><p>在看代码中的函数之前，首先熟悉定义的变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到的sharp点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">cornerPointsSharp</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的less_sharp点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">cornerPointsLessSharp</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的flat点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">surfPointsFlat</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的less_flat点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">surfPointsLessFlat</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一帧所有边缘点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudCornerLast</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//上一帧所有平面点云</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudSurfLast</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存前一个节点发过来的未经处理过的特征点</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudOri</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">coeffSel</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的所有的点云数据</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudFullRes</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//接收到的IMU信息</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">imuTrans</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;())</span></span>;</span><br><span class="line"><span class="comment">//使用上一帧的 less_sharp 点云构造kd-tree</span></span><br><span class="line">pcl::KdTreeFLANN&lt;PointType&gt;::<span class="function">Ptr <span class="title">kdtreeCornerLast</span><span class="params">(<span class="keyword">new</span> pcl::KdTreeFLANN&lt;PointType&gt;())</span></span>;</span><br><span class="line"><span class="comment">//使用上一帧的 less_flat 点云构造kd-tree</span></span><br><span class="line">pcl::KdTreeFLANN&lt;PointType&gt;::<span class="function">Ptr <span class="title">kdtreeSurfLast</span><span class="params">(<span class="keyword">new</span> pcl::KdTreeFLANN&lt;PointType&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> laserCloudCornerLastNum;</span><br><span class="line"><span class="keyword">int</span> laserCloudSurfLastNum;</span><br></pre></td></tr></table></figure><h2 id="A-main"><a href="#A-main" class="headerlink" title="A.main"></a>A.main</h2><p><img src="/posts/49015.htm/image-20220416145103548.png" alt="image-20220416145103548"></p><p>这里的main函数足足600多行代码……，人都傻了，，，</p><p>开始定义了ROS节点和订阅的消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;laserOdometry&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Subscriber subCornerPointsSharp = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_sharp&quot;</span>, <span class="number">2</span>, laserCloudSharpHandler);</span><br><span class="line">  ros::Subscriber subCornerPointsLessSharp = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_less_sharp&quot;</span>, <span class="number">2</span>, laserCloudLessSharpHandler);</span><br><span class="line">  ros::Subscriber subSurfPointsFlat = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_flat&quot;</span>, <span class="number">2</span>, laserCloudFlatHandler);</span><br><span class="line">  ros::Subscriber subSurfPointsLessFlat = nh.subscribe&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/laser_cloud_less_flat&quot;</span>, <span class="number">2</span>, laserCloudLessFlatHandler);</span><br><span class="line">  ros::Subscriber subLaserCloudFullRes = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/velodyne_cloud_2&quot;</span>, <span class="number">2</span>, laserCloudFullResHandler);</span><br><span class="line">  ros::Subscriber subImuTrans = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/imu_trans&quot;</span>, <span class="number">5</span>, imuTransHandler);</span><br><span class="line">  ros::Publisher pubLaserCloudCornerLast = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/laser_cloud_corner_last&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  ros::Publisher pubLaserCloudSurfLast = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/laser_cloud_surf_last&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  ros::Publisher pubLaserCloudFullRes = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">&quot;/velodyne_cloud_3&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  ros::Publisher pubLaserOdometry = nh.advertise&lt;nav_msgs::Odometry&gt; (<span class="string">&quot;/laser_odom_to_init&quot;</span>, <span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  nav_msgs::Odometry laserOdometry;</span><br><span class="line">  laserOdometry.header.frame_id = <span class="string">&quot;camera_init&quot;</span>;</span><br><span class="line">  laserOdometry.child_frame_id = <span class="string">&quot;/laser_odom&quot;</span>;</span><br><span class="line"></span><br><span class="line">  tf::TransformBroadcaster tfBroadcaster;</span><br><span class="line">  tf::StampedTransform laserOdometryTrans;</span><br><span class="line">  laserOdometryTrans.frame_id_ = <span class="string">&quot;camera_init&quot;</span>;</span><br><span class="line">  laserOdometryTrans.child_frame_id_ = <span class="string">&quot;/laser_odom&quot;</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; pointSearchInd;<span class="comment">//搜索到的点序</span></span><br><span class="line">  std::vector&lt;<span class="keyword">float</span>&gt; pointSearchSqDis;<span class="comment">//搜索到的点平方距离</span></span><br><span class="line"></span><br><span class="line">  PointType pointOri, pointSel<span class="comment">/*选中的特征点*/</span>, tripod1, tripod2, tripod3<span class="comment">/*特征点的对应点*/</span>, pointProj<span class="comment">/*unused*/</span>, coeff;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//退化标志</span></span><br><span class="line">  <span class="keyword">bool</span> isDegenerate = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//P矩阵，预测矩阵</span></span><br><span class="line">  <span class="function">cv::Mat <span class="title">matP</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> frameCount = skipFrameNum;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> status = ros::<span class="built_in">ok</span>();</span><br><span class="line">  <span class="keyword">while</span> (status) &#123;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newCornerPointsSharp &amp;&amp; newCornerPointsLessSharp &amp;&amp; newSurfPointsFlat &amp;&amp; </span><br><span class="line">        newSurfPointsLessFlat &amp;&amp; newLaserCloudFullRes &amp;&amp; newImuTrans &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeCornerPointsSharp - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeCornerPointsLessSharp - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeSurfPointsFlat - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeLaserCloudFullRes - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">fabs</span>(timeImuTrans - timeSurfPointsLessFlat) &lt; <span class="number">0.005</span>) &#123;  <span class="comment">//同步作用，确保同时收到同一个点云的特征点以及IMU信息才进入</span></span><br><span class="line">      newCornerPointsSharp = <span class="literal">false</span>;</span><br><span class="line">      newCornerPointsLessSharp = <span class="literal">false</span>;</span><br><span class="line">      newSurfPointsFlat = <span class="literal">false</span>;</span><br><span class="line">      newSurfPointsLessFlat = <span class="literal">false</span>;</span><br><span class="line">      newLaserCloudFullRes = <span class="literal">false</span>;</span><br><span class="line">      newImuTrans = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/***** 一、初始化 *****/</span></span><br><span class="line">      <span class="comment">/***** 二、点云匹配与运动估计 *****/</span></span><br><span class="line">      <span class="comment">/***** 三、坐标转换 *****/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment">* 1、初始化   * </span></span><br><span class="line"><span class="comment">*************/</span></span><br><span class="line"><span class="comment">//将第一个点云数据集发送给laserMapping,从下一个点云数据开始处理</span></span><br><span class="line"><span class="keyword">if</span> (!systemInited) &#123;</span><br><span class="line">    <span class="comment">// 将cornerPointsLessSharp（接收到的less_sharp点云）与laserCloudCornerLast（上一帧所有边缘点云）交换,</span></span><br><span class="line">    <span class="comment">// 目的保存cornerPointsLessSharp（接收到的less_sharp点云）的值下轮使用</span></span><br><span class="line">    pcl::PointCloud&lt;PointType&gt;::Ptr laserCloudTemp = cornerPointsLessSharp;</span><br><span class="line">    cornerPointsLessSharp = laserCloudCornerLast;</span><br><span class="line">    laserCloudCornerLast = laserCloudTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将surfPointLessFlat（接收到的less_flat点云）与laserCloudSurfLast（上一帧所有平面点云）交换，</span></span><br><span class="line">    <span class="comment">// 目的保存surfPointsLessFlat（接收到的less_flat点云）的值下轮使用</span></span><br><span class="line">    laserCloudTemp = surfPointsLessFlat;</span><br><span class="line">    surfPointsLessFlat = laserCloudSurfLast;</span><br><span class="line">    laserCloudSurfLast = laserCloudTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上一帧的特征点构建kd-tree</span></span><br><span class="line">    kdtreeCornerLast-&gt;<span class="built_in">setInputCloud</span>(laserCloudCornerLast);<span class="comment">//所有的边沿点集合</span></span><br><span class="line">    kdtreeSurfLast-&gt;<span class="built_in">setInputCloud</span>(laserCloudSurfLast);<span class="comment">//所有的平面点集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将cornerPointsLessSharp（上一帧所有边缘点云）发送给laserMapping</span></span><br><span class="line">    sensor_msgs::PointCloud2 laserCloudCornerLast2;</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*laserCloudCornerLast, laserCloudCornerLast2);</span><br><span class="line">    laserCloudCornerLast2.header.stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">    laserCloudCornerLast2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">    pubLaserCloudCornerLast.<span class="built_in">publish</span>(laserCloudCornerLast2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将surfPointLessFlat（上一帧所有平面点云）发送给laserMapping</span></span><br><span class="line">    sensor_msgs::PointCloud2 laserCloudSurfLast2;</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*laserCloudSurfLast, laserCloudSurfLast2);</span><br><span class="line">    laserCloudSurfLast2.header.stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">    laserCloudSurfLast2.header.frame_id = <span class="string">&quot;/camera&quot;</span>;</span><br><span class="line">    pubLaserCloudSurfLast.<span class="built_in">publish</span>(laserCloudSurfLast2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记住原点的翻滚角和俯仰角</span></span><br><span class="line">    transformSum[<span class="number">0</span>] += imuPitchStart;</span><br><span class="line">    transformSum[<span class="number">2</span>] += imuRollStart;</span><br><span class="line"></span><br><span class="line">    systemInited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T平移量的初值赋值为加减速的位移量，为其梯度下降的方向（沿用上次转换的T（一个sweep匀速模型），同时在其基础上减去匀速运动位移，即只考虑加减速的位移量）</span></span><br><span class="line">transform[<span class="number">3</span>] -= imuVeloFromStartX * scanPeriod;</span><br><span class="line">transform[<span class="number">4</span>] -= imuVeloFromStartY * scanPeriod;</span><br><span class="line">transform[<span class="number">5</span>] -= imuVeloFromStartZ * scanPeriod;</span><br></pre></td></tr></table></figure><p>【解析】：这部分主要做了两件事，①将订阅的数据保存为上一时刻的数据。作者做了两次数据交换：将<code>cornerPointsLessSharp</code>（接收到的<code>less_sharp</code>点云）与<code>laserCloudCornerLast</code>（上一帧所有边缘点云）交换，将<code>surfPointLessFlat</code>（接收到的<code>less_flat</code>点云）与<code>laserCloudSurfLast</code>（上一帧所有平面点云）交换，目的就是将接收的数据保存为上一时刻的数据，并将上一时刻的数据构建<code>kd-tree</code>，供下轮使用。</p><p>②将上一时刻的数据发布出去。将<code>cornerPointsLessSharp</code>（上一帧所有边缘点云）和<code>surfPointLessFlat</code>（上一帧所有平面点云）也即边沿点和平面点分别发送给<code>laserMapping</code>。</p><h3 id="2-帧间匹配与运动估计"><a href="#2-帧间匹配与运动估计" class="headerlink" title="2.帧间匹配与运动估计"></a>2.帧间匹配与运动估计</h3><p>这部分代码人给我看麻了，通过对代码的折叠和前人的知道，我们可以清晰的看到这部分主要干了什么，先看一下整体的结构。</p><p><img src="/posts/49015.htm/image-20220415151916947.png" alt="image-20220415151916947"></p><p>【解析】：这部分首先进行了一个总的判断，在进行初始化之后，首先要求上一时刻的点的个数必须达到边缘点大于10、平面特征点大于100的要求，才能进行之后的点云匹配以及运动估计。</p><p>然后做了一步操作<code>removeNaNFromPointCloud</code>，它的主要作用是<strong>去除无效点</strong>，参数分别是（输入点云，输出点云，对应保留的索引），所以这里将含有<code>NaN</code>的（无效的）边缘点云去除了，并统计了边缘点和平面点的个数。</p><p>做好上面的初始工作之后，就开始进行迭代优化了，这部分使用的是非线性最小二乘法中的列文伯格（<code>LM</code>）算法，做了25次迭代。当然优化并不是这么简单的事情，所以红色框里的内容就是重点了，它们是优化必不可少的步骤，下面依次介绍每一部分的对应的论文内容。</p><h4 id="①点线匹配与雅可比求解"><a href="#①点线匹配与雅可比求解" class="headerlink" title="①点线匹配与雅可比求解"></a>①点线匹配与雅可比求解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">laserCloudOri-&gt;<span class="built_in">clear</span>();</span><br><span class="line">coeffSel-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前点云中的曲率最大的特征点,从上个点云中曲率比较大的特征点中找两个最近距离点，一个点使用kd-tree查找，另一个根据找到的点在其相邻线找另外一个最近距离的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cornerPointsSharpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TransformToStart</span>(&amp;cornerPointsSharp-&gt;points[i], &amp;pointSel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每迭代五次，重新查找最近点</span></span><br><span class="line">    <span class="keyword">if</span> (iterCount % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">        pcl::<span class="built_in">removeNaNFromPointCloud</span>(*laserCloudCornerLast, *laserCloudCornerLast, indices);</span><br><span class="line">        <span class="comment">// kd-tree查找一个最近距离点，边沿点未经过体素栅格滤波，一般边沿点本来就比较少，不做滤波</span></span><br><span class="line">        kdtreeCornerLast-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">1</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line">        <span class="keyword">int</span> closestPointInd = <span class="number">-1</span>, minPointInd2 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找相邻线距离目标点距离最小的点</span></span><br><span class="line">        <span class="comment">//再次提醒：velodyne是2度一线，scanID相邻并不代表线号相邻，相邻线度数相差2度，也即线号scanID相差2</span></span><br><span class="line">        <span class="keyword">if</span> (pointSearchSqDis[<span class="number">0</span>] &lt; <span class="number">25</span>)</span><br><span class="line">        &#123; <span class="comment">//找到的最近点距离的确很近的话</span></span><br><span class="line">            closestPointInd = pointSearchInd[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//提取最近点线号</span></span><br><span class="line">            <span class="keyword">int</span> closestPointScan = <span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[closestPointInd].intensity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> pointSqDis, minPointSqDis2 = <span class="number">25</span>; <span class="comment">//初始门槛值5米，可大致过滤掉scanID相邻，但实际线不相邻的值</span></span><br><span class="line">            <span class="comment">//寻找距离目标点最近距离的平方和最小的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd + <span class="number">1</span>; j &lt; cornerPointsSharpNum; j++)</span><br><span class="line">            &#123; <span class="comment">//向scanID增大的方向查找</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &gt; closestPointScan + <span class="number">2.5</span>)</span><br><span class="line">                &#123; <span class="comment">//非相邻线</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudCornerLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &gt; closestPointScan)</span><br><span class="line">                &#123; <span class="comment">//确保两个点不在同一条scan上（相邻线查找应该可以用scanID == closestPointScan +/- 1 来做）</span></span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123; <span class="comment">//距离更近，要小于初始值5米</span></span><br><span class="line">                        <span class="comment">//更新最小距离与点序</span></span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123; <span class="comment">//向scanID减小的方向查找</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &lt; closestPointScan - <span class="number">2.5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudCornerLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudCornerLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudCornerLast-&gt;points[j].intensity) &lt; closestPointScan)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记住组成线的点序</span></span><br><span class="line">        pointSearchCornerInd1[i] = closestPointInd; <span class="comment">// kd-tree最近距离点，-1表示未找到满足的点</span></span><br><span class="line">        pointSearchCornerInd2[i] = minPointInd2;    <span class="comment">//另一个最近的，-1表示未找到满足的点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSearchCornerInd2[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//大于等于0，不等于-1，说明两个点都找到了</span></span><br><span class="line">        tripod1 = laserCloudCornerLast-&gt;points[pointSearchCornerInd1[i]];</span><br><span class="line">        tripod2 = laserCloudCornerLast-&gt;points[pointSearchCornerInd2[i]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择的特征点记为O，kd-tree最近距离点记为A，另一个最近距离点记为B</span></span><br><span class="line">        <span class="keyword">float</span> x0 = pointSel.x;</span><br><span class="line">        <span class="keyword">float</span> y0 = pointSel.y;</span><br><span class="line">        <span class="keyword">float</span> z0 = pointSel.z;</span><br><span class="line">        <span class="keyword">float</span> x1 = tripod1.x;</span><br><span class="line">        <span class="keyword">float</span> y1 = tripod1.y;</span><br><span class="line">        <span class="keyword">float</span> z1 = tripod1.z;</span><br><span class="line">        <span class="keyword">float</span> x2 = tripod2.x;</span><br><span class="line">        <span class="keyword">float</span> y2 = tripod2.y;</span><br><span class="line">        <span class="keyword">float</span> z2 = tripod2.z;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量OA = (x0 - x1, y0 - y1, z0 - z1), 向量OB = (x0 - x2, y0 - y2, z0 - z2)，向量AB = （x1 - x2, y1 - y2, z1 - z2）</span></span><br><span class="line">        <span class="comment">//向量OA OB的向量积(即叉乘)为：</span></span><br><span class="line">        <span class="comment">//|  i      j      k  |</span></span><br><span class="line">        <span class="comment">//|x0-x1  y0-y1  z0-z1|</span></span><br><span class="line">        <span class="comment">//|x0-x2  y0-y2  z0-z2|</span></span><br><span class="line">        <span class="comment">//模为：</span></span><br><span class="line">        <span class="keyword">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) + ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) + ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1)) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个最近距离点之间的距离，即向量AB的模</span></span><br><span class="line">        <span class="keyword">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AB方向的单位向量与OAB平面的单位法向量的向量积在各轴上的分量（d的方向）</span></span><br><span class="line">        <span class="comment">// x轴分量i</span></span><br><span class="line">        <span class="keyword">float</span> la = ((y1 - y2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) + (z1 - z2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1))) / a012 / l12;</span><br><span class="line">        <span class="comment">// y轴分量j</span></span><br><span class="line">        <span class="keyword">float</span> lb = -((x1 - x2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) - (z1 - z2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br><span class="line">        <span class="comment">// z轴分量k</span></span><br><span class="line">        <span class="keyword">float</span> lc = -((x1 - x2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) + (y1 - y2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点到线的距离，d = |向量OA 叉乘 向量OB|/|AB|</span></span><br><span class="line">        <span class="keyword">float</span> ld2 = a012 / l12;</span><br><span class="line">        <span class="comment">//权重计算，距离越大权重越小，距离越小权重越大，得到的权重范围&lt;=1</span></span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iterCount &gt;= <span class="number">5</span>)</span><br><span class="line">        &#123; <span class="comment">// 5次迭代之后开始增加权重因素</span></span><br><span class="line">            s = <span class="number">1</span> - <span class="number">1.8</span> * <span class="built_in">fabs</span>(ld2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑权重</span></span><br><span class="line">        coeff.x = s * la;</span><br><span class="line">        coeff.y = s * lb;</span><br><span class="line">        coeff.z = s * lc;</span><br><span class="line">        coeff.intensity = s * ld2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0.1</span> &amp;&amp; ld2 != <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">//只保留权重大的，也即距离比较小的点，同时也舍弃距离为零的</span></span><br><span class="line">            laserCloudOri-&gt;<span class="built_in">push_back</span>(cornerPointsSharp-&gt;points[i]);</span><br><span class="line">            coeffSel-&gt;<span class="built_in">push_back</span>(coeff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【 <span style="color:red;">点线匹配</span> 解析】：这部分主要任务是进行点和线的匹配，通过论文的解析我们知道，我们的特征匹配做的就是对$\overline{P}_k$中的线与$k+1$时刻投影到$k$时刻的点$i,i\in\tilde\xi_{k+1}$之间的匹配。这里对论文中的内容做一个简单的回顾：</p><p>详细查看：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E7%82%B9%E5%92%8C%E5%AF%B9%E5%BA%94%E7%89%B9%E5%BE%81%E5%8C%BA%E5%9F%9F%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97">C.点和对应特征区域距离的计算</a><br>论文中提到，边线是由两个点构成的，即$j,l$且$j,l\in \overline{P}_k$，其中$j$是$i$在$\overline{P}_k$中的最近邻，$l$是$i$在连续两次扫描$j$时的最近邻，$(j, l)$构成$i$的对应关系。所以关键就是这两个点要怎么找，只有找到这两个点之后才能得到一条线，进而才能做点线匹配。由于我们的$j,l$所在的ScanID可能比$i$的大，也可能比$i$的小，因此，代码中是往两头找。</p><p>代码中，通过处理上一帧中曲率最大的特征点，从该特征点中找到两个最近距离的点$j$，一个点使用kd-tree查找，然后根据找到的点在其相邻线找另外一个最近距离的点$l$。并且由于迭代过程中最近的点的匹配是随着 transform 的更新逐渐变化的，因此作者采用了 5 次迭代（计算量的一种平衡吧，每次更新 transform 后都更新一次最近匹配计算资源消耗大？）后再计算一次对应的最近点。这样下次通过更新的最近点匹配对来完成新的计算。</p><p>找到两个点之后定义$i$坐标$O(x_0 , y_0, z_0 )$，$j$的坐标$A(x_1 , y_1, z_1 )$，$l$的坐标$B(x_2 , y_2, z_2)$，由论文可知：</p><script type="math/tex; mode=display">d_\xi=\frac{|\overrightarrow{OA}×\overrightarrow {OB}|}{|\overrightarrow{AB}|}=a012 / l12;</script><p>【 <span style="color:red;">雅可比求解</span> 解析】：</p><p><img src="/posts/49015.htm/image-20220415214835849.png" alt="image-20220415214835849"></p><p>对应代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AB方向的单位向量与OAB平面的单位法向量的向量积在各轴上的分量（d的方向）</span></span><br><span class="line"><span class="comment">// x轴分量i</span></span><br><span class="line"><span class="keyword">float</span> la = ((y1 - y2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) + (z1 - z2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1))) / a012 / l12;</span><br><span class="line"><span class="comment">// y轴分量j</span></span><br><span class="line"><span class="keyword">float</span> lb = -((x1 - x2) * ((x0 - x1) * (y0 - y2) - (x0 - x2) * (y0 - y1)) - (z1 - z2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br><span class="line"><span class="comment">// z轴分量k</span></span><br><span class="line"><span class="keyword">float</span> lc = -((x1 - x2) * ((x0 - x1) * (z0 - z2) - (x0 - x2) * (z0 - z1)) + (y1 - y2) * ((y0 - y1) * (z0 - z2) - (y0 - y2) * (z0 - z1))) / a012 / l12;</span><br></pre></td></tr></table></figure><p>求得梯度方向向量：</p><script type="math/tex; mode=display">\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\mathcal{H},b_\mathcal{H},c_\mathcal{H}]^T=[la,lb,lc]^T</script><h4 id="②点面匹配与雅可比求解"><a href="#②点面匹配与雅可比求解" class="headerlink" title="②点面匹配与雅可比求解"></a>②点面匹配与雅可比求解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对本次接收到的曲率最小的点,从上次接收到的点云曲率比较小的点中找三点组成平面，一个使用kd-tree查找，另外一个在同一线上查找满足要求的，第三个在不同线上查找满足要求的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; surfPointsFlatNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TransformToStart</span>(&amp;surfPointsFlat-&gt;points[i], &amp;pointSel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iterCount % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// kd-tree最近点查找，在经过体素栅格滤波之后的平面点中查找，一般平面点太多，滤波后最近点查找数据量小</span></span><br><span class="line">        kdtreeSurfLast-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">1</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line">        <span class="keyword">int</span> closestPointInd = <span class="number">-1</span>, minPointInd2 = <span class="number">-1</span>, minPointInd3 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pointSearchSqDis[<span class="number">0</span>] &lt; <span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            closestPointInd = pointSearchInd[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> closestPointScan = <span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[closestPointInd].intensity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> pointSqDis, minPointSqDis2 = <span class="number">25</span>, minPointSqDis3 = <span class="number">25</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd + <span class="number">1</span>; j &lt; surfPointsFlatNum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &gt; closestPointScan + <span class="number">2.5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudSurfLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &lt;= closestPointScan)</span><br><span class="line">                &#123; <span class="comment">//如果点的线号小于等于最近点的线号(应该最多取等，也即同一线上的点)</span></span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123; <span class="comment">//如果点处在大于该线上</span></span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis3)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis3 = pointSqDis;</span><br><span class="line">                        minPointInd3 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = closestPointInd - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &lt; closestPointScan - <span class="number">2.5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointSqDis = (laserCloudSurfLast-&gt;points[j].x - pointSel.x) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].x - pointSel.x) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].y - pointSel.y) +</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z) *</span><br><span class="line">                    (laserCloudSurfLast-&gt;points[j].z - pointSel.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in"><span class="keyword">int</span></span>(laserCloudSurfLast-&gt;points[j].intensity) &gt;= closestPointScan)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis2 = pointSqDis;</span><br><span class="line">                        minPointInd2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis3)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minPointSqDis3 = pointSqDis;</span><br><span class="line">                        minPointInd3 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pointSearchSurfInd1[i] = closestPointInd; <span class="comment">// kd-tree最近距离点,-1表示未找到满足要求的点</span></span><br><span class="line">        pointSearchSurfInd2[i] = minPointInd2;    <span class="comment">//同一线号上的距离最近的点，-1表示未找到满足要求的点</span></span><br><span class="line">        pointSearchSurfInd3[i] = minPointInd3;    <span class="comment">//不同线号上的距离最近的点，-1表示未找到满足要求的点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSurfInd2[i] &gt;= <span class="number">0</span> &amp;&amp; pointSearchSurfInd3[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;                                                               <span class="comment">//找到了三个点</span></span><br><span class="line">        tripod1 = laserCloudSurfLast-&gt;points[pointSearchSurfInd1[i]]; <span class="comment">// A点</span></span><br><span class="line">        tripod2 = laserCloudSurfLast-&gt;points[pointSearchSurfInd2[i]]; <span class="comment">// B点</span></span><br><span class="line">        tripod3 = laserCloudSurfLast-&gt;points[pointSearchSurfInd3[i]]; <span class="comment">// C点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量AB = (tripod2.x - tripod1.x, tripod2.y - tripod1.y, tripod2.z - tripod1.z)</span></span><br><span class="line">        <span class="comment">//向量AC = (tripod3.x - tripod1.x, tripod3.y - tripod1.y, tripod3.z - tripod1.z)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量AB AC的向量积（即叉乘），得到的是法向量</span></span><br><span class="line">        <span class="comment">// x轴方向分向量i</span></span><br><span class="line">        <span class="keyword">float</span> pa = (tripod2.y - tripod1.y) * (tripod3.z - tripod1.z) - (tripod3.y - tripod1.y) * (tripod2.z - tripod1.z);</span><br><span class="line">        <span class="comment">// y轴方向分向量j</span></span><br><span class="line">        <span class="keyword">float</span> pb = (tripod2.z - tripod1.z) * (tripod3.x - tripod1.x) - (tripod3.z - tripod1.z) * (tripod2.x - tripod1.x);</span><br><span class="line">        <span class="comment">// z轴方向分向量k</span></span><br><span class="line">        <span class="keyword">float</span> pc = (tripod2.x - tripod1.x) * (tripod3.y - tripod1.y) - (tripod3.x - tripod1.x) * (tripod2.y - tripod1.y);</span><br><span class="line">        <span class="keyword">float</span> pd = -(pa * tripod1.x + pb * tripod1.y + pc * tripod1.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//法向量的模</span></span><br><span class="line">        <span class="keyword">float</span> ps = <span class="built_in">sqrt</span>(pa * pa + pb * pb + pc * pc);</span><br><span class="line">        <span class="comment">// pa pb pc为法向量各方向上的单位向量</span></span><br><span class="line">        pa /= ps;</span><br><span class="line">        pb /= ps;</span><br><span class="line">        pc /= ps;</span><br><span class="line">        pd /= ps;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点到面的距离：向量OA与与法向量的点积除以法向量的模</span></span><br><span class="line">        <span class="keyword">float</span> pd2 = pa * pointSel.x + pb * pointSel.y + pc * pointSel.z + pd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同理计算权重</span></span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iterCount &gt;= <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="number">1</span> - <span class="number">1.8</span> * <span class="built_in">fabs</span>(pd2) / <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(pointSel.x * pointSel.x + pointSel.y * pointSel.y + pointSel.z * pointSel.z));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑权重</span></span><br><span class="line">        coeff.x = s * pa;</span><br><span class="line">        coeff.y = s * pb;</span><br><span class="line">        coeff.z = s * pc;</span><br><span class="line">        coeff.intensity = s * pd2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0.1</span> &amp;&amp; pd2 != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//保存原始点与相应的系数</span></span><br><span class="line">            laserCloudOri-&gt;<span class="built_in">push_back</span>(surfPointsFlat-&gt;points[i]);</span><br><span class="line">            coeffSel-&gt;<span class="built_in">push_back</span>(coeff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【 <span style="color:red;">点面匹配</span> 解析】：点面匹配与点线匹配如出一辙，通过论文的解析我们知道，我们的特征匹配做的就是对$\overline{\mathcal{P} }_k$中的面与$k+1$时刻投影到$k$时刻的点$i,i\in\tilde{\mathcal{H} }_{k+1}$之间的匹配。这里对论文中的内容做一个简单的回顾：</p><p>在$\overline{\mathcal{P} }_k$中找到$ i $的最近邻，记为$j$。 然后，我们找到另外两个点 $l$ 和$ m$，作为$ i $的最近邻，一个在$j $的同一扫描中，另一个在 $j $的两次连续扫描中，其中 $j,l,m\in \overline{\mathcal{P} }_k$。所以关键就是这三个点要怎么找，只有找到这三个点之后才能确定一个面，进而才能做点面匹配。</p><p>同样参考点线匹配，这段代码也是首先通过kd-tree最近点查找，找到点$j $，然后在选择同一线号上的距离最近的点$l$ 以及不同线号上的距离最近的点$ m$。</p><p>找到三个点之后，求解点到面的距离。这里的公式就不赘述了。上图：</p><p><img src="/posts/49015.htm/image-20220415200837885.png" alt="image-20220415200837885"></p><p>所以：</p><script type="math/tex; mode=display">\begin{align*}d_\mathcal{H}&=\frac{\begin{vmatrix}(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})·((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)}))\end{vmatrix}}{\begin{vmatrix}(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)})\end{vmatrix} }\\&=\frac{|\overrightarrow{OA}·(\overrightarrow{AB}×\overrightarrow{AC})|}{|\overrightarrow{AB}×\overrightarrow{AC}|}\end{align*}</script><p>【 <span style="color:red;">雅可比求解</span> 解析】：</p><p><img src="/posts/49015.htm/image-20220416090513137.png" alt="image-20220416090513137"></p><p>这里由于距离通过体积除以面积计算，而体积的梯度方向就是地面对应的法向量，所以面特征的梯度方向就是平面的法向量方向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向量AB AC的向量积（即叉乘），得到的是法向量</span></span><br><span class="line"><span class="comment">// x轴方向分向量i</span></span><br><span class="line"><span class="keyword">float</span> pa = (tripod2.y - tripod1.y) * (tripod3.z - tripod1.z) - (tripod3.y - tripod1.y) * (tripod2.z - tripod1.z);</span><br><span class="line"><span class="comment">// y轴方向分向量j</span></span><br><span class="line"><span class="keyword">float</span> pb = (tripod2.z - tripod1.z) * (tripod3.x - tripod1.x) - (tripod3.z - tripod1.z) * (tripod2.x - tripod1.x);</span><br><span class="line"><span class="comment">// z轴方向分向量k</span></span><br><span class="line"><span class="keyword">float</span> pc = (tripod2.x - tripod1.x) * (tripod3.y - tripod1.y) - (tripod3.x - tripod1.x) * (tripod2.y - tripod1.y);</span><br><span class="line"><span class="keyword">float</span> pd = -(pa * tripod1.x + pb * tripod1.y + pc * tripod1.z);</span><br></pre></td></tr></table></figure><h4 id="③L-M运动估计求解"><a href="#③L-M运动估计求解" class="headerlink" title="③L-M运动估计求解"></a>③L-M运动估计求解</h4><p>假设：雷达的运动是连续的。将所有<strong>对应到的点求到直线的距离到面的距离之和最短然后按照 Levenberg-Marquardt 算法迭代计算</strong>，得到两帧之间的变换$T$，最后通过累计计算里程计。在这里，需要得到的是距离对坐标变换的偏导数。</p><p>具体查看之前的文章，已经说的非常清楚了：<br><a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#B-%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1">B.运动估计</a></p><p><a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3">C.雅可比矩阵求解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** 3. L-M运动估计求解 *****/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> region</span></span><br><span class="line"><span class="keyword">int</span> pointSelNum = laserCloudOri-&gt;points.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//满足要求的特征点至少10个，特征匹配数量太少弃用此帧数据</span></span><br><span class="line"><span class="keyword">if</span> (pointSelNum &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">matA</span><span class="params">(pointSelNum, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAt</span><span class="params">(<span class="number">6</span>, pointSelNum, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtA</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matB</span><span class="params">(pointSelNum, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtB</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matX</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算matA,matB矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointSelNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pointOri = laserCloudOri-&gt;points[i];</span><br><span class="line">    coeff = coeffSel-&gt;points[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> srx = <span class="built_in">sin</span>(s * transform[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">float</span> crx = <span class="built_in">cos</span>(s * transform[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">float</span> sry = <span class="built_in">sin</span>(s * transform[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">float</span> cry = <span class="built_in">cos</span>(s * transform[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">float</span> srz = <span class="built_in">sin</span>(s * transform[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">float</span> crz = <span class="built_in">cos</span>(s * transform[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">float</span> tx = s * transform[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">float</span> ty = s * transform[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">float</span> tz = s * transform[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> arx = (-s * crx * sry * srz * pointOri.x + s * crx * crz * sry * pointOri.y + s * srx * sry * pointOri.z + s * tx * crx * sry * srz - s * ty * crx * crz * sry - s * tz * srx * sry) * coeff.x + (s * srx * srz * pointOri.x - s * crz * srx * pointOri.y + s * crx * pointOri.z + s * ty * crz * srx - s * tz * crx - s * tx * srx * srz) * coeff.y + (s * crx * cry * srz * pointOri.x - s * crx * cry * crz * pointOri.y - s * cry * srx * pointOri.z + s * tz * cry * srx + s * ty * crx * cry * crz - s * tx * crx * cry * srz) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> ary = ((-s * crz * sry - s * cry * srx * srz) * pointOri.x + (s * cry * crz * srx - s * sry * srz) * pointOri.y - s * crx * cry * pointOri.z + tx * (s * crz * sry + s * cry * srx * srz) + ty * (s * sry * srz - s * cry * crz * srx) + s * tz * crx * cry) * coeff.x + ((s * cry * crz - s * srx * sry * srz) * pointOri.x + (s * cry * srz + s * crz * srx * sry) * pointOri.y - s * crx * sry * pointOri.z + s * tz * crx * sry - ty * (s * cry * srz + s * crz * srx * sry) - tx * (s * cry * crz - s * srx * sry * srz)) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> arz = ((-s * cry * srz - s * crz * srx * sry) * pointOri.x + (s * cry * crz - s * srx * sry * srz) * pointOri.y + tx * (s * cry * srz + s * crz * srx * sry) - ty * (s * cry * crz - s * srx * sry * srz)) * coeff.x + (-s * crx * crz * pointOri.x - s * crx * srz * pointOri.y + s * ty * crx * srz + s * tx * crx * crz) * coeff.y + ((s * cry * crz * srx - s * sry * srz) * pointOri.x + (s * crz * sry + s * cry * srx * srz) * pointOri.y + tx * (s * sry * srz - s * cry * crz * srx) - ty * (s * crz * sry + s * cry * srx * srz)) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> atx = -s * (cry * crz - srx * sry * srz) * coeff.x + s * crx * srz * coeff.y - s * (crz * sry + cry * srx * srz) * coeff.z;</span><br><span class="line">    <span class="keyword">float</span> aty = -s * (cry * srz + crz * srx * sry) * coeff.x - s * crx * crz * coeff.y - s * (sry * srz - cry * crz * srx) * coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> atz = s * crx * sry * coeff.x - s * srx * coeff.y - s * crx * cry * coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> d2 = coeff.intensity;</span><br><span class="line"></span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">0</span>) = arx;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">1</span>) = ary;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span>) = arz;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">3</span>) = atx;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">4</span>) = aty;</span><br><span class="line">    matA.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">5</span>) = atz;</span><br><span class="line">    matB.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">0</span>) = <span class="number">-0.05</span> * d2;</span><br><span class="line">&#125;</span><br><span class="line">cv::<span class="built_in">transpose</span>(matA, matAt);</span><br><span class="line">matAtA = matAt * matA;</span><br><span class="line">matAtB = matAt * matB;</span><br><span class="line"><span class="comment">//求解matAtA * matX = matAtB</span></span><br><span class="line">cv::<span class="built_in">solve</span>(matAtA, matAtB, matX, cv::DECOMP_QR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iterCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特征值1*6矩阵</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matE</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">//特征向量6*6矩阵</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV2</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求解特征值/特征向量</span></span><br><span class="line">    cv::<span class="built_in">eigen</span>(matAtA, matE, matV);</span><br><span class="line">    matV.<span class="built_in">copyTo</span>(matV2);</span><br><span class="line"></span><br><span class="line">    isDegenerate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//特征值取值门槛</span></span><br><span class="line">    <span class="keyword">float</span> eignThre[<span class="number">6</span>] = &#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123; <span class="comment">//从小到大查找</span></span><br><span class="line">        <span class="keyword">if</span> (matE.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) &lt; eignThre[i])</span><br><span class="line">        &#123; <span class="comment">//特征值太小，则认为处在兼并环境中，发生了退化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">            &#123; <span class="comment">//对应的特征向量置为0</span></span><br><span class="line">                matV2.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isDegenerate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算P矩阵</span></span><br><span class="line">    matP = matV.<span class="built_in">inv</span>() * matV2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDegenerate)</span><br><span class="line">&#123; <span class="comment">//如果发生退化，只使用预测矩阵P计算</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matX2</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    matX.<span class="built_in">copyTo</span>(matX2);</span><br><span class="line">    matX = matP * matX2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//累加每次迭代的旋转平移量</span></span><br><span class="line">transform[<span class="number">0</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">1</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">2</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">3</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">4</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">transform[<span class="number">5</span>] += matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isnan</span>(transform[i])) <span class="comment">//判断是否非数字</span></span><br><span class="line">        transform[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算旋转平移量，如果很小就停止迭代</span></span><br><span class="line"><span class="keyword">float</span> deltaR = <span class="built_in">sqrt</span>(</span><br><span class="line">    <span class="built_in">pow</span>(<span class="built_in">rad2deg</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(<span class="built_in">rad2deg</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(<span class="built_in">rad2deg</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)), <span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> deltaT = <span class="built_in">sqrt</span>(</span><br><span class="line">    <span class="built_in">pow</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">    <span class="built_in">pow</span>(matX.at&lt;<span class="keyword">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deltaR &lt; <span class="number">0.1</span> &amp;&amp; deltaT &lt; <span class="number">0.1</span>)</span><br><span class="line">&#123; <span class="comment">//迭代终止条件</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> endregion</span></span><br></pre></td></tr></table></figure><p>这段代码对应公式部分真的看的一团麻…….一点点看：</p><p>【解析】：首先作者定义了几个矩阵：$A,A^T,A^TA,B,A^TB,X$，然后定义一串变量，代码中的$T$是前三项是旋转角，后三项是平移向量，即$[ θ_x， θ_y， θ_z,t_x, t_y, t_z]^T$，所以定义：</p><script type="math/tex; mode=display">srx=sin\theta_x=s_x\\crx=cos\theta_x=c_x\\sry=sin\theta_y=s_y\\cry=cos\theta_y=c_y\\srz=sin\theta_z=s_z\\crz=cos\theta_z=c_z\\</script><p>然后结合之前推导的公式，读者自己对应（这是基于欧拉角的，现在并不常用，现在基本上使用李代数……）</p><p><img src="/posts/49015.htm/image-20220415204826886.png" alt="image-20220415204826886"></p><h3 id="3-坐标变换"><a href="#3-坐标变换" class="headerlink" title="3.坐标变换"></a>3.坐标变换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> rx, ry, rz, tx, ty, tz;</span><br><span class="line"><span class="comment">//求相对于原点的旋转量,垂直方向上1.05倍修正?</span></span><br><span class="line"><span class="built_in">AccumulateRotation</span>(transformSum[<span class="number">0</span>], transformSum[<span class="number">1</span>], transformSum[<span class="number">2</span>],</span><br><span class="line">                   -transform[<span class="number">0</span>], -transform[<span class="number">1</span>] * <span class="number">1.05</span>, -transform[<span class="number">2</span>], rx, ry, rz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x1 = <span class="built_in">cos</span>(rz) * (transform[<span class="number">3</span>] - imuShiftFromStartX) - <span class="built_in">sin</span>(rz) * (transform[<span class="number">4</span>] - imuShiftFromStartY);</span><br><span class="line"><span class="keyword">float</span> y1 = <span class="built_in">sin</span>(rz) * (transform[<span class="number">3</span>] - imuShiftFromStartX) + <span class="built_in">cos</span>(rz) * (transform[<span class="number">4</span>] - imuShiftFromStartY);</span><br><span class="line"><span class="keyword">float</span> z1 = transform[<span class="number">5</span>] * <span class="number">1.05</span> - imuShiftFromStartZ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x2 = x1;</span><br><span class="line"><span class="keyword">float</span> y2 = <span class="built_in">cos</span>(rx) * y1 - <span class="built_in">sin</span>(rx) * z1;</span><br><span class="line"><span class="keyword">float</span> z2 = <span class="built_in">sin</span>(rx) * y1 + <span class="built_in">cos</span>(rx) * z1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求相对于原点的平移量</span></span><br><span class="line">tx = transformSum[<span class="number">3</span>] - (<span class="built_in">cos</span>(ry) * x2 + <span class="built_in">sin</span>(ry) * z2);</span><br><span class="line">ty = transformSum[<span class="number">4</span>] - y2;</span><br><span class="line">tz = transformSum[<span class="number">5</span>] - (-<span class="built_in">sin</span>(ry) * x2 + <span class="built_in">cos</span>(ry) * z2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据IMU修正旋转量</span></span><br><span class="line"><span class="built_in">PluginIMURotation</span>(rx, ry, rz, imuPitchStart, imuYawStart, imuRollStart,</span><br><span class="line">                  imuPitchLast, imuYawLast, imuRollLast, rx, ry, rz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到世界坐标系下的转移矩阵</span></span><br><span class="line">transformSum[<span class="number">0</span>] = rx;</span><br><span class="line">transformSum[<span class="number">1</span>] = ry;</span><br><span class="line">transformSum[<span class="number">2</span>] = rz;</span><br><span class="line">transformSum[<span class="number">3</span>] = tx;</span><br><span class="line">transformSum[<span class="number">4</span>] = ty;</span><br><span class="line">transformSum[<span class="number">5</span>] = tz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//欧拉角转换成四元数</span></span><br><span class="line">geometry_msgs::Quaternion geoQuat = tf::<span class="built_in">createQuaternionMsgFromRollPitchYaw</span>(rz, -rx, -ry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// publish四元数和平移量</span></span><br><span class="line">laserOdometry.header.stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">laserOdometry.pose.pose.orientation.x = -geoQuat.y;</span><br><span class="line">laserOdometry.pose.pose.orientation.y = -geoQuat.z;</span><br><span class="line">laserOdometry.pose.pose.orientation.z = geoQuat.x;</span><br><span class="line">laserOdometry.pose.pose.orientation.w = geoQuat.w;</span><br><span class="line">laserOdometry.pose.pose.position.x = tx;</span><br><span class="line">laserOdometry.pose.pose.position.y = ty;</span><br><span class="line">laserOdometry.pose.pose.position.z = tz;</span><br><span class="line">pubLaserOdometry.<span class="built_in">publish</span>(laserOdometry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播新的平移旋转之后的坐标系(rviz)</span></span><br><span class="line">laserOdometryTrans.stamp_ = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(timeSurfPointsLessFlat);</span><br><span class="line">laserOdometryTrans.<span class="built_in">setRotation</span>(tf::<span class="built_in">Quaternion</span>(-geoQuat.y, -geoQuat.z, geoQuat.x, geoQuat.w));</span><br><span class="line">laserOdometryTrans.<span class="built_in">setOrigin</span>(tf::<span class="built_in">Vector3</span>(tx, ty, tz));</span><br><span class="line">tfBroadcaster.<span class="built_in">sendTransform</span>(laserOdometryTrans);</span><br></pre></td></tr></table></figure><p>【解析】：得到帧间点云的相对运动之后，由于它们是在这两帧点云的局部坐标系下的，所以需要进行转换，把它转换到世界坐标系下。</p><h1 id="Ⅳ-laserMapping"><a href="#Ⅳ-laserMapping" class="headerlink" title="Ⅳ.laserMapping"></a>Ⅳ.laserMapping</h1><p><img src="/posts/49015.htm/image-20220416150539893.png" alt="image-20220416150539893"></p><h2 id="A-mian函数"><a href="#A-mian函数" class="headerlink" title="A.mian函数"></a>A.mian函数</h2><p><img src="/posts/49015.htm/image-20220416145505400.png" alt="image-20220416145505400"></p><p>开始定义了ROS节点及其发布的消息，通过思维导图可以作为观察，代码类似第二节。然后来吧，痛苦并快乐着…..</p><h3 id="1-坐标变换"><a href="#1-坐标变换" class="headerlink" title="1.坐标变换"></a>1.坐标变换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** ①坐标转换 *****/</span></span><br><span class="line"><span class="keyword">if</span> (frameCount &gt;= stackFrameNum) &#123;</span><br><span class="line">    <span class="comment">//获取世界坐标系转换矩阵，将相关坐标转移到世界坐标系下-&gt;得到可用于建图的Lidar坐标</span></span><br><span class="line">    <span class="built_in">transformAssociateToMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将最新接收到的平面点和边沿点进行旋转平移转换到世界坐标系下(这里和后面的逆转换应无必要)</span></span><br><span class="line">    <span class="comment">// 将上一时刻所有边特征转到世界坐标系下</span></span><br><span class="line">    <span class="keyword">int</span> laserCloudCornerLastNum = laserCloudCornerLast-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; laserCloudCornerLastNum; i++) &#123;</span><br><span class="line">        <span class="built_in">pointAssociateToMap</span>(&amp;laserCloudCornerLast-&gt;points[i], &amp;pointSel);</span><br><span class="line">        laserCloudCornerStack2-&gt;<span class="built_in">push_back</span>(pointSel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上一时刻所有面特征转到世界坐标系下</span></span><br><span class="line">    <span class="keyword">int</span> laserCloudSurfLastNum = laserCloudSurfLast-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; laserCloudSurfLastNum; i++) &#123;</span><br><span class="line">        <span class="built_in">pointAssociateToMap</span>(&amp;laserCloudSurfLast-&gt;points[i], &amp;pointSel);</span><br><span class="line">        laserCloudSurfStack2-&gt;<span class="built_in">push_back</span>(pointSel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【解析】：这部分就是坐标变换，把点和面特征全部都转换到世界坐标系$\left\{W \right\}$下，具体转换函数调用的是<code>pointAssociateToMap</code>，并且转换用的是欧拉角表示的位姿。</p><h3 id="2-优化处理"><a href="#2-优化处理" class="headerlink" title="2.优化处理"></a>2.优化处理</h3><h4 id="①定义Cube"><a href="#①定义Cube" class="headerlink" title="①定义Cube"></a>①定义Cube</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> laserCloudCenWidth = <span class="number">10</span>;    <span class="comment">// cube宽度, cm为单位</span></span><br><span class="line"><span class="keyword">int</span> laserCloudCenHeight = <span class="number">5</span>;    <span class="comment">// cube高度</span></span><br><span class="line"><span class="keyword">int</span> laserCloudCenDepth = <span class="number">10</span>;    <span class="comment">// cube深度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudWidth = <span class="number">21</span>; <span class="comment">// 子cube沿宽方向的分割个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudHeight = <span class="number">11</span>;<span class="comment">// 子cube沿高方向个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudDepth = <span class="number">21</span>; <span class="comment">// 子cube沿深度方向个数</span></span><br><span class="line"><span class="comment">// 子cube总数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudNum = laserCloudWidth * laserCloudHeight * laserCloudDepth;<span class="comment">//4851</span></span><br></pre></td></tr></table></figure><p>cube相关操作的代码还不是特别明白……</p><h4 id="②迭代优化"><a href="#②迭代优化" class="headerlink" title="②迭代优化"></a>②迭代优化</h4><ul><li>迭代边缘点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代边缘点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; laserCloudCornerStackNum; i++) &#123;</span><br><span class="line">    pointOri = laserCloudCornerStack-&gt;points[i];</span><br><span class="line">    <span class="comment">//转换回世界坐标系</span></span><br><span class="line">    <span class="built_in">pointAssociateToMap</span>(&amp;pointOri, &amp;pointSel);</span><br><span class="line">    kdtreeCornerFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);<span class="comment">//寻找最近距离五个点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSqDis[<span class="number">4</span>] &lt; <span class="number">1.0</span>) &#123;<span class="comment">//5个点中最大距离不超过1才处理</span></span><br><span class="line">        <span class="comment">//将五个最近点的坐标加和求平均</span></span><br><span class="line">        <span class="keyword">float</span> cx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> cy = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">float</span> cz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            cx += laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">            cy += laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">            cz += laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">        &#125;</span><br><span class="line">        cx /= <span class="number">5</span>;</span><br><span class="line">        cy /= <span class="number">5</span>; </span><br><span class="line">        cz /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求均方差</span></span><br><span class="line">        <span class="keyword">float</span> a11 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> a12 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">float</span> a13 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> a22 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> a23 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">float</span> a33 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">float</span> ax = laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].x - cx;</span><br><span class="line">            <span class="keyword">float</span> ay = laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].y - cy;</span><br><span class="line">            <span class="keyword">float</span> az = laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].z - cz;</span><br><span class="line"></span><br><span class="line">            a11 += ax * ax;</span><br><span class="line">            a12 += ax * ay;</span><br><span class="line">            a13 += ax * az;</span><br><span class="line">            a22 += ay * ay;</span><br><span class="line">            a23 += ay * az;</span><br><span class="line">            a33 += az * az;</span><br><span class="line">        &#125;</span><br><span class="line">        a11 /= <span class="number">5</span>;</span><br><span class="line">        a12 /= <span class="number">5</span>; </span><br><span class="line">        a13 /= <span class="number">5</span>;</span><br><span class="line">        a22 /= <span class="number">5</span>;</span><br><span class="line">        a23 /= <span class="number">5</span>; </span><br><span class="line">        a33 /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建矩阵</span></span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = a11;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>) = a12;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) = a13;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>) = a12;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>) = a22;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) = a23;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>) = a13;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">1</span>) = a23;</span><br><span class="line">        matA1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) = a33;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特征值分解</span></span><br><span class="line">        cv::<span class="built_in">eigen</span>(matA1, matD1, matV1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matD1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">3</span> * matD1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//如果最大的特征值大于第二大的特征值三倍以上</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> x0 = pointSel.x;</span><br><span class="line">            <span class="keyword">float</span> y0 = pointSel.y;</span><br><span class="line">            <span class="keyword">float</span> z0 = pointSel.z;</span><br><span class="line">            <span class="keyword">float</span> x1 = cx + <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">float</span> y1 = cy + <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">float</span> z1 = cz + <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> x2 = cx - <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">float</span> y2 = cy - <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">float</span> z2 = cz - <span class="number">0.1</span> * matV1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1))</span><br><span class="line">                              * ((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                              + ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))</span><br><span class="line">                              * ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                              + ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))</span><br><span class="line">                              * ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> la = ((y1 - y2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                        + (z1 - z2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> lb = -((x1 - x2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                         - (z1 - z2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> lc = -((x1 - x2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                         + (y1 - y2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> ld2 = a012 / l12;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//权重系数计算</span></span><br><span class="line">            <span class="keyword">float</span> s = <span class="number">1</span> - <span class="number">0.9</span> * <span class="built_in">fabs</span>(ld2);</span><br><span class="line"></span><br><span class="line">            coeff.x = s * la;</span><br><span class="line">            coeff.y = s * lb;</span><br><span class="line">            coeff.z = s * lc;</span><br><span class="line">            coeff.intensity = s * ld2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s &gt; <span class="number">0.1</span>) &#123;<span class="comment">//距离足够小才使用</span></span><br><span class="line">                laserCloudOri-&gt;<span class="built_in">push_back</span>(pointOri);</span><br><span class="line">                coeffSel-&gt;<span class="built_in">push_back</span>(coeff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【解析】：</p><p><strong>首先解释一下这里使用最近邻的方法找到了五个点的做法起什么作用？</strong></p><p>我们这一对应代码部分做推导，设五个点分别是：$(x_1,y_1,z_1),(x_2,y_2,z_2),(x_3,y_3,z_3),(x_4,y_4,z_4),(x_5,y_5,z_5),$</p><p>求平均值：</p><script type="math/tex; mode=display">\begin{align*}\overline{x}&=\frac{x_1+x_2+x_3+x_4+x_5}{5}\\\overline{y}&=\frac{y_1+y_2+y_3+y_4+y_5}{5}\\\overline{z}&=\frac{z_1+z_2+z_3+z_4+z_5}{5}\\\end{align*}</script><p>求协方差：</p><script type="math/tex; mode=display">\begin{align*}Cov(x,x)&=\sigma_{x}^2=E[(x-\overline{x})]^2\\Cov(y,y)&=\sigma_{y}^2=E[(y-\overline{y})]^2\\Cov(z,z)&=\sigma_{z}^2=E[(z-\overline{z})]^2\\Cov(x,y)&=\sigma_{x}\sigma_{y}=E[(x-\overline{x})(y-\overline{y})]\\Cov(x,z)&=\sigma_{x}\sigma_{z}=E[(x-\overline{x})(z-\overline{z})]\\Cov(y,z)&=\sigma_{y}\sigma_{z}=E[(y-\overline{y})(z-\overline{z})]\end{align*}</script><p>得到协方差矩阵：</p><script type="math/tex; mode=display">A=\begin{bmatrix}\sigma_{x}^2&\sigma_{x}\sigma_{y}&\sigma_{x}\sigma_{z}\\\sigma_{y}\sigma_{x}&\sigma_{y}^2&\sigma_{y}\sigma_{z}\\\sigma_{z}\sigma_{x}&\sigma_{z}\sigma_{y}&\sigma_{z}^2\end{bmatrix}</script><p>对$A$矩阵进行特征值分解：</p><p>如果这五个点<strong>共线</strong>的话，则分解出来的最大的特征值是另外两个的三倍以上；</p><p>如果这五个点<strong>共面</strong>的话，则分解出来的两个比较大的特征值是第三大的三倍以上；</p><p>总结为一句话就是：<span style="color:red;"><strong>线特征的特征值是一大两小，面特征的特征值是两大一小</strong></span></p><p>对于边缘点来说，当我们确定这五个点是共线的，则进行<code>if (matD1.at&lt;float&gt;(0, 0) &gt; 3 * matD1.at&lt;float&gt;(0, 1))&#123;....&#125;</code>内容下的操作；</p><p>与之前的点线匹配类似，这里用点$(x_0,y_0,z_0)$以及使用最大的特征值生成的两个虚拟点，利用这三个点，求得梯度方向向量：</p><p>参考链接：<a href="https://lukeyalvin.top/2022/04/11/loam%E8%AE%BA%E6%96%87%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#C-%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3">LOAM-SLAM深度剖析-C.雅可比矩阵求解</a></p><script type="math/tex; mode=display">\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\mathcal{H},b_\mathcal{H},c_\mathcal{H}]^T=[la,lb,lc]^T</script><p>这里和之前的里程计一致。</p><ul><li>迭代平面点</li></ul><p>平面点的代码就不贴了，与边缘点大同小异，不同的地方就是特征值的要求不一样，还有就是梯度方向的对应里程计中梯度方向的求法。</p><p>到此为止，我们得到了$\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }$（损失函数对点云的偏导）的求解。</p><h1 id="Ⅴ-参考文献"><a href="#Ⅴ-参考文献" class="headerlink" title="Ⅴ.参考文献"></a>Ⅴ.参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/29719106">LOAM:3D激光里程计及环境建图的方法和实现（一）</a></p><p><a href="https://blog.csdn.net/nksjc/article/details/76401092">3D 激光 SLAM -&gt;loam_velodyne 论文与代码解析</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;对于LOAM的论文以及原理清晰之后，我们还需要对论文算法的具体实现做深度剖析，做到将论文的每一部分与代码相对应，并学习LOAM实现的方式。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM项目实践" scheme="https://lukeyalvin.top/categories/SLAM%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="LOAM" scheme="https://lukeyalvin.top/tags/LOAM/"/>
    
  </entry>
  
  <entry>
    <title>loam&amp;&amp;aloam源码编译与数据集运行</title>
    <link href="https://lukeyalvin.top/posts/15478.html"/>
    <id>https://lukeyalvin.top/posts/15478.html</id>
    <published>2022-04-12T12:54:24.570Z</published>
    <updated>2022-04-26T01:20:20.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本文主要把loam_velodyne与aloam_velodyne源码进行编译运行，感受一下在数据集下两者的运行效果。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><blockquote><p> 基本环境:ubuntu20.04; ROS1:noetic;你首先得熟悉十四讲吧……</p></blockquote><h1 id="LOAM"><a href="#LOAM" class="headerlink" title="LOAM"></a>LOAM</h1><p><img src="https://github.com/laboshinl/loam_velodyne/raw/master/capture.bmp" alt="Screenshot"></p><p>由于LOAM在机器人操作系统上进行搭建，所以需要构建工作空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建工作空间</span></span><br><span class="line">mkdir -p LOAM_WS/src</span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; catkin_init_workspace </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/laboshinl/loam_velodyne.git</span><br><span class="line"><span class="built_in">cd</span> .. &amp;&amp; catkin_make</span><br><span class="line"><span class="comment"># 编译和运行</span></span><br><span class="line">catkin_make -DCMAKE_BUILD_TYPE=Release </span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br></pre></td></tr></table></figure><p>如果你是用的vscode记得把引用放入<code>c_cpp_properties.json</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/opt/ros/noetic/include/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/alvin/workspace/slam_ws/LOAM/LOAM_WS/src/loam_velodyne/include/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span></span><br><span class="line">                ],</span><br></pre></td></tr></table></figure><p>LOAM_WS/src下运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口1 </span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">roslaunch loam_velodyne loam_velodyne.launch</span><br><span class="line"><span class="comment"># 窗口2 </span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">rosbag play nsh_indoor_outdoor.bag <span class="comment"># 这里下载的数据集放在了工作空间下</span></span><br></pre></td></tr></table></figure><p><img src="/posts/15478.htm/image-20220412211213586.png" alt="image-20220412211213586"></p><p>错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] [1628642694.176070835]: Error transforming odometry <span class="string">&#x27;Odometry&#x27;</span> from frame <span class="string">&#x27;/camera_init&#x27;</span> to frame <span class="string">&#x27;camera_init&#x27;</span></span><br><span class="line">[ERROR] [1628642694.509388228]: Error transforming odometry <span class="string">&#x27;Odometry&#x27;</span> from frame <span class="string">&#x27;/camera_init&#x27;</span> to frame <span class="string">&#x27;camera_init&#x27;</span></span><br></pre></td></tr></table></figure><p>解决办法参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/laboshinl/loam_velodyne/issues/157">https://github.com/laboshinl/lo</a></p><p>修改LaserMapping.cpp, LaserOdomertyr.cpp, TransformMaintenance.cpp这三个文件中的“/camera_int”为“camera_init”</p><p><img src="/posts/15478.htm/image-20220412212407985.png" alt="image-20220412212407985"></p><h1 id="ALOAM"><a href="#ALOAM" class="headerlink" title="ALOAM"></a>ALOAM</h1><p>源代码地址：<a href="https://github.com/HKUST-Aerial-Robotics/A-LOAM">https://github.com/HKUST-Aerial-Robotics/A-LOAM</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建工作空间</span></span><br><span class="line">mkdir -p ALOAM_WS/src</span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; catkin_init_workspace </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/HKUST-Aerial-Robotics/A-LOAM</span><br><span class="line"><span class="built_in">cd</span> .. &amp;&amp; catkin_make</span><br><span class="line"><span class="comment"># 编译和运行</span></span><br><span class="line">catkin_make -DCMAKE_BUILD_TYPE=Release </span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br></pre></td></tr></table></figure><p>当然会遇到一些问题</p><p>①把你的CMakeLists.txt文件中的C++11声明改成C++14</p><p>ALOAM_WS/src/A-LOAM/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## set(CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14&quot;</span>)</span><br></pre></td></tr></table></figure><p>②同LOAM，由于rviz版本问题，修改src下文件中的“/camera_int”为“camera_init”</p><p>③将<code>ALOAM_WS/src/A-LOAM/src/kittiHelper.cpp</code>下的<code>CV_LOAD_IMAGE_GRAYSCALE</code>修改为<code>cv::IMREAD_GRAYSCALE</code></p><p>这是由于pencv2 和 3 的命名规范产生了出入，具体查看 <a href="https://blog.csdn.net/qq_28660035/article/details/80772071"><strong>opencv3 与 opencv2 代码区别总结</strong></a></p><p>然后重新编译运行即可：</p><p><img src="/posts/15478.htm/image-20220418094922467.png" alt="image-20220418094922467"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本文主要把loam_velodyne与aloam_velodyne源码进行编译运行，感受一下在数据集下两者的运行效果。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM项目实践" scheme="https://lukeyalvin.top/categories/SLAM%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="ALOAM" scheme="https://lukeyalvin.top/tags/ALOAM/"/>
    
    <category term="LOAM" scheme="https://lukeyalvin.top/tags/LOAM/"/>
    
  </entry>
  
  <entry>
    <title>LOAM-SLAM深度剖析</title>
    <link href="https://lukeyalvin.top/posts/33314.html"/>
    <id>https://lukeyalvin.top/posts/33314.html</id>
    <published>2022-04-11T03:06:44.036Z</published>
    <updated>2022-04-26T01:20:20.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LOAM这篇论文是发表于2014年RSS的文章，全称为：LOAM: Lidar Odometry and Mapping in Real-time . LOAM是基于激光雷达而搭建的在ROS平台下的SLAM系统。之后许多激光SLAM算法借鉴了LOAM中的一些思想，可以说学习LOAM对学习3D激光SLAM很有帮助。本文对LOAM原论文进行了解析。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ.概述"></a>Ⅰ.概述</h1><p>如图所示，整个<code>LOAM</code>的流程为：<code>Lidar</code>接收数据，首先进行<code>Point Cloud Registration</code>，<code>Lidar Odometry</code>以$10Hz$的频率进行运动估计和坐标转换，<code>Lidar Mapping</code>以$1Hz$的频率构建三维地图。这样做主要是为了保证系统的实时性。</p><p><img src="/posts/33314.htm/image-20220410153142890.png" alt="image-20220410153142890"></p><p>本文的核心主要在于两个部分：<strong>特征提取（Lidar Registration）</strong>和<strong>里程计解算（Odometry and Mapping）</strong>。<br>当提取出特征后，通过高频率的里程计（Odometry）实现<strong>粗定位</strong>，即为高频低精度；低频率的里程计（Mapping）实现<strong>精定位</strong>，即为低频高精度。 </p><h1 id="Ⅱ-符号约定"><a href="#Ⅱ-符号约定" class="headerlink" title="Ⅱ.符号约定"></a>Ⅱ.符号约定</h1><ul><li><p>一个sweep代表了一次扫描周期，$k$表示第$k$次扫描周期，$k\in Z^+$</p></li><li><p>一个扫描周期内获取到的所有点云记作 $P_k$， 代表了第$k$个扫描周期的点云</p></li><li><p>激光雷达坐标系$\left\{L\right\}$是一个以激光雷达几何中心为原点的三维坐标系。$x$轴是向左的，$y$轴是向上的，$z$轴是向前的。点$i, i\in P_k$在$\left\{L\right\}$中的坐标表示为$X^L_{(k,i)}$。</p></li><li><p>世界坐标系$\left\{W\right\}$是在初始位置与$\left\{L\right\}$重合的三维坐标系。点$i, i\in P_k$在$\left\{W\right\}$中的坐标为$X^W_{(k,i)}$。</p></li></ul><p><strong>已知一段点云序列$P_k,k\in Z^+$ ，计算在前$k$个时期内的雷达位姿以及构建全局地图。</strong></p><h1 id="Ⅲ-特征提取（点云注册）"><a href="#Ⅲ-特征提取（点云注册）" class="headerlink" title="Ⅲ.特征提取（点云注册）"></a>Ⅲ.特征提取（点云注册）</h1><h2 id="A-线束模型"><a href="#A-线束模型" class="headerlink" title="A.线束模型"></a>A.线束模型</h2><p>要读懂代码中特征提取中的一些处理，需要弄清楚<code>VLP16</code>扫描时的运动模型,论文中称单个线束为一个<code>Scan</code>，对全部$16$线组成的一帧点云称为一个<code>Sweep</code>，虽然是用的多线激光雷达,但是LOAM是针对单个<code>Scan</code>提取特征点的，这里主要考虑到线束间角分辨率(竖直分辨率)与单个线内点间角分辨率(水平分辨率)存在的差异。以VLP$16$为例, 竖直分辨率约为$2^\circ$，而水平分辨率最大为$0.4^\circ$。</p><p>角分辨率越大， 代表越远的物体，反射的两点距离越大，中间丢失的信息越多。因此， LOAM没有针对Scan和<code>Scan</code>之间的点的关联性提取和描述特征， 而是直接针对单个<code>Scan</code>提取特征。</p><p><img src="/posts/33314.htm/image-20220413152223146.png" alt="image-20220413152223146"></p><p><strong>一个Sweep数据的采集如何完成的？</strong></p><p>一帧内所有的点， 都是按顺序穿行扫描的，比如开始的时候水平的第一个角度为$0^\circ$左右，扫描水平角度为$0^\circ$上的竖直方向所有$16$个点（对应$16$个<code>Scan</code>）的深度，并且这$16$个点也是串行按顺序排列的，然后转到下一个水平角度；设水平分辨率为$0.4^\circ$，则下一个水平角度为$0.4^\circ$，其次水平角度为$0.8^\circ$，依次顺时针扫完一圈(论文中是$[-\pi,\pi]$)，这就完成了一个<code>Sweep</code>数据的采集。</p><p><img src="/posts/33314.htm/image-20220413162337900.png" alt="image-20220413162337900"></p><p>由于从驱动得到的一个<code>Sweep</code>是以点云的形式输出（也就是一堆点，每个点有$XYZ$的信息，点和点之间无其他关系信息），因此我们并不知道每个点属于哪个<code>Scan</code>， 对应哪个水平角度。因此，我们需要根据上面的扫描模型去计算每个点的竖直角度和水平角度。点坐标与竖直角度/水平角度的换算关系如下图所示。[详细翻阅<a href="https://velodynelidar.com/wp-content/uploads/2019/12/63-9243-Rev-E-VLP-16-User-Manual.pdf">vlp-16 sensor coordinate system文档</a>]</p><p><img src="/posts/33314.htm/image-20220413151359585.png" alt="image-20220413151359585"></p><p>通过这个图很容易就能理解如何确定某个点属于哪个<code>Scan</code>，我们使用激光点的垂直距离除以它的水平距离，就可以得到雷达到该点的射线和水平面的夹角，用过这个夹角我们就可以很容易的判断该点属于哪个<code>Scan</code>。但是，实际上，在多线雷达（比如$32$线，$64$线），由于竖直方向的点更密集，<code>Scan</code>与<code>Scan</code>之间的距离很小，很容易出现把<code>Scan10</code>分配到<code>Scan13</code>这样的误差。当然，如果有条件，可以修改数据存储格式，建议把某个点属于哪个<code>Scan</code>直接保存的该点对应的数据中去。</p><p>摘取对应代码（src/loam_velodyne/src/scanRegistration.cpp）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++) &#123;</span><br><span class="line">    <span class="comment">//坐标轴交换，velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系</span></span><br><span class="line">    point.x = laserCloudIn.points[i].y;</span><br><span class="line">    point.y = laserCloudIn.points[i].z;</span><br><span class="line">    point.z = laserCloudIn.points[i].x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算点的仰角(根据lidar文档垂直角计算公式),根据仰角排列激光线号，velodyne每两个scan之间间隔2度</span></span><br><span class="line">    <span class="keyword">float</span> angle = <span class="built_in">atan</span>(point.y / <span class="built_in">sqrt</span>(point.x * point.x + point.z * point.z)) * <span class="number">180</span> / M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-区分边缘点和平面点"><a href="#B-区分边缘点和平面点" class="headerlink" title="B.区分边缘点和平面点"></a>B.区分边缘点和平面点</h2><p>常见的特征点提取方法：特征向量、直方图、旋转图片等。这些方法虽然能很精准的涵盖一帧数据的大部分信息，但是由于计算量大，很难在激光slam的相邻帧的匹配中使用。 因此，需要想一些更好的方法。</p><p>LOAM的特征提取基于曲率，只提取两种特征点：边缘点和平面点，分别对应场景的平面区域和曲折区域。作者根据点的曲率来计算<strong>平面光滑度</strong>作为提取当前帧的特征信息的指标。如下图所示，边缘点的矢量和的模一般较大，矢量<strong>和不为零</strong>向量，而对应平面点的矢量和的模一般较小，矢量<strong>和为零</strong>向量。</p><ul><li>平面点：在三维空间中处于平滑平面上的点，其和周围点的大小差距不大，曲率较低，平滑度较低。</li><li>边缘点：在三维空间中处于尖锐边缘上的点，其和周围点的大小差距较大，曲率较高，平滑度较高。</li></ul><p><img src="/posts/33314.htm/image-20220411152638255.png" alt="image-20220411152638255"></p><p>可以发现，LOAM没有使用特征描述子(连曲率都没有参与后续的匹配)。从代码中的边缘点与平面点的曲率判断阈值可以看出，LOAM提取的边缘点和平面点特征点的曲率，并没有特别大的差别，这使得LOAM有较强的场景适应性，在场景中比较曲折的区域，边缘点点会占据主导,而在较为平缓的区域，平面点点占据主导。 在激光扫描到的一块区域，总会提取出几个特征点。</p><hr><p>定义<strong>平面光滑度</strong>$c$：</p><script type="math/tex; mode=display">c=\frac{1}{|S|·\parallel X^L_{(k,i)}\parallel} \sum_{j\in S,j\ne i} \parallel (X^L_{(k,i)}-X^L_{(k,j)}) \parallel \tag{1}</script><p>根据$c$值对扫描中的点进行排序，选择$c$值最大的点为边缘点，$c$值最小的点为平面点的特征点。论文中为了在环境中均匀分布特征点，将扫描分割成四个相同的子区域。每个子区域最多可提供$2$个边缘点和$4$个平面点。只有当点$i$的$c$值大于或小于一个阈值，且所选点的个数不超过最大值时，才能将点$i$选择为边缘点或平面点。</p><p>通过代码可以知道这四个相同的子区域分别为：</p><ul><li>曲率特别大的点（sharp）</li><li>曲率大的点（less_sharp）</li><li>曲率特别小的点（flat）</li><li>曲率小的点（less_flat）</li></ul><p>代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点分类标号:2-代表曲率很大，1-代表曲率比较大,-1-代表曲率很小，0-曲率比较小(其中1包含了2,0包含了1,0和1构成了点云全部的点)</span></span><br><span class="line"><span class="keyword">int</span> cloudLabel[<span class="number">40000</span>];</span><br></pre></td></tr></table></figure><blockquote><p>这样操作的主要作用是，在进行后面的优化的时候，我们能根据这样的“等级”划分获得更明显</p></blockquote><h2 id="C-不可靠点的删除"><a href="#C-不可靠点的删除" class="headerlink" title="C.不可靠点的删除"></a>C.不可靠点的删除</h2><p>如图所示，对位于平行于激光束的表面上的点，以及被遮挡区域(虚线橙线段)的边界上的点，可以被检测为边缘点。它们都是不可靠的。</p><p><img src="/posts/33314.htm/image-20220410153159251.png" alt="image-20220410153159251"></p><p>选取点的三要素：</p><ul><li>选择的边缘点或平面点的数量不能超过子区域的最大值</li><li>它周围的点都没有被选中</li><li>它不能在大致平行于激光束的表面上，也不能在被遮挡区域的边界上。</li></ul><p>经过特征点的提取，就可以得到论文中的帧数据对应的特征信息（边缘点和平面点分别用黄色和红色标记。）：</p><p><img src="/posts/33314.htm/image-20220410153221345.png" alt="image-20220410153221345"></p><h1 id="Ⅳ-特征点匹配"><a href="#Ⅳ-特征点匹配" class="headerlink" title="Ⅳ.特征点匹配"></a>Ⅳ.特征点匹配</h1><p>将点云重新投影到扫描的末端。蓝色线段表示扫描$k$时感知到的点云 $P_k$，在$k$次扫描结束时，经过<strong>畸变校正</strong>之后将$P_k$重新投影到时间戳$t_{k+1}$，得到绿色线段$\overline{P}_k$。然后，在$k+1$次扫描时，重投影点云数据(经过畸变校正)$\overline{P}_k$和新感知的点云$P_{k+1}$(橙色线段)一起估计激光雷达运动。</p><p><img src="/posts/33314.htm/image-20220410153230555.png" alt="image-20220410153230555"></p><p>我们根据论文中的描述：</p><ul><li><p>$P_k$是$k$时刻激光雷达感知的点云集合， 根据上文的特征提取规则，得到边缘点的集合$\xi_{k}$和平面点的集合$H_{k}$；</p></li><li><p>$\overline{P}_k$是将$k$时刻激光雷达感知的点云集合$P_k$，经过畸变校正得到的点云集合；</p></li><li>$P_{k+1}$是$k+1$时刻激光雷达感知的点云集合， 类似$P_k$，边缘点的集合$\xi_{k+1}$以及平面点的集合$H_{k+1}$；</li><li>在每次迭代中，使用当前估计的变换将$\xi_{k+1}$和$H_{k+1}$重新投影到扫描的开始，记$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$为重投影的点集。</li></ul><blockquote><p>这里我们将$k$时刻的扫描点云$P_k$经过畸变校正，得到了$\overline{P}_k$，然后$k+1$时刻的扫描点云$P_{k+1}$的$\xi_{k+1}$和$H_{k+1}$重投影到了扫描的开始，得到$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$，这样就使得$\overline{P}_k$与$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$统一在同一坐标系下，进而我们才可以计算下面的距离。</p></blockquote><hr><h2 id="A-激光雷达数据的畸变"><a href="#A-激光雷达数据的畸变" class="headerlink" title="A.激光雷达数据的畸变"></a>A.激光雷达数据的畸变</h2><p>激光雷达数据产生的畸变又叫<strong>激光雷达自运动畸变</strong>，对于多数激光雷达而言，尽管激光的发射与接收很快，但构成点云的每一个点仍非同一时刻生成的。一般我们会将$100ms $(对应典型值$10Hz$) 内累积的数据作为一帧点云输出。若在这$100ms$内，激光雷达本体或安装所在的机体发生绝对位置的变化，那么<strong>此帧点云中每一个点的坐标系就是不同的。</strong>直观上看，这一帧点云数据就会发生一定的“变形”，不能真实对应所探测到的环境信息，类似于拍照时手抖了，拍出来的照片就会糊。这便是激光雷达的自运动畸变。</p><p>举一个例子，激光雷达对面有一面平行的墙面，理想状况下激光处于位置A或者位置B位置墙面的点云应该一样，但实际上，由于在这$100ms$内，激光雷达本身在运动，所以这一帧的墙面的点云中，某些点的坐标系就变得不同了，进而失去了原始平行墙面的特征，所以说，AB位置的差距必须要考虑，或者说激光在这期间的运动必须要考虑。</p><p>如果是一堵平行的墙面，理想状况下激光处于A或者B位置测量到的同一点云的距离应该一样，但是实际中，激光雷达的位置发生了变化，所以这一帧的墙面的点云中，每一个点的坐标系就是不同的，失去了原始平行墙面的特征，进行激光SLAM时，AB位置的差距必须要考虑，或者说激光在这期间的运动必须要考虑</p><p><img src="/posts/33314.htm/image-20220411193701848.png" alt="image-20220411193701848"></p><h2 id="B-将点与线和面匹配的原因"><a href="#B-将点与线和面匹配的原因" class="headerlink" title="B.将点与线和面匹配的原因"></a>B.将点与线和面匹配的原因</h2><p>理想情况下，没有畸变，激光雷达在短时间里获取的相邻帧数据是<strong>含有大量同一特征点</strong>的，也就是$P_k$和$P_{k+1}$中很多特征点只是雷达在不同位置下观察的同一个点。所以只要找到一个变化关系$T$使得$P_k$和$P_{k+1}$对应的点的匹配，这个$T$就是表示激光雷达的帧间运动。为了减少计算量，增加鲁棒性，不直接使用点与点的匹配，而是使用边缘点和对应的线特征，平面点和对应的面特征，这样也可以得到变换关系 $T$。</p><p>但是实际情况下，激光雷达的点云数据是含有畸变的，所以作者将矫正的$P_k$重新投影到时间戳$t_{k+1}$，得到$\overline{P}_k$。我们的目的就是：从$\overline{P}_k$中找到与$\xi_{k+1}$中的点对应的边线，从平面图中找到与$H_{k+1}$中的点对应的平面贴片(patch)。那么现在就是一边进行矫正，一边进行匹配，然后进行迭代。迭代过程中，$T$的值不断变化，直到寻找到一个$T$使得<strong>所有点和对应特征区域距离和最小</strong>。</p><h2 id="C-点和对应特征区域距离的计算"><a href="#C-点和对应特征区域距离的计算" class="headerlink" title="C.点和对应特征区域距离的计算"></a>C.点和对应特征区域距离的计算</h2><p><img src="/posts/33314.htm/image-20220411202023128.png" alt="image-20220411202023128"></p><p>其中：$i\in \tilde{\xi}_{k+1}$，$j,l,m\in \overline{P}_k$</p><p>图$7(a)$给出了寻找边缘点对应的边线的过程。设$i$是属于$\tilde{\xi}_{k+1}$的点，即$ i \in \tilde{\xi}_{k+1}$。边线由两个点表示。设$j$是$i$在$\overline{P}_k$中的最近邻，$j\in \overline{P}_k$，设$l$是$i$在连续两次扫描$j$时的最近邻，$(j, l)$构成$i$的对应关系。然后，为了验证$j$和$l$都是边缘点，我们根据公式$(1)$来检查局部表面的平滑度。这里，我们特别要求$j$和$l$来自不同的扫描，考虑到一次扫描不能包含来自同一边线的多个点。</p><p>图$7(b)$显示了寻找平面贴片(patch)作为平面点对应的过程。设$ i$ 为$\tilde{H}_{k+1}$中的一个点，即$i \in  \tilde{H}_{k+1}$。平面贴片(patch)由三个点表示。与上一段类似，我们在$\overline{P}_k$中找到$ i $的最近邻，记为$j$。 然后，我们找到另外两个点 $l$ 和$ m$，作为$ i $的最近邻，一个在$j $的同一扫描中，另一个在 $j $的两次连续扫描中。 这保证了三个点是非共线的。 为了验证 $j$、$l$和 $m$ 都是平面点，我们根据$ (1) $再次检查局部表面的平滑度。</p><p>根据匹配的原理，可以构造优化问题：求解变换关系$T$，使边缘点和边缘线距离最短，平面点和平面距离最短</p><ul><li><p>$\tilde{X}^L_{(k+1,i)}$    ：表示$i， i \in \tilde{\xi}_{k+1}$在$\left\{L\right\}$中的坐标;</p></li><li><p>$\overline{X}^L_{(k,j)}$：表示$j， j \in \overline{P}_k$在$\left\{L\right\}$中的坐标;</p></li><li><p>$\overline{X}^L_{(k,l)}$：表示$l， l\in \overline{P}_k$在$\left\{L\right\}$中的坐标;</p></li><li><p>$\overline{X}^L_{(k,m)}$：表示$m， m\in \overline{P}_k$在$\left\{L\right\}$中的坐标;</p></li></ul><h3 id="a-点到线的距离"><a href="#a-点到线的距离" class="headerlink" title="a.点到线的距离"></a>a.点到线的距离</h3><p>主要原理是利用“<strong>两向量叉积的模等于以这两个向量为边形成的平行四边形的面积</strong>”这条定理。</p><p>如下图：</p><script type="math/tex; mode=display">S=OD·AB=|\overrightarrow{OA}×\overrightarrow {OB}|=|\overrightarrow{OA}|·|\overrightarrow{OB}|·sin\theta</script><p>如果我们需要求高：</p><script type="math/tex; mode=display">OD = \frac{S}{|\overrightarrow{AB}|}=\frac{|\overrightarrow{OA}×\overrightarrow {OB}|}{|\overrightarrow{AB}|}</script><p><img src="/posts/33314.htm/image-20220411204216656.png" alt="image-20220411204216656"></p><p>所以对于：</p><p><img src="/posts/33314.htm/image-20220411204829280.png" alt="image-20220411204829280"></p><p>得到点到线的距离$d_\xi$为：</p><script type="math/tex; mode=display">d_{\xi}=\frac{|(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})×(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,l)})|}{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|}. \tag{2}</script><h3 id="b-点到面的距离"><a href="#b-点到面的距离" class="headerlink" title="b.点到面的距离"></a>b.点到面的距离</h3><p> 主要原理是<strong>点与平面内一点形成的向量与该平面的单位法向量的点积的模即为该点到平面的距离</strong>。</p><p><img src="/posts/33314.htm/image-20220411210656962.png" alt="image-20220411210656962"></p><script type="math/tex; mode=display">d_\mathcal{H}=\frac{\begin{vmatrix}(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})·((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)}))\end{vmatrix}}{\begin{vmatrix}(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)})\end{vmatrix} }. \tag{3}</script><h1 id="Ⅴ-运动估计"><a href="#Ⅴ-运动估计" class="headerlink" title="Ⅴ.运动估计"></a>Ⅴ.运动估计</h1><h2 id="A-线性插值"><a href="#A-线性插值" class="headerlink" title="A.线性插值"></a>A.线性插值</h2><p><img src="/posts/33314.htm/Linear_interpolation.png" alt="Linear interpolation.png"></p><p>假设我们已知坐标 $(x_0,y_0)$ 与$(x_1,y_1)$，要得到$[x_0.x_1]$区间内某一位置 $x$ 在直线上的值。根据图中所示，我们得到:</p><script type="math/tex; mode=display">\frac{y-y_0}{x-x_0}=\frac{y_1-y_0}{x_1-x_0}</script><p>由于 $x$值已知，所以可以从公式得到 $y $的值:</p><script type="math/tex; mode=display">y=y_0+\frac{y_1-y_0}{x_1-x_0}(x-x_0)</script><p>线性插值经常用于已知函数$ f $在两点的值要近似获得其它点数值的方法，这种近似方法的误差定义为:</p><script type="math/tex; mode=display">R_T=f(x)-p(x)</script><p>其中 $p$ 表示上面定义的线性插值多项式</p><script type="math/tex; mode=display">p(x)=f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x_1-x_0). \tag{4}</script><p>根据罗尔定理，我们可以证明：如果 f 有二阶连续导数，那么误差范围是：</p><script type="math/tex; mode=display">|R_T|\leq \frac{(x_1-x_0)^2}{8}\underset{x_0\leq x\leq x_1}{max}|f^{\prime\prime}(x)|</script><h2 id="B-运动估计"><a href="#B-运动估计" class="headerlink" title="B.运动估计"></a>B.运动估计</h2><p>激光雷达运动在扫描期间以<strong>恒定的角速度和线速度建模</strong>。这允许我们在一个扫描中对在不同时间接收到的点进行线性插值。</p><p>假设$t$是当前的时间戳，$t_{k+1}$是扫描$k+1$的开始时间。</p><p>设$T^L_{k+1}$为$[t_{k+1}, t]$之间的激光雷达位姿变换。$T^L_{k+1}$包含$6$自由度激光雷达的刚性运动，$T^L_{k+1} = [t_x, t_y, t_z， θ_x， θ_y， θ_z]^T$，其中我们用$T^L_{k+1}(1:3)$表示 $t_x$、$t_y$和$t_z$，它们分别是$\left\{L\right\}$沿$x-$、$y-$和$z-$轴的平移，我们用$T^L_{k+1}(4:6)$表示$θ_x$、$θ_y$和$θ_z$，它们是旋转角度，遵循右手规则。</p><p>给定点$i，i \in P_k$，设$t_i$为其时间戳，设为$[t_{k+1}, t_i]$之间的$T^L_{(k+1,i)}$位姿变换。</p><p>$T^L_{(k+1,i)}$可以通过$T^L_{k+1}$的线性插值得到：</p><script type="math/tex; mode=display">\begin{align}\frac{T^L_{(k+1,i)} }{t_i-t_{k+1} }&=\frac{ T^L_{k+1}}{t-t_{k+1} }.\end{align}</script><p>整理一下即为论文中的公式:</p><script type="math/tex; mode=display">T^L_{(k+1,i)}=\frac{t_i-t_{k+1} }{t-t_{k+1} }T^L_{k+1}. \tag{5}</script><p>由前文：在每次迭代中，使用当前估计的变换将$\xi_{k+1}$和$H_{k+1}$重新投影到扫描的开始，记$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$为重投影的点集。由于激光雷达位姿的变化，设旋转矩阵为$R$，平移向量$t=T^L_{(k+1,i)}(1:3)$我们可以得到：</p><script type="math/tex; mode=display">X^L_{(k+1,i)}=R\tilde X^L_{(k+1,i)}+T^L_{(k+1,i)}(1:3). \tag{6}</script><p>由罗德里格斯公式：</p><script type="math/tex; mode=display">R=e^{\hat{w} \theta}=I + \hat{w}sin\theta+\hat{w}^2(1-cos\theta).\tag{7}</script><p>在上式中，$θ$为旋转的大小，</p><script type="math/tex; mode=display">\theta = \parallel T^L_{(k+1,i)}(4:6) \parallel. \tag{8}</script><p>$w$是表示旋转方向的单位向量，</p><script type="math/tex; mode=display">w=\frac{T^L_{(k+1,i)}(4:6)}{\parallel T^L_{(k+1,i)}(4:6) \parallel}. \tag{9}</script><p>$\hat{w}$为$w$的斜对称矩阵[25]。</p><p>忆$(2)$和$(3)$计算属于$\tilde \xi_{k+1} $ 和$\tilde H_{k+1}$ 的点之间的距离及其对应关系。结合$(2)$和$(5)-(8)$，我们可以推导出$\xi_{k+1}$中的一个边点与相应的边线之间的几何关系，</p><script type="math/tex; mode=display">f_{\xi}(X^L_{(k+1,i)},T^L_{k+1})=d_\xi,i\in \xi_{k+1}.\tag{10}</script><p>合$(3)(5)-(8)$，我们可以在$H_{k+1}$中的一个平面点与对应的平面贴片(patch)建立另一个几何关系，</p><script type="math/tex; mode=display">f_H(X^L_{(k+1,i)},T^L_{k+1})=d_H,i\in H_{k+1}.\tag{11}</script><p>最后，我们用<code>Levenberg-Marquardt</code>方法[26]求解激光雷达运动。将$\xi_{k+1}$和$H_{k+1}$中每个特征点$(9)$和$(10)$叠加，得到一个非线性函数:</p><script type="math/tex; mode=display">f(T^L_{k+1})=d,\tag{12}</script><p>其中每一行$f$对应一个特征点，$d$包含相应的距离。我们计算$f$关于$T^L_{k+1}$的雅可比矩阵，记作$J$，其中$J =\partial f /\partial T^L_{k+1}$。然后，$(12)$通过非线性迭代，使$d$趋近于$0$，</p><script type="math/tex; mode=display">T^L_{k+1}\gets T^L_{k+1}-(J^TJ+\lambda diag(J^TJ))^{-1}J^Td.\tag{13}</script><p>$\lambda$是由<code>Levenberg-Marquardt</code>方法确定的因子</p><h2 id="C-雅可比矩阵求解"><a href="#C-雅可比矩阵求解" class="headerlink" title="C.雅可比矩阵求解"></a>C.雅可比矩阵求解</h2><p>LOAM中代价函数主要由两部分组成，即点到面的距离与点到线的距离，因此LOAM的代价函数不难写出：</p><script type="math/tex; mode=display">loss= \sum^{N_{\xi} }_{i=1}d_{\xi_i}+\sum^{N_{H} }_{i=1}d_{H_i}=D(\tilde{X}^L_{(k+1,i)}).\tag{14}</script><blockquote><p>我们的目的就是残差对位姿求偏导，进而求得一个使得残差最小的最优位姿。</p></blockquote><p>定义$t+1$时刻的位姿：$T^L_{k+1} = [t_x, t_y, t_z， θ_x， θ_y， θ_z]^T$，其中我们用$t=T^L_{k+1}(1:3)=[t_x, t_y, t_z]^T$表示位移 $t_x$、$t_y$和$t_z$，同时$R$也可以通过$T^L_{k+1}$经罗德里格斯公式求解。</p><p>特征点从当前雷达坐标系投影到目标坐标系：</p><script type="math/tex; mode=display">\tilde X^L_{(k+1,i)}=R X^L_{(k+1,i)}+t=G(X^L_{(k+1,i)},T^L_{k+1})</script><blockquote><p>这里与论文略有不同，这里$t_{k+1}$时刻的点经过位姿变化投影到$t_{k}$时刻，进而将两帧的点云统一在一个坐标系下，论文中是相反的（公式6），但是含义是一样的。</p></blockquote><p>将旋矩阵转换成欧拉角：</p><script type="math/tex; mode=display">\begin{align*}R &= R_yR_xR_z\\&=\begin{bmatrix}c_yc_z+s_ys_xs_z &c_zs_ys_x-c_ys_z &c_xs_y\\c_xs_z&c_xc_z&-s_x\\c_ys_xs_z-c_zs_y&c_yc_zs_x+s_ys_z&c_yc_x\end{bmatrix}\end{align*}.\tag{15}</script><p>其中$c_x=cos(\theta_x),c_y=cos(\theta_y),c_z=cos(\theta_z),s_x=sin(\theta_x),s_y=sin(\theta_y),s_z=sin(\theta_z)$</p><p>将$(14)(15)$合并：</p><script type="math/tex; mode=display">loss=F(X^L_{(k+1,i)},T^L_{k+1})=D(G(X^L_{(k+1,i)},T^L_{k+1})).\tag{16}</script><p>损失函数建立之后，我们就可以优化位姿，求损失对于位姿的偏导：</p><script type="math/tex; mode=display">\begin{align*}J&=\frac{\partial F(X^L_{(k+1,i)},T^L_{k+1}) }{\partial T^L_{k+1} }\\&=\frac{\partial D(G(X^L_{(k+1,i)},T^L_{k+1})) }{\partial T^L_{k+1} }\\&=\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }·\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial T^L_{k+1} }\end{align*}.\tag{17}</script><p>我们分别对这两部分进行推导：</p><ul><li>$\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }$的求解</li></ul><p>这部分表示的是损失函数对点云的偏导，这部分没有必要通过变量求导的方式去推导，我们知道求偏导就是求梯度方向，梯度方向就是使得残差减小的最快的方向；对于点云来说，残差减小最快的方向就是垂直于特征区域的方向：</p><p>​    ①对于线特征，梯度方向为通过特征点的垂直于直线的方向：</p><script type="math/tex; mode=display">\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\xi,b_\xi,c_\xi]^T</script><p>​    ②对于面特征，梯度方向为通过特征点的垂直于平面的方向：</p><script type="math/tex; mode=display">\frac{\partial D(\tilde{X}^L_{(k+1,i)})}{\partial \tilde{X}^L_{(k+1,i)} }=[a_\mathcal{H},b_\mathcal{H},c_\mathcal{H}]^T</script><ul><li>$\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial T^L_{k+1} }$的求解</li></ul><p>这部分表示的是点云对位姿的偏导，主要是对平移和旋转的求导：</p><p>​    ①对平移求导</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial t_x}=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial t_x}=\begin{bmatrix} 1\\0\\0 \end{bmatrix}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial t_y}=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial t_y}=\begin{bmatrix} 0\\1\\0 \end{bmatrix}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial t_z}=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial t_z}=\begin{bmatrix} 0\\0\\1 \end{bmatrix}\end{align*}</script><p>​    ②对角度求导</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial \theta_x }&=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial \theta_x }=\frac{\partial G(R X^L_{(k+1,i)})}{\partial \theta_x }\\&=\begin{bmatrix}s_yc_xs_z&c_zs_yc_x &-s_xs_y\\-s_xs_z &-s_xc_z&-c_x\\c_yc_xs_z&c_yc_zc_x&-c_ys_x\end{bmatrix}\begin{bmatrix}x_{(k+1,i)}\\y_{(k+1,i)}\\z_{(k+1,i)}\end{bmatrix}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial \theta_y }&=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial \theta_y }=\frac{\partial G(R X^L_{(k+1,i)})}{\partial \theta_y }\\&=\begin{bmatrix}-s_yc_z+c_ys_xs_z&c_zc_ys_x+s_ys_z &c_xc_y\\0&0&0\\-s_ys_xs_z-c_zc_y&-s_yc_zs_x+c_ys_z&-s_yc_x\end{bmatrix}\begin{bmatrix}x_{(k+1,i)}\\y_{(k+1,i)}\\z_{(k+1,i)}\end{bmatrix}\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\frac{\partial G(X^L_{(k+1,i)},T^L_{k+1})}{\partial \theta_z }&=\frac{\partial G(R X^L_{(k+1,i)}+t)}{\partial \theta_z}=\frac{\partial G(R X^L_{(k+1,i)})}{\partial \theta_z }\\&=\begin{bmatrix}-c_ys_z+s_ys_xc_z&-s_zs_ys_x &0\\c_xc_z &-c_xs_z&0\\c_ys_xc_z+s_zs_y&-c_ys_zs+s_yc_z&0\end{bmatrix}\begin{bmatrix}x_{(k+1,i)}\\y_{(k+1,i)}\\z_{(k+1,i)}\end{bmatrix}\end{align*}</script><h1 id="Ⅵ-构建地图"><a href="#Ⅵ-构建地图" class="headerlink" title="Ⅵ.构建地图"></a>Ⅵ.构建地图</h1><h2 id="A-概览"><a href="#A-概览" class="headerlink" title="A.概览"></a>A.概览</h2><p><strong>①为什么使用建图节点？</strong></p><p>通过前面的步骤，我们计算出了帧间的里程计，可以对激光雷达的运动做粗略的估计，但是由于收到噪声的影响，位姿估计并不是准确，经过长时间的累积漂移会直接导致最终拼接的地图不成样子，因此，我们还需要依靠其他的方式对位姿进行估计进一步优化。</p><p>在SLAM领域，一般会采用与地图匹配的方式来优化这一结果。其实道理也很简单，我们始终认为后一时刻的观测较前一时刻带有更多的误差，换而言之，我们更加信任前一时刻结果。因此我们对已经构建地图的信任程度远高于临帧点云配准后的Lidar运动估计。所以我们可以利用已构建地图对位姿估计结果进行修正。</p><p>因此建图的作用就是 <span style="color:red;">优化Lidar里程计的位姿估计结果</span></p><p><strong>②建图节点如何工作的？</strong></p><p>如何利用地图进行优化呢？在文章的开始，我们就说里程计部分是高频率低精度，而地图部分是低频率高精度，所以才说里程计估计的位姿仅仅是粗略的估计，而利用地图的优化则是高精度的，但考虑资源消耗，所以调用频率相对于里程计的十分之一。</p><ul><li><p>首先，假设激光雷达在第一帧的时候得到数万个点云，此时Lidar的位置我们把它作为$(0,0,0)$，（此时记雷达位姿为$T^W_k$，地图 $ Q_k$），此时如果不考虑测量误差，则这数万个点都是精确的，我们把这数万个点所构成的环境作为此时的地图。</p></li><li><p>然后，假如激光雷达运动了一小段，得到了第二帧的点云，我们通过激光雷达里程计的方法估计了帧间的相对运动（就是$T^L_{k+1}$），但我们说了里程计的位姿估计是一个粗略的、低精度的、高频率的，因此我们做下一步操作。</p></li><li>最后，我们利用里程计得到的粗略的位姿估计，把第二帧的点云转换到第一帧（建立地图时的坐标系）的坐标系下，很显然，由于里程计不准确，就会导致地图拼歪了（就是论文中的$ \overline{Q}_{k+1}$），而建图节点的作用就是把歪的地图扶正后完整的拼上去，这就从另一个角度优化的雷达的位姿。</li></ul><p>但是，我们要清楚，拿当前的点云和地图中所有的点云去配准，这个计算量十分巨大，消耗也非常大，但是又要保证算法的实时性，所以调用建图节点的频率仅为调用里程计节点频率的十分之一。</p><p><img src="/posts/33314.htm/image-20220416101236496.png" alt="image-20220416101236496"></p><p>建图过程如右图示意。 蓝色曲线表示地图上的激光雷达位姿$T^W_k$ ，由建图算法在扫描 $k $处生成。 橙色曲线表示扫描 $k + 1$期间的激光雷达运动$T^L_{k+1}$，由里程计算法计算得出。 使用$ T^W_k$和$T^L_{k+1}$，将里程计算法发布的未失真点云投影到地图上，表示为（绿色线段）$\overline{Q}_{k+1}$，并与地图上现有的云$ Q_k$（黑色线段）进行匹配。</p><h2 id="B-合并地图点"><a href="#B-合并地图点" class="headerlink" title="B.合并地图点"></a>B.合并地图点</h2><p>合并地图点并没有在论文中提及，但是在代码中体现出来了，它更多的是一种工程实验的手段。在上文，我们知道第二帧的地图点在往第一帧做匹配然后去合并到第一帧，这样就能够形成一个地图，但是应该如何合并这是一个问题。</p><p>合并的规则：就是把场景看成一个立方体，然后划分成一定的小网格，将落入小网格的特征点进行合并，等下一帧的点云进来的时候，找对应的栅格即可。</p><ul><li>把关键帧的特征点按照位姿转到地图坐标系中</li><li>按照位置和<code>cube</code>尺寸划分到对应的<code>cube</code>中</li></ul><h2 id="C-优化位姿"><a href="#C-优化位姿" class="headerlink" title="C.优化位姿"></a>C.优化位姿</h2><p>优化位姿与里程计相同。</p><h1 id="Ⅶ-参考链接"><a href="#Ⅶ-参考链接" class="headerlink" title="Ⅶ.参考链接"></a>Ⅶ.参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/111388877/">LOAM-SLAM原理深度解析</a></p><p><a href="https://zhuanlan.zhihu.com/p/260012025/">LOAM SLAM原理之论文原理解读</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTM1MTQwMw==&amp;mid=2247530490&amp;idx=1&amp;sn=7d1c84b1a4b338887d9c9061da1bd0e3&amp;chksm=ec13c9fedb6440e87aeec427609c2c8592590353565c307e6bd046b1f168af75918871b457b4&amp;scene=132#wechat_redirect">【泡泡点云时空LOAM专题-3】LOAM 代价函数设计与雅可比求解详细推导（上）</a></p><p><a href="https://zhuanlan.zhihu.com/p/57351961">LOAM细节分析</a></p><p><a href="https://www.bilibili.com/video/BV1744y1J7ov/?spm_id_from=333.788.recommend_more_video.1">任务4 前端里程计LOAM系列</a></p><p><a href="https://zhuanlan.zhihu.com/p/29939195">LOAM:3D激光里程计及环境建图的方法和实现（三）</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LOAM这篇论文是发表于2014年RSS的文章，全称为：LOAM: Lidar Odometry and Mapping in Real-time . LOAM是基于激光雷达而搭建的在ROS平台下的SLAM系统。之后许多激光SLAM算法借鉴了LOAM中的一些思想，可以说学习LOAM对学习3D激光SLAM很有帮助。本文对LOAM原论文进行了解析。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="LOAM" scheme="https://lukeyalvin.top/tags/LOAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>LOAM-SLAM翻译</title>
    <link href="https://lukeyalvin.top/posts/36439.html"/>
    <id>https://lukeyalvin.top/posts/36439.html</id>
    <published>2022-04-10T07:29:00.883Z</published>
    <updated>2022-04-26T01:20:20.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>LOAM是Ji Zhang于2014年提出的使用激光雷达完成定位与三维建图的算法，即Lidar Odometry and Mapping。之后许多激光SLAM算法借鉴了LOAM中的一些思想，可以说学习LOAM对学习3D激光SLAM很有帮助。本文对LOAM原论文进行了翻译。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们提出了一种实时里程测量和地图绘制方法，该方法使用$ 6$ 自由度移动的$ 2$ 轴激光雷达的距离测量。这个问题很难解决，因为距离测量是在不同的时间接收的，运动估计中的错误可能会导致结果点云的错误配准。迄今为止，我们可以通过离线批处理方法构建连贯的 $3D$ 地图，通常使用循环闭合来校正随时间的漂移。我们的方法实现了低漂移和低计算复杂度，无需高精度测距或惯性测量。获得这一性能水平的关键思想是通过两种算法来划分同时定位和建图的复杂问题，该问题寻求同时优化大量变量。一种算法以高频但低保真度进行里程测量，以估计激光雷达的速度。另一种算法以较低数量级的频率运行，用于点云的精细匹配和配准。这两种算法的结合允许该方法实时建图。该方法已通过大量实验以及 KITTI 里程计基准进行了评估。结果表明，该方法可以达到离线批处理方法的精度水平。</p><h1 id="I-介绍"><a href="#I-介绍" class="headerlink" title="I. 介绍"></a>I. 介绍</h1><p>$3D$ 建图仍然是一种流行的技术 [1]–[3]。使用激光雷达进行建图是常见的，因为激光雷达可以提供高频范围测量，无论测量的距离如何，误差都相对恒定。在激光雷达的唯一运动是旋转激光束的情况下，点云的配准很简单。然而，如果激光雷达本身在许多环境的应用中都在移动，则精确建图需要在连续激光测距期间了解激光雷达的位姿。解决这个问题的一种常见方法是使用独立的位置估计(例如通过GPS/INS)将激光点注册到一个固定的坐标系中。另一组方法使用里程计测量，如从轮编码器或视觉里程计系统[4]，[5]记录激光点。由于里程计集成了随时间推移的微小增量运动，它必然会发生漂移，因此人们非常关注如何减少漂移(例如使用环路闭合)。</p><p>在这里，我们考虑使用$6$自由度移动的$2$轴激光雷达创建低漂移里程计地图的情况。使用激光雷达的一个关键优势是它对场景中的环境光线和光学纹理不敏感。随着激光雷达的发展，它们的尺寸和重量缩小了很多。激光雷达在人手持的情况下穿越环境 [6]，也可以连接到微型飞行器 [7]。由于我们的方法旨在推动里程计估计中的最小化漂移相关的问题，因此目前不涉及回环问题。</p><p><img src="/posts/36439.htm/image-20220410153023132.png" alt="image-20220410153023132"></p><blockquote><p>图1所示。该方法的目标是利用移动两轴激光雷达进行运动估计和建图。由于接收激光点的时间不同，激光雷达的运动导致点云出现失真(如图左侧的激光雷达云所示)。我们提出的方法是将问题分解为两个并行运行的算法。里程计算法估计激光雷达的速度和校正点云中的失真，然后建图算法匹配并注册点云以创建地图。两种算法的结合保证了问题的实时可行性。</p></blockquote><p>该方法实现了低漂移和低计算复杂度，无需高精度测距惯性测量。获得这一性能水平的关键思想是用两种算法将通常复杂的同时定位与建图(SLAM)[8]问题分割开来，该问题旨在同时优化大量变量。其中一种算法采用高频但保真度较低的里程计来估计激光雷达的速度。另一种算法以较低数量级的频率运行，用于点云的精细匹配和配准。虽然没有必要，但如果IMU可用，可以提供一个运动先验来帮助描述高频运动。两种算法分别提取尖锐边缘和平面表面上的特征点，并将其分别与边缘线段和平面表面斑块进行匹配。里程计算法在保证快速计算的前提下，找到特征点的对应关系。在建图算法中，通过相关特征值和特征向量检查局部点簇的几何分布来确定对应关系。</p><p>通过对原问题的分解，首先解决了一个简单的问题，即在线运动估计。之后，建图作为批量优化（类似于迭代最近点（ICP）方法 [9]）进行，以生成高精度运动估计和地图。并行算法结构保证了问题实时求解的可行性。此外，由于运动估计是在更高的频率下进行的，因此给建图足够的时间来提高精度。当以较低的频率运行时，建图算法能够包含大量的特征点，并使用足够多的迭代进行收敛。</p><h1 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II.相关工作"></a>II.相关工作</h1><p>激光雷达已经成为机器人导航中应用广泛的传感器 [10]。对于定位和建图，大多数都使用 $2D $激光雷达[11]。当激光雷达扫描速率远高于其外部运动时，扫描中的运动失真通常可以忽略。在这种情况下，标准$ICP $方法[12] 可用于匹配不同扫描之间的激光数据。此外，提出了一种两步法来消除失真[13]:基于$ICP$的速度估计步骤，然后使用计算的速度进行失真补偿步骤。类似的技术也用于补偿单轴 $3D$激光雷达引入的失真[14]。然而，如果扫描运动相对缓慢，则运动失真可能严重。这也是为什么使用两轴激光雷达，因为一个轴通常比另一个轴慢得多。通常，其他传感器用于提供速度测量，通过这些测量，可以消除运动失真。例如，激光雷达点云可以通过与 IMU[15] 集成的视觉里程计的状态估计来注册。当多个传感器（如 GPS/INS 和车轮编码器）同时可用时，问题通常通过扩展卡尔曼滤波器[16] 或粒子滤波器 [1] 解决。这些方法可以实现实时建图，以辅助机器人导航中的路径规划和避障。</p><p>如果在不借助其他传感器的情况下使用双轴激光雷达，运动估计和失真校正将成为一个问题。Barfoot 等人使用的一种方法是从返回激光强度创建视觉图像，并在图像之间匹配视觉上不同的特征 [17]，以恢复地面车辆的运动[18]–[21]。在[18]、[19] 中，车辆运动被建模为恒定速度，在 [20]、[21] 中，车辆运动被建模为高斯过程。我们的方法使用了与 [18]、[19] 中类似的里程计算法线性运动模型，但具有不同类型的特征。方法 [18]–[21] 涉及强度图像的视觉特征，需要稠密点云。该方法在笛卡尔空间中提取和匹配几何特征，对点云密度要求较低。最接近我们的方法是Bosse和Zlot的[3]、[6]、[22]。利用两轴激光雷达获取点云，通过匹配局部点簇[22]的几何结构进行配准。此外，他们使用多个 2 轴激光雷达绘制地下矿井地图 [3]。此方法融合了 IMU，并使用回环检测构建大型地图。由同一作者提出的Zebedee是一个由2D激光雷达和IMU组成的建图设备，IMU通过弹簧[6]连接到手杆上。通过手动操作装置进行建图。采用批量优化方法对分段数据集进行处理，并在分段数据集之间添加边界约束。该方法利用IMU的测量值对激光点进行配准，并通过优化来校正IMU的偏差。从本质上说，Bosse和Zlot的方法需要批处理来开发精确的地图，因此不适用于需要实时地图的应用。相比之下，该方法在实时生成的地图在定性上与Bosse和Zlot的方法相似。区别在于，我们的方法可以为自动驾驶汽车的引导提供运动估计。此外，该方法利用了激光雷达扫描模式和点云分布。在里程计和建图算法中，分别实现了保证计算速度和精度的特征匹配。</p><h1 id="III-符号和任务描述"><a href="#III-符号和任务描述" class="headerlink" title="III.符号和任务描述"></a>III.符号和任务描述</h1><p>本文所要解决的问题是利用三维激光雷达感知的点云进行自动估计，并建立所经过环境的地图。我们假设激光雷达是预先校准的。我们还假设激光雷达的角速度和线速度随时间的变化是平滑和连续的，没有突变。第二个假设将在第VII-B节中通过使用IMU来释放。</p><p>在本文中，我们习惯用大写右标来表示坐标系。我们定义扫描(a sweep)为激光雷达完成一次扫描覆盖，我们使用正确的订阅$k,k\in Z^+$表示扫描，$P_k$表示扫描为$k$时感知的点云。让我们如下定义两个坐标系。</p><ul><li><p>激光雷达坐标系$\left\{L\right\}$是一个以激光雷达几何中心为原点的三维坐标系。$x$轴是向左的，$y$轴是向上的，$z$轴是向前的。点$i, i\in P_k$在$\left\{L\right\}$中的坐标表示为$X^L_{(k,i)}$。</p></li><li><p>世界坐标系$\left\{W\right\}$是在初始位置与$\left\{L\right\}$重合的三维坐标系。点$i, i\in P_k$在$\left\{W\right\}$中的坐标为$X^W_{(k,i)}$。</p></li></ul><p>有了假设和符号，我们的激光雷达里程测量和建图问题可以定义为:</p><p>​    <strong>问题:</strong>给定一个激光雷达云序列$i, i\in P_k$，计算每次扫描$k$时激光雷达的帧间运动(ego-motion)，用$P_k$构建遍历环境的地图。</p><h1 id="IV-系统总览"><a href="#IV-系统总览" class="headerlink" title="IV.系统总览"></a>IV.系统总览</h1><h2 id="A-激光雷达硬件"><a href="#A-激光雷达硬件" class="headerlink" title="A.激光雷达硬件"></a>A.激光雷达硬件</h2><p>本文的研究是在基于Hokuyo UTM-30LX激光扫描仪的定制3D激光雷达上进行验证的，但并不限于此。通过本文，我们将使用从激光雷达收集的数据来说明该方法。该激光扫描仪的视场为$180^◦$，分辨率为$0.25^◦$以及$40$行/秒扫描速率。所述激光扫描仪与电机相连，电机被控制以$180^◦/s$的角速度旋转，在$−90^◦$和$90^◦$之间，激光扫描仪的水平方向为零。对于这个特定的单位，扫描是从$−90^◦$旋转到$90^◦$或在相反的方向(持续1秒)。这里，请注意，对于一个连续旋转的激光雷达，扫描只是一个简单的半球面旋转。板载编码器以$0.25^◦$的分辨率测量电机旋转角度，利用该分辨率将激光点投影到激光雷达坐标$\left\{L\right\}$中。</p><p><img src="/posts/36439.htm/image-20220410153045839.png" alt="image-20220410153045839"></p><blockquote><p> 图$2$所示。三维激光雷达在本研究中使用的是一个由马达驱动旋转运动的Hokuyo激光扫描仪，以及一个测量旋转角度的编码器。该激光扫描仪的视场为$180^◦$的分辨率为$0.25^◦$。扫描速度为$40$行/秒。电机被控制从$−90^◦$旋转到$90^◦$与激光扫描仪的水平方向为零。</p></blockquote><p><img src="/posts/36439.htm/image-20220410153142890.png" alt="image-20220410153142890"></p><blockquote><p>图$3$所示。激光雷达测程与建图软件系统框图。</p></blockquote><h2 id="B-软件系统概述"><a href="#B-软件系统概述" class="headerlink" title="B.软件系统概述"></a>B.软件系统概述</h2><p>图$3$显示了软件系统的示意图。设$\hat{P}$为激光扫描接收到的点。在每次扫描期间，$\hat{P}$在$\left\{L\right\}$中注册。扫描$k$时合并的点云形成$P_k$，然后用两种算法处理$P_k$。激光雷达里程计取点云并计算激光雷达在两次连续扫描之间的运动。在$P_k$中使用估计的运动来校正失真，算法运行在$10Hz$左右的频率。激光雷达建图进一步处理输出，以$1Hz$的频率匹配并将未失真的云注册到地图上。最后，将两种算法发布的位姿变换集成在一起，生成一个关于激光雷达相对于地图的位姿的约$10Hz$的变换输出。第V、VI节详细介绍了软件框图中的模块</p><h1 id="V-激光雷达里程计"><a href="#V-激光雷达里程计" class="headerlink" title="V.激光雷达里程计"></a>V.激光雷达里程计</h1><h2 id="A-特征点提取"><a href="#A-特征点提取" class="headerlink" title="A.特征点提取"></a>A.特征点提取</h2><p>我们首先从激光雷达云$P_k$中提取特征点，如图$3$所示的激光雷达在$P_k$中自然地产生了分布不均匀的点。在一个扫描中，从激光扫描仪返回的分辨率为$0.25^◦$，这些点位于扫描平面上。然而，当激光扫描仪以$180^◦/s$的角速度旋转，并产生40Hz的扫描，在垂直方向的扫描平面的分辨率是$180^◦/40 = 4.5^◦$。考虑到这一事实，在$P_k$中提取特征点时，仅使用单个扫描的信息，且具有共面几何关系。</p><p>我们选择尖锐边缘上的特征点和平面表面的特征点。设$i$是$P_k$中的一个点，$i\in P_k$，设$S$是激光扫描仪在同一次扫描中返回的$i$的连续点的集合。由于激光扫描器以$CW$或$CCW$顺序生成点返回，$S$包含一半位于$i$和两点之间$0.25^◦$间隔的每一边上的点。定义一个术语来评估局部表面的平滑度，</p><script type="math/tex; mode=display">c=\frac{1}{|S|·\parallel X^L_{(k,i)}\parallel} \sum_{j\in S,j\ne i} \parallel (X^L_{(k,i)}-X^L_{(k,j)}) \parallel \tag{1}</script><p>根据$c$值对扫描中的点进行排序，选择$c$值最大的点为边缘点，$c$值最小的点为平面点的特征点。为了在环境中均匀分布特征点，我们将扫描分割成四个相同的子区域。每个子区域最多可提供$2$个边缘点和$4$个平面点。只有当点$i$的$c$值大于或小于一个阈值，且所选点的个数不超过最大值时，才能将点$i$选择为边或平面点。</p><p><img src="/posts/36439.htm/image-20220410153159251.png" alt="image-20220410153159251"></p><blockquote><p>图4所示。$(a)$实线段表示局部表面贴片。点$A$位于与激光束有一定角度的表面上(虚线橙色线段)。点$B$在一个大致平行于激光束的表面上。我们将$B$作为一个不可靠的激光返回点，不选择它作为特征点。$(b)$实线段是激光的可观测对象。点$A$位于被遮挡区域(虚线橙线段)的边界上，可以被检测为边缘点。然而，如果从不同的角度看，被遮挡的区域会发生变化，变得可以观察到。我们不把$A$作为显著边缘点，也不选择它作为特征点。</p></blockquote><p>在选择特征点时，我们希望避免选择周围点被选择的点，或者大致平行于激光束的局部平面上的点(图$4(a)$中的点$B$)。这些观点通常被认为是不可靠的。此外，我们希望避免在被遮挡区域边界上的点[23]。如图$4(b)$所示为一个例子。点$A$是激光雷达云中的边缘点，因为它的连接面(虚线段)被另一个物体遮挡。然而，如果激光雷达移动到另一个视点，被遮挡区域就会发生变化，成为可观测的。为了避免前面提到的待选点，我们再次找到点$S$的集合。只有当$S$它不能在大致平行于激光束的表面上，也不能在被遮挡区域的边界上。不形成一个大致平行于激光束的表面贴片时，点$i$才能被选择。在$S$中，没有一个点在激光束方向上通过间隙与$i$断开，同时比$i$更靠近激光雷达(如图$4(b)$中的B点)。</p><p>综上所述，从$c$值的最大值开始选取特征点作为边缘点，从$c$值的最小值开始选取特征点作为平面点，如果选取一个点，</p><ul><li>选择的边缘点或平面点的数量不能超过子区域的最大值</li><li>它周围的点都没有被选中</li><li>它不能在大致平行于激光束的表面上，也不能在被遮挡区域的边界上。</li></ul><p>从走廊场景中提取特征点的示例如图$5$所示。边缘点和平面点分别用黄色和红色标记。</p><p><img src="/posts/36439.htm/image-20220410153221345.png" alt="image-20220410153221345"></p><blockquote><p>图$5$所示。从走廊的激光雷达云中提取边缘点(黄色)和平面点(红色)的例子。同时，激光雷达以$0.5m/s$的速度向图左侧的壁面移动，导致壁面运动失真。</p></blockquote><h2 id="B-寻找特征点对应"><a href="#B-寻找特征点对应" class="headerlink" title="B.寻找特征点对应"></a>B.寻找特征点对应</h2><p>里程计算法估计激光雷达在扫描范围内的运动。设$t_k$为扫描$k$的起始时间。在每次扫描结束时，将扫描过程中感知到的点云$P_k$重新投影到时间戳$t_{k+1}$，如图$6$所示。我们将重新投影的点云表示为$\overline{P}_k$。在下一次扫描$k+1$时，$\overline{P}_k$和新接收到的点云$P_{k+1}$一起使用，来估计激光雷达的运动。</p><p><img src="/posts/36439.htm/image-20220410153230555.png" alt="image-20220410153230555"></p><blockquote><p>图$6$所示。将点云重新投影到扫描的末端。蓝色线段表示扫描$k$时感知到的点云 $P_k$，在扫描$k$结束时，将$P_k$重新投影到时间戳$t_{k+1}$，得到绿色线段$\overline{P}_k$。然后，在扫描$k+1$时，$\overline{P}_k$和新感知的点云$P_{k+1}$(橙色线段)一起估计激光雷达运动。</p></blockquote><p>让我们假设$\overline{P}_k$和$P_{k+1}$现在都是可用的，然后从找到两个激光雷达云之间的对应关系开始。对于$P_{k+1}$，我们使用上一节讨论的方法从激光雷达云中找到边缘点和平面点。设$\xi_{k+1}$和$H_{k+1}$分别为边点和平面点的集合。我们将从$\overline{P}_k$中找到与$\xi_{k+1}$中的点对应的边线，从平面图中找到与$H_{k+1}$中的点对应的平面贴片(patch)。</p><p>请注意，在扫描$k+1$开始时，$P_{k+1}$是一个空集，它在扫描过程中随着接收到更多点数而增长。激光雷达里程计递归地估计了扫描期间的$6-DOF$运动，并随着$P_{k+1}$的增加逐渐包含更多的点。在每次迭代中，使用当前估计的变换将$\xi_{k+1}$和$H_{k+1}$重新投影到扫描的开始，记$\tilde{\xi}_{k+1}$和$\tilde{H}_{k+1}$为重投影的点集。对于每个点在$\xi_{k+1}$和$H_{k+1}$，我们将在$\overline{P}_k$中找到最近的邻居点。在这里，$\overline{P}_k$被存储在$3D$  $ KD-tree$[24]中，用于快速索引。</p><p>图$7(a)$给出了寻找边缘点对应的边线的过程。设$i$是属于$\tilde{\xi}_{k+1}$的点，即$ i \in \tilde{\xi}_{k+1}$。边线由两个点表示。设$j$是$i$在$\overline{P}_k$中的最近邻，$j\in \overline{P}_k$，设$l$是$i$在连续两次扫描$j$时的最近邻，$(j, l)$构成$i$的对应关系。然后，为了验证$j$和$l$都是边缘点，我们根据公式$(1)$来检查局部表面的平滑度。这里，我们特别要求$j$和$l$来自不同的扫描，考虑到一次扫描不能包含来自同一边线的多个点。只有一个例外，即边缘线在扫描平面上。然而，如果是这样，边缘线就会退化且<br>在扫描平面上显示为一条直线，并且特征点在边缘线上不应该首先被提取。</p><p><img src="/posts/36439.htm/image-20220410153242817.png" alt="image-20220410153242817"></p><blockquote><p>图7所示。在$\tilde{\xi}_{k+1}$中找到一条边缘线作为边缘点的对应关系，如图$(a)$，以及作为$\tilde{H}_{k+1}$中平面点的对应关系的平面贴片(patch)，如图$(b)$。在$(a)$和$(b)$中，$j $是距离特征点最近的点，在$\overline{P}_k$中找到。橙色的线表示对j的相同扫描，蓝色的线表示连续的两次扫描。为了找出$(a)$中的边线对应关系，我们在蓝色的直线上找到另一个点$l$，对应关系用$(j, l)$表示。为了找到$(b)$中的平面贴片(patch)对应关系，我们发现另外两个点，$l $和 $m$，分别位于橙色和蓝色线上。对应关系为$(j, l, m)$。</p></blockquote><p>图$7(b)$显示了寻找平面贴片(patch)作为平面点对应的过程。设$ i$ 为$\tilde{H}_{k+1}$中的一个点，即$i \in  \tilde{H}_{k+1}$。平面贴片(patch)由三个点表示。与上一段类似，我们在$\overline{P}_k$中找到$ i $的最近邻，记为$j$。 然后，我们找到另外两个点 $l$ 和$ m$，作为$ i $的最近邻，一个在$j $的同一扫描中，另一个在 $j $的两次连续扫描中。 这保证了三个点是非共线的。 为了验证 $j$、$l$和 $m$ 都是平面点，我们根据$ (1) $再次检查局部表面的平滑度。</p><p>根据特征点的对应关系，推导出特征点到对应关系的距离表达式。在下一节中，我们将通过最小化特征点的整体距离来恢复激光雷达运动。我们从边点开始。对于点$ i \in \tilde{\xi}_{k+1}$，如果$(j, l)$是对应的边线，$j,l \in \overline{P}_k$，则点到线的距离可以计算为</p><script type="math/tex; mode=display">d_{\xi}=\frac{|(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})×(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,l)})|}{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|},\tag{2}</script><p>其中$\tilde{X}^L_{(k+1,i)},\overline{X}^L_{(k,j)}$， 和$\overline{X}^L_{(k,l)}$分别是点$i, j, l$在$\left\{L\right\}$中的坐标。那么，对于点$i \in  \tilde{H}_{k+1}$，如果$(j, l, m)$是对应的平面贴片(patch),$j,l,m \in \overline{P}_k$，则点到平面的距离为</p><script type="math/tex; mode=display">d_H=\frac{\begin{vmatrix}(\tilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})\\((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)}))\end{vmatrix}}{\begin{vmatrix}(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})×(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,m)})\end{vmatrix} },\tag{3}</script><p>其中$\overline{X}^L_{(k,m)}$是点$m$在$\left\{L\right\}$中的坐标。</p><h2 id="C-运动估计"><a href="#C-运动估计" class="headerlink" title="C.运动估计"></a>C.运动估计</h2><p>激光雷达运动在扫描期间以恒定的角速度和线速度建模。这允许我们在一个扫描中对在不同时间接收到的点进行线性插值。假设$t$是当前的时间戳，$t_{k+1}$是扫描$k+1$的开始时间。设$T^L_{k+1}$为$[t_{k+1}, t]$之间的激光雷达位姿变换。$T^L_{k+1}$包含$6$自由度激光雷达的刚性运动，$T^L_{k+1} = [t_x, t_y, t_z， θ_x， θ_y， θ_z]^T$，其中$t_x$、$t_y$和$t_z$分别是$\left\{L\right\}$沿$x-$、$y-$和$z-$轴的平移，$θ_x$、$θ_y$和$θ_z$是旋转角度，遵循右手规则。给定点$i，i \in P_k$，设$t_i$为其时间戳，设为$[t_{k+1}, t_i]$之间的$T^L_{(k+1,i)}$位姿变换。$T^L_{(k+1,i)}$可以通过$T^L_{k+1}$的线性插值得到，</p><script type="math/tex; mode=display">T^L_{(k+1,i)}=\frac{t_i-t_{k+1} }{t-t_{k+1} }T^L_{k+1}.\tag{4}</script><p>回想一下，$\xi_{k+1} $和 $H_{k+1}$ 是从 $P_{k+1}$ 中提取的边缘点和平面点的集合，$\tilde \xi_{k+1} $ 和$\tilde H_{k+1}$ 是重新投影到扫描开始$ t_{k+1}$的点集合 。为了解决激光雷达运动，我们需要建立$\xi_{k+1} $和$\tilde \xi_{k+1} $或$H_{k+1}$ 和$\tilde H_{k+1}$ 之间的几何关系。利用$(4)$中的变换，我们可以推导，</p><script type="math/tex; mode=display">X^L_{(k+1,i)}=R\tilde X^L_{(k+1,i)}+T^L_{(k+1,i)}(1:3),\tag{5}</script><p>其中$X^L_{(k+1,i)}$是$\xi_{k+1} $或$H_{k+1}$中的点$i$的坐标，$\tilde X^L_{(k+1,i)}$是$\tilde \xi_{k+1} $或$\tilde H_{k+1}$中的点$i$的坐标，$(a:b)$是$T^L_{(k+1,i)}$的第$a$到$b$个项，$R$是由$Rodrigues$公式[25]定义的旋转矩阵。</p><script type="math/tex; mode=display">R=e^{\hat{w} \theta}=I + \hat{w}sin\theta+\hat{w}^2(1-cos\theta).\tag{6}</script><p>在上式中，$θ$为旋转的大小，</p><script type="math/tex; mode=display">\theta = \parallel T^L_{(k+1,i)}(4:6) \parallel,\tag{7}</script><p>$w$是表示旋转方向的单位向量，</p><script type="math/tex; mode=display">w=\frac{T^L_{(k+1,i)}(4:6)}{\parallel T^L_{(k+1,i)}(4:6) \parallel},\tag{8}</script><p>$\hat{w}$为$w$的斜对称矩阵[25]。</p><p>回忆$(2)$和$(3)$计算属于$\tilde \xi_{k+1} $ 和$\tilde H_{k+1}$ 的点之间的距离及其对应关系。结合$(2)$和$(4)-(8)$，我们可以推导出$\xi_{k+1}$中的一个边点与相应的边线之间的几何关系，</p><script type="math/tex; mode=display">f_{\xi}(X^L_{(k+1,i)},T^L_{k+1})=d_\xi,i\in \xi_{k+1}.\tag{9}</script><p>同样，结合$(3)(4)-(8)$，我们可以在$H_{k+1}$中的一个平面点与对应的平面贴片(patch)建立另一个几何关系，</p><script type="math/tex; mode=display">f_H(X^L_{(k+1,i)},T^L_{k+1})=d_H,i\in H_{k+1}.\tag{10}</script><p>最后，我们用<code>Levenberg-Marquardt</code>方法[26]求解激光雷达运动。将$\xi_{k+1}$和$H_{k+1}$中每个特征点$(9)$和$(10)$叠加，得到一个非线性函数:</p><script type="math/tex; mode=display">f(T^L_{k+1})=d,\tag{11}</script><p>其中每一行$f$对应一个特征点，$d$包含相应的距离。我们计算$f$关于$T^L_{k+1}$的雅可比矩阵，记作$J$，其中$J =\partial f /\partial T^L_{k+1}$。然后，$(11)$通过非线性迭代，使$d$趋近于$0$，</p><script type="math/tex; mode=display">T^L_{k+1}\gets T^L_{k+1}-(J^TJ+\lambda diag(J^TJ))^{-1}J^Td.\tag{12}</script><p>$\lambda$是由<code>Levenberg-Marquardt</code>方法确定的因子。</p><h2 id="D-激光雷达里程计算法"><a href="#D-激光雷达里程计算法" class="headerlink" title="D.激光雷达里程计算法"></a>D.激光雷达里程计算法</h2><p><img src="/posts/36439.htm/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p>激光雷达里程计算法如算法1所示。该算法以上次扫描的点云$\overline{P}_k$、当前扫描的增长点云$P_{k+1}$和上次递归的位姿变换$T^L_{k+1}$作为输入。如果启动了新的扫描，$T^L_{k+1}$将被设置为零(第$4-6$行)。然后，算法从$P_{k+1}$中提取特征点构造第$7$行$\xi_{k+1}$和$H_{k+1}$。对于每个特征点，我们可以在$\overline{P}_k$(第$9-19$行)中找到对应。运动估计适应于鲁棒拟合[27]。在第$ 15 $行，该算法为每个特征点分配一个平方权值。 与其对应的距离较大的特征点被分配较小的权重，距离大于阈值的特征点被视为异常值并分配零权重。然后，在第$ 16 $行，为一次迭代更新位姿变换。 当发现收敛或满足最大迭代次数时，非线性优化终止。 如果算法到达扫描结束，则使用扫描期间估计的运动将$P_{k+1}$重新投影到时间戳 $t_{k+2}$。 否则，仅返回变换$T^L_{k+1}$ 用于下一轮递归。</p><h1 id="VI-激光雷达建图"><a href="#VI-激光雷达建图" class="headerlink" title="VI.激光雷达建图"></a>VI.激光雷达建图</h1><p><img src="/posts/36439.htm/image-20220410153350151.png" alt="image-20220410153350151"></p><blockquote><p>图 8. 建图过程示意图。 蓝色曲线表示地图上的激光雷达位姿$T^W_k$ ，由建图算法在扫描 $k $处生成。 橙色曲线表示扫描 $k + 1$ 期间的激光雷达运动$T^L_{k+1}$，由里程计算法计算得出。 使用$ T^W_k$和$T^L_{k+1}$，将里程计算法发布的未失真点云投影到地图上，表示为（绿色线段）$\overline{Q}_{k+1}$，并与地图上现有的云$ Q_k$（黑色线段）进行匹配。</p></blockquote><p>建图算法运行的频率比里程计算法低，并且每次扫描只调用一次。在扫描 $k + 1$结束时，即介于$ [t_{k+1}, t_{k+2 }]$，激光雷达里程计生成一个未失真的点云$\overline{P}_{k+1}$，同时生成一个激光雷达的位姿变换$T^L_{k+1}$。建图算法在世界坐标$\left\{W\right\}$中匹配并注册$\overline{P}_{k+1}$，如图$8$所示。为了解释这个过程，让我们将$ Q_k$ 定义为累积到扫描 $k$的地图上的点云，设 $T^W_k$是扫描 $k $在$t_{k+1}$结束时，激光雷达在地图上的位姿。利用激光雷达里程计的输出，建图算法将 $T^W_k$扩展到从$t_{k+1}$到 $t_{k+2}$的一次扫描，以获得$T^W_{k+1}$，并将 $\overline{P}_{k+1}$投影到世界坐标$\left\{W\right\}$中，表示为$\overline{Q}_{k+1}$。 接下来，该算法通过优化激光雷达位姿$T^W_{k+1}$，将$\overline{Q}_{k+1}$ 与$ Q_k$ 匹配。</p><p>特征点的提取方法与第$V-A$节相同，但使用了$ 10 $倍的特征点。 为了找到特征点的对应关系，我们将点云存储在地图上$ Q_k$，在 $10$ 立方米区域中。立方体中与$\overline{Q}_{k+1}$相交的点被提取并存储在 $3D$  $KD-tree$ [24] 中。 我们发现$ Q_k$中的点在特征点周围的某一区域内。令$ S^\prime $为一组周围点。 对于边缘点，我们只在 $ S^\prime $中保留边缘线上的点，对于平面点，我们只保留平面上的点。然后，计算 $ S^\prime $的协方差矩阵，记为$M$, $M$的特征值和特征向量，分别记为$V$和$E$。如果$ S^\prime $分布在一条边线上，$V$包含的一个特征值明显大于其他两个特征值，$E$中与最大特征值相关联的特征向量表示边缘线的方向。另一方面，如果$ S^\prime $分布在一个平面贴片(patch)上，$V$包含两个较大的特征值，第三个特征值明显较小，$E$中最小的特征值对应的特征向量表示该平面贴片(patch)的方位。通过$ S^\prime $的几何中心确定边缘线或平面贴片(patch)的位置。</p><p>为了计算特征点与其对应点的距离，我们在边缘线上选择两个点，在平面贴片(patch)上选择三个点。这允许使用$(2)$和$(3)$相同的公式来计算距离。然后，为每个特征点推导出一个方程为$(9)$ 或 $(10)$，但不同之处在于$\overline{Q}_{k+1}$ 中的所有点共享相同的时间戳$t_{k+2}$。 非线性优化通过 <code>Levenberg-Marquardt</code>方法 [26] 通过鲁棒拟合 [27] 再次求解，并在$\overline{Q}_{k+1}$被注册在地图上。为了均匀分布这些点，地图云通过体素网格过滤器 [28] 缩小尺寸，体素大小为 5 厘米立方体。</p><p><img src="/posts/36439.htm/image-20220410153401364.png" alt="image-20220410153401364"></p><blockquote><p>图 9. 位姿变换的集成。 蓝色区域说明了建图算法 $T^W_k$ 的激光雷达位姿，每次扫描生成一次。 橙色区域是当前扫描 $T^L_{k+1} $内的激光雷达运动，由里程计算法计算得出。 激光雷达的运动估计是两种变换的组合，频率与 $T^L_{k+1} $相同。</p></blockquote><p>位姿变换的集成如图 $9 $所示。蓝色区域代表激光雷达映射 $T^W_k$ 的位姿输出，每次扫描生成一次。 橙色区域表示来自激光雷达里程计的变换输出$T^L_{k+1} $，频率约为$ 10Hz$。 相对于地图的激光雷达姿态是两种变换的组合，频率与激光雷达里程计相同。</p><h1 id="VII-实验"><a href="#VII-实验" class="headerlink" title="VII.实验"></a>VII.实验</h1><p>在实验期间，在$2.5GHz$四核$6Gib$内存的笔记本电脑上，在Linux下的机器人操作系统$(ROS)$[29]上对激光雷达数据进行了处理。 该方法总共消耗两个核心，里程计和建图程序在两个独立的核心上运行。 我们的软件代码和数据集是公开的$^{1,2}$。</p><blockquote><p>1wiki.ros.org/loam_back_and_forth<br>2wiki.ros.org/loam_continuous</p></blockquote><h2 id="A-室内和室外测试"><a href="#A-室内和室外测试" class="headerlink" title="A.室内和室外测试"></a>A.室内和室外测试</h2><p>该方法已在室内和室外环境中进行了测试。在室内测试中，激光雷达与电池和笔记本电脑一起放置在一个推车上。一个人推着手推车走。图$10(a)$和图$10(c)$展示了两种典型的室内环境，一个狭长走廊和一个大厅的地图。图$10(b)$和图$10(d)$为同一场景拍摄的两张照片。</p><p><img src="/posts/36439.htm/image-20220410153413911.png" alt="image-20220410153413911"></p><blockquote><p>图10所示。$(a)-(b)$狭长的走廊，$(c)-(d)$大厅，$(e)-(f)$植被覆盖的道路和$(g)-(h)$两行树木之间的果园生成的地图。激光雷达在室内测试中放置在手推车上，在室外测试中安装在地面车辆上。所有测试使用$0.5m/s$的速度。</p></blockquote><p>为了评估地图的局部准确性，我们从相同的环境中收集了第二组激光雷达云。在数据选择过程中，激光雷达保持静止，并放置在每个环境中的几个不同的位置。使用点对面$ICP$方法[9]对两个点云进行匹配和比较。 匹配完成后，将一个点云与第二个点云中对应的平面块之间的距离视为匹配误差。 图 $11 $显示了误差分布的密度。室内匹配误差小于室外匹配误差。结果是合理的，因为在自然环境中特征匹配不如在人造环境中精确。</p><p><img src="/posts/36439.htm/image-20220410153427498.png" alt="image-20220410153427498"></p><blockquote><p>图11所示。廊道(红色)、大堂(绿色)、绿化路(蓝色)、果园(黑色)的匹配误差，对应图$10$中的四个场景。</p></blockquote><p><img src="/posts/36439.htm/image-20220410153545569.png" alt="image-20220410153545569"></p><p>此外，我们还对运动估计的累积漂移进行了测试。我们选择包含闭环的走廊进行室内实验。这使得我们可以在同一个地方开始和结束。运动估计在起始位置和结束位置之间产生一个间隙，该间隙表明了漂移量。对于户外实验，我们选择果园环境。 携带激光雷达的地面车辆配备了高精度 $GPS/INS$，用于获取地面实况。 将测得的漂移与行进距离作为相对精度进行比较，并列于表$ I$。具体来说，测试$ 1 $使用与图 $10(a)$ 和图 $10(g) $相同的数据集。 一般来说，室内测试的相对准确度在$ 1\% $左右，室外测试的相对准确度在 $2.5\% $左右。</p><h2 id="B-融合IMU"><a href="#B-融合IMU" class="headerlink" title="B.融合IMU"></a>B.融合IMU</h2><p>我们将<code>Xsens MTi-10 IMU</code> 连接到激光雷达以应对快速的速度变化。 点云在发送到所提出的方法之前以两种方式进行预处理，$1)$ 使用来自 $IMU$ 的方向，在一次扫描中接收到的点云被旋转，使得与该扫描中激光雷达的初始方向对齐，$2)$ 使用加速度测量 ，运动失真被部分消除，就好像激光雷达在扫描过程中以恒定速度移动一样。 然后由激光雷达里程计和建图程序处理点云。</p><p>$IMU $定位是通过在卡尔曼滤波器 [1] 中集成来自陀螺仪的角速率和来自加速度计的读数来获得的。 图 $12(a) $显示了一个示例结果。 一个人拿着激光雷达走在楼梯上。 在计算红色曲线时，我们使用 IMU 提供的方向，我们的方法只估计平移。 在 $5 $分钟的数据收集过程中，方向漂移超过 $25°$。 假设没有可用的$ IMU$，绿色曲线仅依赖于我们方法中的优化。 蓝色曲线使用$ IMU $数据进行预处理，然后采用本文方法。 我们观察到绿色和蓝色曲线之间的微小差异。 图 $12(b) $给出了对应于蓝色曲线的图。 在图$ 12(c)$中，我们比较了图 $12(b)$中黄色矩形中地图的两个闭合视图。 上图和下图分别对应蓝色和绿色曲线。 仔细对比发现，上图的边缘更加清晰。</p><p><img src="/posts/36439.htm/image-20220410153604781.png" alt="image-20220410153604781"></p><p><img src="/posts/36439.htm/image-20220410153615690.png" alt="image-20220410153615690"></p><blockquote><p>图 $12$所示。有/无$IMU$ 辅助的结果比较。 一个人拿着激光雷达走在楼梯上。 黑点是起点。 在$(a)$中，红色曲线使用来自$ IMU $的方向和我们的方法估计的平移来计算，绿色曲线仅依赖于我们方法中的优化，蓝色曲线使用$ IMU$数据进行预处理，然后再进行该方法。 $(b)$是对应于蓝色曲线的地图。 在$(c)$中，上图和下图分别对应于蓝色和绿色曲线，使用$(b)$中黄色矩形标记的区域。 上图中的边缘更清晰，表明地图上的准确性更高。</p></blockquote><p>表 $II$ 比较了使用和不使用$ IMU $的运动估计的相对误差。 激光雷达由一个人以$0.5m/s $的速度行走并以$ 0.5m $左右的幅度上下移动激光雷达。 地面实况(ground truth)是由卷尺手动测量的。 在所有四个测试中，在$ IMU $的帮助下使用所提出的方法可以获得最高的准确度，而使用 $IMU$ 定位只会导致最低的准确度。 结果表明，$IMU$有效地消除了非线性运动，所提出的方法利用它来处理线性运动。</p><h2 id="C-使用-KITTI-数据集进行测试"><a href="#C-使用-KITTI-数据集进行测试" class="headerlink" title="C.使用 KITTI 数据集进行测试"></a>C.使用 KITTI 数据集进行测试</h2><p><img src="/posts/36439.htm/image-20220410153653541.png" alt="image-20220410153653541"></p><blockquote><p>图 13. $(a) $KITTI 基准测试使用的传感器配置和车辆。该车辆安装有 Velodyne 激光雷达、立体摄像头和用于获取地面实况的高精度 GPS/INS。我们的方法仅使用来自 Velodyne 激光雷达的数据。$(b)$ 来自城市场景的示例激光雷达云（上图）和相应的视觉图像（下图）。</p></blockquote><p>我们还使用来自 KITTI 里程计基准 [30]、[31] 的数据集评估了我们的方法。数据集仔细地与安装在结构化道路上行驶的乘用车顶部的传感器相注册（图 $13(a)$）。车辆配备$ 360° $Velodyne 激光雷达、彩色/单色立体摄像头、以及用于地面实况(ground truth)的高精度 GPS/INS，激光雷达数据以 $10Hz $记录，并由我们的方法用于里程计估计。由于篇幅问题，我们无法将结果包括在内。但是，我们鼓励读者在评估(benchmark)网站上查看我们的结果$^3$。</p><blockquote><p>3www.cvlibs.net/datasets/kitti/eval_odometry.php</p></blockquote><p>数据集主要涵盖三类环境：周围有建筑物的“城市”、场景中有植被的小路上的“乡村”以及道路较宽且周围环境相对干净的“高速公路”。图 13$(b)$ 显示了一个示例激光雷达云和来自城市环境的相应视觉图像。数据集中包含的总行驶距离为$ 39.2 $公里。上传车辆轨迹后，评估(benchmark)服务器会自动计算准确性和排名。我们的方法在评估(benchmark)的所有方法中排名第一，无论传感方式如何，包括最先进的立体视觉里程计 [32]、[33]。平均位置误差是行进距离的 $0.88\%$，使用 $3D $坐标中 $100m、200m、…、800m $长度的轨迹段生成。</p><h1 id="VIII-结论和未来的工作"><a href="#VIII-结论和未来的工作" class="headerlink" title="VIII. 结论和未来的工作"></a>VIII. 结论和未来的工作</h1><p>使用来自旋转激光扫描仪的点云进行运动估计和建图可能很困难，因为该问题涉及激光雷达云中运动的恢复和运动失真的校正。所提出的方法通过并行运行的两种算法来划分和解决问题：激光雷达里程计进行粗略处理以估计较高频率的速度，而激光雷达建图执行精细处理以在较低频率创建地图。两种算法的合作允许实时准确的运动估计和建图。此外，该方法可以利用激光雷达扫描模式和点云分布。进行特征匹配以确保里程计算法中的快速计算，并增建图算法的准确性。该方法已在室内和室外以及 KITTI 里程计评估(benchmark)上进行了测试。</p><p>由于当前的方法不能识别闭环，我们未来的工作包括开发一种通过闭环来修复运动估计漂移的方法。此外，我们将我们方法的输出与卡尔曼滤波器中的 IMU 集成，以进一步减少运动估计漂移。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;LOAM是Ji Zhang于2014年提出的使用激光雷达完成定位与三维建图的算法，即Lidar Odometry and Mapping。之后许多激光SLAM算法借鉴了LOAM中的一些思想，可以说学习LOAM对学习3D激光SLAM很有帮助。本文对LOAM原论文进行了翻译。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="LOAM" scheme="https://lukeyalvin.top/tags/LOAM/"/>
    
    <category term="文献阅读" scheme="https://lukeyalvin.top/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>位姿图优化</title>
    <link href="https://lukeyalvin.top/posts/40808.html"/>
    <id>https://lukeyalvin.top/posts/40808.html</id>
    <published>2022-04-07T08:57:07.783Z</published>
    <updated>2022-04-26T01:20:20.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>我们可以构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。通过这种方式，我们省去了大量的特征点优化的计算，只保留了关键帧的轨迹，从而构建了所谓的位姿图（Pose Graph）。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>我们将带有相机位姿和空间点的图优化称为 BA，能够有效地求解大规模的定位与建图问题。但是考虑大场景以及实时性的要求，我们不得不想办法缩减计算量，这就是引入位姿图的意义。</p><p><img src="/posts/40808.htm/image-20220407170107621.png" alt="image-20220407170107621"></p><h1 id="g2o-原生位姿图"><a href="#g2o-原生位姿图" class="headerlink" title="g2o 原生位姿图"></a>g2o 原生位姿图</h1><p>Pose Graph 图优化的<strong>节点</strong>表示相机位姿，以 $\xi_1,\xi_2,…,\xi_n$来表达。而<strong>边</strong>，则是两个位姿节点之间相对运动的估计，该估计可能来自于特征点法或直接法。</p><p><img src="/posts/40808.htm/image-20220408092815957.png" alt="image-20220408092815957"></p><p><code>g2o</code>仿真产生的位姿图，由 <code>g2o</code>自带的 create sphere 程序仿真生成的。它的真实轨迹为一个球，由从下往上的多个层组成。每层为一个正圆形，很多个大小不一的圆形层组成了一个完整的球体，共包含 2500 个位姿节点，可以看成一个转圈上升的过程。然后，仿真程序生成了$ t − 1 $到 $t$ 时刻的边，称为<code>odometry</code><strong>边（里程计）</strong>。此外，又生成层与层之间的边，称为 <strong>loop closure（回环）</strong>。</p><p>sphere.g2o 也是一个文本文件，可以用文本编辑器打开，查看它里面的内容。文件前半部分由节点组成，后半部分则是边：</p><p><img src="/posts/40808.htm/image-20220408093444275.png" alt="image-20220408093444275"></p><p>可以看到，节点类型是 VERTEX_SE3，表达一个相机位姿。 g2o 默认使用四元数和平移向量表达位姿，所以后面的字段意义为：$ ID， t_x , t_y , t_z , q_x , q_y , q_z , q_w $。前三个为平移向量元素，后四个为表示旋转的单位四元数。同样，边的信息为：两个节点的 $ID， t _x , t _y , t _z , q _x , q _y , q _z , q _w$ ，信息矩阵的右上角（由于信息矩阵为对称阵，只需保存一半即可）。可以看到这里把信息矩阵设成了对角阵。</p><p>为了优化该位姿图，我们可以使用 g2o 默认的顶点和边，它们是由四元数表示的。由于仿真数据也是 g2o 生成的，所以用 g2o 本身优化就无需我们多做什么工作了，只需配置一下优化参数即可。</p><p><code>pose_graph_g2o_SE3.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/slam3d/types_slam3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/cholmod/linear_solver_cholmod.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment"> * 本程序演示如何用g2o solver进行位姿图优化</span></span><br><span class="line"><span class="comment"> * sphere.g2o是人工生成的一个Pose graph，我们来优化它。</span></span><br><span class="line"><span class="comment"> * 尽管可以直接通过load函数读取整个图，但我们还是自己来实现读取代码，以期获得更深刻的理解</span></span><br><span class="line"><span class="comment"> * 这里使用g2o/types/slam3d/中的SE3表示位姿，它实质上是四元数而非李代数.</span></span><br><span class="line"><span class="comment"> * **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 传入待优化的信息</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入文件 sphere.g2o&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择了 6×6 的块求解器</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">6</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 1.线性方程求解器（LinearSolverCholmod使用sparse cholesky分解法。继承自LinearSolverCCS）</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver。（梯度下降方法，从GN, LM, DogLeg 中选）</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4、创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexCnt = <span class="number">0</span>, edgeCnt = <span class="number">0</span>; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">    <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读文件 sphere.g2o</span></span><br><span class="line">        string name;</span><br><span class="line">        fin &gt;&gt; name;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">&quot;VERTEX_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3 顶点</span></span><br><span class="line">            g2o::VertexSE3 *v = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3</span>();</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            fin &gt;&gt; index;</span><br><span class="line">            v-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">            v-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line">            vertexCnt++;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                v-&gt;<span class="built_in">setFixed</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;EDGE_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3-SE3 边</span></span><br><span class="line">            g2o::EdgeSE3 *e = <span class="keyword">new</span> g2o::<span class="built_in">EdgeSE3</span>();</span><br><span class="line">            <span class="keyword">int</span> idx1, idx2;</span><br><span class="line">            fin &gt;&gt; idx1 &gt;&gt; idx2;</span><br><span class="line">            e-&gt;<span class="built_in">setId</span>(edgeCnt++);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, optimizer.<span class="built_in">vertices</span>()[idx1]);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, optimizer.<span class="built_in">vertices</span>()[idx2]);</span><br><span class="line">            e-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addEdge</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fin.<span class="built_in">good</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读到&quot;</span> &lt;&lt; vertexCnt &lt;&lt; <span class="string">&quot;个点，&quot;</span> &lt;&lt; edgeCnt &lt;&lt; <span class="string">&quot;个边&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;准备优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;执行优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保存优化结果......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">save</span>(<span class="string">&quot;result.g2o&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_graph )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Eigen</span></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># sophus </span></span><br><span class="line"><span class="keyword">find_package</span>( Sophus REQUIRED )</span><br><span class="line"><span class="comment"># Sophus链接错误</span></span><br><span class="line"><span class="keyword">set</span>(Sophus_LIBRARIES libSophus.so)</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;Sophus_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># g2o </span></span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( Cholmod REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;CHOLMOD_INCLUDE_DIR&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_graph_g2o_SE3 pose_graph_g2o_SE3.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_graph_g2o_SE3</span><br><span class="line">    g2o_core g2o_stuff g2o_types_slam3d <span class="variable">$&#123;CHOLMOD_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>优化结束执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line">./build/pose_graph_g2o_SE3 ../sphere.g2o  </span><br><span class="line"><span class="comment"># 查看优化够的位姿图</span></span><br><span class="line">g2o_viewer result.g2o </span><br></pre></td></tr></table></figure><p><img src="/posts/40808.htm/image-20220408142818313.png" alt="image-20220408142818313"></p><h1 id="李代数上的位姿图优化"><a href="#李代数上的位姿图优化" class="headerlink" title="李代数上的位姿图优化"></a>李代数上的位姿图优化</h1><p>把 Sophus 用到 g2o 中，定义自己的顶点和边吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定误差求J_R^&#123;-1&#125;的近似</span></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">6</span>&gt; Matrix6d;</span><br><span class="line"><span class="function">Matrix6d <span class="title">JRInv</span><span class="params">(SE3 e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix6d J;</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>) = SO3::<span class="built_in">hat</span>(e.<span class="built_in">so3</span>().<span class="built_in">log</span>());</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = SO3::<span class="built_in">hat</span>(e.<span class="built_in">translation</span>());</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>) = Eigen::Matrix3d::<span class="built_in">Zero</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    J.<span class="built_in">block</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = SO3::<span class="built_in">hat</span>(e.<span class="built_in">so3</span>().<span class="built_in">log</span>());</span><br><span class="line">    J = J * <span class="number">0.5</span> + Matrix6d::<span class="built_in">Identity</span>();</span><br><span class="line">    <span class="keyword">return</span> J;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义李代数顶点"><a href="#定义李代数顶点" class="headerlink" title="定义李代数顶点"></a>定义李代数顶点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 李代数顶点</span></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Vector6d;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexSE3LieAlgebra</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">6</span>, SE3&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            is &gt;&gt; data[i];</span><br><span class="line">        <span class="built_in">setEstimate</span>(<span class="built_in">SE3</span>(Eigen::<span class="built_in">Quaterniond</span>(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>]),</span><br><span class="line">                        Eigen::<span class="built_in">Vector3d</span>(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        Eigen::Quaterniond q = _estimate.<span class="built_in">unit_quaternion</span>();</span><br><span class="line">        os &lt;&lt; _estimate.<span class="built_in">translation</span>().<span class="built_in">transpose</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        os &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate = Sophus::<span class="built_in">SE3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左乘更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Sophus::SE3 <span class="title">up</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Sophus::SO3(update[<span class="number">3</span>], update[<span class="number">4</span>], update[<span class="number">5</span>]),</span></span></span><br><span class="line"><span class="params"><span class="function">            Eigen::Vector3d(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]))</span></span>;</span><br><span class="line">        _estimate = up * _estimate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="定义李代数节点之边"><a href="#定义李代数节点之边" class="headerlink" title="定义李代数节点之边"></a>定义李代数节点之边</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个李代数节点之边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3LieAlgebra</span> :</span> <span class="keyword">public</span> g2o::BaseBinaryEdge&lt;<span class="number">6</span>, SE3, VertexSE3LieAlgebra, VertexSE3LieAlgebra&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            is &gt;&gt; data[i];</span><br><span class="line">        <span class="function">Eigen::Quaterniond <span class="title">q</span><span class="params">(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span></span>;</span><br><span class="line">        q.<span class="built_in">normalize</span>();</span><br><span class="line">        <span class="built_in">setMeasurement</span>(Sophus::<span class="built_in">SE3</span>(q, Eigen::<span class="built_in">Vector3d</span>(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">information</span>().<span class="built_in">rows</span>() &amp;&amp; is.<span class="built_in">good</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">information</span>().<span class="built_in">cols</span>() &amp;&amp; is.<span class="built_in">good</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                is &gt;&gt; <span class="built_in">information</span>()(i, j);</span><br><span class="line">                <span class="keyword">if</span> (i != j)</span><br><span class="line">                    <span class="built_in">information</span>()(j, i) = <span class="built_in">information</span>()(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VertexSE3LieAlgebra *v1 = <span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        VertexSE3LieAlgebra *v2 = <span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">        os &lt;&lt; v1-&gt;<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2-&gt;<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        SE3 m = _measurement;</span><br><span class="line">        Eigen::Quaterniond q = m.<span class="built_in">unit_quaternion</span>();</span><br><span class="line">        os &lt;&lt; m.<span class="built_in">translation</span>().<span class="built_in">transpose</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        os &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>()[<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">// information matrix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">information</span>().<span class="built_in">rows</span>(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">information</span>().<span class="built_in">cols</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                os &lt;&lt; <span class="built_in">information</span>()(i, j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        os &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 误差计算与书中推导一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::SE3 v1 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">0</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        Sophus::SE3 v2 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">1</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error = (_measurement.<span class="built_in">inverse</span>() * v1.<span class="built_in">inverse</span>() * v2).<span class="built_in">log</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 雅可比计算</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::SE3 v1 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">0</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        Sophus::SE3 v2 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra *&gt;(_vertices[<span class="number">1</span>]))-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        Matrix6d J = <span class="built_in">JRInv</span>(SE3::<span class="built_in">exp</span>(_error));</span><br><span class="line">        <span class="comment">// 尝试把J近似为I？</span></span><br><span class="line">        _jacobianOplusXi = -J * v2.<span class="built_in">inverse</span>().<span class="built_in">Adj</span>();</span><br><span class="line">        _jacobianOplusXj = J * v2.<span class="built_in">inverse</span>().<span class="built_in">Adj</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义文件传入</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请传入文件sphere.g2o&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件&quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择了 6×6 的块求解器</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">6</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 1.线性方程求解器（LinearSolverCholmod使用sparse cholesky分解法。继承自LinearSolverCCS）</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver。（梯度下降方法，从GN, LM, DogLeg 中选）</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4、创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexCnt = <span class="number">0</span>, edgeCnt = <span class="number">0</span>; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">    vector&lt;VertexSE3LieAlgebra *&gt; vectices;</span><br><span class="line">    vector&lt;EdgeSE3LieAlgebra *&gt; edges;</span><br><span class="line">    <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读文件 sphere.g2o</span></span><br><span class="line">        string name;</span><br><span class="line">        fin &gt;&gt; name;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">&quot;VERTEX_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3 顶点</span></span><br><span class="line">            VertexSE3LieAlgebra *v = <span class="keyword">new</span> <span class="built_in">VertexSE3LieAlgebra</span>(); <span class="comment">// 使用自定义的顶点</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            fin &gt;&gt; index;</span><br><span class="line">            v-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">            v-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line">            vertexCnt++;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                v-&gt;<span class="built_in">setFixed</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;EDGE_SE3:QUAT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3-SE3 边</span></span><br><span class="line">            EdgeSE3LieAlgebra *e = <span class="keyword">new</span> <span class="built_in">EdgeSE3LieAlgebra</span>(); <span class="comment">// 使用自定义的边</span></span><br><span class="line">            <span class="keyword">int</span> idx1, idx2;</span><br><span class="line">            fin &gt;&gt; idx1 &gt;&gt; idx2;</span><br><span class="line">            e-&gt;<span class="built_in">setId</span>(edgeCnt++);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, optimizer.<span class="built_in">vertices</span>()[idx1]);</span><br><span class="line">            e-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, optimizer.<span class="built_in">vertices</span>()[idx2]);</span><br><span class="line">            e-&gt;<span class="built_in">read</span>(fin);</span><br><span class="line">            optimizer.<span class="built_in">addEdge</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fin.<span class="built_in">good</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读到&quot;</span> &lt;&lt; vertexCnt &lt;&lt; <span class="string">&quot;个点，&quot;</span> &lt;&lt; edgeCnt &lt;&lt; <span class="string">&quot;个边&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;准备优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;执行优化......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保存优化结果......&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 因为用了自定义顶点且没有向g2o注册，这里保存自己来实现</span></span><br><span class="line">    <span class="comment">// 伪装成 SE3 顶点和边，让 g2o_viewer 可以认出</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;result_lie.g2o&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (VertexSE3LieAlgebra *v : vectices)</span><br><span class="line">    &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;VERTEX_SE3:QUAT &quot;</span>;</span><br><span class="line">        v-&gt;<span class="built_in">write</span>(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (EdgeSE3LieAlgebra *e : edges)</span><br><span class="line">    &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;EDGE_SE3:QUAT &quot;</span>;</span><br><span class="line">        e-&gt;<span class="built_in">write</span>(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;我们可以构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。通过这种方式，我们省去了大量的特征点优化的计算，只保留了关键帧的轨迹，从而构建了所谓的位姿图（Pose Graph）。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>g2o-viewer安装</title>
    <link href="https://lukeyalvin.top/posts/15722.html"/>
    <id>https://lukeyalvin.top/posts/15722.html</id>
    <published>2022-04-05T13:00:25.324Z</published>
    <updated>2022-04-26T01:20:20.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>g2o_viewer是g2o提供的位姿图优化的仿真程序，该位姿图是由 g2o 自带的 create sphere 程序仿真生成的。它的真实轨迹为一个球，由从下往上的多个层组成。每层为一个正圆形，很多个大小不一的圆形层组成了一个完整的<br>球体，共包含 2500 个位姿节点，可以看成一个转圈上升的过程。然后，仿真程序生成了 t − 1 到 t 时刻的边，称为 odometry 边（里程计）。此外，又生成层与层之间的边，称为 loop closure。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>首先，你要下载$g2o$:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.2 libcholmod-dev</span><br><span class="line"><span class="comment"># g2o_viewer依赖</span></span><br><span class="line">sudo apt-get install libsuitesparse-dev qtdeclarative5-dev qt5-qmake libqglviewer-dev-qt5</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> g2o</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>文件结构已经提过了</p><p><img src="/posts/15722.htm/image-20220405210455088.png" alt="image-20220405210455088"></p><p>我们的g2o_viewer源文件就在app里面：</p><p><img src="/posts/15722.htm/image-20220405210828391.png" alt="image-20220405210828391"></p><p>我们编译之后检查一下g2o源代码目录下<code>g2o\bin</code>下有没有生成g2o_viewer的可执行文件</p><p><img src="/posts/15722.htm/image-20220405211004286.png" alt="image-20220405211004286"></p><p>因为我们编译了，所以检查一下有没有在本地</p><p><img src="/posts/15722.htm/image-20220405211129848.png" alt="image-20220405211129848"></p><p>如果没有说明你没有<code>sudo make install</code>成功。</p><p>如果此时还不可以直接在终端打开g2o:</p><p><img src="/posts/15722.htm/image-20220405211231692.png" alt="image-20220405211231692"></p><p>这就是没有链接成功了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ld.so.conf</span><br></pre></td></tr></table></figure><p>然后加入：<code>include /usr/local/lib</code>,当然如果你有就不加咯</p><p>然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>然后就可以使用了！</p><p><img src="/posts/15722.htm/image-20220405211615903.png" alt="image-20220405211615903"></p><p>如果还不可以，那你指定哪一步不对劲！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;g2o_viewer是g2o提供的位姿图优化的仿真程序，该位姿图是由 g2o 自带的 create sphere 程序仿真生成的。它的真实轨迹为一个球，由从下往上的多个层组成。每层为一个正圆形，很多个大小不一的圆形层组成了一个完整的&lt;br&gt;球体，共包含 2500 个位姿节点，可以看成一个转圈上升的过程。然后，仿真程序生成了 t − 1 到 t 时刻的边，称为 odometry 边（里程计）。此外，又生成层与层之间的边，称为 loop closure。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="安装" scheme="https://lukeyalvin.top/categories/%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="安装" scheme="https://lukeyalvin.top/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>线性最小二乘</title>
    <link href="https://lukeyalvin.top/posts/44179.html"/>
    <id>https://lukeyalvin.top/posts/44179.html</id>
    <published>2022-04-04T08:46:33.032Z</published>
    <updated>2022-04-26T01:20:20.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>按偏差平方和最小的原则选取拟合曲线，并且采取二项式方程为拟合曲线的方法, 称为最小二乘法。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>常见的几种曲线拟合方式：</p><ul><li>使偏差绝对值之和最小</li></ul><script type="math/tex; mode=display">\underset{φ}{min} \sum^m_{1=1}|e_i|= \sum^m_{1=1}|φ(x_i)-y_i|</script><ul><li>使偏差平方和最小</li></ul><script type="math/tex; mode=display">\underset{φ}{min} \sum^m_{1=1}e_i^2= \sum^m_{1=1}(φ(x_i)-y_i)^2</script><ul><li>使偏差绝对值最大的最小</li></ul><script type="math/tex; mode=display">\underset{φ}{min} \underset{i}{max} \sum^m_{1=1}|e_i|= \sum^m_{1=1}|φ(x_i)-y_i|</script><p>按偏差平方和最小的原则选取拟合曲线，并且采取二项式方程为拟合曲线的方法, 称为最小二乘法。</p><h1 id="线性最小二乘"><a href="#线性最小二乘" class="headerlink" title="线性最小二乘"></a>线性最小二乘</h1><h2 id="一元线性回归求解过程"><a href="#一元线性回归求解过程" class="headerlink" title="一元线性回归求解过程"></a>一元线性回归求解过程</h2><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>举一个简单的例子，某次实验得到了四个数据点$(x,y):(1,6),(2,5),(3,7),(4,10)$，如图所示</p><p><img src="/posts/44179.htm/image-20220404164725825.png" alt="image-20220404164725825"></p><p>我们需要找到一条直线与这四个点的最佳匹配，设这条直线为$y=ax+b$，即找出在某种“最佳情况”下能够大致符合如下超定线性方程组的 $a,b$:</p><script type="math/tex; mode=display">1a+b=6\\2a+b=5\\3a+b=7\\4a+b=10\\</script><p>最小二乘法采用的方法是尽量使得等号两边的平方差最小，也就是找出这个函数的最小值：</p><script type="math/tex; mode=display">\begin{align*}S(a,b)&=[6-(1a+b)]^2+[5-(2a+b)]^2+[7-(3a+b)]^2+[10-(4a+b)]^2\\\end{align*}</script><p>最小值可以通过对$S(a,b)$分别求$a$和$b$的偏导数，然后使他们等于零得到。</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial S}{\partial a}&=8a+20b-56=0\\\frac{\partial S}{\partial a}&=20a+60b-154=0\end{align*}</script><p>如此就得到了一个只有两个未知数的方程组，很容易就可以解出：</p><script type="math/tex; mode=display">a=3.5\\b=1.4</script><p>也就是说直线$y=3.5x+1.4$是最佳的！</p><p>所以最小二乘法就是：寻找一个最能代表拟合数据的曲线，使得每个点到达这条曲线的距离最小。</p><h3 id="一般式推导"><a href="#一般式推导" class="headerlink" title="一般式推导"></a>一般式推导</h3><p>一般情况下，我们称$y=\theta_0+\theta_1x$为拟合函数，称$J(\theta_0,\theta_1)$为损失函数；</p><script type="math/tex; mode=display">J(\theta_0,\theta_1)=\sum^m_{i=0}(y_i-(\theta_0+\theta_1x))^2</script><p>损失函数$J(\theta_0,\theta_1)$分别对$\theta_0,\theta_1$求偏导：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial J(\theta_0,\theta_1)}{\theta_0}&=-2\sum^m_{i=0}(y_i-(\theta_0+\theta_1x_i))=0\\\frac{\partial J(\theta_0,\theta_1)}{\theta_1}&=-2\sum^m_{i=0}(y_i-(\theta_0+\theta_1x_i))x_i=0\\\\end{align*}</script><p>联立两式，求解可得：</p><script type="math/tex; mode=display">\begin{align*}\theta_1&=\frac{\sum \limits ^m_{i=1}(x_i-\overline{x})(y_i-\overline{y}) }{\sum \limits ^m_{i=1}(x_i-x)^2} \\\theta_0&=\overline{y}-\theta_1\overline{x}\end{align*}</script><h3 id="使用矩阵求解"><a href="#使用矩阵求解" class="headerlink" title="使用矩阵求解"></a>使用矩阵求解</h3><p>当$f(x)$取线性函数的形式:</p><script type="math/tex; mode=display">f(x)=Ax-b</script><p>其中A是m*n的矩阵，b是m维向量，损失函数可以表示为：</p><script type="math/tex; mode=display">min\parallel Ax-b\parallel^2</script><p>定理：$x^<em>$是极小点的充分必要条件是，$x^</em>$是方程组</p><script type="math/tex; mode=display">A^TAx=A^Tb</script><p>的解。</p><blockquote><p>这个定理的证明过程就是利用上文的求导方式进行的，详细查询相关资料。</p></blockquote><p>所以对于上面的案例：</p><script type="math/tex; mode=display">A=\begin{bmatrix}1&1\\2&1\\3&1\\4&1\\\end{bmatrix},b=\begin{bmatrix}6\\5\\7\\10\\\end{bmatrix}</script><p>求解：</p><script type="math/tex; mode=display">\begin{bmatrix}1&2 &3&4\\1&1 &1&1\\\end{bmatrix}\begin{bmatrix}1&1\\2&1\\3&1\\4&1\\\end{bmatrix}\begin{bmatrix}\theta_0\\\theta_1\\\end{bmatrix}=\begin{bmatrix}1&2 &3&4\\1&1 &1&1\\\end{bmatrix}\begin{bmatrix}6\\5\\7\\10\\\end{bmatrix}</script><p>易得：</p><script type="math/tex; mode=display">\begin{bmatrix}\theta_0\\ \theta_1\\\end{bmatrix}=\begin{bmatrix}1.4\\3.5\\\end{bmatrix}</script><h2 id="多元线性回归求解过程"><a href="#多元线性回归求解过程" class="headerlink" title="多元线性回归求解过程"></a>多元线性回归求解过程</h2><p>【背景】给定$m$组点$(x_{11},…,x_{1n},y_1),(x_{21},…,x_{2n},y_2),…,(x_{m1},…,x_{mn},y_m)$，求它的拟合曲线？</p><p>对于多元函数的拟合，可以设拟合函数为：$ h_θ(x_1,x_2,…x_n)=θ_1+θ_2x_{j1}+…+θ_nx_{jn}$</p><p>为了简化，我们增加一个特征值$x_0=1$使得$ h_θ(x_0,x_1,x_2,…x_n)=θ_1+θ_2x_{j1}+…+θ_nx_{jn}$</p><p>则每一组数为$(1,x_1,x_2,…,x_n,yj),j=1,2,…,m$，也就是求取最合适的系数$\theta_0,\theta_1,…\theta_n$,使得多元函数对所有点的拟合达到最佳！</p><p>损失函数：</p><script type="math/tex; mode=display">J(\theta)=\sum^m_{j=0}(y_j-(θ_1+θ_2x_{j1}+...+θ_nx_{jn})^2</script><p>分别对$\theta_1,\theta_2,…,\theta_n$，求偏导：</p><p>由于一共有$m$组数据，所以使用每一组数据对$\theta_1,\theta_2,…,\theta_n$分别求偏导，比如对$\theta_1$求偏导：</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial J_1(\theta)}{\partial \theta_1}&= \frac{\partial[ y_1-(θ_0+θ_1x_{11} +...+θ_nx_{1n})]^2}{\partial \theta_1}\\\frac{\partial J_2(\theta)}{\partial \theta_1}&= \frac{\partial[ y_2-(θ_0+θ_1x_{21} +...+θ_nx_{2n})]^2}{\partial \theta_1}\\&......\\\frac{\partial J_m(\theta)}{\partial \theta_1}&= \frac{\partial[ y_m-(θ_0+θ_1x_{m1} +...+θ_nx_{mn})]^2}{\partial \theta_1}\end{align*}</script><p>我们可以得到一个雅可比矩阵：</p><script type="math/tex; mode=display">J(\theta)=\begin{bmatrix}\frac{\partial J_1(\theta)}{\partial \theta_1}&\frac{\partial J_2(\theta)}{\partial \theta_1}&...&\frac{\partial J_m(\theta)}{\partial \theta_1}\\\frac{\partial J_1(\theta)}{\partial \theta_2}&\frac{\partial J_2(\theta)}{\partial \theta_2}&...&\frac{\partial J_m(\theta)}{\partial \theta_2}\\...&...&...&...\\\frac{\partial J_1(\theta)}{\partial \theta_n}&\frac{\partial J_2(\theta)}{\partial \theta_n}&...&\frac{\partial J_m(\theta)}{\partial \theta_n}\\\end{bmatrix}</script><p>这样的问题可以用矩阵表示：</p><script type="math/tex; mode=display">Ax=b</script><p>其中$X$表示$m$组点的自变量的值，$Y$代表每一组自变量对应的函数值。</p><script type="math/tex; mode=display">A=\begin{bmatrix}1&x_{12}& ...&x_{1n}\\1&x_{22}& ...&x_{2n}\\1&...& ...&...\\1&x_{m2}& ...&x_{mn}\\\end{bmatrix}，x=\begin{bmatrix}\theta_1\\\theta_2\\ ...\\\theta_n\\\end{bmatrix},b=\begin{bmatrix}y_1\\y_2\\ ...\\y_m\\\end{bmatrix}</script><p>损失函数：</p><script type="math/tex; mode=display">J(\theta)=\sum^{m}_{i=1}|y_i-\sum^n_{j=1}x_{ij}\theta_j|^2=\parallel  Ax-b \parallel^2</script><p>由上文的定理：</p><script type="math/tex; mode=display">A^TAx=A^Tb</script><p>求得：</p><script type="math/tex; mode=display">x=\begin{bmatrix}\theta_1\\\theta_2\\ ...\\\theta_n\\\end{bmatrix}=(A^TA)^{-1}A^Tb</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;按偏差平方和最小的原则选取拟合曲线，并且采取二项式方程为拟合曲线的方法, 称为最小二乘法。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>SLAM中的非线性优化</title>
    <link href="https://lukeyalvin.top/posts/48933.html"/>
    <id>https://lukeyalvin.top/posts/48933.html</id>
    <published>2022-04-04T06:49:56.115Z</published>
    <updated>2022-04-26T01:20:20.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经典 SLAM 模型。它由一个状态方程和一个运动方程构成：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},u_{k})+w_{k}\\z_{k,j}&=h(y_j,x_k)+v_{k,j}\end{align*}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$</p><p>对应视觉$SLAM$，这里的 $x_k $乃是相机的位姿，$u_k$ 是运动传感器的读数（有时也叫输入），$y_j$代表的是相机在$x_k $处观察到的路标，并且观察到$y_j$后，产生了一个观测数据 $z_{k,j}$。整个方程里面，求解相机的位姿$x_k $就是一个定位的问题，而求解路标$y_j$就是一个建图的过程，但是由于噪声$w_{k}，v_{k,j}$的影响，我们得到的传感器数据$u_k$ 和$z_{k,j}$肯定不是完全准确的，因此需要使用这两组不太准确的数据，寻找一个相对最优的相机位姿$x_k $以及路标$y_j$。这个过程就是SLAM中的非线性优化问题。</p><h2 id="需要优化什么？"><a href="#需要优化什么？" class="headerlink" title="需要优化什么？"></a>需要优化什么？</h2><p>我们把所有带估计的数据放在一个集合：</p><script type="math/tex; mode=display">x=\left\{x_1,....,x_N,y_1,...y_M\}\right.</script><p>那么，我们的问题就变成求已知输入数据 $u$ 和观测数据 $z$ 的条件下，计算状态 $x$ 的条件概率分布：</p><script type="math/tex; mode=display">P(x|z,u)</script><hr><p>但是多数情况下，我们只有相机观察到的一帧帧的图片$z_{k,j}$，即只考虑观测方程带来的数据时，没有运动传感器$u_k$ ，这个概率分布就变成$P(x|z)$，利用贝叶斯法则：</p><script type="math/tex; mode=display">P(x|z)=\frac{P(z|x)P(x)}{P(z)}∝P (z|x) P (x) .</script><p>$\frac{P(z|x)P(x)}{P(z)}$称为后验估计，$P (z|x)$ 称为似然，另一部分$ P (x)$ 称为先验。</p><p>直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下，后验概率最大化（Maximize a Posterior，MAP），则是可行的：</p><script type="math/tex; mode=display">x^∗_{MAP} = arg max P (x|z) = arg max P (z|x)P (x).</script><p>但是当我们不知道机器人位姿大概在什么地方，此时就没有了先验,那么，可以求解$x $的最大似然估计（Maximize Likelihood Estimation, MLE）：</p><script type="math/tex; mode=display">x^∗_{MLE} = arg max P (z|x)</script><p>最大似然估计的含义就是：相机在什么样的状态下（这里指集合$x$即为相机位姿$x_{k}$以及路标$y_{j}$），最可能产生当前观测到的数据$z_{k,j}$。</p><p><strong>所以我们需要优化的内容就是：求解最优的$x_k , y_j$，使得观测方程带来的最小误差，此时就是求$x$（或者是说$x_k , y_j$）的最大似然然估计。</strong></p><h2 id="最小二乘问题"><a href="#最小二乘问题" class="headerlink" title="最小二乘问题"></a>最小二乘问题</h2><p>只考虑观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}</script><p>由于我们假设了噪声项 $v_k ∼ N (0, Q)$，所以观测数据的条件概率为：</p><script type="math/tex; mode=display">P (z_{j,k} |x_k , y_j ) = N (h(y_j , x_k ), Q) .</script><p>我们的目标就是最大化$x_k , y_j$，使得该状态下最可能产生当前观测到的数据$z_{k,j}$。</p><p>考虑一个任意的高维高斯分布 $x ∼ N (µ, Σ)$，它的概率密度函数展开形式为:</p><script type="math/tex; mode=display">\begin{align*}p(x)=\frac{1}{\sqrt{(2\pi)^N det(Σ)} }exp(−(x−\mu)Σ^{-1} (x−\mu))\end{align*}</script><p>取负对数:</p><script type="math/tex; mode=display">\begin{align*}-ln(p(x))=\frac{1}{2}ln((2\pi)^N det(Σ))+\frac{1}{2}(x−\mu)^TΣ^{-1} (x−\mu)\end{align*}</script><p>对原分布求最大化相当于对负对数求最小化。在最小化上式的 $x$ 时，第一项与 $x $无关，可以略去于是，只要最小化右侧的二次型项。带入SLAM观测模型：</p><script type="math/tex; mode=display">x^*=argmin((z_{k,j}-h(x_k,y_j))^TQ^{-1}_{k,j}(z_{k,j}-h(x_k,y_j)))</script><p>定义：</p><script type="math/tex; mode=display">\begin{align*}e_{v,k}&=x_k-f(x_{k-1},u_k)\\e_{u,j,k}&=z_{k,j}-h(x_k,y_j)\end{align*}</script><p>考虑运动与观测方程结合来看，我们求解的就是总的误差的平方和：</p><script type="math/tex; mode=display">J(x)=\sum_ke^T_{v,k}R^{-1}e_{v,k}+\sum_k\sum_je^T_{y,k,j}Q^{-1}e_{y,k,j}</script><p>这就得到了一个总体意义下的最小二乘问题（Least Square Problem）。我们明白它的最优解等价于状态的最大似然估计。直观来讲，由于噪声的存在，当我们把估计的轨迹与地图代入 SLAM 的运动、观测方程中时，它们并不会完美的成立。这时候怎么办呢？我们把状态的估计值进行微调，使得整体的误差下降一些。当然这个下降也有限度，它一般会到达一个极小值。这就是一个典型非线性优化的过程。</p><h2 id="非线性函数线性化"><a href="#非线性函数线性化" class="headerlink" title="非线性函数线性化"></a>非线性函数线性化</h2><p>在非线性优化的过程中，由于高斯分布经过非线性映射后不会再符合高斯分布，因此，一般我们对非线性进行线性化，这里用到泰勒级数：</p><p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f^\prime(x_0)(x-x_0)</script><p>如果对于二维以上的，我们的一阶泰勒展开如下：</p><script type="math/tex; mode=display">\begin{align*}f(x，y)&=f(x_0)+\frac{\partial f}{\partial x}|_{x=x_0}(x-x_0)\\&=f(x_0)+J(x)(x-x_0)\end{align*}</script><p>这里的雅克比矩阵代表的就是$f(x)$对于$x$的偏导数。</p><h1 id="求解非线性最小二乘"><a href="#求解非线性最小二乘" class="headerlink" title="求解非线性最小二乘"></a>求解非线性最小二乘</h1><p>对于上文，我们知道通过把最大似然估计问题转化为最小化其负对数的问题，其实就是求解一个非线性函数的最小值的问题，我们暂且考虑一个问题，我们有一个非线性的函数$f(x)$，如何求解它的最小值？</p><p>这就是一个简单的最小二乘问题：</p><script type="math/tex; mode=display">\underset{x}{min}\frac{1}{2}\parallel f(x) \parallel^2</script><p>这里自变量 $x\in \mathbb R^n$ ，$f $是任意一个非线性函数，我们设它有 $m $维：$f (x) \in \mathbb R^m$ 。</p><p>一般求解就是类似于二元函数求极值，对$x$求导，使得$\frac{df}{dx}=0$，即可得到$f(x)$的极值，但是也不是绝对的，我们知道这个点可能是极大值、极小值也可能是鞍点，因此需要比较所有使得$\frac{df}{dx}=0$的自变量对应的函数值$f(x)$.</p><p>但是在SLAM中，$f(x)$将是一个复杂的非线性方程，所以一般我们使用迭代的方法，从一个初始值出发，不断地更新当前的优化变量，使目标函数下降，具体步骤如下：</p><ul><li>给定某个初始值$ x_0$</li><li>对于第$k$次迭代，寻找一个增量$\Delta x_k$，使得$\parallel f(x_k+\Delta x_k)\parallel^2_2$达到极小值。</li><li>若$\Delta x_k$足够小，则停止</li><li>否则，令$x_{k+1}=x_k+\Delta x_k$，返回第二步。</li></ul><p>这让求解导函数为零的问题，变成了一个不断寻找梯度并下降的过程。直到某个时刻增量非常小，无法再使函数下降。此时算法收敛，目标达到了一个极小，我们完成了寻找极小值的过程。在这个过程中，我们只要找到迭代点的梯度方向即可，而无需寻找全局导函数为零的情况。</p><hr><p><strong>如何寻找$\Delta x_k$?</strong></p><h2 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h2><p>我们之前介绍过非线性的线性化方法，我们可以将一个非线性函数在某个点附件进行泰勒展开。</p><p>比如：对于增量方程在$x$附近进行泰勒展开：</p><script type="math/tex; mode=display">\parallel f(x+\Delta x)\parallel^2_2\approx\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x</script><p>这里$J$是 $\parallel f(x)\parallel^2$ 关于$ x $的导数（雅可比矩阵），而$ H $则是二阶导数（海塞（Hessian）矩阵）。保留一阶二阶分别就对应了一阶梯度法和二阶梯度法。</p><h3 id="一阶梯度法"><a href="#一阶梯度法" class="headerlink" title="一阶梯度法"></a>一阶梯度法</h3><script type="math/tex; mode=display">\Delta x^*=argmin\parallel f(x)\parallel^2_2+J(x)\Delta x</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">\Delta x^*=-J^T(x)</script><p>当然，我们还需要该方向上取一个步长$ λ$，求得最快的下降方式。这种方法被称为<strong>最速下降法</strong>。但是它本身也有缺点：最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。</p><h3 id="二阶梯度-牛顿法"><a href="#二阶梯度-牛顿法" class="headerlink" title="二阶梯度(牛顿法)"></a>二阶梯度(牛顿法)</h3><script type="math/tex; mode=display">\Delta x^*=argmin\parallel f(x)\parallel^2_2+J(x)\Delta x +\frac{1}{2}\Delta x^TH\Delta x</script><p>对右边等式关于$\Delta x$求导，并令它为0：</p><script type="math/tex; mode=display">H\Delta x=-J^T.</script><p>但是牛顿法需要计算目标函数的 $H $矩阵，这在问题规模较大时非常困难，我们通常倾向于避免$ H $的计算。</p><h2 id="Gauss-Newton"><a href="#Gauss-Newton" class="headerlink" title="Gauss-Newton"></a>Gauss-Newton</h2><p>Gauss Newton 是最优化算法里面最简单的方法之一。它的思想是$f(x)$而不是$f(x)^2$在$x$处进行一阶泰勒展开：</p><script type="math/tex; mode=display">f(x+\Delta x)\approx f(x)+J(x)\Delta x</script><p>这里$ J (x)$ 为$ f (x) $关于$ x$ 的导数，实际上是一个$ m × n$ 的矩阵，也是一个雅可比矩阵。</p><p>当前的目标是为了寻找下降矢量 $\Delta x$，使得$ f(x+\Delta x)$达到最小。为了求 $\Delta x$，我们需要解一个线性的最小二乘问题：</p><script type="math/tex; mode=display">\Delta x^*=argmin\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2</script><p>对上式平方项进行展开：</p><script type="math/tex; mode=display">\begin{align*}\frac{1}{2}\parallel f(x)+J(x)\Delta x \parallel^2&=\frac{1}{2}(f(x)+J(x)\Delta x)^T(f(x)+J(x)\Delta x)\\&=\frac{1}{2}(\parallel f(x)\parallel^2_2+2f(x)^TJ(x)\Delta x+\Delta x^TJ(x)^TJ(x)\Delta x)\\\end{align*}</script><p>求上式关于 $\Delta x$ 的导数，并令其为零：</p><script type="math/tex; mode=display">2J(x)^Tf(x)+2J(x)^TJ(x)\Delta x=0</script><p>化简：</p><script type="math/tex; mode=display">J(x)^TJ(x)\Delta x=-J(x)^Tf(x)</script><p>要求解的变量是  $\Delta x$，因此这是一个线性方程组，我们称它为增量方程，也可以称为<strong>高斯牛顿方程 (Gauss Newton equations)</strong> 或者<strong>正规方程 (Normal equations)</strong>。我们把左边的系数定义为 $H$，右边定义为 $g$，那么上式变为：</p><script type="math/tex; mode=display">H \Delta x=g</script><p>对比牛顿法可见，Gauss-Newton 用$J(x)^TJ(x)$作为牛顿法中二阶 Hessian 矩阵的近似，从而省略了计算 $H $的过程。求解增量方程是整个优化问题的核心所在。</p><p>Gauss Newton 求解步骤：</p><ul><li>给定初始值$x_0$</li><li>对于第$k$次迭代，求出当前的雅可比矩阵$J(x_k)和误差$$f(x_k)$</li><li>求解增量方程：$H \Delta x=g$</li><li>若$\Delta x_k$足够小，则停止。否则，令$x_{k+1}=x_k+\Delta x_k$，返回步骤2.</li></ul><p>整个步骤中，增量方程的求解占据着主要地位。原则上，它要求我们所用的近似 $H$ 矩阵是可逆的（而且是正定的），但实际数据中计算得到的 $J(x)^TJ(x)$却只有半正定性。也就是说，在使用 Gauss Newton 方法时，可能出现$J(x)^TJ(x)$为<strong>奇异矩阵</strong>或者<strong>病态 (ill-condition)</strong> 的情况，此时增量的稳定性较差，导致算法不收敛。</p><p>更严重的是，就算我们假设$ H $非奇异也非病态，如果我们求出来的步长$ ∆x $太大，也会导致我们采用的局部近似不够准确，这样一来我们甚至都无法保证它的迭代收敛，哪怕是让目标函数变得更大都是有可能的。</p><h2 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h2><h1 id="BA求解"><a href="#BA求解" class="headerlink" title="BA求解"></a>BA求解</h1><h2 id="投影模型"><a href="#投影模型" class="headerlink" title="投影模型"></a>投影模型</h2><p>从一个世界坐标系中的点 p 出发，把相机的内外参数和畸变都考虑进来，最后投影成像素坐标，一共需要如下几个步骤：</p><ol><li>首先，把世界坐标转换到相机坐标，这里将用到相机外参数$ (R, t)$：</li></ol><script type="math/tex; mode=display">P^\prime=Rp+t=[X^\prime,Y^\prime,Z^\prime]^T</script><ol><li>然后，将 $P^\prime$ 投至归一化平面，得到归一化坐标：</li></ol><script type="math/tex; mode=display">P_c=[u_c,v_c,1]^T=[\frac{X^\prime}{Z^\prime},\frac{Y^\prime}{Z^\prime},1]^T</script><ol><li>对归一化坐标去畸变，得到去畸变后的坐标。这里暂时只考虑径向畸变：</li></ol><script type="math/tex; mode=display">u_c^\prime=u_c(1+k_1r_c^2+k_2r_c^4)\\v_c^\prime=v_c(1+k_1r_c^2+k_2r_c^4)\</script><ol><li>最后，根据内参模型，计算像素坐标：</li></ol><script type="math/tex; mode=display">u_s=f_xu_c^\prime+c_x\\v_s=f_yv_c^\prime+c_y</script><p>对于观测方程：</p><script type="math/tex; mode=display">z_{k,j}=h(y_j,x_k)+v_{k,j}</script><p>这里的 $x$ 指代此时相机的位姿，即外参 $R, t$，它对应的李代数为 $ξ$。路标 $y$ 即这里的三维点 $p$，而观测数据则是像素坐标$z = [u_s , v_s ]^T $。</p><p><img src="/posts/48933.htm/image-20220405145736323.png" alt="image-20220405145736323"></p><p>以最小二乘的角度来考虑，那么可以列写关于此次观测的误差：</p><script type="math/tex; mode=display">e=z-h(ξ,p)</script><p>设 $z_{ij}$为在位姿 $ξ_i $处观察路标 $p_j $产生的数据，那么整体的损失函数（Cost Function）为：</p><script type="math/tex; mode=display">\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}\parallel^2=\frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel z_{ij}-h(ξ_i,p_j) \parallel^2</script><p>对这个最小二乘进行求解，相当于对位姿和路标同时作了调整，也就是所谓的$BA$。</p><h2 id="BA求解-1"><a href="#BA求解-1" class="headerlink" title="BA求解"></a>BA求解</h2><p>在整体 $BA$目标函数上，我们必须把自变量定义成所有待优化的变量：</p><script type="math/tex; mode=display">x=[\xi_1,...,\xi_m,p_1,...,p_n]^T</script><p>相应的，增量方程中的$ ∆x $则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e_{ij}+F_{ij}\Delta\xi_i+E_{ij}\Delta p_i \parallel^2</script><p>其中$ F_{ij} $表示整个代价函数在当前状态下对<strong>相机姿态</strong>的偏导数，而 $E_{ij}$ 表示该函数对<strong>路标点位置</strong>的偏导。</p><p><strong>观测相机方程关于相机位姿的导数矩阵：</strong></p><script type="math/tex; mode=display">\begin{align*}J&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\\end{align*}</script><p><strong>观测相机方程关于特征点的导数矩阵</strong></p><script type="math/tex; mode=display">J=\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}R</script><p>现在，把相机位姿变量放在一起：</p><script type="math/tex; mode=display">x_c=[\xi_1,\xi_2,...,\xi_1]\in\mathbb{R}^{6m}</script><p>并把空间点的变量也放在一起：</p><script type="math/tex; mode=display">x_p=[p_1,p_2,...,p_n]^T\in \mathbb{R}^{3n}</script><p>目标函数变为：</p><script type="math/tex; mode=display">\frac{1}{2}\parallel f(x+\Delta x)\parallel^2\approx \frac{1}{2}\sum^m_{i=1}\sum^n_{j=1}\parallel e+F\Delta x_c+E_\Delta x_p \parallel^2</script><p>需要注意的是，该式从一个由<strong>很多个小型二次项之和</strong>，变成了一个更整体的样子。这里的雅可比矩阵 $E $和$ F$ 必须是整体目标函数对整体变量的导数，它将是一个很大块的矩阵，而里头每个小分块，需要由每个误差项的导数 $F_{ij} $和 $E_{ij}$ “拼凑”起来。然后，无论我们使用 $G-N$ 还是$ L-M $方法，最后都将面对增量线性方程：</p><script type="math/tex; mode=display">H\Delta x = g</script><p>如果是高斯牛顿，$H$ 取$J^TJ$；列文伯格是 $J^T J + λI $的形式</p><p>由于我们把变量归类成了位姿和空间点两种，所以雅可比矩阵可以分块为：</p><script type="math/tex; mode=display">J=\begin{bmatrix}F & E\end{bmatrix}</script><p>其中$F$是$2 × 6$的矩阵，$E$是$2 × 3$的矩阵.</p><p>以 G-N 为例，则 H 矩阵为：</p><script type="math/tex; mode=display">H=J^TJ=\begin{bmatrix}F^TF & F^TE\\E^TF & E^TE\end{bmatrix}</script><p>在SLAM中我们会考虑H矩阵的稀疏性，进而加速BA的求解。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;由于噪声的存在，运动方程和观测方程的等式必定不是精确成立的。即使我们有着高精度的相机，运动方程和观测方程也只能近似的成立。所以，与其假设数据必须符合方程，不如来讨论，如何在有噪声的数据中进行准确的状态估计。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波的数学推导</title>
    <link href="https://lukeyalvin.top/posts/60703.html"/>
    <id>https://lukeyalvin.top/posts/60703.html</id>
    <published>2022-04-02T06:52:57.548Z</published>
    <updated>2022-04-26T01:20:20.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>卡尔曼滤波（Kalman filter）是一种高效率的<strong>递归滤波器</strong>（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h1><h2 id="先验与后验估计"><a href="#先验与后验估计" class="headerlink" title="先验与后验估计"></a>先验与后验估计</h2><p>由之前的状态空间方程：</p><script type="math/tex; mode=display">\begin{align*}{x_k }&=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_{k}&=Hx_{k}+v_k\end{align*}</script><p>其中$w_{k}$为过程噪声(Process Noise)，$v_k$为测量噪声(Measurement Noise)，暂且认为它们符合高斯分布，即$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，且$Q=E[ww^T],R=[vv^T]$，推导如下：</p><script type="math/tex; mode=display">\begin{align*}Q=E[ww^T]&=E\begin{bmatrix}\begin{bmatrix}w_1\\w_2\\.\\.\\w_k \end{bmatrix}\begin{bmatrix}w_1&w_2&...&w_k \end{bmatrix}\end{bmatrix}=E\begin{bmatrix}w_1^2&w_1w_2&...&w_1w_k\\w_2w_1&w_2^2&...&w_2w_k\\...&...&...&...\\w_kw_1&w_kw_1&...&w_k^2\end{bmatrix}\\&=\begin{bmatrix}Ew_1^2&Ew_1w_2&...&Ew_1w_k\\Ew_2w_1&Ew_2^2&...&Ew_2w_k\\...&...&...&...\\Ew_kw_1&Ew_kw_1&...&Ew_k^2\end{bmatrix}\end{align*}</script><p>由于$w$的期望为$0$，由方差等于平方的期望减去期望的平方以及协方差公式：</p><script type="math/tex; mode=display">\begin{align*}Var(X)&=E(X^2)-E^2(X)\\Cov(X,Y)&=E((X-\mu)(Y-v))\end{align*}</script><p>所以此处平方的期望就等于方差：</p><script type="math/tex; mode=display">\begin{align*}Var(X)&=E(X^2)\\Cov(X,Y)&=E(X·Y)\end{align*}</script><p>即为：</p><script type="math/tex; mode=display">Ew_k^2=\sigma_{w_1}^2,Ew_iw_j=\sigma_i\sigma_j</script><p>所以：</p><script type="math/tex; mode=display">Q=\begin{bmatrix}Ew_1^2&Ew_1w_2&...&Ew_1w_k\\Ew_2w_1&Ew_2^2&...&Ew_2w_k\\...&...&...&...\\Ew_kw_1&Ew_kw_1&...&Ew_k^2\end{bmatrix}=\begin{bmatrix}\sigma_{w_{1} }^2&\sigma_{w_1}\sigma_{w_2}&...&\sigma_{w_1}\sigma_{w_k}\\\sigma_{w_2}\sigma_{w_1}&\sigma_{w_{2} }^2&...&\sigma_{w_2}\sigma_{w_k}\\...&...&...&...\\\sigma_{w_k}\sigma_{w_1}&\sigma_{w_k}\sigma_{w_1}&...&\sigma_{w_{k} }^2\end{bmatrix}</script><p>因此$Q$就是之前所提到的协方差矩阵，同样的，测量噪声也有协方差矩阵$R$，满足类似的条件。</p><hr><p>由于存在噪声的影响，所得到的$x_k$并不精确，我们暂且设它为$\hat{x}_k$，表示这是$x_k$的估计值；同样的$x_{k-1}$也是不准确的，设为$\hat{x}_{k-1}$，并且我们设通过下试得到的$x_k$成为先验估计，定义为$\hat{x}^-_k$；</p><p><b><span style="color:rgb(255, 0, 255);">先验估计（公式1）：</span></b></p><script type="math/tex; mode=display">\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}</script><p>由于$z_k$是测出的结果，是已知的，由$z_k=Hx_k$可知：</p><script type="math/tex; mode=display">\hat{x}_{kmea}=H^-z_k</script><p>对于上面的两个式子，$\hat{x}^-_k$是算出来的，$\hat{x}_{kmea}$是测出来的，因为收到噪声的影响，它们两个都是不准确的，因此这时候卡尔曼滤波的作用就显现出来了，如何利用两个不准确的值去得出一个相对准确的结果？这里就很容易想到之前提到的数据融合的思想。</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+G(H^-z_k-\hat{x}^-_k)，G\in[0,1]</script><p>分析式子很容易理解，当我们的测量数据很少时，$G\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多时，$G\approx1$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p><p>一般教科书上设$G=K_kH$；</p><p><b><span style="color:rgb(255, 0, 255);">后验估计（公式2）：</span></b></p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]</script><p>同样的，当我们的测量数据很少（不准确）时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多（相对准确）时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p><h2 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h2><p>因此，我们的目标变得十分明确了，如何选择一个合适的$K_k$值，使得$\hat{x}_k\rightarrow x_k$，其中$x_k$表示真实值。</p><p>此时，我们定义一个误差值$e_k$，以及一个先验误差值$e_k^-$：</p><script type="math/tex; mode=display">e_k=x_k-\hat{x}_k\\e_k^-=x_k-\hat{x}^-_k</script><p>误差也是符合高斯分布，$p(e_k)\sim(0,P)$，其中协方差矩阵$P=E[ee^T]$，与之前推导的$Q$是类似的。</p><p>因此，最终的目的就是选择一个合适的$K_k$值，使得$e_k$最小，也就是使得它的方差最小，因为方差越小，说明越接近期望值$0$，即$e_k\approx0$。而方差最小就是使得它的协方差矩阵的迹$tr(P)=\sigma^2_{e_{1} }+\sigma^2_{e_{2} }+…+\sigma^2_{e_{k} }$最小。</p><font color="#dd0000">所以，最终的目的为：寻找一个合适的$K_k$使得$tr(P)$最小！</font><hr><script type="math/tex; mode=display">\begin{align*}tr(P)&=E[ee^T]\\&=E[(x_k-\hat{x}_k)(x_k-\hat{x}_k)^T]\end{align*}</script><p>已知：</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k)\\z_k=Hx_k+v_k</script><p>带入上式：</p><script type="math/tex; mode=display">\begin{align*}x_k-\hat{x}_k&=x_k-(\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k))\\&=x_k-\hat{x}^-_k-K_kz_k+K_kH\hat{x}^-_k\\&=x_k-\hat{x}^-_k-K_k(Hx_k+v_k)+K_kH\hat{x}^-_k\\&=x_k-\hat{x}^-_k-K_kHx_k-K_kv_k+K_kH\hat{x}^-_k\\&=(x_k-\hat{x}^-_k)-K_kH(x_k-\hat{x}^-_k)-K_kv_k\\&=(I-K_kH)(x_k-\hat{x}^-_k)-K_kv_k\\&=(I-K_kH)e_k^--K_kv_k\end{align*}</script><p>所以：</p><blockquote><p>可能会用到的公式：</p><p>$(AB)^T=B^TA^T$，$(A+B)^T=A^T+B^T$</p></blockquote><script type="math/tex; mode=display">\begin{align*}tr(P)&=E[ee^T]\\&=E[(x_k-\hat{x}_k)(x_k-\hat{x}_k)^T]\\&=E[[(I-K_kH)e_k^--K_kv_k][(I-K_kH)e_k^--K_kv_k]^T]\\&=E[[(I-K_kH)e_k^--K_kv_k][e_k^{-T}(I-K_kH)^T-v_k^TK_k^T]]\\&=E[(I-K_kH)e_k^-e_k^{-T}(I-K_kH)^T-(I-K_kH)e_k^-v_k^TK_k^T\\&-K_kv_ke_k^{-T}(I-K_kH)^T+K_kv_kv_k^TK_k^T]\\\end{align*}</script><p>分别求每一项的期望：</p><blockquote><p>可能会用到的已知条件：</p><p>$E[e_k^-]=0,E[e_k^{-T}]=0,E[v_k^T]=0,E[v_k]=0$</p></blockquote><script type="math/tex; mode=display">\begin{align*}&E[-(I-K_kH)e_k^-v_k^TK_k^T]\\&=-(I-K_kH)E[e_k^-v_k^T]K_k^T\\&=-(I-K_kH)E[e_k^-]E[v_k^T]K_k^T\\&=0\end{align*}</script><p>同理可得：</p><script type="math/tex; mode=display">\begin{align*}&E[-K_kv_ke_k^{-T}(I-K_kH)^T]\\&=-K_kE[v_k]E[e_k^{-T}](I-K_kH)^T\\&=0\end{align*}</script><p>所以最终：</p><blockquote><p>可能会用到的定义：</p><p>已知协方差矩阵$P=E[ee^T]$，则定义$P_k^-=E[e_k^-e_k^{-T}]$</p><p>$p_{(v)}\sim(0,R)$，所以$R_k=E[v_kv^T_k]$</p></blockquote><script type="math/tex; mode=display">\begin{align*}tr(P)&=E[ee^T]\\&=E[(I-K_kH)e_k^-e_k^{-T}(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\&=(I-K_kH)E[e_k^-e_k^{-T}](I-K_kH)^T+K_kE[v_kv_k^T]K_k^T\\&=(P_k^--K_kHP_k^-)(I^T-H^TK_k^T)+K_kR_kK_k^T\\&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kR_kK_k^T\\\end{align*}</script><blockquote><p>由于，协方差矩阵的转置就是它本身，所以$P_k^{-T}=P_k^-$</p><p>$(P_k^-H^TK_k^T)^T=K_kHP_k^{-T}=K_kHP_k^-$，所以$tr(K_kHP_k^-)=tr(P_k^-H^TK_k^T)$</p></blockquote><p>因此：</p><script type="math/tex; mode=display">\begin{align*}tr(P)&=tr(P_k^-)-tr(K_kHP_k^-)-tr(P_k^-H^TK_k^T)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kR_kK_k^T)\\&=tr(P_k^-)-2tr(K_kHP_k^-)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kR_kK_k^T)\end{align*}</script><p>$tr(P)$对$K_k$求导，使得$\frac{dtr(P_k)}{dK_k}=0$：</p><blockquote><p>可能会用到的公式：</p><p>$\frac{dtr(AB)}{dA}=B^T$，$\frac{dtr(ABA^T)}{dA}=2AB$</p></blockquote><script type="math/tex; mode=display">\begin{align*}\frac{dtr(P_k)}{dK_k}&=\frac{tr(P_k^-)}{dK_k}-\frac{2tr(K_kHP_k^-)}{dK_k}+\frac{tr(K_kHP_k^-H^TK_k^T))}{dK_k}+\frac{tr(K_kR_kK_k^T))}{dK_k}\\&=0-2(HP_k^-)^T+2K_kHP_k^-H^T+2K_kR_k\\&=0\end{align*}</script><p>所以：</p><script type="math/tex; mode=display">\begin{align*}(HP_k^-)^T&=K_k(HP_k^-H^T+R_k)\end{align*}</script><p><b><span style="color:rgb(255, 0, 255);">卡尔曼增益（公式3）：</span></b></p><script type="math/tex; mode=display">\begin{align*}K_k&=\frac{P_k^-H^T}{HP_k^-H^T+R_k}\end{align*}</script><p>因此，结合我们之前的结论：</p><blockquote><p>当我们的测量数据很少（不准确）时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；当我们的测量数据很多（相对准确）时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p></blockquote><p>此处也是相同的：</p><p>$R_k$表示测量噪声，当测量噪声很大时，$K_k\approx0$，则$\hat{x}_k=\hat{x}^-_k$，我们选择相信计算值；</p><p>当测量噪声很小时，$K_k\approx H^-$，则$\hat{x}_k=H^-z_k$，我们选择相信测量值；</p><hr><h2 id="误差协方差矩阵"><a href="#误差协方差矩阵" class="headerlink" title="误差协方差矩阵"></a>误差协方差矩阵</h2><p>总结前面推导的三个公式：</p><p><font color="#dd0000"><strong>先验估计（公式1）：</strong></font></p><script type="math/tex; mode=display">\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}</script><p><font color="#dd0000"><strong>后验估计（公式2）：</strong></font></p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]</script><p><font color="#dd0000"><strong>卡尔曼增益（公式3）：</strong></font></p><script type="math/tex; mode=display">\begin{align*}K_k&=\frac{P_k^-H^T}{HP_k^-H^T+R_k}\end{align*}</script><p>上面的公式里只有$P_k^-$是未知的，需要推导。由于已知协方差矩阵$P=E[ee^T]$，所以定义$P_k^-=E[e_k^-e_k^{-T}]$，如何求这个误差协方差矩阵是以下篇幅讨论的重点。</p><blockquote><p>可能会用到的定义与公式：</p><p>$e_k=x_k-\hat{x}_k$，$P_k=E[ee^T]$</p><p>$e_k^-=x_k-\hat{x}^-_k$ ，$P_k^-=E[e_k^-e_k^{-T}]$</p><p>$\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}$</p><p>$x_k =Ax_{k-1}+Bu_{k-1}+w_{k-1}$</p></blockquote><p>首先推导$e_k^-=x_k-\hat{x}^-_k$:</p><script type="math/tex; mode=display">\begin{align*}e_k^-&=x_k-\hat{x}^-_k\\&=Ax_{k-1}+Bu_{k}+w_{k-1}-A\hat{x}_{k-1}-Bu_{k}\\&=A(x_{k-1}-\hat{x}_{k-1})+w_{k-1}\\&=Ae_{k-1}+w_{k-1}\end{align*}</script><p>所以：</p><blockquote><p>由于$e_{k-1}=x_{k-1}-\hat{x}_{k-1}$，所以$e_{k-1}$作用的是上一时刻，而$w_k$是作用于当前时刻的，它们之间是相互独立的。$E[e_{k-1}w_{k}^T]=E[e_{k-1}]E[w_{k}^T]$，且$E[e_{k-1}]=E[w_{k}^T]=0$</p></blockquote><script type="math/tex; mode=display">\begin{align*}P_k^-&=E[e_k^-e_k^{-T}]\\&=E[(Ae_{k-1}+w_{k-1})(Ae_{k-1}+w_{k-1})^T]\\&=E[(Ae_{k-1}+w_{k-1})(e_{k-1}^TA^T+w_{k-1}^T)]\\&=E[Ae_{k-1}e_{k-1}^TA^T+Ae_{k-1}w_{k-1}^T+w_{k-1}e_{k-1}^TA^T+w_{k-1}w_{k-1}^T]\\&=E[Ae_{k-1}e_{k-1}^TA^T]+E[Ae_{k-1}w_{k-1}^T]+E[w_{k-1}e_{k-1}^TA^T]+E[w_{k-1}w_{k-1}^T]\\&=AE[e_{k-1}e_{k-1}^T]A^T+E[w_{k-1}w_{k-1}^T]\\&=AP_{k-1}A^T+Q\end{align*}</script><p><font color="#dd0000"><strong>误差协方差矩阵（公式4）：</strong></font></p><script type="math/tex; mode=display">\begin{align*}P_k^-=AP_{k-1}A^T+Q\end{align*}</script><p>由于每一次的误差协方差矩阵$P_k^-$，都需要上一次的$P_{k-1}$，所以每一时刻我们都需要更新一下$P_k$的值，为下一时刻使用做准备。</p><p><font color="#dd0000"><strong>更新误差协方差：（公式5）：</strong></font></p><script type="math/tex; mode=display">\begin{align*}P_k&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kR_kK_k^T\\&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_k(HP_k^-H^T+R_k)K_k^T\\&=P_k^--K_kHP_k^--P_k^-H^TK_k^T+\frac{P_k^-H^T}{HP_k^-H^T+R_k}(HP_k^-H^T+R_k)K_k^T\\&=P_k^--K_kHP_k^-\\&=(I-K_kH)P_k^-\end{align*}</script><p>至此，我们可以总结一下整个卡尔曼滤波的过程：</p><div class="table-container"><table><thead><tr><th style="text-align:left">预测</th><th>校正</th></tr></thead><tbody><tr><td style="text-align:left">先验：$\hat{x}^-_k=A\hat{x}_{k-1}+Bu_{k-1}$</td><td>卡尔曼增益：$K_k=\frac{P_k^-H^T}{HP_k^-H^T+R_k}$</td></tr><tr><td style="text-align:left">先验误差协方差：$P_k^-=AP_{k-1}A^T+Q$</td><td>后验估计：$\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k),K_k\in[0,H^-]$</td></tr><tr><td style="text-align:left"></td><td>更新误差协方差：$P_k=(I-K_kH)P_k^-$</td></tr></tbody></table></div><blockquote><p><strong>介绍卡尔曼滤波论文：</strong><a href="http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf">http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf</a></p></blockquote><h1 id="非线性滤波器"><a href="#非线性滤波器" class="headerlink" title="非线性滤波器"></a>非线性滤波器</h1><p>前面的卡尔曼滤波我们可以在一个线性系统得到一个最优的估计值，那么卡尔曼滤波器在非线性系统中的应用如何呢？一般来说有许多方法，但是最基本的方法就是将非线性系统进行线性化，这种滤波器我们称为扩展卡尔曼滤波器（Extended Kalman Filter，简称EKF）。</p><hr><p>对于线性系统的状态空间表达式：</p><script type="math/tex; mode=display">\begin{align*}{x_k }&=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_{k}&=Hx_{k}+v_k\end{align*}</script><p>其中$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵</p><hr><p>对于非线性系统的状态空间表达式：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(x_{k-1},u_{k-1},w_{k-1})\\z_k&=h(x_k,v_k)\end{align*}</script><p>其中$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵</p><p>虽然噪声仍然满足正态分布，但是<span style="color:red;">正态分布的随机变量通过非线性系统后就不再是正态的了。</span></p><p><img src="/posts/60703.htm/image-20220402154736261.png" alt="image-20220402154736261"></p><p>所以需要对非线性系统进行线性化处理，这里会用到泰勒展开。</p><p>比如我们对$f(x)$在$x_0$处进行泰勒展开：</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{\partial f}{\partial x}(x-x_0)</script><p>对于一个非线性系统来说，最好的一个线性化的点就是它的真实点，但是由于系统存在误差，所以我们永远无法知道系统的真实点是多少，所以一般$f(x)$在$\hat{x}_{k-1}$(即上一时刻的后验估计)处进行线性化。</p><ul><li>过程方程线性化</li></ul><blockquote><p>假设误差$w_{k-1}=0$</p></blockquote><script type="math/tex; mode=display">\begin{align*}x_k&=f(\hat{x}_{k-1},u_{k-1},w_{k-1})+A(x_k-\hat{x}_{k-1})+Ww_{k-1}\\&=f(\hat{x}_{k-1},u_{k-1},0)+A(x_k-\hat{x}_{k-1})+Ww_{k-1}\end{align*}</script><blockquote><p>记：$f(\hat{x}_{k-1},u_{k-1},0)=\widetilde{x}$，而$A，W$是雅可比矩阵，且$A=\frac{\partial f}{\partial x}|\hat{x}_{k-1},u_{k-1}$，$W=\frac{\partial f}{\partial w}|\hat{x}_{k-1},u_{k-1}$</p></blockquote><ul><li>测量方程线性化</li></ul><p>将$z_k$在$\widetilde{x}$处线性化：</p><blockquote><p>假设误差 $v_{k}=0$</p></blockquote><script type="math/tex; mode=display">z_{k}=h(\widetilde{x}_{k},v_k)+H(x_k-\widetilde{x}_{k})+Vv_k</script><blockquote><p>而$H，V$是雅可比矩阵，且$H=\frac{\partial f}{\partial x}|\widetilde{x}_{k}$，$V=\frac{\partial f}{\partial v}|\widetilde{x}_{k}$</p></blockquote><p>所以非线性系统线性化后：</p><script type="math/tex; mode=display">\begin{align*}x_k&=f(\hat{x}_{k-1},u_{k-1},0)+A(x_k-\hat{x}_{k-1})+Ww_{k-1}\\z_{k}&=h(\widetilde{x}_{k},v_k)+H(x_k-\widetilde{x}_{k})+Vv_k\end{align*}</script><p>由于$p_{(w)}\sim N(0,Q)，p_{(v)}\sim N(0,R)$，其中$0$表示期望，$Q,R$代表协方差矩阵，那么很容易得到$p_{(Ww)}\sim N(0,wQw^T)，p_{(Vv)}\sim N(0,vRv^T)$</p><p>至此，我们可以总结一下整个卡尔曼滤波的过程：</p><div class="table-container"><table><thead><tr><th style="text-align:left">预测</th><th>校正</th></tr></thead><tbody><tr><td style="text-align:left">先验：$\hat{x}^-_k=Af(\hat{x}_{k-1},u_{k-1},0)+Bu_{k-1}$</td><td>卡尔曼增益：$K_k=\frac{P_k^-H^T}{HP_k^-H^T+vRv^T}$</td></tr><tr><td style="text-align:left">先验误差协方差：$P_k^-=AP_{k-1}A^T+wQw^T$</td><td>后验估计：$\hat{x}_k=\hat{x}^-_k+K_k(z_k-h(\hat{x}^-_k,0)),K_k\in[0,H^-]$</td></tr><tr><td style="text-align:left"></td><td>更新误差协方差：$P_k=(I-K_kH)P_k^-$</td></tr></tbody></table></div><h2 id="EKF在SLAM中的局限性"><a href="#EKF在SLAM中的局限性" class="headerlink" title="EKF在SLAM中的局限性"></a>EKF在SLAM中的局限性</h2><p>假设了马尔可夫性，也就是$ k$ 时刻的状态只与$ k − 1$时刻相关，而与$ k − 1 $之前的状态和观测都无关（或者和前几个有限时间的状态相关）。这有点像是在视觉里程计中，只考虑相邻两帧关系一样。如果当前帧确实与很久之前的数据有关（例如回环），那么滤波器就会难以处理这种情况。</p><p>$EKF$ 滤波器仅在 $\hat{x}_{k−1}$ 处做了一次线性化，然后就直接根据这次线性化结果，把后验概率给算了出来。这相当于在说，我们认为该点处线性化近似，在后验概率处仍然是有效的。而实际上，当我们离开工作点较远的时候，一阶泰勒展开并不一定能够近似整个函数，这取决于运动模型和观测模型的非线性情况。</p><p>从程序实现上来说，EKF 需要存储状态量的均值和方差，并对它们进行维护和更新。如果把路标也放进状态的话，由于视觉 SLAM 中路标数量很大，这个存储量是相当可观的，且与状态量呈平方增长（因为要存储协方差矩阵）。因此，EKF SLAM 普遍被认为不可适用于大型场景。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;卡尔曼滤波（Kalman filter）是一种高效率的&lt;strong&gt;递归滤波器&lt;/strong&gt;（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波器的数学基础</title>
    <link href="https://lukeyalvin.top/posts/8369.html"/>
    <id>https://lukeyalvin.top/posts/8369.html</id>
    <published>2022-04-01T01:23:32.450Z</published>
    <updated>2022-04-26T01:20:20.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>卡尔曼滤波（Kalman filter）是一种高效率的<strong>递归滤波器</strong>（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="卡尔曼滤波器的数学基础"><a href="#卡尔曼滤波器的数学基础" class="headerlink" title="卡尔曼滤波器的数学基础"></a>卡尔曼滤波器的数学基础</h1><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>卡尔曼滤波器(Kalman Filter)，它是一种最优化的递归的数字处理算法(Optimal Recursive Data Processing Algorithm)。</p><p><strong>为什么使用卡尔曼滤波？</strong></p><p>因为显示生活中充满了不确定性，而这些不确定性主要体现在以下几个方面：</p><ul><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量传感器存在误差</li></ul><hr><p>【例】测量硬币的例子</p><p>如图所示，不同的人去测量一个硬币的直径，一共测量$k$次，得到的测量值为$z_1,……z_k$，估计硬币的真实直径是多少？</p><p><img src="/posts/8369.htm/image-20220401093317316.png" alt="image-20220401093317316"></p><p><strong>取平均值</strong></p><p>设我们的平均值即对真实值的估计值(Estimate)为$\hat{x}$</p><script type="math/tex; mode=display">\begin{align*}\hat{x}_k&=\frac{1}{k}(z_1+z_2+...+z_k)\\&=\frac{1}{k}(z_1+z_2+...+z_{k-1})+\frac{1}{k}z_k\\&=\frac{1}{k} \frac{k-1}{k-1}(z_1+z_2+...+z_{k-1})+\frac{1}{k}z_k\\&=\frac{k-1}{k}  \hat{x}_{k-1}+\frac{1}{k}z_k\\&=\hat{x}_{k-1}-\frac{1}{k}\hat{x}_{k-1}  +\frac{1}{k}z_k\end{align*}</script><p>整理得：</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}_{k-1} +\frac{1}{k}(z_k-\hat{x}_{k-1} )</script><p>令$K_k=1/k$</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}_{k-1} +K_k(z_k-\hat{x}_{k-1} )</script><p>即为：当前的估计值=上一时刻的估计值+$K_k$(当前测量值-上一时刻的估计值)</p><p><strong>分析：</strong></p><ul><li>随着$k$的增加，$K_k$趋近于0，可以得到$\hat{x}_k=\hat{x}_{k-1}$，测量的结果$z_k$不再重要</li><li>当$k$比较小的时候，$K_k$很大，则说明测量结果是非常重要的</li><li>$K_k$就是<strong>卡尔曼增益</strong>，或叫做卡尔曼因数。</li></ul><p><strong>求解卡尔曼增益$K_k$:</strong></p><p>设估计误差：$e_{EST}$，测量误差：$e_{MEA}$</p><script type="math/tex; mode=display">K_k=\frac{ {e_{EST} }_{k-1} }{ {e_{EST} }_{k-1}+{e_{MEA} }_{k} }</script><p><strong>分析：</strong></p><ul><li>$e_{EST}&gt;&gt;e_{MEA}：$$K_k$趋近于1，则$\hat{x}_k=\hat{x}_{k-1} +z_k-\hat{x}_{k-1} =z_k$，即估计误差大相信测量值</li><li>$e_{EST}&lt;&lt;e_{MEA}：$$K_k$趋近于0，则$\hat{x}_k=\hat{x}_{k-1} $，测量误差大相信估计值</li></ul><hr><p>【例】卡尔曼滤波的应用举例：</p><ul><li><strong>一般计算卡尔曼滤波分为三步：</strong><ul><li>计算卡尔曼增益：$K_k=\frac{ {e_{EST} }_{k-1} }{ {e_{EST} }_{k-1}+{e_{MEA} }_{k} }$</li><li>计算$\hat{x}_k=\hat{x}_{k-1} +K_k(z_k-\hat{x}_{k-1} )$</li><li>更新${ e_{EST} }_{k}=(1-K_k){e_{EST} }_{k-1}$</li></ul></li></ul><p>已知物体的实际长度为$50mm$，测量误差$e_{MEA}=3mm$，估计误差$e_{MEA}=5mm$，$\hat{x}_0=40mm$，一共测量了13次，根据上面的三个步骤，我们可以计算并画出折线图。</p><p><img src="/posts/8369.htm/image-20220401102705574.png" alt="image-20220401102705574"></p><p><img src="/posts/8369.htm/image-20220401102555645.png" alt="image-20220401102555645"></p><p>很明显，经过测量次数的增加，最终的估计值是接近真实值的，这就是卡尔曼滤波递归的作用。</p><h2 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h2><p>数据融合(Data Fusion)</p><p>【例】现有两个称，已知它们称的结果都符合正态分布，现去称同一个物体，已知称$A$称得物体重量为$z_1=30g$，并且已知它的标准差为$\sigma_1=2g$；称$B$称得物体重量为$z_2=32g$，并且已知它的标准差为$\sigma_2=4g$；估计该物体的真实重量$\hat{z}_k=?$。</p><p>根据递归的思想：</p><script type="math/tex; mode=display">\hat{z}_k=z_1+K_k(z_2-z_1)，K_k\in[0,1]</script><p>为了求解最接近真实值的$\hat{z}_k$，即求解最优的$K_k$值，使得方差$Var(\hat{z}_k)$最小。</p><script type="math/tex; mode=display">\begin{align*}\sigma^2_{\hat{z}_k }&=Var(z_1+K_k(z_2-z_1))\\&=Var(z_1+K_kz_2-K_kz_1)\\&=Var((1-K_k)z_1+K_kz_2)\\&=Var((1-K_k)z_1)+Var(K_kz_2)\\&=(1-K_k)^2Var(z_1)+K_k^2Var(z_2)\\&=(1-K_k)^2\sigma_1^2+K_k^2\sigma_2^2\\\end{align*}</script><p>对$K_k$求导：</p><script type="math/tex; mode=display">\begin{align*}&\frac{d\sigma^2_{\hat{z}_k } }{dK_k}=0\\-2(1-K_k)&\sigma_1^2+2K_k\sigma_2^2=0\\&K_k=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}\end{align*}</script><p>已知$\sigma_1=2,\sigma_2=4$:</p><script type="math/tex; mode=display">K_k=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}=\frac{4}{4+16}=0.2</script><p>带入：</p><script type="math/tex; mode=display">\begin{align*}\hat{z}_k&=z_1+K_k(z_2-z_1)\\&=30+0.2(32-20)\\&=30.4g\end{align*}</script><p>对应方差：</p><script type="math/tex; mode=display">\begin{align*}\sigma^2_{\hat{z}_k }&=(1-K_k)^2\sigma_1^2+K_k^2\sigma_2^2\\&=(1-0.2)^2*4+0.2^2*16\\&=3.2\\\sigma_{\hat{z}_k }&=\sqrt{3.2} \\&= 1.79\end{align*}</script><p>因此，我们根据两个称的特性，根据测量值对物体的真实重量进行了预测，预测值为$30.4g$，而且它是最优解。</p><p>这个过程就是数据融合。</p><p><strong>公式：</strong></p><p>对于两个高斯分布的融合，如$p(A)\sim N(\mu_a,\sigma^2_a)$，$p(B)\sim N(\mu_b,\sigma^2_b)$</p><p>融合之后的高斯分布$p(C)\sim N(\mu_c,\sigma^2_c)$：</p><script type="math/tex; mode=display">\begin{align*}\mu_c&=\frac{\sigma^2_b\mu_a+\sigma^2_a\mu_b}{\sigma^2_a+\sigma^2_b}\\\sigma_c&=\frac{\sigma^2_a\sigma^2_b}{\sigma^2_b+\sigma^2_b}\end{align*}</script><p><img src="/posts/8369.htm/WeChat%20Image_20220401141112.jpg" alt="WeChat Image_20220401141112"></p><hr><h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>协方差矩阵(Covariance Matrix)，它可以把方差和协方差在一个矩阵中表现出来，体现了变量之间的；联动关系。</p><p>【例】</p><div class="table-container"><table><thead><tr><th style="text-align:center">球员</th><th style="text-align:center">身高x</th><th style="text-align:center">体重y</th><th style="text-align:center">年龄z</th></tr></thead><tbody><tr><td style="text-align:center">瓦尔迪</td><td style="text-align:center">179</td><td style="text-align:center">74</td><td style="text-align:center">33</td></tr><tr><td style="text-align:center">奥巴梅杨</td><td style="text-align:center">187</td><td style="text-align:center">80</td><td style="text-align:center">31</td></tr><tr><td style="text-align:center">萨拉赫</td><td style="text-align:center">175</td><td style="text-align:center">71</td><td style="text-align:center">28</td></tr><tr><td style="text-align:center"><strong>平均值</strong></td><td style="text-align:center"><strong>180.3</strong></td><td style="text-align:center"><strong>75</strong></td><td style="text-align:center"><strong>30.7</strong></td></tr></tbody></table></div><p>分别求三者的方差以及相互之间的协方差，</p><script type="math/tex; mode=display">Var(x)=\sigma_x^2=\frac{1}{n}\sum^n_{i=1}(x_i-\mu)^2=\frac{1}{n}(\sum^n_{i=1}x_i^2-n\mu^2)</script><p>方差：$\sigma_x^2=24.89, \sigma_y^2=14,\sigma_z^2=4.22$，</p><script type="math/tex; mode=display">Cov(X,Y)=E((X-\mu)(Y-v))=E(X·Y)-\mu v</script><p>协方差：$\sigma_x\sigma_y=\sigma_y\sigma_x=18.7,\sigma_x\sigma_z=\sigma_z\sigma_x=4.4,\sigma_y\sigma_z=\sigma_z\sigma_y=3.3$。所以协方差矩阵为：</p><script type="math/tex; mode=display">P=\begin{bmatrix}\sigma_x^2&\sigma_x\sigma_y&\sigma_x\sigma_z\\\sigma_y\sigma_x&\sigma_y^2&\sigma_y\sigma_z\\\sigma_z\sigma_x&\sigma_z\sigma_y&\sigma_z^2\end{bmatrix}=\begin{bmatrix}24.89&18.7&4.4\\18.7&14&3.3\\4.4&3.3&4.22\end{bmatrix}</script><p>可以看出运动员的身高与体重相关性比较大，而身高体重和年龄的相关性是比较小的，这种规律，数据越多越明显。</p><p><strong>如何使用矩阵批量计算协方差矩阵？</strong></p><p>一般需要设置一个过渡矩阵：</p><script type="math/tex; mode=display">a=\begin{bmatrix}x_1&y_1&z_1\\x_2&y_2&z_2\\x_3&y_3&z_3\end{bmatrix}-\frac{1}{3}\begin{bmatrix}1&1&1\\\1&1&1\\1&1&1\end{bmatrix}\begin{bmatrix}x_1&y_1&z_1\\x_2&y_2&z_2\\x_3&y_3&z_3\end{bmatrix}</script><p>协方差：</p><script type="math/tex; mode=display">P=\frac{1}{3}a^Ta</script><h2 id="状态空间表达式"><a href="#状态空间表达式" class="headerlink" title="状态空间表达式"></a>状态空间表达式</h2><p>【例】：有一个弹簧阻尼系统，对质量为$m$的物块施加一个力$F$，弹簧向右的位移量为$x$，已知弹簧的胡克系数为$k$，阻尼系数为$B$</p><p><img src="/posts/8369.htm/image-20220401152419675.png?40" alt="image-20220401152419675"></p><p>定义输入为$u_{(t)}=F_{(t)}$，输出为$x$</p><p>由胡克定律可知，弹簧拉力$f_k$以及阻力$f_B$：</p><script type="math/tex; mode=display">f_k=kx\\f_B=B\dot{x}</script><p>根据牛顿第二定律$F=ma$：</p><script type="math/tex; mode=display">\begin{align*}&m\ddot{x}=F-f_k-f_B\\&m\ddot{x}+f_B+f_k=F\\&m\ddot{x}+B\dot{x}+kx=F\end{align*}</script><p>所以系统的动态方程表达式：</p><script type="math/tex; mode=display">m\ddot{x}+B\dot{x}+kx=F</script><p>使用经典控制理论可以对上式进行拉普拉斯变换，进而求得系统的传递函数：</p><script type="math/tex; mode=display">ms^2X_{(s)}+BsX_{(s)}+kX_{(s)}=F_{(s)}\\G_{(s)}=\frac{X_{(s)} }{F_{(s)} }=\frac{1}{ms^2+Bs+K}</script><p>但在现代控制理论中则更多的使用状态空间方程，状态空间方程可以看成一个集合，它包含系统的输入、系统的输出以及状态变量，最终使用一个一阶微分方程的形式表达出来。</p><p>即：</p><script type="math/tex; mode=display">m\ddot{x}+B\dot{x}+kx=u</script><p>确定两个合适的状态变量，把二阶项消除：</p><ul><li>位置：$z_1=x=x_1$</li><li>速度：$z_2=\dot{x}=x_2$</li></ul><p>由于$x_1=x，x_2=\dot{x}$，因此可以得到：$\dot{x_1}=x_2，\dot{x_2}=\ddot{x}$，利用上述方程化简：</p><script type="math/tex; mode=display">\begin{align*}\dot{x_1}=x_2\\\dot{x_2}=\ddot{x}&=\frac{1}{m}\mu-\frac{B}{m}\dot{x}-\frac{k}{m}x\\&=\frac{1}{m}\mu-\frac{B}{m}x_2-\frac{k}{m}x_1\end{align*}</script><p>综合上面的四个方程：</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x_1}\\\dot{x_2}\end{bmatrix}=\begin{bmatrix}0&1\\-\frac{K}{m}&-\frac{B}{m}\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}+\begin{bmatrix}0\\ \frac{1}{m}\end{bmatrix}u</script><script type="math/tex; mode=display">\begin{bmatrix}z_1\\z_2\end{bmatrix}=\begin{bmatrix}1&0\\0&1\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}</script><p>进一步归纳：</p><p>连续型：</p><script type="math/tex; mode=display">\dot{X}_{(t)}=AX_{(t)}+Bu_{(t)}\\Z_{(t)}=HX_{(t)}</script><p>离散型：</p><script type="math/tex; mode=display">{X_k }=AX_{k-1}+Bu_{k}\\Z_{k}=HX_{k}</script><p>其中$k$表示采样时间单位。</p><p>由于现实中存在着不确定性，比如存在过程噪声(Process Noise)：$w_{k}$，测量噪声(Measurement Noise)：$v_k$</p><script type="math/tex; mode=display">\begin{align*}{X_k }&=AX_{k-1}+Bu_{k}+w_{k}\\Z_{k}&=HX_{k}+v_k\end{align*}</script><p>因此，我们的模型和测量都存在误差，导致计算值以及测量值都是不准确的，如何通过两个不确定的值去估计一个准确的值$\hat{x}_k=?$，根据数据融合的例子，我们可以使用这两个不准确的结果进行数据融合，从而得到一个比较准确的估计值。</p><h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>泰勒级数展开式：对于函数$f(x)$在任意一点$x_0$处展开</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f^\prime(x_0)}{1!}(x-x_0)+\frac{f^{\prime \prime}(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{1!}(x-x_0)^{n}</script><p>一般当$x-x_0\rightarrow0$时，则$(x-x_0)^{n}\rightarrow0,n\geq 2$，只取一阶泰勒：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f^\prime(x_0)(x-x_0)</script><p>设$f(x_0)=k_1,f^\prime(x_0)=k_2$:</p><script type="math/tex; mode=display">\begin{align*}f(x)&=k_1+k_2(x-x_0)\\&=k_2x+(k_1-k_2x_0)\\&=k_2x+b\end{align*}</script><p>因此这样的一个非线性的函数$f(x)$在点$x_0$附近就被线性化为一个线性的函数。</p><ul><li><p><span style="color:red;">线性化是对某个点附近进行线性化，而不是全局进行线性化</span></p></li><li><p><span style="color:red;">线性化的前提条件，一定是$(x-x_0)\rightarrow0$ </span></p></li></ul><p>如果对于二维以上的，我们的一阶泰勒展开如下：</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{\partial f}{\partial x_0}(x-x_0)</script>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;卡尔曼滤波（Kalman filter）是一种高效率的&lt;strong&gt;递归滤波器&lt;/strong&gt;（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch9_设计前端</title>
    <link href="https://lukeyalvin.top/posts/32548.html"/>
    <id>https://lukeyalvin.top/posts/32548.html</id>
    <published>2022-03-30T11:33:12.913Z</published>
    <updated>2022-04-26T01:20:20.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>本次实践将前几章内容结合进来，实际书写一个视觉里程计程序，由于单目相机存在初始化问题以及尺度问题，因此本实践采用的是最简单的RGB-D相机，但是使用的也只是RGB-D数据集，而非真正的RGB-D相机。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="一、搭建VO框架"><a href="#一、搭建VO框架" class="headerlink" title="一、搭建VO框架"></a>一、搭建VO框架</h1><h2 id="1-1-确定程序基本框架"><a href="#1-1-确定程序基本框架" class="headerlink" title="1.1 确定程序基本框架"></a>1.1 确定程序基本框架</h2><h3 id="项目目录框架"><a href="#项目目录框架" class="headerlink" title="项目目录框架"></a>项目目录框架</h3><p>在编写一个小规模的库时，我们通常会建立一些文件夹，把源代码、头文件、文档、测试数据、配置文件、日志等等分类存放，这样会显得很有条理。如果一个库内容很多，我们还会把代码分解各个独立的小模块，以便测试。</p><p>我们的工程目录如下：</p><ul><li><p><strong>bin：</strong>用来存放可执行的二进制文件；</p></li><li><p><strong>include/myslam：</strong> 存放 slam 模块的头文件，主要是<code>.h</code>。这种做法的理由是，当你把包含目录设到 include 时，在引用自己的头文件时，需要写<code>include ”myslam/xxx.h”</code>，这样不容易和别的库混淆。</p></li><li><p><strong>src：</strong>存放源代码文件，主要是 cpp；</p></li><li><p><strong>lib：</strong> 存放编译好的库文件；</p></li><li><p><strong>build：</strong>存放执行编译操作生成的中间文件；</p></li><li><p><strong>config：</strong> 存放配置文件；</p></li><li><p><strong>cmake_modules：</strong> 第三方库的 cmake 文件，在使用 g2o 之类的库中会用到它</p></li><li><p><strong>test：</strong> 存放测试用的文件，也是 cpp</p></li><li><strong>dataset：</strong>存放我们使用的RGB-D数据集</li><li><strong>tools：</strong>这里是对数据集操作用的python文件</li></ul><p><img src="/posts/32548.htm/image-20220330203310388.png" alt="image-20220330203310388"></p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p><strong>帧：</strong>一个帧是相机采集到的图像单位。它主要包含一个图像（RGB-D 情形下是一对图像）。此外，还有特征点、位姿、内参等信息。在视觉 SLAM 中我们会谈论关键帧（Key-frame），通常的做法是把某些我们认为更重要的帧保存起来，并认为相机轨迹就可以用这些关键帧来描述。关键帧如何选择是一个很大的问题，而且基于工程经验，很少有理论上的指导。</p><p><strong>路标：</strong>路标点即图像中的特征点。当相机运动之后，我们还能估计它们的 3D 位置。通常，会把路标点放在一个地图当中，并将新来的帧与地图中的路标点进行匹配，估计相机位姿。</p><h2 id="1-2-基本类的实现"><a href="#1-2-基本类的实现" class="headerlink" title="1.2 基本类的实现"></a>1.2 基本类的实现</h2><p>刚开始的阶段。我们一共写五个类：Frame 为帧，Camera 为相机模型，MapPoint 为特征点/路标点，Map<br>管理特征点，Config 提供配置参数。</p><p><img src="/posts/32548.htm/image-20220330200432411.png" alt="image-20220330200432411"></p><p>每个类对应一个头文件，一个源文件，由于许多类会引用很多头文件，所以我们不妨直接写一个头文件专门存放头文件，让所有的头文件都引这个头文件。当然，这个头文件里的内容是不断填充的，现在就以直接给出的形式呈现。</p><p><strong>WL_SLAM_VO/include/myslam/common_include.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_INCLUDE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_INCLUDE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for Eigen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Eigen::Vector2d;</span><br><span class="line"><span class="keyword">using</span> Eigen::Vector3d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for Sophus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/se3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/so3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Sophus::SE3;</span><br><span class="line"><span class="keyword">using</span> Sophus::SO3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for cv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> cv::Mat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="Camera类"><a href="#Camera类" class="headerlink" title="Camera类"></a>Camera类</h3><p>Camera 类存储相机的内参和外参，并完成相机坐标系、像素坐标系、和世界坐标系之间的坐标变换。当然，在世界坐标系中你需要一个相机的（变动的）外参，我们以参数的形式传入。</p><p><strong>WL_SLAM_VO/include/myslam/Camera.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们用命名空间 namespace myslam </span></span><br><span class="line"><span class="comment">将类定义包裹起来命名空间可以防止我们不小心定义出别的库里同名的函数，也是一种比较安全和规范的做法。*/</span> </span><br><span class="line"><span class="keyword">namespace</span> mysalm</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 把智能指针定义成 Camera 的指针类型，因此以后在传递参数时，只需用 Camera::Ptr 类型即可</span></span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Camera&gt; Ptr;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> fx_, fy_, cx_, cy_, depth_scale_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="keyword">float</span> fx,<span class="keyword">float</span> fy,<span class="keyword">float</span> cx,<span class="keyword">float</span> cy, <span class="keyword">float</span> depth_scale) : </span><br><span class="line">        <span class="built_in">fx_</span>(fx),<span class="built_in">fy_</span>(fy),<span class="built_in">cx_</span>(cx),<span class="built_in">cy_</span>(cy),<span class="built_in">depth_scale_</span>(depth_scale)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标变换</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">world2camera</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">camera2world</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">    <span class="function">Vector2d <span class="title">camera2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c)</span></span>;</span><br><span class="line">    <span class="function">Vector2d <span class="title">pixel2camera</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">pixel2world</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">const</span> SE3 &amp;T_c_w, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">world2pixel</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span>;</span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>智能指针：std::shared_ptr</p><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p><p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。</p></blockquote><p><strong>WL_SLAM_VO/src/camera.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line">    Camera::<span class="built_in">Camera</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::world2camera</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T_c_w * p_w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::camera2world</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T_c_w.<span class="built_in">inverse</span>() * p_c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2d <span class="title">Camera::camera2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2d</span>(</span><br><span class="line">            fx_ * <span class="built_in">p_c</span>(<span class="number">0</span>, <span class="number">0</span>) / <span class="built_in">p_c</span>(<span class="number">2</span>, <span class="number">0</span>) + cx_,  <span class="comment">// u = fx*X/Z+cx</span></span><br><span class="line">            fx_ * <span class="built_in">p_c</span>(<span class="number">1</span>, <span class="number">0</span>) / <span class="built_in">p_c</span>(<span class="number">2</span>, <span class="number">0</span>) + cy_); <span class="comment">// v = fy*Y/Z+cy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::pixel2camera</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector3d</span>(</span><br><span class="line">            (<span class="built_in">p_p</span>(<span class="number">0</span>, <span class="number">0</span>) - cx_) * depth / fx_, <span class="comment">// X = (u-cx)*Z/fx</span></span><br><span class="line">            (<span class="built_in">p_p</span>(<span class="number">1</span>, <span class="number">0</span>) - cy_) * depth / fy_, <span class="comment">// Y = (v-cy)*Z/fy</span></span><br><span class="line">            depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">Camera::pixel2world</span><span class="params">(<span class="keyword">const</span> Vector2d &amp;p_p, <span class="keyword">const</span> SE3 &amp;T_c_w, <span class="keyword">double</span> depth = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">camera2world</span>(<span class="built_in">pixel2camera</span>(p_p, depth), T_c_w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2d <span class="title">Camera::world2pixel</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;p_w, <span class="keyword">const</span> SE3 &amp;T_c_w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">camera2pixel</span>(<span class="built_in">world2camera</span>(p_w, T_c_w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Frame类"><a href="#Frame类" class="headerlink" title="Frame类"></a>Frame类</h3><p>由于 Frame 类是基本数据单元，在许多地方会用到它，但现在初期设计阶段，我们还不清楚以后可能新加的内容。所以这里的 Frame 类只提供基本的数据存储和接口。如果之后有新增的内容，我们就继续往里添加。</p><p><strong>WL_SLAM_VO/include/myslam/frame.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FRAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME</span></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 提前声明MapPoint类，需要用到帧的关键点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapPoint</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Frame&gt; Ptr; <span class="comment">// 定义Frame类的智能指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> id_;                  <span class="comment">// 图像帧的id编号</span></span><br><span class="line">    <span class="keyword">double</span> time_stamp_;                 <span class="comment">// 图像帧被记录的时间戳</span></span><br><span class="line">    SE3 T_c_w_;                         <span class="comment">// 世界坐标系到相机坐标系的变换矩阵</span></span><br><span class="line">    Camera::Ptr camera_;                <span class="comment">//针孔RGB-D相机模型</span></span><br><span class="line">    Mat color_, depth_;                 <span class="comment">// 彩色图以及图像深度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frame</span>();</span><br><span class="line">    <span class="built_in">Frame</span>(<span class="keyword">long</span> id, <span class="keyword">double</span> time_stamp=<span class="number">0</span>, SE3 T_c_w=<span class="built_in">SE3</span>(), Camera::Ptr=<span class="literal">nullptr</span>,</span><br><span class="line">        Mat color = <span class="built_in">Mat</span>(),Mat depth = <span class="built_in">Mat</span>() );</span><br><span class="line">    ~<span class="built_in">Frame</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建帧</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Frame::Ptr <span class="title">creatFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 寻找给定点对应的深度 </span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findDepth</span><span class="params">(<span class="keyword">const</span> cv::KeyPoint &amp;kp)</span></span>;</span><br><span class="line">    <span class="comment">// 获取相机光心</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">getCamCenter</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 判断某个点是否在视野内</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInFrame</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;pt_world)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>WL_SLAM_VO/src/frame.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/common_include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myslam/frame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myslam</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造与析构</span></span><br><span class="line">Frame::<span class="built_in">Frame</span>() : <span class="built_in">id_</span>(<span class="number">-1</span>),<span class="built_in">time_stamp_</span>(<span class="number">-1</span>),<span class="built_in">camera_</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">Frame::<span class="built_in">Frame</span> ( <span class="keyword">long</span> id, <span class="keyword">double</span> time_stamp, SE3 T_c_w, Camera::Ptr camera, Mat color, Mat depth )</span><br><span class="line">: <span class="built_in">id_</span>(id), <span class="built_in">time_stamp_</span>(time_stamp), <span class="built_in">T_c_w_</span>(T_c_w), <span class="built_in">camera_</span>(camera), <span class="built_in">color_</span>(color), <span class="built_in">depth_</span>(depth)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Frame::~<span class="built_in">Frame</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Frame</span></span><br><span class="line"><span class="function">Frame::Ptr <span class="title">Frame::creatFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> factory_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Frame::<span class="built_in">Ptr</span>( <span class="keyword">new</span> <span class="built_in">Frame</span>(factory_id++) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找给定点对应的深度</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Frame::findDepth</span><span class="params">(<span class="keyword">const</span> cv::KeyPoint &amp;kp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得像素点的坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">cvRound</span>(kp.pt.x);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">cvRound</span>(kp.pt.y);</span><br><span class="line">    <span class="comment">// 得到像素点的深度</span></span><br><span class="line">    ushort d = depth_.ptr&lt;ushort&gt;(y)[x];</span><br><span class="line">    <span class="keyword">if</span>(d != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in"><span class="keyword">double</span></span>(d)/camera_-&gt;depth_scale_;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果该像素深度为0，则选择附近的点作为参考</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            d = depth_.ptr&lt;ushort&gt;(y+dy[i])[x+dx[i]];</span><br><span class="line">            <span class="keyword">if</span>(d != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in"><span class="keyword">double</span></span>(d)/camera_-&gt;depth_scale_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取相机光心</span></span><br><span class="line"><span class="function">Vector3d <span class="title">Frame::getCamCenter</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//相机坐标系的（0,0,0）在世界坐标系下的位置</span></span><br><span class="line">    <span class="keyword">return</span> T_c_w_.<span class="built_in">inverse</span>().<span class="built_in">translation</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断某个点是否在视野内</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Frame::isInFrame</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;pt_world)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将世界坐标系下的点转换为相机坐标系</span></span><br><span class="line">    Vector3d p_cam = camera_-&gt;<span class="built_in">world2camera</span>(pt_world,T_c_w_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">p_cam</span>(<span class="number">2.0</span>)&lt;<span class="number">0</span>) <span class="comment">// Z小于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Vector2d pixel = camera_-&gt;<span class="built_in">world2pixel</span>(pt_world,T_c_w_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pixel</span>(<span class="number">0</span>,<span class="number">0</span>)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">1</span>,<span class="number">0</span>)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">0</span>,<span class="number">0</span>)&lt;color_.cols </span><br><span class="line">        &amp;&amp; <span class="built_in">pixel</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;color_.rows;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace myslam</span></span><br></pre></td></tr></table></figure><h3 id="MapPoint-类"><a href="#MapPoint-类" class="headerlink" title="MapPoint 类"></a>MapPoint 类</h3><p><strong>WL_SLAM_VO/include/myslam/mappoint.h</strong></p><p>MapPoint 表示路标点。我们将估计它的世界坐标，并且我们会拿当前帧提取到的特征点与地图中的路标点匹配，来估计相机的运动，因此还需要存储它对应的描述子。此外，我们会记录一个点被观测到的次数和被匹配到的次数，作为评价它的好坏程度的指标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><p><strong>WL_SLAM_VO/include/myslam/map.h</strong></p><p>Map 类管理着所有的路标点，并负责添加新路标、删除不好的路标等工作。VO 的匹配过程只需要和 Map 打交道即可。当然 Map 也会有很多操作，但现阶段我们只定义主要的数据结构。</p><p><strong>WL_SLAM_VO/src/map.h</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;本次实践将前几章内容结合进来，实际书写一个视觉里程计程序，由于单目相机存在初始化问题以及尺度问题，因此本实践采用的是最简单的RGB-D相机，但是使用的也只是RGB-D数据集，而非真正的RGB-D相机。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch8_RGB-D直接法实践</title>
    <link href="https://lukeyalvin.top/posts/18310.html"/>
    <id>https://lukeyalvin.top/posts/18310.html</id>
    <published>2022-03-29T08:19:56.968Z</published>
    <updated>2022-04-26T01:20:20.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>此次实践使用RGB-D相机主要是因为它省略掉了深度的恢复部分，如果使用单目相机，则需要进行深度的恢复，在之前的实践内容中，我们使用单目相机主要是采用基于特征点的深度恢复，后面会介绍相应的基于块匹配的深度恢复。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="一、直接法"><a href="#一、直接法" class="headerlink" title="一、直接法"></a>一、直接法</h1><p>直接法根据空间点$P$的来源不同，对应不同的直接法。</p><ul><li>稀疏直接法</li></ul><p>若$P$来自于稀疏关键点，我们称之为稀疏直接法。通常我们使用数百个至上千个关键点，并且像 $L-K $光流那样，假设它周围像素也是不变的。这种稀疏直接法不必计算描述子，并且只使用数百个像素，因此速度最快，但只能计算稀疏的重构。</p><ul><li>半稠密（Semi-Dense）的直接法</li></ul><p>如果像素梯度为零，整一项雅可比就为零，不会对计算运动增量有任何贡献。因此，可以考虑只使用带有梯度的像素点，舍弃像素梯度不明显的地方。</p><script type="math/tex; mode=display">J=-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><ul><li>稠密直接法</li></ul><p>稠密重构需要计算所有像素（一般几十万至几百万个），因此多数不能在现有的 CPU 上实时计算，需要 GPU 的加速。但是，如前面所讨论的，梯度不明显的点，在运动估计中不会有太大贡献，在重构时也会难以估计位置。</p><blockquote><p>稀疏到稠密重构，都可以用直接法来计算。它们的计算量是逐渐增长的。<strong>稀疏方法可以快速地求解相机位姿，而稠密方法可以建立完整地图。</strong>具体使用哪种方法，需要视机器人的应用环境而定。特别地，在低端的计算平台上，稀疏直接法可以做到非常快速的效果，适用于实时性较高且计算资源有限的场合</p></blockquote><h1 id="二、稀疏直接法"><a href="#二、稀疏直接法" class="headerlink" title="二、稀疏直接法"></a>二、稀疏直接法</h1><p>由于求解直接法最后等价于求解一个优化问题，因此我们可以使用$ g2o$ 或$ Ceres $这些优化库帮助我们求解。本节以 $g2o $为例设计实验，在使用 $g2o$之前，需要把直接法抽象成一个图优化问题。显然，直接法是由以下顶点和边组成的：</p><ul><li>优化变量</li></ul><p>优化变量为<strong>一个相机位姿</strong>，因此需要一个位姿顶点。由于我们在推导中使用了李代数，故程序中使用李代数表达的 $SE(3) $位姿顶点。可以使用“Ver-texSE3Expmap”作为相机位姿。</p><ul><li>误差项</li></ul><p>误差项为单个像素的<strong>光度误差</strong>。由于整个优化过程中 $I_1 (p_1 ) $保持不变，我们可以把它当成一个固定的预设值，然后调整相机位姿，使 $I_2 (p_2 )$ 接近这个值。于是，这种边只连接一个顶点，为一元边。由于 $g2o $中本身没有计算光度误差的边，我们需要自己定义一种新的边。</p><h2 id="2-1-构建直接法的边"><a href="#2-1-构建直接法的边" class="headerlink" title="2.1 构建直接法的边"></a>2.1 构建直接法的边</h2><p>直接法的边表示的光度误差，它是一个一元边，定义边的格式之前已经叙述，主要是对<code>virtual void computeError()</code>和<code>virtual void linearizeOplus()</code>两个函数进行重写。我们分别介绍。</p><h3 id="光度误差类的定义"><a href="#光度误差类的定义" class="headerlink" title="光度误差类的定义"></a>光度误差类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义直接法的边(光度误差的边),它是一个一元边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3ProjectDirect</span> :</span> <span class="keyword">public</span> BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">    <span class="title">EdgeSE3ProjectDirect</span><span class="params">(Eigen::Vector3d point, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, cv::Mat *image)</span> : x_world_(point), fx_(fx), fy_(fy), cx_(cx), cy_(cy), image_(image)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolread</span><span class="params">(istream &amp;in)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 从参考图像中获取灰度值（双线性插值）</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Eigen::Vector3d x_world_;                 <span class="comment">// 世界坐标系中的3D点</span></span><br><span class="line">    <span class="keyword">float</span> cx_ = <span class="number">0</span>, cy_ = <span class="number">0</span>, fx_ = <span class="number">0</span>, fy_ = <span class="number">0</span>; <span class="comment">// 相机内参</span></span><br><span class="line">    cv::Mat *image_ = <span class="literal">nullptr</span>;                <span class="comment">//参考图像</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们的边继承自 <code>g2o::BaseUnaryEdge</code>。在继承时，需要在模板参数里填入测量值的维度、类型，以及连接此边的顶点，同时，我们把空间点 P 、相机内参和图像存储在该边的成员变量中。为了让 g2o 优化该边对应的误差，我们需要覆写两个虚函数：用 <code>computeError()</code>计算误差值，用<code>linearizeOplus()</code>计算雅可比。</p><h3 id="getPixelValue"><a href="#getPixelValue" class="headerlink" title="getPixelValue"></a>getPixelValue</h3><p>为了更精细地计算像素亮度，我们要对图像进行插值。我们这里采用了简单的双线性插值，也可以使用更复杂的插值方式，但计算代价可能会变高一些。</p><p>所以，相比之前的边的定义，这里多了一个函数<code>inline float getPixelValue(float x, float y);</code>，它的作用是从参考图像中获取灰度值，利用的是OpenCV中的双线性插值法，我们先书写它的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从参考图像中获取灰度值（双线性插值）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar *data = &amp;image_-&gt;data[<span class="built_in"><span class="keyword">int</span></span>(y) * image_-&gt;step + <span class="built_in"><span class="keyword">int</span></span>(x)];</span><br><span class="line">    <span class="keyword">float</span> xx = x - <span class="built_in">floor</span>(x);</span><br><span class="line">    <span class="keyword">float</span> yy = y - <span class="built_in">floor</span>(y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">float</span></span>(</span><br><span class="line">    (<span class="number">1</span> - xx) * (<span class="number">1</span> - yy) * data[<span class="number">0</span>] +</span><br><span class="line">    xx * (<span class="number">1</span> - yy) * data[image_-&gt;step] +</span><br><span class="line">    (<span class="number">1</span> - xx) * yy * data[image_-&gt;step + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释待理解……</p><h3 id="computeError"><a href="#computeError" class="headerlink" title="computeError"></a>computeError</h3><p>由前文可知，误差项为单个像素的<strong>光度误差</strong>。由于整个优化过程中 $I_1 (p_1 ) $保持不变，我们可以把它当成一个固定的预设值，然后调整相机位姿，使 $I_2 (p_2 )$ 接近这个值。<code>virtual void computeError()</code>这个函数则是使用该边连接的节点和观测值来计算误差。</p><p>程序中的误差计算里，使用了$ I_2 (p_2 ) − I_1 (p_1 )$ 的形式，因此前面的负号可以省去，只需把像素梯度乘以像素到李代数的梯度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line"><span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> VertexSE3Expmap *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    Eigen::Vector3d x_local = v-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(x_world_); <span class="comment">//.map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">    <span class="comment">// 获得像素坐标</span></span><br><span class="line">    <span class="keyword">float</span> x = x_local[<span class="number">0</span>] * fx_ / x_local[<span class="number">2</span>] + cx_; <span class="comment">// x(u) = (X * fx)/Z + cx</span></span><br><span class="line">    <span class="keyword">float</span> y = x_local[<span class="number">1</span>] * fy_ / x_local[<span class="number">2</span>] + cy_; <span class="comment">// y(v) = (Y * fy)/Z + cy</span></span><br><span class="line">    <span class="comment">// 检查该像素点是否在图像内</span></span><br><span class="line">    <span class="keyword">if</span> (x - <span class="number">4</span> &lt; <span class="number">0</span> || (x + <span class="number">4</span>) &gt; image_-&gt;cols || (y - <span class="number">4</span>) &lt; <span class="number">0</span> || (y + <span class="number">4</span>) &gt; image_-&gt;rows)</span><br><span class="line">    &#123;</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setLevel</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = <span class="built_in">getPixelValue</span>(x, y) - _measurement; <span class="comment">// 光度误差，像素的亮度误差，或者是灰度值误差</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linearizeOplus"><a href="#linearizeOplus" class="headerlink" title="linearizeOplus"></a>linearizeOplus</h3><p>这个函数主要是计算雅克比矩阵，它是可选的，如果给出了则进行解析求导，不给则进行数值求导。我们直接在直接法的推导中已经介绍了该矩阵的计算，下面是推导结论，因此直接根据公式书写代码即可。</p><p>由直接法的推导可知：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial u}{\partial \delta \xi}&=\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}=\begin{bmatrix}\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}&-\frac{f_xXY}{Z^{2}}&f_x+\frac{f_xX^2}{Z^{2}}&-\frac{f_xY}{Z}\\0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}&-f_y-\frac{f_yY^{2}}{Z^{2}}&\frac{f_yXY}{Z}&\frac{f_yX}{Z}\end{bmatrix}\end{align}</script><p>最终的约旦矩阵为：</p><script type="math/tex; mode=display">J=-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><p>由于上面的误差使用的是$ I_2 (p_2 ) − I_1 (p_1 )$ 的形式，所以：</p><script type="math/tex; mode=display">J=\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">level</span>() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _jacobianOplusXi = Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt;::<span class="built_in">Zero</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">    VertexSE3Expmap *vtx = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 将世界坐标系下的三维点的估计转换成相机坐标系下</span></span><br><span class="line">    Eigen::Vector3d xyz_trans = vtx-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(x_world_);</span><br><span class="line">    <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];          <span class="comment">// X</span></span><br><span class="line">    <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];          <span class="comment">// Y</span></span><br><span class="line">    <span class="keyword">double</span> invz = <span class="number">1.0</span> / xyz_trans[<span class="number">2</span>]; <span class="comment">// 1/Z</span></span><br><span class="line">    <span class="keyword">double</span> invz_2 = invz * invz;      <span class="comment">// 1/Z^2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> u = x * fx_ * invz + cx_; <span class="comment">// u = (X*fx)/Z+cx</span></span><br><span class="line">    <span class="keyword">float</span> v = v * fy_ * invz + cy_; <span class="comment">// v = (Y*fy)/Z+cy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先求投影方程关于变换的导数 ∂u/∂δξ</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">6</span>&gt; jacobian_uv_ksai;</span><br><span class="line">    <span class="comment">// g2o 是旋转在前，平移在后；</span></span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">0</span>) = -x * y * fx_ * invz_2;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">1</span>) = (<span class="number">1</span> + x * x * invz_2) * fx_;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">2</span>) = -fx_ * y * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">3</span>) = fx_ * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">0</span>, <span class="number">6</span>) = -fx_ * x * invz_2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">0</span>) = -(<span class="number">1</span> + y * y * invz_2) * fy_;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">1</span>) = fy_ * x * y * invz_2;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">2</span>) = fy_ * x * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">4</span>) = fy_ * invz;</span><br><span class="line">    <span class="built_in">jacobian_uv_ksai</span>(<span class="number">1</span>, <span class="number">5</span>) = -y * invz_2 * fy_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像素的梯度 ∂I2/∂u</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; jacobian_pixel_uv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jacobian_pixel_uv</span>(<span class="number">0</span>, <span class="number">0</span>) = (<span class="built_in">getPixelValue</span>(u + <span class="number">1</span>, v) - <span class="built_in">getPixelValue</span>(u - <span class="number">1</span>, v)) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">jacobian_pixel_uv</span>(<span class="number">0</span>, <span class="number">1</span>) = (<span class="built_in">getPixelValue</span>(u, v + <span class="number">1</span>) - <span class="built_in">getPixelValue</span>(u, v - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// J矩阵 = ∂I2/∂u * ∂u/∂δξ</span></span><br><span class="line">    _jacobianOplusXi = jacobian_pixel_uv*jacobian_uv_ksai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-直接法估计相机运动"><a href="#2-2-直接法估计相机运动" class="headerlink" title="2.2 直接法估计相机运动"></a>2.2 直接法估计相机运动</h2><p>在使用直接法估计相机运动时，我们用过g2o对相机的位姿进行优化，其中的观测值为世界坐标系下的3D点坐标以及对应的灰度值，因此我们使用一个结构体<code>Measurement</code>用来存储观测值，由于需要用到相机坐标系之间的变换，所以还需要写坐标变换相关的函数。</p><h3 id="Measurement结构体"><a href="#Measurement结构体" class="headerlink" title="Measurement结构体"></a>Measurement结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Measurement</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Measurement</span>(Eigen::Vector3d p, <span class="keyword">float</span> g) : <span class="built_in">pos_world</span>(p), <span class="built_in">grayscale</span>(g) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d pos_world;</span><br><span class="line">    <span class="keyword">float</span> grayscale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="project2Dto3D"><a href="#project2Dto3D" class="headerlink" title="project2Dto3D"></a>project2Dto3D</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将像素坐标系转换为世界坐标系</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector3d <span class="title">project2Dto3D</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> zz = <span class="built_in"><span class="keyword">float</span></span>(d) / scale;</span><br><span class="line">    <span class="keyword">float</span> xx = zz * (x - cx) / fx; <span class="comment">// X = Z*(u-cx)/fx</span></span><br><span class="line">    <span class="keyword">float</span> yy = zz * (y - cy) / fy; <span class="comment">// Y = Z*(u-cy)/fy</span></span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector3d</span>(xx, yy, zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="project3Dto2D"><a href="#project3Dto2D" class="headerlink" title="project3Dto2D"></a>project3Dto2D</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将世界坐标系转换为像素坐标系</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector2d <span class="title">project3Dto2D</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> u = fx * x / z + cx; <span class="comment">// u = fx*X/Z + cx</span></span><br><span class="line">    <span class="keyword">float</span> v = fy * y / z + cy; <span class="comment">// v = fy*Y/Z + cy</span></span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector2d</span>(u, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poseEstimationDirect"><a href="#poseEstimationDirect" class="headerlink" title="poseEstimationDirect"></a>poseEstimationDirect</h3><p>这是最主要的一个函数，用直接法估计相机运动，并使用了g2o对位姿进行优化。<strong>相比于特征点法，直接法完全依靠优化来求解相机位姿。</strong></p><p>原理就是以第一个图像为参考帧，然后用直接法求解后续图像的位姿。在参考帧中，对第一张图像提取 FAST 关键点（不需要描述子），并使用直接法估计这些关键点在第二个图像中的位置，以及第二个图像的相机位姿。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用直接法估计相机运动(使用非线性BA优化)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">poseEstimationDirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Measurement&gt; &amp;measurements, <span class="comment">// 测量值：一个世界坐标系下三维点与一个灰度值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Mat *gray,                          <span class="comment">// 灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Eigen::Matrix3f &amp;K,                     <span class="comment">// 相机参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Eigen::Isometry3d &amp;Tcw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">1</span>&gt;&gt; DirectBlock;</span><br><span class="line">    <span class="comment">// 1.创建线性求解器 LinearSolverDense使用dense cholesky分解法</span></span><br><span class="line">    DirectBlock::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;DirectBlock::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 2.创建矩阵块求解器，用上面我们定义的线性求解器LinearSolver来初始化。</span></span><br><span class="line">    DirectBlock *solver_ptr = <span class="keyword">new</span> <span class="built_in">DirectBlock</span>(std::unique_ptr&lt;DirectBlock::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 3.创建总求解器solver</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmLevenberg</span>(unique_ptr&lt;DirectBlock&gt;(solver_ptr));</span><br><span class="line">    <span class="comment">// 4.创建稀疏优化器</span></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用LM方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.定义图的顶点和边</span></span><br><span class="line">    <span class="comment">// 顶点(待优化变量，这里是相机位姿)</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    <span class="comment">// 设置待优化位姿旋转(Rotation)(角轴或四元素表示)、平移(Translation)</span></span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(Tcw.<span class="built_in">rotation</span>(), Tcw.<span class="built_in">translation</span>()));</span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边(误差，这里是光影误差)</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Measurement m : measurements)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeSE3ProjectDirect *edge = <span class="keyword">new</span> <span class="built_in">EdgeSE3ProjectDirect</span>(</span><br><span class="line">            m.pos_world,</span><br><span class="line">            <span class="built_in">K</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">K</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">K</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="built_in">K</span>(<span class="number">1</span>, <span class="number">2</span>), gray);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, pose);                                      <span class="comment">// 定义顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(m.grayscale);                             <span class="comment">// 定义观测值</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>()); <span class="comment">// 定义协方差矩阵的逆</span></span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(id++);</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;图中的边的个数：&quot;</span> &lt;&lt; optimizer.<span class="built_in">edges</span>().<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 6.开始优化</span></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">30</span>); <span class="comment">// 迭代次数</span></span><br><span class="line">    <span class="comment">// 优化后的相机位姿</span></span><br><span class="line">    Tcw = pose-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-主函数"><a href="#2-3-主函数" class="headerlink" title="2.3 主函数"></a>2.3 主函数</h2><p>整个主函数的顺序需要了解</p><ul><li>首先是一些判断或者一些初始化</li><li>然后我们对数据集循环操作每一张图片，但是第一张图像为参考，对后续图像和参考图像做直接法</li><li>对第一张图提取Fast关键点（不需要描述子）</li><li>使用直接法估计这些关键点在第二个图像中的位置，以及第二个图像的相机位姿</li><li>最后就是绘制这些特征点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;usage: useLK path_to_dataset&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    string path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    string assciate_file = path_to_dataset + <span class="string">&quot;/assciate.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(assciate_file)</span></span>;</span><br><span class="line">    string rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    cv::Mat color, depth, gray;</span><br><span class="line">    vector&lt;Measurement&gt; measurements;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">float</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">float</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">float</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">float</span> depth_scale = <span class="number">1000.0</span>;</span><br><span class="line">    Eigen::Matrix3f K;</span><br><span class="line">    K &lt;&lt; fx, <span class="number">0.f</span>, cx, <span class="number">0.f</span>, fy, cy, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Isometry3d Tcw = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line">    cv::Mat prev_color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们以第一个图像为参考，对后续图像和参考图像做直接法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*********** loop &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">        fin &gt;&gt; time_rgb &gt;&gt; rgb_file &gt;&gt; time_depth &gt;&gt; depth_file;</span><br><span class="line">        color = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + rgb_file);</span><br><span class="line">        depth = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + depth_file, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (color.data == <span class="literal">nullptr</span> || depth.data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环</span></span><br><span class="line">        <span class="comment">// 将BGR格式(color)转换成灰度图片(gray)</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(color, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;cv::KeyPoint&gt; keypoints;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">            <span class="comment">// 使用Fast特征点检测，讲检测后的特征点存入容器keypoints中</span></span><br><span class="line">            detector-&gt;<span class="built_in">detect</span>(color, keypoints);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉邻近边缘处的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (kp.pt.x &lt; <span class="number">20</span> || kp.pt.y &lt; <span class="number">20</span> || (kp.pt.x + <span class="number">20</span>) &gt; color.cols || (kp.pt.y + <span class="number">20</span>) &gt; color.rows)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环</span></span><br><span class="line">                <span class="comment">// d指定到depth矩阵的y行第x列个像素</span></span><br><span class="line">                ushort d = depth.ptr&lt;ushort&gt;(<span class="built_in">cvRound</span>(kp.pt.y))[<span class="built_in">cvRound</span>(kp.pt.x)];</span><br><span class="line">                <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 将像素坐标系转换为世界坐标系</span></span><br><span class="line">                Eigen::Vector3d p3p = <span class="built_in">project2Dto3D</span>(kp.pt.x, kp.pt.y, d, fx, fy, cx, cy, depth_scale);</span><br><span class="line">                <span class="comment">// grayscale指定到gray矩阵的y行第x列个像素</span></span><br><span class="line">                <span class="keyword">float</span> grayscale = <span class="built_in"><span class="keyword">float</span></span>(gray.<span class="built_in">ptr</span>(<span class="built_in">cvRound</span>(kp.pt.y))[<span class="built_in">cvRound</span>(kp.pt.x)]);</span><br><span class="line">                <span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line">                measurements.<span class="built_in">push_back</span>(<span class="built_in">Measurement</span>(p3p, grayscale));</span><br><span class="line">            &#125;</span><br><span class="line">            prev_color = color.<span class="built_in">clone</span>();</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;add total &quot;</span>&lt;&lt;measurements.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; measurements.&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.对后续图像使用直接法计算相机运动</span></span><br><span class="line">        <span class="built_in">poseEstimationDirect</span>(measurements, &amp;gray, K, Tcw);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tcw=&quot;</span> &lt;&lt; Tcw.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.绘制特征点</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">img_show</span><span class="params">(color.rows * <span class="number">2</span>, color.cols, CV_8UC3)</span></span>;</span><br><span class="line">        prev_color.<span class="built_in">copyTo</span>(<span class="built_in">img_show</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, color.cols, color.rows)));</span><br><span class="line">        color.<span class="built_in">copyTo</span>(<span class="built_in">img_show</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, color.rows, color.cols, color.rows)));</span><br><span class="line">        <span class="keyword">for</span> (Measurement m : measurements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rand</span>() &gt; RAND_MAX / <span class="number">5</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p = m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_prev = <span class="built_in">project3Dto2D</span>(<span class="built_in">p</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">p</span>(<span class="number">2</span>, <span class="number">0</span>), fx, fy, cx, cy);</span><br><span class="line">            Eigen::Vector3d p2 = Tcw * m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_now = <span class="built_in">project3Dto2D</span>(<span class="built_in">p2</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">p2</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">p2</span>(<span class="number">2</span>, <span class="number">0</span>), fx, fy, cx, cy);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span> || <span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>) &gt;= color.cols || <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span> || <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) &gt;= color.rows)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> b = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> g = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> r = <span class="number">255</span> * <span class="built_in"><span class="keyword">float</span></span>(<span class="built_in">rand</span>()) / RAND_MAX;</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_prev</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_prev</span>(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">8</span>, cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">2</span>);</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) + color.rows), <span class="number">8</span>, cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">2</span>);</span><br><span class="line">            cv::<span class="built_in">line</span>(img_show, cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_prev</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_prev</span>(<span class="number">1</span>, <span class="number">0</span>)), cv::<span class="built_in">Point2d</span>(<span class="built_in">pixel_now</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">pixel_now</span>(<span class="number">1</span>, <span class="number">0</span>) + color.rows), cv::<span class="built_in">Scalar</span>(b, g, r), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, img_show);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( directMethod )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块路径</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( G2O )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span> ) </span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( <span class="string">&quot;/usr/include/eigen3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( G2O_LIBS </span><br><span class="line">    g2o_core g2o_types_sba g2o_solver_csparse g2o_stuff g2o_csparse_extension </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( direct_sparse direct_sparse.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( direct_sparse <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;G2O_LIBS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( direct_semidense direct_semidense.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( direct_semidense <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;G2O_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">*********** loop <span class="number">0</span> ************</span><br><span class="line">add total <span class="number">1402</span> measurements.</span><br><span class="line">*********** loop <span class="number">1</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7403254.830490</span>    <span class="selector-tag">time</span>= <span class="number">0.00082488</span>        cumTime= <span class="number">0.00082488</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">60236876.490033</span>        levenbergIter= <span class="number">5</span></span><br><span class="line">iteration= <span class="number">1</span>     chi2= <span class="number">7403254.830490</span>    <span class="selector-tag">time</span>= <span class="number">0.00102553</span>        cumTime= <span class="number">0.00185041</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">2119396675894340747264.000000</span>  levenbergIter= <span class="number">9</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00288273</span>  <span class="number">2.64449</span>e-<span class="number">05</span> -<span class="number">0.000928174</span></span><br><span class="line"> -<span class="number">0.00288272</span>     <span class="number">0.999996</span> -<span class="number">0.000436968</span> -<span class="number">3.76331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.77045</span>e-<span class="number">05</span>   <span class="number">0.00043689</span>            <span class="number">1</span>   <span class="number">0.00103318</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">2</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7759380.788781</span>    <span class="selector-tag">time</span>= <span class="number">0.00174707</span>        cumTime= <span class="number">0.00174707</span>     </span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">9</span>     chi2= <span class="number">7758019.671470</span>    <span class="selector-tag">time</span>= <span class="number">0.000755714</span>       cumTime= <span class="number">0.00772499</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">3783063956763384479744.000000</span>  levenbergIter= <span class="number">5</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00288243</span>  <span class="number">2.77591</span>e-<span class="number">05</span> -<span class="number">0.000928009</span></span><br><span class="line"> -<span class="number">0.00288242</span>     <span class="number">0.999996</span> -<span class="number">0.000441154</span> -<span class="number">3.82145</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.90306</span>e-<span class="number">05</span>  <span class="number">0.000441072</span>            <span class="number">1</span>   <span class="number">0.00103304</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">3</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">7824244.109174</span>    <span class="selector-tag">time</span>= <span class="number">0.00174816</span>        cumTime= <span class="number">0.00174816</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">6220200914927.365234</span>   levenbergIter= <span class="number">8</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">8</span>     chi2= <span class="number">7819308.542160</span>    <span class="selector-tag">time</span>= <span class="number">0.0010889</span>         cumTime= <span class="number">0.00689116</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">3127198551927549329408.000000</span>  levenbergIter= <span class="number">7</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00289109</span>  <span class="number">2.80266</span>e-<span class="number">05</span> -<span class="number">0.000927608</span></span><br><span class="line"> -<span class="number">0.00289108</span>     <span class="number">0.999996</span> -<span class="number">0.000451442</span> -<span class="number">3.83751</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.93317</span>e-<span class="number">05</span>  <span class="number">0.000451359</span>            <span class="number">1</span>   <span class="number">0.00103126</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">4</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8430224.068489</span>    <span class="selector-tag">time</span>= <span class="number">0.0017704</span>         cumTime= <span class="number">0.0017704</span>      edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">14477120284239.218750</span>  levenbergIter= <span class="number">8</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">10</span>    chi2= <span class="number">8429345.097617</span>    <span class="selector-tag">time</span>= <span class="number">0.000582781</span>       cumTime= <span class="number">0.00791508</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">25272065502643142656.000000</span>    levenbergIter= <span class="number">4</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">5</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8454586.253220</span>    <span class="selector-tag">time</span>= <span class="number">0.00216226</span>        cumTime= <span class="number">0.00216226</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">11915390830915310583808.000000</span>         levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">6</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8159516.143149</span>    <span class="selector-tag">time</span>= <span class="number">0.00214553</span>        cumTime= <span class="number">0.00214553</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">7207697814143619825664.000000</span>  levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">7</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8203720.110076</span>    <span class="selector-tag">time</span>= <span class="number">0.0021112</span>         cumTime= <span class="number">0.0021112</span>      edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">21225209233812976828416.000000</span>         levenbergIter= <span class="number">10</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>    <span class="number">0.0028903</span>  <span class="number">2.74361</span>e-<span class="number">05</span> -<span class="number">0.000927784</span></span><br><span class="line"> -<span class="number">0.00289029</span>     <span class="number">0.999996</span>  -<span class="number">0.00044829</span> -<span class="number">3.78331</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">2.87317</span>e-<span class="number">05</span>  <span class="number">0.000448209</span>            <span class="number">1</span>   <span class="number">0.00103136</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">8</span> ************</span><br><span class="line">图中的边的个数：<span class="number">1402</span></span><br><span class="line">iteration= <span class="number">0</span>     chi2= <span class="number">8054487.520687</span>    <span class="selector-tag">time</span>= <span class="number">0.00161749</span>        cumTime= <span class="number">0.00161749</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">306330210612.899292</span>    levenbergIter= <span class="number">7</span></span><br><span class="line">......</span><br><span class="line">iteration= <span class="number">5</span>     chi2= <span class="number">8047353.368341</span>    <span class="selector-tag">time</span>= <span class="number">0.00105102</span>        cumTime= <span class="number">0.00563404</span>     edges= <span class="number">1402</span>     schur= <span class="number">0</span>        lambda= <span class="number">4158192944542638931968.000000</span>  levenbergIter= <span class="number">6</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999996</span>   <span class="number">0.00290379</span>  <span class="number">2.91578</span>e-<span class="number">05</span> -<span class="number">0.000927602</span></span><br><span class="line"> -<span class="number">0.00290378</span>     <span class="number">0.999996</span> -<span class="number">0.000470562</span> -<span class="number">4.13493</span>e-<span class="number">05</span></span><br><span class="line">-<span class="number">3.05241</span>e-<span class="number">05</span>  <span class="number">0.000470476</span>            <span class="number">1</span>   <span class="number">0.00103238</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">*********** loop <span class="number">9</span> ************</span><br></pre></td></tr></table></figure><p><img src="/posts/18310.htm/image-20220329164608300.png" alt="image-20220329164608300"></p><h1 id="三、半稠密直接法"><a href="#三、半稠密直接法" class="headerlink" title="三、半稠密直接法"></a>三、半稠密直接法</h1><p>我们很容易就能把程序拓展成半稠密的直接法形式。对参考帧中，先提取梯度较明显的像素，然后用直接法，以这些像素为图优化边，来估计相机运动。对先前的程序做如下的修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// select the pixels with high gradiants </span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x=<span class="number">10</span>; x&lt;gray.cols<span class="number">-10</span>; x++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> y=<span class="number">10</span>; y&lt;gray.rows<span class="number">-10</span>; y++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Eigen::Vector2d <span class="title">delta</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            gray.ptr&lt;uchar&gt;(y)[x+<span class="number">1</span>] - gray.ptr&lt;uchar&gt;(y)[x<span class="number">-1</span>], </span></span></span><br><span class="line"><span class="params"><span class="function">            gray.ptr&lt;uchar&gt;(y+<span class="number">1</span>)[x] - gray.ptr&lt;uchar&gt;(y<span class="number">-1</span>)[x]</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ( delta.<span class="built_in">norm</span>() &lt; <span class="number">50</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ushort d = depth.ptr&lt;ushort&gt; (y)[x];</span><br><span class="line">            <span class="keyword">if</span> ( d==<span class="number">0</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p3d = <span class="built_in">project2Dto3D</span> ( x, y, d, fx, fy, cx, cy, depth_scale );</span><br><span class="line">            <span class="keyword">float</span> grayscale = <span class="built_in"><span class="keyword">float</span></span> ( gray.ptr&lt;uchar&gt; (y) [x] );</span><br><span class="line">            measurements.<span class="built_in">push_back</span> ( <span class="built_in">Measurement</span> ( p3d, grayscale ) );</span><br><span class="line">        &#125;</span><br><span class="line">        prev_color = color.<span class="built_in">clone</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;add total &quot;</span>&lt;&lt;measurements.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; measurements.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*********** loop <span class="number">0</span> ************</span><br><span class="line">add total <span class="number">12556</span> measurements.</span><br><span class="line">*********** loop <span class="number">1</span> ************</span><br><span class="line">图中的边的个数：<span class="number">12556</span></span><br><span class="line">.....</span><br><span class="line">iteration= <span class="number">19</span>    chi2= <span class="number">71515789.320224</span>   <span class="selector-tag">time</span>= <span class="number">0.00527771</span>        cumTime= <span class="number">0.0867877</span>      edges= <span class="number">12556</span>    schur= <span class="number">0</span>        lambda= <span class="number">4022565853557871345664.000000</span>  levenbergIter= <span class="number">4</span></span><br><span class="line">Tcw= </span><br><span class="line">    <span class="number">0.999999</span> -<span class="number">1.99501</span>e-<span class="number">06</span>  -<span class="number">0.00124229</span>    <span class="number">0.0166827</span></span><br><span class="line"> <span class="number">3.02563</span>e-<span class="number">06</span>            <span class="number">1</span>  <span class="number">0.000829608</span>   -<span class="number">0.0119843</span></span><br><span class="line">  <span class="number">0.00124229</span> -<span class="number">0.000829611</span>     <span class="number">0.999999</span>   -<span class="number">0.0118238</span></span><br><span class="line">           <span class="number">0</span>            <span class="number">0</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">....</span><br><span class="line">*********** loop <span class="number">9</span> ************</span><br></pre></td></tr></table></figure><p><img src="/posts/18310.htm/alvin/Documents/lukeyalvin.github.io/Blog/source/_posts/RGB-D%E7%9B%B4%E6%8E%A5%E6%B3%95%E5%AE%9E%E8%B7%B5/image-20220330165208010.png" alt="image-20220330165208010"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;此次实践使用RGB-D相机主要是因为它省略掉了深度的恢复部分，如果使用单目相机，则需要进行深度的恢复，在之前的实践内容中，我们使用单目相机主要是采用基于特征点的深度恢复，后面会介绍相应的基于块匹配的深度恢复。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch8_直接法的推导</title>
    <link href="https://lukeyalvin.top/posts/50957.html"/>
    <id>https://lukeyalvin.top/posts/50957.html</id>
    <published>2022-03-29T07:04:31.274Z</published>
    <updated>2022-04-26T01:20:20.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>之前估计相机运动时使用对极几何、PnP 或 ICP 算法，而根据图像的像素灰度信息也可以计算相机运动，这种方法称为直接法。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>考虑某个空间点 $P$ 和两个时刻的相机。$P $的世界坐标为$ [X, Y, Z]$，它在两个相机上成像，记非齐次像素坐标为 $p_1 , p_2$ 。</p><p><img src="/posts/50957.htm/image-20220329150722092.png" alt="image-20220329150722092"></p><p>我们的目标是求第一个相机到第二个相机的相对位姿变换。我们以第一个相机为参照系，设第二个相机旋转和平移为$ R, t$（对应李代数为 $\xi$）。同时，两相机的内参相同，记为 $K$。为清楚起见，我们列写完整的投影方程：</p><script type="math/tex; mode=display">\begin{align*}p_1 &= \begin{bmatrix}u\\v\\1\end{bmatrix}_1=\frac{1}{Z_1}KP\\p_2&=\begin{bmatrix}u\\v\\1\end{bmatrix}_2=\frac{1}{Z_2}K(RP+t)=\frac{1}{Z_2}K(exp(\xi^{\land})P)_{1:3}\end{align*}</script><p>特征点法中，由于我们通过匹配描述子，知道了 $p_1 , p_2$ 的像素位置，所以可以计算重投影的位置。但在直接法中，由于没有特征匹配，我们无从知道哪一个 $p_1 , p_2$  对应着同一个点。</p><p>直接法的思路是根据当前相机的位姿估计值，来寻找 $p_2$ 的位置。但若相机位姿不够好， $p_2$ 的外观和  $p_1$ 会有明显差别。于是，为了减小这个差别，我们优化相机的位姿，来寻找与  $p_1$更相似的 $p_2$。</p><p>这同样可以通过解一个优化问题，但此时<strong>最小化的不是重投影误差</strong>，而是<strong>光度误差（Photometric Error）</strong>，也就是 $P $的两个像的亮度误差：</p><script type="math/tex; mode=display">e = I_1 (p_1 ) − I_2 (p_2 )</script><p>这里 e 是一个标量，同样的，优化目标为该误差的二范数，暂时取不加权的形式，为：</p><script type="math/tex; mode=display">\underset{\xi}{min}J(\xi)=\parallel e\parallel^2</script><p>由灰度不变假设，对于$N$个空间点$P_i$，整个相机的位姿估计问题变为：</p><script type="math/tex; mode=display">\underset{\xi}{min}J(\xi)=\sum^N_{i=1}e_i^Te_i\\e_i=I_1(p_1,i)-I_2(p_2,i)</script><p>这里的优化变量是相机位姿 $\xi$，为了求解这个优化问题，我们关心误差 $e$ 是如何随着相机位姿 $\xi$ 变化的，需要分析它们的导数关系。因此，使用李代数上的扰动模型。我们给 $exp(\xi) $左乘一个小扰动$ exp(\delta \xi)$:</p><script type="math/tex; mode=display">\begin{align*}e(\xi⊕\delta \xi)&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}K exp(\delta \xi^{\land})exp(\xi^{\land})P)\\&\approx I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}K (1+\delta \xi^{\land})exp(\xi^{\land})P)\\&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+\frac{1}{Z_2}K \delta \xi^{\land}exp(\xi^{\land})P)\\\end{align*}</script><p>记：</p><script type="math/tex; mode=display">\begin{align*}q&=\delta \xi^{\land}exp(\xi^{\land})P\\u&=\frac{1}{Z_2}Kq\end{align*}</script><p>$q $为$ P $在扰动之后，位于第二个相机坐标系下的坐标，而 $u $为它的像素坐标</p><p>由一阶泰勒展开可知：</p><script type="math/tex; mode=display">I(x+dx)\approx \frac{\partial I}{\partial x}dx\\I(x+\delta \xi)\approx \frac{\partial I}{\partial \delta \xi}{\delta \xi}</script><p>所以，同样的进行一阶泰勒展开：</p><script type="math/tex; mode=display">\begin{align*}e(\xi⊕\delta \xi)&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+\frac{1}{Z_2}K \delta \xi^{\land}exp(\xi^{\land})P)\\&=I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P+u)\\&\approx I_1(\frac{1}{Z_1}KP)-I_2(\frac{1}{Z_2}Kexp(\xi^{\land})P)-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}\delta \xi\\&=e(\xi)-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}\delta \xi\end{align*}</script><p>一阶导数由于链式法则分成了三项，分别计算这三部分：</p><p>$\partial I_2 / \partial u$为$ u $处的像素梯度；</p><p>$∂u/∂q $为投影方程关于相机坐标系下的三维点的导数，$q $为$ P $在扰动之后，位于第二个相机坐标系下的坐标，$u $为它的像素坐标，记为$q = [X, Y, Z]^T$</p><script type="math/tex; mode=display">\frac{\partial u}{\partial q}=-\begin{bmatrix}\frac{\partial u}{\partial X}&\frac{\partial u}{\partial Y}&\frac{\partial u}{\partial Z}            \\ \frac{\partial v}{\partial X}&\frac{\partial v}{\partial Y}&\frac{\partial v}{\partial Z}\end{bmatrix}=-\begin{bmatrix}\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}\\0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}\end{bmatrix}</script><p>$∂q/∂δξ $为变换后的三维点对变换的导数，由于$q$为变换后的三维点，设变换前的三维点为$q_0$</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial q}{\partial \delta \xi}&=\frac{\partial(Tq_0)}{\partial \delta \xi} \\ &=\underset{\delta \xi \rightarrow0}{lim}\frac{exp(\delta \xi ^{\land})exp(\xi ^{\land})q_0-exp(\xi ^{\land})q_0}{\delta \xi}\\&\approx\underset{\delta \xi \rightarrow0}{lim}\frac{(I+\delta \xi ^{\land})exp(\xi ^{\land})q_0-exp(\xi ^{\land})q_0}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\delta \xi ^{\land}exp(\xi ^{\land})q_0}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\begin{bmatrix}\delta \phi^{\land}&\delta \rho \\0^T&0\end{bmatrix}\begin{bmatrix}Rq_0+t \\1\end{bmatrix}}{\delta \xi}\\&=\underset{\delta \xi \rightarrow0}{lim}\frac{\begin{bmatrix}\delta \phi^{\land}(Rq_0+t)+\delta \rho  \\0\end{bmatrix}}{\delta \xi}\\&=\begin{bmatrix}I &-(Rq_0+t)^{\land}\\0^{T}&0^{T}\end{bmatrix}\\&=\begin{bmatrix}I &-q^{\land}\\0^{T}&0^{T}\end{bmatrix}\\&=(Tq)^⊙\end{align*}</script><p>后两项只与三维点 q 有关，而与图像无关，我们经常把它合并在一起：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial u}{\partial \delta \xi}&=\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta \xi}=-\begin{bmatrix}\frac{f_x}{Z}&0&-\frac{f_xX}{Z^{2}}&-\frac{f_xXY}{Z^{2}}&f_x+\frac{f_xX^2}{Z^{2}}&-\frac{f_xY}{Z}\\0&\frac{f_y}{Z}&-\frac{f_yY}{Z^{2}}&-f_y-\frac{f_yY^{2}}{Z^{2}}&\frac{f_yXY}{Z}&\frac{f_yX}{Z}\end{bmatrix}\end{align}</script><p>推导了误差相对于李代数的雅可比矩阵：</p><script type="math/tex; mode=display">J=-\frac{\partial I_2}{\partial u}\frac{\partial u}{\partial \delta \xi}</script><p>对于 $N $个点的问题，我们可以用这种方法计算优化问题的雅可比，然后使用$ G-N$或$L-M$ 计算增量，迭代求解。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;之前估计相机运动时使用对极几何、PnP 或 ICP 算法，而根据图像的像素灰度信息也可以计算相机运动，这种方法称为直接法。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch8_使用LK光流法</title>
    <link href="https://lukeyalvin.top/posts/46698.html"/>
    <id>https://lukeyalvin.top/posts/46698.html</id>
    <published>2022-03-29T02:32:32.151Z</published>
    <updated>2022-04-26T01:20:20.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>光流是一种描述像素随着时间，在图像之间运动的方法。随着时间的经过，同一个像素会在图像中运动，而我们希望追踪它的运动过程。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。稀疏光流以$ Lucas-Kanade$ 光流为代表，并可以在 SLAM 中用于跟踪特征点位置。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="/posts/46698.htm/image-20220329104428515.png" alt="image-20220329104428515"></p><h1 id="LK光流法原理"><a href="#LK光流法原理" class="headerlink" title="LK光流法原理"></a>LK光流法原理</h1><p>在$ LK $光流中，我们认为来自相机的图像是随时间变化的。图像可以看作时间的函数：$I(t)$。那么，一个在$ t $时刻，位于$ (x, y)$ 处的像素，它的灰度可以写成</p><script type="math/tex; mode=display">I(x, y, t).</script><p>灰度不变假设：</p><script type="math/tex; mode=display">I(x+d_x,y+d_y,t+d_t)=I(x, y, t)</script><p>对左边进行泰勒展开，保留一阶项，得：</p><script type="math/tex; mode=display">I (x + dx, y + dy, t + dt) \approx I (x, y, t)+\frac{\partial I}{\partial x}d_x+\frac{\partial I}{\partial y}d_y+\frac{\partial I}{\partial t}d_t</script><p>假设了灰度不变:</p><script type="math/tex; mode=display">\frac{\partial I}{\partial x}d_x+\frac{\partial I}{\partial y}d_y+\frac{\partial I}{\partial t}d_t=0</script><p>两边除以 $dt$:</p><script type="math/tex; mode=display">\frac{\partial I}{\partial x}\frac{d_x}{d_t}+\frac{\partial I}{\partial y}\frac{d_y}{d_t}=-\frac{\partial I}{\partial t}</script><p>其中: $dx/dt $为像素在 $x $轴上运动速度，记为$u$， $dy/dt $为像素在 $y$轴上运动速度，记为$v$</p><p>$\partial I/\partial x$为图像在该点处 $x$ 方向的梯度，记为$I_x$，$\partial I/\partial y$为图像在该点处 $y$ 方向的梯度，记为$I_y$</p><p>图像灰度对时间的变化量记为 $I_t$</p><script type="math/tex; mode=display">\begin{bmatrix}I_x & I_y\end{bmatrix}\begin{bmatrix}u \\ v\end{bmatrix}= - I_t</script><p>我们想计算的是像素的运动$ u, v$，但是该式是带有两个变量的一次方程，仅凭它无法计算出$ u, v$。因此，必须引入额外的约束来计算$ u, v$。在$ LK $光流中，我们假设某一个窗口内的像素具有相同的运动。</p><p>考虑一个大小为 $w × w$ 大小的窗口，它含有 $w^2 $数量的像素。由于该窗口内像素具有同样的运动，因此我们共有 $w^2 $个方程：</p><script type="math/tex; mode=display">\begin{bmatrix}I_x & I_y\end{bmatrix}_k\begin{bmatrix}u \\ v\end{bmatrix}= - I_{tk},k=1,....,w^2</script><p>即为：</p><script type="math/tex; mode=display">A = \begin{bmatrix}\begin{bmatrix}I_x & I_y\end{bmatrix}_1\\.\\.\\\begin{bmatrix}I_x & I_y\end{bmatrix}_k\end{bmatrix},b=\begin{bmatrix}I_{t1} \\.\\.\\I_{tk} \end{bmatrix}</script><p>于是整个方程为：</p><script type="math/tex; mode=display">A\begin{bmatrix}u\\u\end{bmatrix}=-b</script><p>这是一个关于 u, v 的超定线性方程，传统解法是求最小二乘解。最小二乘在很多时候都用到过：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\u\end{bmatrix}^*=-(A^TA)^{-1}A^Tb</script><p>这样就得到了像素在图像间的运动速度 $u, v$</p><h1 id="使用LK光流法"><a href="#使用LK光流法" class="headerlink" title="使用LK光流法"></a>使用LK光流法</h1><h2 id="光流追踪的原理"><a href="#光流追踪的原理" class="headerlink" title="光流追踪的原理"></a>光流追踪的原理</h2><ul><li><p>cv2.FastFeatureDetector()：Fast角点检测器确定要追踪的特征点</p></li><li><p>cv2.calcOpticalFlowPyrLK()： 追踪视频中的稀疏特征点</p></li><li><p>cv2.calcOpticalFlowFarneback()： 追踪视频中的密集特征点</p></li></ul><p>取第一帧，检测其中的一些 Fast角点，使用 Lucas-Kanade 光流迭代跟踪这些点。对于函数 cv2.calcOpticalFlowPyrLK() 传递前一帧、前一个点和下一帧。它返回下一个点以及一些状态编号，如果找到下一个点，则值为 1，否则为零。然后在下一步中迭代地将这些下一个点作为前一个点传递。</p><h2 id="光流的两种方法"><a href="#光流的两种方法" class="headerlink" title="光流的两种方法"></a>光流的两种方法</h2><p>OpenCV提供了俩种算法计算光流，分别通过：cv2.calcOpticalFlowPyrLK()、cv2.calcOpticalFlowFarneback实现；</p><ul><li>稀疏光流： 通过 Lucas-Kanade 方法计算稀疏特征集的光流（使用 角点检测算法检测到的角点）。</li></ul><p>参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::calcOpticalFlowPyrLK</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray prevImg, <span class="comment">//上一帧单通道灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray nextImg, <span class="comment">//下一帧单通道灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputArray prevPts, <span class="comment">//像素点上一帧二维坐标pts</span></span></span></span><br><span class="line"><span class="params"><span class="function">        InputOutputArray nextPts,<span class="comment">//像素点下一帧二维坐标pts</span></span></span></span><br><span class="line"><span class="params"><span class="function">        OutputArray status,<span class="comment">// 输出状态向量,（无符号字符）;如果找到相应特征的流，则向量的每个元素设置为1，否则设置为0。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        OutputArray err, <span class="comment">//输出错误的矢量;如果未找到流，则未定义错误（使用status参数查找此类情况）。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        Size winSize = Size(<span class="number">21</span>, <span class="number">21</span>),<span class="comment">//每个金字塔等级的搜索窗口的winSize大小。</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> maxLevel = <span class="number">3</span>,<span class="comment">// 基于0的最大金字塔等级数;如果设置为0，则不使用金字塔（单级），如果设置为1，则使用两个级别，依此类推;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, <span class="number">30</span>, <span class="number">0.01</span>),<span class="comment">//参数，指定迭代搜索算法的终止条件</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">double</span> minEigThreshold = <span class="number">1e-4</span> <span class="comment">//算法计算光流方程的2x2正常矩阵的最小特征值，除以窗口中的像素数;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><ul><li>密集光流： 通过 Gunner Farneback 来寻找密集光流。它计算帧中所有点的光流。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在使用数据之前，需要根据采集时间，对数据进行一次时间上的对齐，以便对彩色图和深度图进行配对。TUM 提供了一个 python 脚本“asso-ciate.py”帮我们完成这件事。请把此文件放到数据集目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python associate.py rgb.txt depth.txt &gt; associate.txt</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入数据集所在的路径！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    string associate_file = path_to_dataset + <span class="string">&quot;/associate.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(associate_file)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;associate.txt文件不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    list&lt;cv::Point2f&gt; keypoints; <span class="comment">// 因为要删除跟踪失败的点，使用list</span></span><br><span class="line">    cv::Mat color, depth, last_color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        fin &gt;&gt; time_rgb &gt;&gt; rgb_file &gt;&gt; time_depth &gt;&gt; depth_file;</span><br><span class="line">        color = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + rgb_file);       <span class="comment">// 读入彩色图</span></span><br><span class="line">        depth = cv::<span class="built_in">imread</span>(path_to_dataset + <span class="string">&quot;/&quot;</span> + depth_file, <span class="number">-1</span>); <span class="comment">// 读入深度图</span></span><br><span class="line">        <span class="comment">// 1.对第一帧提取FAST特征点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;cv::KeyPoint&gt; kps;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::<span class="built_in">create</span>();</span><br><span class="line">            detector-&gt;<span class="built_in">detect</span>(color, kps); <span class="comment">// 提取FAST特征点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> kp : kps)           <span class="comment">// 把提取的特征点存入list</span></span><br><span class="line">                keypoints.<span class="built_in">push_back</span>(kp.pt);</span><br><span class="line">            last_color = color;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.对其他帧使用LK跟踪特征点</span></span><br><span class="line">        <span class="keyword">if</span> (color.data == <span class="literal">nullptr</span> &amp;&amp; depth.data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;cv::Point2f&gt; next_keypoints;</span><br><span class="line">        vector&lt;cv::Point2f&gt; prev_keypoints;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">            prev_keypoints.<span class="built_in">push_back</span>(kp); <span class="comment">// 讲list中的数据赋给prev_keypoints</span></span><br><span class="line">        vector&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; status;</span><br><span class="line">        vector&lt;<span class="keyword">float</span>&gt; error;</span><br><span class="line"></span><br><span class="line">        chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">calcOpticalFlowPyrLK</span>(last_color, color, prev_keypoints, next_keypoints, status, error);</span><br><span class="line"></span><br><span class="line">        chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LK Flow use time：&quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把跟丢的点删掉</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = keypoints.<span class="built_in">begin</span>(); iter != keypoints.<span class="built_in">end</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (status[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iter = keypoints.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *iter = next_keypoints[i];</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;跟踪到的点个数为： &quot;</span> &lt;&lt; keypoints.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (keypoints.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;all keypoints are lost.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出 keypoints</span></span><br><span class="line">        cv::Mat img_show = color.<span class="built_in">clone</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> kp : keypoints)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::<span class="built_in">circle</span>(img_show, kp, <span class="number">10</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">240</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;corners&quot;</span>, img_show);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">        last_color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为要删除跟踪失败的点，使用list,原因如下：</p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p>list的优点：</p><blockquote><p>采用动态存储分配，不会造成内存浪费和溢出<br>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</p></blockquote></blockquote><p>打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LK Flow use time：0.0157339 seconds.</span><br><span class="line">跟踪到的点个数为： 1749</span><br><span class="line">LK Flow use time：0.0144717 seconds.</span><br><span class="line">跟踪到的点个数为： 1742</span><br><span class="line">LK Flow use time：0.0186928 seconds.</span><br><span class="line">跟踪到的点个数为： 1703</span><br><span class="line">LK Flow use time：0.0153624 seconds.</span><br><span class="line">跟踪到的点个数为： 1676</span><br><span class="line">LK Flow use time：0.019426 seconds.</span><br><span class="line">跟踪到的点个数为： 1664</span><br><span class="line">LK Flow use time：0.0140176 seconds.</span><br><span class="line">跟踪到的点个数为： 1656</span><br><span class="line">LK Flow use time：0.0187153 seconds.</span><br><span class="line">跟踪到的点个数为： 1641</span><br><span class="line">LK Flow use time：0.0187284 seconds.</span><br><span class="line">跟踪到的点个数为： 1634</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( useLK )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++11 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( useLK useLK.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( useLK <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/46698.htm/image-20220329144916230.png" alt="image-20220329144916230"></p><p>LK 光流跟踪能够直接得到特征点的对应关系。这个对应关系就像是描述子的匹配，但实际上我们大多数时候只会碰到特征点跟丢的情况，而不太会遇到误匹配，这应该是光流相对于描述子的一点优势。但是，匹配描述子的方法在相机运动较大时仍能成功，而光流必须要求相机运动是微小的。从这方面来说，光流的鲁棒性比描述子差一些。</p><p>光流法参考：</p><ul><li><a href="https://www.shouxicto.com/article/1871.html">OpenCV中的光流及视频特征点追踪</a></li><li><a href="https://docs.opencv.org/3.4.6/dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323"> calcOpticalFlowPyrLK()</a></li><li><a href="https://docs.opencv.org/3.4.6/dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af">calcOpticalFlowFarneback()</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;光流是一种描述像素随着时间，在图像之间运动的方法。随着时间的经过，同一个像素会在图像中运动，而我们希望追踪它的运动过程。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。稀疏光流以$ Lucas-Kanade$ 光流为代表，并可以在 SLAM 中用于跟踪特征点位置。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>g2o的结构以及BA节点与边的定义</title>
    <link href="https://lukeyalvin.top/posts/5123.html"/>
    <id>https://lukeyalvin.top/posts/5123.html</id>
    <published>2022-03-28T03:38:08.097Z</published>
    <updated>2022-04-26T01:20:20.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。在<code>g2o/types/sba/types_six_dof_expmap.h</code>中则提供了李代数表达的节点和边。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="g2o的结构"><a href="#g2o的结构" class="headerlink" title="g2o的结构"></a>g2o的结构</h1><blockquote><p>参考博客：<a href="https://www.cnblogs.com/gaoxiang12/p/5304272.html">深入理解图优化与g2o：g2o篇</a></p></blockquote><p>源码：<a href="https://github.com/RainerKuemmerle/g2o">https://github.com/RainerKuemmerle/g2o</a></p><p><img src="/posts/5123.htm/image-20220328125016497.png" alt="image-20220328125016497"></p><ul><li><strong>cmake_modules：</strong>给cmake用来寻找库的文件。我们用g2o时也会用它里头的东西，例如FindG2O.cmake</li><li><strong>doc：</strong>文档。包括g2o自带的说明书（难度挺大的一个说明文档）。</li><li><strong>g2o：</strong>最重要的源代码都在这里！</li><li><strong>script：</strong>在android等其他系统编译用的脚本</li></ul><p><a href="https://github.com/RainerKuemmerle/g2o/tree/master/g2o">https://github.com/RainerKuemmerle/g2o/tree/master/g2o</a></p><p><img src="/posts/5123.htm/image-20220328125308391.png" alt="image-20220328125308391"></p><ul><li><strong>apps：</strong>一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</li><li><strong>core：</strong>核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</li><li><strong>examples：</strong>一些例程，可以参照着这里的东西来写。不过注释不太多。</li><li><strong>solvers：</strong>求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</li><li><strong>stuff：</strong>对用户来讲可有可无的一些工具函数。</li><li><strong>types：</strong>各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</li></ul><p><strong>就经验而言，solvers给人的感觉是大同小异，而 types 的选取，则是 g2o 用户主要关心的内容。然后 core 下面的内容，我们要争取弄的比较熟悉，才能确保使用中出现错误可以正确地应对。</strong></p><p>g2o最基本的类结构：</p><p><img src="/posts/5123.htm/606958-20160321233900042-681579456.png" alt="img"></p><p>　先看上半部分。SparseOptimizer 是我们最终要维护的东东。它是一个Optimizable Graph，从而也是一个Hyper Graph。一个 SparseOptimizer 含有很多个顶点 （都继承自 Base Vertex）和很多个边（继承自 BaseUnaryEdge, BaseBinaryEdge或BaseMultiEdge）。这些 Base Vertex 和 Base Edge 都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 SparseOptimizer.addVertex 和 SparseOptimizer.addEdge 向一个图中添加顶点和边，最后调用 SparseOptimizer.optimize 完成优化。</p><p>　　在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 SparseOptimizer 拥有一个 Optimization Algorithm，继承自Gauss-Newton, Levernberg-Marquardt, Powell’s dogleg 三者之一（我们常用的是GN或LM）。同时，这个 Optimization Algorithm 拥有一个Solver，它含有两个部分。一个是 SparseBlockMatrix ，用于计算稀疏的雅可比和海塞； 一个是用于计算迭代过程中最关键的一步</p><script type="math/tex; mode=display">HΔx=−b</script><p>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p><p><strong>综上所述，在g2o中选择优化方法一共需要三个步骤：</strong></p><ol><li>创建一个线性求解器LinearSolver。从 PCG, CSparse, Choldmod中选，实际则来自 g2o/solvers 文件夹中定义的内容。</li><li>创建BlockSolver，并用上面定义的线性求解器初始化。</li><li>创建总求解器solver，并从GN/LM/DogLeg 中选一个作为迭代策略，再用上述块求解器BlockSolver初始化。</li><li>创建图优化的核心：稀疏优化器（SparseOptimizer）。</li><li>定义图的顶点和边，并添加到SparseOptimizer中。</li><li>设置优化参数，开始执行优化。</li></ol><h1 id="g2o中定义的顶点和边"><a href="#g2o中定义的顶点和边" class="headerlink" title="g2o中定义的顶点和边"></a>g2o中定义的顶点和边</h1><p>$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。<code>g2o/types/sba/types_six_dof_expmap.h</code>中则提供了李代数表达的节点和边。</p><p>因为在不同的应用场景（二维空间，三维空间），有不同的待优化变量（位姿，空间点），还涉及不同的优化类型（李代数位姿、李群位姿），g2o本身内部定义了一些常用的顶点类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VertexSE2 : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, SE2&gt;  <span class="comment">//2D位姿顶点, (x,y,theta)</span></span><br><span class="line">VertexSE3 : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, Isometry3&gt;  <span class="comment">//6d vector (x,y,z,qx,qy,qz) 请注意，我们省略了四元数的 w 部分</span></span><br><span class="line">VertexPointXY : <span class="keyword">public</span> BaseVertex&lt;<span class="number">2</span>, Vector2&gt;</span><br><span class="line">VertexPointXYZ : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt;</span><br><span class="line">VertexSBAPointXYZ : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt;</span><br><span class="line"></span><br><span class="line">VertexSE3Expmap : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SE3Quat&gt;</span><br><span class="line">VertexCam : <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SBACam&gt;</span><br><span class="line">VertexSim3Expmap : <span class="keyword">public</span> BaseVertex&lt;<span class="number">7</span>, Sim3&gt;</span><br></pre></td></tr></table></figure><h2 id="顶点Vertex"><a href="#顶点Vertex" class="headerlink" title="顶点Vertex"></a>顶点Vertex</h2><p>g2o中顶点为<strong>待优化变量</strong>，边为<strong>误差项</strong>，综合之前所提到的非线性优化的应用：</p><ul><li><p>求解$PnP$</p><ul><li>待优化的变量是：相机的位姿以及所有的特征点的空间位置$P$</li><li>误差项：重投影误差 $ξ^{*}=arg \underset{ξ}{min}\frac{1}{2}\sum^n_{i=1}\parallel u_i-\frac{1} {s_i}Kexp(ξ^{\land})P_i\parallel^2_2$</li></ul></li><li><p>求解$ICP$</p><ul><li>待优化的变量是：相机的位姿以及所有的特征点的空间位置$P$</li><li>误差项：重投影误差$\underset{\xi}{min}=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - exp(\xi^{\land})p^{\prime}_i) \parallel^2_2$</li></ul></li></ul><h3 id="VertexSE3Expmap"><a href="#VertexSE3Expmap" class="headerlink" title="VertexSE3Expmap"></a><code>VertexSE3Expmap</code></h3><p>VertexSE3Expmap(李代数位姿)</p><p>继承于<code>BaseVertex</code>这个模板类<br>需要设置的模板参数：</p><ul><li>参数<code>6</code> ：表示它内部存储的优化变量维度。可以看到这是一个 6 维的李代数。，前三维表示旋转，后三维表示平移</li><li>参数<code>SE3Quat</code> ：表示优化变量的类型。这里使用了 g2o 定义的相机位姿： SE3Quat。这个类内部使用了四元数加位移向量来存储位姿，但同时也支持李代数上的运算，例如对数映射（log 函数）和李代数上增量（update 函数）等操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SBA_API</span> <span class="title">VertexSE3Expmap</span> :</span> <span class="keyword">public</span> BaseVertex&lt;<span class="number">6</span>, SE3Quat&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function">        <span class="title">VertexSE3Expmap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 顶点重置函数，设定被优化变量的原始值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate = <span class="built_in">SE3Quat</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector6&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">          <span class="built_in">setEstimate</span>(SE3Quat::<span class="built_in">exp</span>(update) * <span class="built_in">estimate</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>使用时需要设置的参数，可以参考之前使用$PnP$优化第二个相机的位姿的时设置的参数内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">Eigen::Matrix3d R_mat;</span><br><span class="line">R_mat &lt;&lt; </span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 设置Id号</span></span><br><span class="line">pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>( <span class="comment">// 设置待优化位姿R,t</span></span><br><span class="line">    R_mat,</span><br><span class="line">    Eigen::<span class="built_in">Vector3d</span>(t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))、</span><br><span class="line">));</span><br><span class="line">optimizer.<span class="built_in">addVertex</span>(pose); <span class="comment">// 向一个图中添加顶点</span></span><br></pre></td></tr></table></figure><h3 id="VertexPointXYZ"><a href="#VertexPointXYZ" class="headerlink" title="VertexPointXYZ"></a><code>VertexPointXYZ</code></h3><p>VertexPointXYZ(空间点位置)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SLAM3D_API</span> <span class="title">VertexPointXYZ</span> :</span> <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Vector3&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="built_in">VertexPointXYZ</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// 顶点重置函数，设定被优化变量的原始值。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123; _estimate.<span class="built_in">fill</span>(<span class="number">0.</span>); &#125;</span><br><span class="line"><span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span> </span>&#123;</span><br><span class="line">        <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector3&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">        _estimate += update;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><p>使用时需要设置的参数，可以参考之前使用$PnP$优化所有特征点的空间位置P时，设置的参数内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化所有特征点的空间位置 P</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Point3f p : points_3d)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::VertexPointXYZ *point = <span class="keyword">new</span> g2o::<span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">    point-&gt;<span class="built_in">setId</span>(index++); <span class="comment">// 设置Id号</span></span><br><span class="line">    point-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z));<span class="comment">// 设置待优化空间点3D位置XYZ</span></span><br><span class="line">    point-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>); <span class="comment">// 是否边缘化（以便稀疏化求解）g2o中必须设置 marg 参见第十讲内容</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(point); <span class="comment">// 向一个图中添加顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="边Edge"><a href="#边Edge" class="headerlink" title="边Edge"></a>边Edge</h2><p>BaseUnaryEdge，BaseBinaryEdge，BaseMultiEdge 分别表示一元边，两元边，多元边。一元边可以理解为一条边只连接一个顶点，两元边理解为一条边连接两个顶点，也就是我们常见的边啦，多元边理解为一条边可以连接多个（3个以上）顶点</p><p><img src="/posts/5123.htm/5c7df32d30e9d.png" alt></p><h3 id="EdgeProjectXYZ2UV"><a href="#EdgeProjectXYZ2UV" class="headerlink" title="EdgeProjectXYZ2UV"></a>EdgeProjectXYZ2UV</h3><p>EdgeProjectXYZ2UV(重投影误差)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2O_TYPES_SBA_API</span> <span class="title">EdgeProjectXYZ2UV</span> :</span> <span class="keyword">public</span> BaseBinaryEdge&lt;<span class="number">2</span>, Vector2, VertexPointXYZ, VertexSE3Expmap&gt; </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">//1. 默认初始化</span></span><br><span class="line">    <span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//2. 计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>; <span class="comment">// 使用当前顶点的值计算的测量值与真实的测量值之间的误差</span></span><br><span class="line">    <span class="comment">//3. 线性增量函数，也就是雅克比矩阵J的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>; <span class="comment">// 在当前顶点的值下，该误差对优化变量的偏导数，也就是我们说的Jacobian</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//相机参数</span></span><br><span class="line">  CameraParameters* _cam;  <span class="comment">// TODO make protected member?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是个二元边。第1个参数2是说观测值是2维的，也就是图像像素坐标x,y的差值，即$ z − h(ξ, P )$，对应观测值的类型是Vector2D，两个顶点也就是优化变量分别是三维点 VertexPointXYZ，和李群位姿VertexSE3Expmap</p><h4 id="computeError"><a href="#computeError" class="headerlink" title="computeError()"></a>computeError()</h4><p>对应的<code>computeError()</code>的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeProjectXYZ2UV::computeError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> VertexSE3Expmap* v1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap*&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> VertexPointXYZ* v2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPointXYZ*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> CameraParameters* cam =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CameraParameters*&gt;(<span class="built_in">parameter</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 误差 = 观测 - 投影</span></span><br><span class="line">  _error = <span class="built_in">measurement</span>() - cam-&gt;<span class="built_in">cam_map</span>(v1-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(v2-&gt;<span class="built_in">estimate</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>_vertices[0]</code>对应的是 VertexPointXYZ 类型的顶点，也就是三维点，<code>_vertices[1]</code>对应的是VertexSE3Expmap 类型的顶点，也就是位姿pose。因此前面 1 对应的就应该是 pose，0对应的应该就是三维点。</p><p>cam_map 函数功能是把相机坐标系下三维点（输入）用内参转换为图像坐标（输出），具体代码如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector2 <span class="title">CameraParameters::cam_map</span><span class="params">(<span class="keyword">const</span> Vector3 &amp;trans_xyz)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector2 proj = <span class="built_in">project</span>(trans_xyz);</span><br><span class="line">    Vector2 res;</span><br><span class="line">    res[<span class="number">0</span>] = proj[<span class="number">0</span>] * focal_length + principle_point[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">1</span>] = proj[<span class="number">1</span>] * focal_length + principle_point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.map的功能是把世界坐标系下三维点变换到相机坐标系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3 <span class="title">map</span><span class="params">(<span class="keyword">const</span> Vector3&amp; xyz)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _r * xyz + <span class="keyword">_t</span>; &#125;</span><br></pre></td></tr></table></figure><p>因此下面这个代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(v2-&gt;<span class="built_in">estimate</span>())</span><br></pre></td></tr></table></figure><p>就是用V1估计的pose把V2代表的三维点，变换到相机坐标系下。</p><h4 id="linearizeOplus"><a href="#linearizeOplus" class="headerlink" title="linearizeOplus()"></a>linearizeOplus()</h4><p>对应的<code>linearizeOplus()</code>的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeProjectXYZ2UV::linearizeOplus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VertexSE3Expmap* vj = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap*&gt;(_vertices[<span class="number">1</span>]);</span><br><span class="line">  <span class="function">SE3Quat <span class="title">T</span><span class="params">(vj-&gt;estimate())</span></span>;</span><br><span class="line">  VertexPointXYZ* vi = <span class="keyword">static_cast</span>&lt;VertexPointXYZ*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">  Vector3 xyz = vi-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">  Vector3 xyz_trans = T.<span class="built_in">map</span>(xyz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">number_t</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">number_t</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">number_t</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">number_t</span> z_2 = z * z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> CameraParameters* cam =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CameraParameters*&gt;(<span class="built_in">parameter</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  Eigen::Matrix&lt;<span class="keyword">number_t</span>, <span class="number">2</span>, <span class="number">3</span>, Eigen::ColMajor&gt; tmp;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">0</span>) = cam-&gt;focal_length;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">0</span>, <span class="number">2</span>) = -x / z * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">1</span>) = cam-&gt;focal_length;</span><br><span class="line">  <span class="built_in">tmp</span>(<span class="number">1</span>, <span class="number">2</span>) = -y / z * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXi = <span class="number">-1.</span> / z * tmp * T.<span class="built_in">rotation</span>().<span class="built_in">toRotationMatrix</span>();</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">0</span>) = x * y / z_2 * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">1</span>) = -(<span class="number">1</span> + (x * x / z_2)) * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">2</span>) = y / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">3</span>) = <span class="number">-1.</span> / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  _jacobianOplusXj(<span class="number">0</span>, <span class="number">5</span>) = x / z_2 * cam-&gt;focal_length;</span><br><span class="line"></span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">0</span>) = (<span class="number">1</span> + y * y / z_2) * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">1</span>) = -x * y / z_2 * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">2</span>) = -x / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">-1.</span> / z * cam-&gt;focal_length;</span><br><span class="line">  _jacobianOplusXj(<span class="number">1</span>, <span class="number">5</span>) = y / z_2 * cam-&gt;focal_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量<code>_jacobianOplusXi</code>是<strong>误差到空间点的导数</strong>，<code>_jacobianOplusXj</code>是误<strong>差到相机位姿的导数</strong>，以李代数的左乘扰动表达。稍有差别的是，g2o 的相机里用 $f$ 统一描述 $f_x , f_y$ ，并且李代数定义顺序不同（g2o 是旋转在前，平移在后；我们是平移在前，旋转在后），所以矩阵前三列和后三列与我们的定义是颠倒的。此外都是一致的。</p><p>李代数定义的$J$：（）</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial e}{\partial \delta \xi}&=\frac{\partial e}{\partial P^′}\frac{\partial P^′}{\partial \delta \xi}\\&=-\begin{bmatrix}\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}&-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}\\0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}&-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&-\frac{f_yX^′}{Z^{′}}\end{bmatrix}\\&=J\end{align*}</script><p>而g2o中的$J$定义的方式如下：（旋转在前，平移在后）</p><script type="math/tex; mode=display">-\begin{bmatrix}-\frac{f_xX^′Y^′}{Z^{′2}}&f_x+\frac{f_xX^2}{Z^{′2}}&-\frac{f_xY^′}{Z^{′}}&\frac{f_x}{Z^′}&0&-\frac{f_xX^′}{Z^{′2}}\\-f_y-\frac{f_yY^{′2}}{Z^{′2}}&\frac{f_yX^′Y^′}{Z^{′}}&-\frac{f_yX^′}{Z^{′}}&0&\frac{f_y}{Z^′}&-\frac{f_yY^′}{Z^{′2}}\end{bmatrix}</script><p>值得一提的是，我们亦可自己实现相机位姿节点，并使用<code>Sophus::SE3</code>来表达位姿，提供类似的求导过程。然而，既然 g2o 已经提供了这样的类，在没有额外要求的情况下，自己重新实现就没有必要了。</p><p>使用时需要设置的参数，以$PnP$中重投影误差为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.设置边(每个 3D 点在第二个相机中的投影)</span></span><br><span class="line">index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Point2f p : points_2d)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> g2o::<span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">    edge-&gt;<span class="built_in">setId</span>(index); <span class="comment">//定义边的编号（决定了在H矩阵中的位置）</span></span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexPointXYZ *&gt;(optimizer.<span class="built_in">vertex</span>(index)));</span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose); <span class="comment">// 定义顶点</span></span><br><span class="line">    edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y)); <span class="comment">// 定义观测值</span></span><br><span class="line">    edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>()) ; <span class="comment">// 定义协方差矩阵的逆</span></span><br><span class="line">    optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义顶点类型"><a href="#自定义顶点类型" class="headerlink" title="自定义顶点类型"></a>自定义顶点类型</h1><p>一般情况下，如果我们需要用的顶点已经提供，则直接使用即可，但是有时候我们需要的顶点类型这里面没有，就得自己定义了。重新定义顶点一般需要考虑重写如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点重置函数，设定被优化变量的原始值。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 顶点更新函数。主要用于优化过程中增量△x的计算</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update)</span></span>;</span><br><span class="line"><span class="comment">// 读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下就可以</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p><code>virtual void setToOriginImpl();</code>顶点重置函数，设定被优化变量的原始值。</p><p><code>virtual void oplusImpl(const number_t* update);</code>顶点更新函数。主要用于优化过程中增量△x的计算。我们根据增量方程计算出增量之后，就是通过这个函数对估计值进行调整的。</p><p>自定义顶点的格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myVertex</span>:</span> <span class="keyword">public</span> g2::BaseVertex&lt;Dim, Type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">myVertex</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    _estimate = <span class="built_in">Type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* update)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    _estimate += <span class="comment">/*update*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义边的类型"><a href="#自定义边的类型" class="headerlink" title="自定义边的类型"></a>自定义边的类型</h1><p>在使用BA求解ICP的实践中,使用的是3D-3D的边,由于g2o本身没有提供3D-3D的边,因此需自定义一个3D-3D的边:</p><p>自定义边格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;n,Dim, Type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">myEdge</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以构建3D-3D的边为例:</p><p>主要考虑两个函数的实现</p><ul><li><p><code>virtual void computeError()</code></p><p> 在添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，这个函数则是使用该边连接的节点和观测值来计算误差</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// measurement is p, point is p&#x27;</span></span><br><span class="line">    _error = _measurement - pose-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(_point); <span class="comment">//.map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里误差的定义方式,是考虑相邻两帧图像之间的重投影误差,比如我们通过特征点匹配,确定了两个匹配好的特征点,$p_i$和$p_i^{\prime}$他们的关系为:</p><script type="math/tex; mode=display">p_i = Rp_i^{\prime}+t</script><p>由于一些噪声,我们发现依据所求得的相机位姿$R,t$并没有达到理想的准确度,即$Rp_i^{\prime}+t \neq p_i$,他们的差值我们就定义为误差项:</p><script type="math/tex; mode=display">e_i = p_i - (Rp_i^{\prime}+t)</script><p>因此,我们把估计的$p_i^{\prime}$的世界坐标系下三维点转换成相机坐标系,并与$p_i$做差</p><ul><li><code>virtual void linearizeOplus()</code></li></ul><p>计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导,但是就优化效率而言,前者计算速度是更快的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">        g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">g2o::SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;          <span class="comment">// 顶点的当前估计</span></span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point); <span class="comment">// .map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_jacobianOplusXi是误差关于世界坐标系下坐标点的偏导</span></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>, <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>, <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>, <span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前代码待理解……</p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;$g2o $提供了许多关于$BA $的节点和边，我们不必自己从头实现所有的计算。在&lt;code&gt;g2o/types/sba/types_six_dof_expmap.h&lt;/code&gt;中则提供了李代数表达的节点和边。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>ch7_求解ICP并使用BA优化</title>
    <link href="https://lukeyalvin.top/posts/12311.html"/>
    <id>https://lukeyalvin.top/posts/12311.html</id>
    <published>2022-03-26T08:31:15.472Z</published>
    <updated>2022-04-26T01:20:20.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>$ICP:$迭代最近点$（Iterative Closest Point）$求解。读者应该注意到，$3D-3D $位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组 $3D $点之间的变换时，和相机并没有关系。因此，在激光 $SLAM $中也会碰到 $ICP$，不过由于激光数据特征不够丰富，我们无从知道两个点集之间的匹配关系，只能认为距离最近的两个点为同一个，所以这个方法称为迭代最近点。而在视觉中，特征点为我们提供了较好的匹配关系，所以整个问题就变得更简单了。</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>和 $PnP$ 类似，$ICP $的求解也分为两种方式：利用线性代数的求解（主要是$ SVD$），以及利用非线性优化方式的求解（类似于 $Bundle Adjustment$）。</p><h1 id="求解ICP"><a href="#求解ICP" class="headerlink" title="求解ICP"></a>求解ICP</h1><h2 id="SVD方法"><a href="#SVD方法" class="headerlink" title="SVD方法"></a>SVD方法</h2><h3 id="构建最小二乘"><a href="#构建最小二乘" class="headerlink" title="构建最小二乘"></a>构建最小二乘</h3><p>假设我们有一组配对好的 3D 点（比如我们对两个 RGB-D 图像进行了匹配）：</p><script type="math/tex; mode=display">P = {p_1 , . . . , p_n } \\ P^′= {p^′_1 , . . . , p^′_n }</script><p>现在，想要找一个欧氏变换 $R, t，$使得：</p><script type="math/tex; mode=display">∀i, p_i = Rp^′_i + t.</script><p>定义第 $i$对点的误差项：</p><script type="math/tex; mode=display">e_i=p_i - (Rp^′_i + t).</script><p>构建最小二乘问题:</p><script type="math/tex; mode=display">\underset{R,t}{min}J=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^′_i + t)) \parallel^2_2</script><h3 id="求解最小二乘"><a href="#求解最小二乘" class="headerlink" title="求解最小二乘"></a>求解最小二乘</h3><p>首先，定义两组点的质心(注意质心是没有下标)：</p><script type="math/tex; mode=display">p=\frac{1}{n}\sum^n_{i=1}(p_i)，p^{\prime}=\frac{1}{n}\sum^n_{i=1}(p^{\prime}_i)</script><p>在误差函数中，我们作如下的处理：</p><script type="math/tex; mode=display">\begin{align*}\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^{\prime}_i + t)) \parallel^2&=\frac{1}{2}\sum^n_{i=1}\parallel p_i - Rp^{\prime}_i - t-p+Rp^{\prime}+p-Rp^{\prime} \parallel^2\\&= \frac{1}{2}\sum^n_{i=1}\parallel (p_i -p- R(p^{\prime}_i-p^{\prime}) )+(p- Rp^{\prime}+t) \parallel^2\\&= \frac{1}{2}\sum^n_{i=1}(\parallel p_i -p- R(p^{\prime}_i-p^{\prime}) \parallel^2+\parallel p- Rp^{\prime}+t\parallel^2\\&+2(p_i -p-R(p^{\prime}_i-p^{\prime})^T(p-Rp^{\prime}-t))\end{align*}</script><p>其中：</p><script type="math/tex; mode=display">\begin{align*}p_i-p-R(p^{\prime}_i-p^{\prime})&=(Rp^{\prime}_i+t)-(Rp^{\prime}+t)-R(p^{\prime}_i-p^{\prime})\\&=Rp^{\prime}_i+t-Rp^{\prime}-t-Rp^{\prime}_i+Rp^{\prime}\\&=0\end{align*}</script><p>所以：</p><script type="math/tex; mode=display">\begin{align*}\underset{R,t}{min}J&=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - (Rp^′_i + t)) \parallel^2\\&=\frac{1}{2}\sum^n_{i=1}\parallel p_i -p- R(p^{\prime}_i-p^{\prime}) \parallel^2+\parallel p- Rp^{\prime}+t\parallel^2\end{align*}</script><p>仔细观察左右两项，我们发现左边只和旋转矩阵 R 相关，而右边既有 R 也有 t，但只和质心相关。只要我们获得了 R，令第二项为零就能得到 t。于是，ICP 可以分为以下三个步骤求解：</p><p>1.计算两组点的质心位置 $p$, $p^{\prime}$，然后计算每个点的去质心坐标：</p><script type="math/tex; mode=display">q_i = p_i − p,\\q_i^{\prime} = p_i^{\prime} − p^{\prime}  .</script><p>2.根据以下优化问题计算旋转矩阵：</p><script type="math/tex; mode=display">R^{*}=arg\underset{R}{min}\frac{1}{2}\sum^n_{i=1}\parallel q_i - Rq_i^{\prime} \parallel^2</script><p>3.根据第二步的 $R$，计算 $t$：</p><script type="math/tex; mode=display">t^∗ = p − Rp^{\prime} .</script><p>计算$R$：</p><script type="math/tex; mode=display">\frac{1}{2}\sum^n_{i=1}\parallel q_i - Rq_i^{\prime} \parallel^2=\frac{1}{2}\sum^n_{i=1}q_i^{T}q_i+q_i^{\prime T}R^TRq_i^{\prime}-2q^T_iRq_i^{\prime}</script><p>第一项和$ R$ 无关，第二项由于 $R^T R = I$，亦与 $R $无关。因此，实际上优化目标函数变为：</p><script type="math/tex; mode=display">\sum^n_{i=1}-q_i^{T}Rq_i^{\prime}=\sum^n_{i=1}-tr(Rq_i^{\prime}q_i^{T})=-tr(R\sum^n_{i=1}q_i^{\prime}q_i^{T})</script><p>定义：</p><script type="math/tex; mode=display">W=\sum^n_{i=1}q_i^{\prime}q_i^{T}</script><p>$W $是一个$ 3 × 3 $的矩阵，对$ W$ 进行 $SVD$ 分解，得：</p><script type="math/tex; mode=display">W = UΣV^T</script><p>$Σ $为奇异值组成的对角矩阵，对角线元素从大到小排列，而 $U $和$ V$ 为正交矩阵。当 $W$ 满秩时，$R$ 为：</p><script type="math/tex; mode=display">R = UV^T</script><p>解得 $R$后,按照$t^∗ = p − Rp^{\prime} .$求解 t 即可</p><h2 id="非线性优化方法"><a href="#非线性优化方法" class="headerlink" title="非线性优化方法"></a>非线性优化方法</h2><p>求解$ ICP$ 的另一种方式是使用非线性优化，以迭代的方式去找最优值。该方法和我们前面讲述的 $PnP $非常相似。以李代数表达位姿时，目标函数可以写成：</p><script type="math/tex; mode=display">\underset{\xi}{min}=\frac{1}{2}\sum^n_{i=1}\parallel (p_i - exp(\xi^{\land})p^{\prime}_i) \parallel^2_2</script><p>单个误差项关于位姿导数已经在前面推导过了，使用李代数扰动模型即可:</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \delta \xi}=-(exp(\xi^{\land}p^{\prime}_i))^{⊙}</script><p>用非线性优化来计算$ ICP$不仅考虑相机的位姿，同时会优化 $3D$点的空间位置。对我们来说，RGB-D 相机每次可以观测到路标点的三维位置，从而产生一个$ 3D$ 观测数据。不过，由于$ g2o/sba$ 中没有提供 $3D$ 到 $3D$ 的边，而我们又想使用$ g2o/sba $中李代数实现的位姿节点，所以最好的方式是自定义一种这样的边，并向$ g2o$ 提供解析求导方式。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="1-特征点匹配"><a href="#1-特征点匹配" class="headerlink" title="1. 特征点匹配"></a>1. 特征点匹配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.特征点匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;img_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DMatch&gt; &amp;matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line"></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(<span class="string">&quot;BruteForce-Hamming&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_1, keypoints_1);</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span>(img_2, keypoints_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_1, keypoints_1, descriptors_1);</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span>(img_2, keypoints_2, descriptors_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; match;</span><br><span class="line">    matcher-&gt;<span class="built_in">match</span>(descriptors_1, descriptors_2, match);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist = <span class="number">10000</span>, max_dist = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; min_dist)</span><br><span class="line">            min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; max_dist)</span><br><span class="line">            max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_dist: &quot;</span> &lt;&lt; max_dist &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_dist: &quot;</span> &lt;&lt; min_dist &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i].distance &lt;= <span class="built_in">max</span>(<span class="number">2</span> * min_dist, <span class="number">30.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-建立3D点"><a href="#2-建立3D点" class="headerlink" title="2.建立3D点"></a>2.建立3D点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_3d_points</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;depth_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;depth_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Mat &amp;K,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;KeyPoint&gt; &amp;keypoints_1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;KeyPoint&gt; &amp;keypoints_2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;DMatch&gt; matches,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Point3f&gt; &amp;pts2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//提取特征点的深度值：</span></span><br><span class="line">    <span class="keyword">for</span> (DMatch m : matches)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取得匹配点的深度，queryIdx(表示匹配点的索引)查询描述子索引，pt关键点的坐标 (y行地址)[x列地址]</span></span><br><span class="line">        ushort d1 = depth_1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_1[m.queryIdx].pt.x)];</span><br><span class="line">        ushort d2 = depth_2.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(<span class="built_in"><span class="keyword">int</span></span>(keypoints_2[m.trainIdx].pt.y))[<span class="built_in"><span class="keyword">int</span></span>(keypoints_2[m.trainIdx].pt.x)];</span><br><span class="line">        <span class="keyword">if</span> (d1 == <span class="number">0</span> || d2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Point2d p1 = <span class="built_in">pixel2cam</span>(keypoints_1[m.queryIdx].pt, K);<span class="comment">// p1:(X/Z,Y/Z,1)</span></span><br><span class="line">        Point2d p2 = <span class="built_in">pixel2cam</span>(keypoints_2[m.trainIdx].pt, K);<span class="comment">// p2:(X/Z,Y/Z,1)</span></span><br><span class="line">        <span class="keyword">float</span> dd1 = <span class="built_in"><span class="keyword">float</span></span>(d1) / <span class="number">5000.0</span>;</span><br><span class="line">        <span class="keyword">float</span> dd2 = <span class="built_in"><span class="keyword">float</span></span>(d2) / <span class="number">5000.0</span>;</span><br><span class="line">        <span class="comment">// 将相机归一化坐标转换为相机坐标系下的3D组坐标</span></span><br><span class="line">        pts1.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p1.x * dd1, p1.y * dd1, dd1));<span class="comment">// (X,Y,Z)第一帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">        pts2.<span class="built_in">push_back</span>(<span class="built_in">Point3f</span>(p2.x * dd2, p2.y * dd2, dd2));<span class="comment">// (X,Y,Z)第二帧图像的3D坐标（相机坐标系下）</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3d-3d pairs: &quot;</span> &lt;&lt; pts1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-SVD求解ICP"><a href="#3-SVD求解ICP" class="headerlink" title="3.SVD求解ICP"></a>3.SVD求解ICP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.SVD求解ICP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_3d3d</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3f p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = pts1.<span class="built_in">size</span>(); <span class="comment">// N = 72;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 += pts1[i]; <span class="comment">// p1 为pts1坐标各维之和</span></span><br><span class="line">        p2 += pts2[i]; <span class="comment">// p2 为pts2坐标各维之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">Point3f</span>(<span class="built_in">Vec3f</span>(p1) / N); <span class="comment">// 取平均得到质心p1</span></span><br><span class="line">    p2 = <span class="built_in">Point3f</span>(<span class="built_in">Vec3f</span>(p2) / N); <span class="comment">// 取平均得到质心p2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Point3f&gt; <span class="title">q1</span><span class="params">(N)</span>, <span class="title">q2</span><span class="params">(N)</span></span>; <span class="comment">// remove the center</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1[i] = pts1[i] - p1; <span class="comment">// 计算每个点的去质心坐标q1</span></span><br><span class="line">        q2[i] = pts2[i] - p2; <span class="comment">// 计算每个点的去质心坐标q2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// compute q1*q2^T</span></span><br><span class="line">    Eigen::Matrix3d W = Eigen::Matrix3d::<span class="built_in">Zero</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// w = sum(q1*q2^T)</span></span><br><span class="line">        W += Eigen::<span class="built_in">Vector3d</span>(q1[i].x, q1[i].y, q1[i].z) * Eigen::<span class="built_in">Vector3d</span>(q2[i].x, q2[i].y, q2[i].z).<span class="built_in">transpose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;W=&quot;</span> &lt;&lt; W &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 对W进行SVD分解</span></span><br><span class="line">    <span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; <span class="title">svd</span><span class="params">(W, Eigen::ComputeFullU | Eigen::ComputeFullV)</span></span>;</span><br><span class="line">    Eigen::Matrix3d U = svd.<span class="built_in">matrixU</span>(); <span class="comment">// 正交矩阵U</span></span><br><span class="line">    Eigen::Matrix3d V = svd.<span class="built_in">matrixV</span>(); <span class="comment">// 正交矩阵V</span></span><br><span class="line">    <span class="keyword">if</span> (U.<span class="built_in">determinant</span>() * V.<span class="built_in">determinant</span>() &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">U</span>(x, <span class="number">2</span>) *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U=&quot;</span> &lt;&lt; U &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V=&quot;</span> &lt;&lt; V &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix3d R_ = U * (V.<span class="built_in">transpose</span>());</span><br><span class="line">    Eigen::Vector3d t_ = Eigen::<span class="built_in">Vector3d</span>(p1.x, p1.y, p1.z) - R_ * Eigen::<span class="built_in">Vector3d</span>(p2.x, p2.y, p2.z);</span><br><span class="line"></span><br><span class="line">    R = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">         <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">0</span>), <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">1</span>), <span class="built_in">R_</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    t = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; <span class="built_in">t_</span> ( <span class="number">0</span>,<span class="number">0</span> ), <span class="built_in">t_</span> ( <span class="number">1</span>,<span class="number">0</span> ), <span class="built_in">t_</span> ( <span class="number">2</span>,<span class="number">0</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-BA优化"><a href="#4-BA优化" class="headerlink" title="4.BA优化"></a>4.BA优化</h2><h3 id="自定义3D-3D的边"><a href="#自定义3D-3D的边" class="headerlink" title="自定义3D-3D的边"></a>自定义3D-3D的边</h3><p>由于 g2o/sba 中没有提供 3D 到 3D 的边，而我们又想使用 g2o/sba 中李代数实现的位姿节点，所以最好的方式是自定义一种这样的边，并向 g2o 提供解析求导方式。</p><p> $J$矩阵:</p><script type="math/tex; mode=display">\begin{bmatrix}0     &-z &y     &-1 &0     &0 \\z     &0     &-x &0     &-1 &0 \\-y     &x  &0     &0     &0     &-1\end{bmatrix}</script><p>自定义 3D 到 3D 的边：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjectXYZRGBDPoseOnly</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">3</span>, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 结构体包含eigen成员必须进行宏定义 EIGEN_MAKE_ALIGNED_OPERATOR_NEW, 保证内存对齐</span></span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(<span class="keyword">const</span> Eigen::Vector3d &amp;point) : _point(point) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再添加边之前需要设定好该边连接的节点的索引以及观测值和信息矩阵，</span></span><br><span class="line">    <span class="comment">// 这个函数则是使用该边连接的节点和观测值来计算误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// measurement is p, point is p&#x27;</span></span><br><span class="line">        _error = _measurement - pose-&gt;<span class="built_in">estimate</span>().<span class="built_in">map</span>(_point); <span class="comment">// 重投影误差</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵，这个函数是可选的，如果给出了则进行解析求导，不给则进行数值求导</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// VertexSE3Expmap，这个表示李代数的位姿；</span></span><br><span class="line">        g2o::VertexSE3Expmap *pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">g2o::SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;</span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point); <span class="comment">// .map的功能是把世界坐标系下三维点变换到相机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//_jacobianOplusXi是误差关于世界坐标系下坐标点的偏导</span></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BA优化"><a href="#BA优化" class="headerlink" title="BA优化"></a>BA优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.BA优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> vector&lt;Point3f&gt; &amp;pts2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Mat &amp;R, Mat &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化</span></span><br><span class="line">    <span class="comment">// 每个误差项优化变量维度为6(即为se3李代数的维数，前三维为平移，后三维为旋转)</span></span><br><span class="line">    <span class="comment">// 误差值维度为3(每个3D点在第二个相机中的投影)</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; Block;</span><br><span class="line">    <span class="comment">// 实例化线性方程求解器:使用eigen中sparse Cholesky 求解</span></span><br><span class="line">    Block::LinearSolverType *linearSolver = <span class="keyword">new</span> g2o::LinearSolverEigen&lt;Block::PoseMatrixType&gt;();</span><br><span class="line">    <span class="comment">// 实例化矩阵块求解器</span></span><br><span class="line">    Block *solver_ptr = <span class="keyword">new</span> <span class="built_in">Block</span>(unique_ptr&lt;Block::LinearSolverType&gt;(linearSolver));</span><br><span class="line">    <span class="comment">// 梯度下降方法，GN(高斯牛顿)418133364</span></span><br><span class="line">    g2o::OptimizationAlgorithmGaussNewton *solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(unique_ptr&lt;Block&gt;(solver_ptr));</span><br><span class="line"></span><br><span class="line">    g2o::SparseOptimizer optimizer; <span class="comment">// 创建稀疏优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver); <span class="comment">// 用前面定义好的求解器作为求解方法：（使用GN(高斯牛顿)方法）</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);     <span class="comment">// setVerbose是设置优化过程输出信息用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.构建顶点</span></span><br><span class="line">    g2o::VertexSE3Expmap *pose = <span class="keyword">new</span> g2o::<span class="built_in">VertexSE3Expmap</span>(); <span class="comment">// 相机位姿</span></span><br><span class="line">    pose-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    pose-&gt;<span class="built_in">setEstimate</span>(g2o::<span class="built_in">SE3Quat</span>(Eigen::Matrix3d::<span class="built_in">Identity</span>(), Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.构建边</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    vector&lt;EdgeProjectXYZRGBDPoseOnly*&gt; edges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeProjectXYZRGBDPoseOnly *edge = <span class="keyword">new</span> <span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(Eigen::<span class="built_in">Vector3d</span>(pts2[i].x,pts2[i].y,pts2[i].z));</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(index);</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt;(pose));</span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector3d</span>(pts1[i].x,pts1[i].y,pts1[i].z));</span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix3d::<span class="built_in">Identity</span>()*<span class="number">1e4</span>);</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">        index++;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 开始优化</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2-t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;优化用时: &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;优化后的T: \n: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Eigen::<span class="built_in">Isometry3d</span>(pose-&gt;<span class="built_in">estimate</span>()).<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;提供彩色图与深度图：img1 img2 depth1 depth2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.特征点匹配</span></span><br><span class="line">    Mat img_1 = <span class="built_in">imread</span>(argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    Mat img_2 = <span class="built_in">imread</span>(argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="built_in">find_feature_matches</span>(img_1, img_2, keypoints_1, keypoints_2, matches);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共找到&quot;</span> &lt;&lt; matches.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;组特征匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.建立3D点</span></span><br><span class="line">    Mat depth_1 = <span class="built_in">imread</span>(argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    Mat depth_2 = <span class="built_in">imread</span>(argv[<span class="number">4</span>], CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">    Mat K = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    vector&lt;Point3f&gt; pts1, pts2;</span><br><span class="line">    <span class="built_in">build_3d_points</span>(depth_1, depth_2, K, keypoints_1, keypoints_2, matches, pts1, pts2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.SVD求解ICP</span></span><br><span class="line">    Mat R, t;</span><br><span class="line">    <span class="built_in">pose_estimation_3d3d</span>(pts1, pts2, R, t);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共有&quot;</span> &lt;&lt; pts1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;对3D-3D&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ICP分解结果为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R: \n&quot;</span></span><br><span class="line">         &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: \n&quot;</span></span><br><span class="line">         &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 由于前面的推导是按照pi= Rp′i+t进行的，这里的R,t, </span></span><br><span class="line">    <span class="comment">// 是第二帧到第一帧的变换，与前面PnP部分是相反的。</span></span><br><span class="line">    <span class="comment">// 所以在输出结果中，我们同时打印了逆变换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;R_inv: \n &quot;</span> &lt;&lt; R.<span class="built_in">t</span>() &lt;&lt; endl; <span class="comment">// 求逆</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t_inv: \n &quot;</span> &lt;&lt; -R.<span class="built_in">t</span>() * t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.BA优化</span></span><br><span class="line">    <span class="built_in">bundleAdjustment</span>(pts1, pts2, R, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLsits.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>( VERSION <span class="number">2.8</span> )</span><br><span class="line"><span class="keyword">project</span>( pose_estimation_3d3d )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>( CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> )</span><br><span class="line"><span class="keyword">set</span>( CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++14 -O3&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cmake模块以使用g2o</span></span><br><span class="line"><span class="keyword">list</span>( APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake_modules )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>( OpenCV <span class="number">3.1</span> REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( G2O REQUIRED )</span><br><span class="line"><span class="keyword">find_package</span>( CSparse REQUIRED )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>( </span><br><span class="line">    <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> </span><br><span class="line">    <span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CSPARSE_INCLUDE_DIR&#125;</span></span><br><span class="line">    <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( pose_estimation_3d3d pose_estimation_3d3d.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( pose_estimation_3d3d </span><br><span class="line">   <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">   g2o_core g2o_stuff g2o_types_sba g2o_csparse_extension </span><br><span class="line">   <span class="variable">$&#123;CSPARSE_LIBRARY&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">max_dist: 94</span><br><span class="line">min_dist: 4</span><br><span class="line">一共找到79组特征匹配</span><br><span class="line">3d-3d pairs: 72</span><br><span class="line">W=  10.871 -1.01948  2.54771</span><br><span class="line">-2.16033  3.85307 -5.77742</span><br><span class="line"> 3.94738 -5.79979  9.62203</span><br><span class="line">U=  0.558087  -0.829399 -0.0252034</span><br><span class="line"> -0.428009  -0.313755   0.847565</span><br><span class="line">  0.710878   0.462228   0.530093</span><br><span class="line">V=  0.617887  -0.784771 -0.0484806</span><br><span class="line"> -0.399894  -0.366747   0.839989</span><br><span class="line">  0.676979   0.499631   0.540434</span><br><span class="line">一共有72对3D-3DICP分解结果为：</span><br><span class="line">R: </span><br><span class="line">[0.9969452349468715, 0.05983347698056557, -0.05020113095482046;</span><br><span class="line"> -0.05932607657705309, 0.9981719679735133, 0.01153858699565957;</span><br><span class="line"> 0.05079975545906246, -0.008525103184062521, 0.9986724725659557]</span><br><span class="line">t: </span><br><span class="line">[0.144159841091821;</span><br><span class="line"> -0.06667849443812729;</span><br><span class="line"> -0.03009747273569774]</span><br><span class="line">R_inv: </span><br><span class="line"> [0.9969452349468715, -0.05932607657705309, 0.05079975545906246;</span><br><span class="line"> 0.05983347698056557, 0.9981719679735133, -0.008525103184062521;</span><br><span class="line"> -0.05020113095482046, 0.01153858699565957, 0.9986724725659557]</span><br><span class="line">t_inv: </span><br><span class="line"> [-0.1461462958593589;</span><br><span class="line"> 0.05767443542067568;</span><br><span class="line"> 0.03806388018483625]</span><br><span class="line">iteration= 0     chi2= 18161.146626      time= 4.6935e-05        cumTime= 4.6935e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 1     chi2= 18155.141919      time= 9.614e-06         cumTime= 5.6549e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 2     chi2= 18155.140765      time= 9.938e-06         cumTime= 6.6487e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 3     chi2= 18155.140764      time= 9.516e-06         cumTime= 7.6003e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 4     chi2= 18155.140764      time= 8.688e-06         cumTime= 8.4691e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 5     chi2= 18155.140764      time= 8.358e-06         cumTime= 9.3049e-05     edges= 72       schur= 0</span><br><span class="line">iteration= 6     chi2= 18155.140764      time= 1.0723e-05        cumTime= 0.000103772    edges= 72       schur= 0</span><br><span class="line">iteration= 7     chi2= 18155.140764      time= 1.1911e-05        cumTime= 0.000115683    edges= 72       schur= 0</span><br><span class="line">iteration= 8     chi2= 18155.140764      time= 1.3427e-05        cumTime= 0.00012911     edges= 72       schur= 0</span><br><span class="line">iteration= 9     chi2= 18155.140764      time= 1.207e-05         cumTime= 0.00014118     edges= 72       schur= 0</span><br><span class="line">优化用时: 0.000604832ms</span><br><span class="line">优化后的T: </span><br><span class="line">: </span><br><span class="line">  0.996945  0.0598335 -0.0502011    0.14416</span><br><span class="line">-0.0593261   0.998172  0.0115386 -0.0666785</span><br><span class="line"> 0.0507998 -0.0085251   0.998672 -0.0300979</span><br><span class="line">         0          0          0          1</span><br></pre></td></tr></table></figure><p>不使用解析求导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">优化用时: 0.00123263ms</span><br><span class="line">优化后的T: </span><br><span class="line">: </span><br><span class="line">   0.996945   0.0598335  -0.0502011     0.14416</span><br><span class="line"> -0.0593261    0.998172   0.0115386  -0.0666785</span><br><span class="line">  0.0507998 -0.00852509    0.998672  -0.0300979</span><br><span class="line">          0           0           0           1</span><br></pre></td></tr></table></figure><p><strong>不难发现,使用解析求导(即给出函数<code>virtual void linearizeOplus()</code>),比使用数值求导(即不提供该函数)要快的多.</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;$ICP:$迭代最近点$（Iterative Closest Point）$求解。读者应该注意到，$3D-3D $位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组 $3D $点之间的变换时，和相机并没有关系。因此，在激光 $SLAM $中也会碰到 $ICP$，不过由于激光数据特征不够丰富，我们无从知道两个点集之间的匹配关系，只能认为距离最近的两个点为同一个，所以这个方法称为迭代最近点。而在视觉中，特征点为我们提供了较好的匹配关系，所以整个问题就变得更简单了。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="SLAM十四讲" scheme="https://lukeyalvin.top/categories/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"/>
    
    
    <category term="SLAM实践" scheme="https://lukeyalvin.top/tags/SLAM%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
